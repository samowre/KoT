more_list_props[T: TYPE]: THEORY
BEGIN
  IMPORTING adt_props
  
  l, m, l1, l2: VAR list[T]
  ll: VAR list[list[T]]
  p: VAR pred[T]
  P: VAR pred[list[T]]
  a, b, c: VAR T
  x, y, z: VAR T

  of_length(n: nat): TYPE = { l | length(l) = n }

  %% Characterization of lists as the set of its elements
  % Currified version of member
  member(l)(x): bool = member(x, l)

  % Remove (all instances of) an element from a list
  remove(a, l): { m | FORALL x: member(x, m) IFF (x /= a AND member(x, l)) } =
    filter(l, LAMBDA x: x /= a)

  % Useful conversion between every/some and forall/exists
  % The same conversion with nth instead of member is already
  % in the prelude for every, and a some is a negation of a
  % every with the theorems in the adt_props theory.
  every_forall: THEOREM
    every(p)(l) IFF (FORALL x: member(x, l) IMPLIES p(x))

  some_exists: THEOREM
    some(p)(l) IFF (EXISTS x: member(x, l) AND p(x))

  % subset relation
  subset?(l, m): bool = every(member(m))(l)
  member_subset: THEOREM subset?(l, m) IFF (FORALL x: member(x, l) IMPLIES member(x, m))
  subset_order: THEOREM preorder?(subset?)

  % set equality
  equal?(l, m): bool = subset?(l, m) AND subset?(m, l)
  member_equal: THEOREM equal?(l, m) IFF (FORALL x: member(x, l) IFF member(x, m))
  equal_equiv: THEOREM equivalence?(equal?)
  equal_reflexive: THEOREM equal?(l, l)
  equal_transitive: THEOREM
    equal?(l, l1) AND equal?(l1, l2) IMPLIES equal?(l, l2)
  equal_symmetric: THEOREM
    equal?(l1, l2) IMPLIES equal?(l2, l1)
  cons_equal: THEOREM member(x, l) IMPLIES equal?(l, cons(x, l))
  
  % Specification of common list functions with member
  member_append: THEOREM
    member(x, append(l, m)) IFF member(x, l) OR member(x, m)
  member_reverse: THEOREM
    member(x, reverse(l)) IFF member(x, l)
  member_nth: THEOREM
    member(x, l) IFF (EXISTS (i: below(length(l))): nth(l, i) = x)

  % Specifications of comon list functions with nth
  nth_append: THEOREM FORALL (i:below(length(l)+length(m))): 
    nth(append(l,m),i)= 
    	IF i<length(l) THEN nth(l,i)
    		       ELSE nth(m,i-length(l))
	ENDIF
  nth_reverse: THEOREM FORALL (i:below(length(l))):
    nth(reverse(l),i) = nth(l,length(l)-1-i)

  % Flattens a list of lists
  flatten(ll: list[list[T]]): list[T] =
    reduce(null, (LAMBDA l, m: append(l, m)))(ll)

  flatten_null: THEOREM
    flatten(null) = null
    
  flatten_cons: THEOREM
    flatten(cons(l, ll)) = append(l, flatten(ll))

  flatten_member: THEOREM
    FORALL (ll: list[list[T]]):
      member(x, flatten(ll)) IFF (EXISTS l: member(x, l) AND member(l, ll))
      
  % Lists without duplication
  uniques?(l): RECURSIVE bool =
    CASES l OF
      null: TRUE,
      cons(h, t): NOT member(h, t) AND uniques?(t)
    ENDCASES
  MEASURE length(l)

  uniques(l): RECURSIVE { m | uniques?(m) AND equal?(m, l) } =
    CASES l OF
      null: null,
      cons(h, t):
        IF member(h, t)
	  THEN uniques(t)
	  ELSE cons(h, uniques(t))
	ENDIF
    ENDCASES
  MEASURE length(l)

  % Find an element satisfying a predicate
  find(p, l): RECURSIVE lift[T]=
    CASES l OF
      null: bottom,
      cons(h, t): IF p(h) THEN up(h) ELSE find(p, t) ENDIF
    ENDCASES
  MEASURE length(l)

  find_char: THEOREM
    CASES find(p, l) OF
      bottom: NOT some(p, l),
      up(r): p(r) AND member(r, l)
    ENDCASES

  
  %% Less usual functions
  % More efficient way to compute append(reverse(l1), l2)
  rev_append(l1, l2): RECURSIVE list[T] =
    CASES l1 OF
      null: l2,
      cons(x, t1): rev_append(t1, cons(x, l2))
    ENDCASES
  MEASURE length(l1)

  % Characterisation of rev_append
  rev_append_char: THEOREM
    rev_append(l1, l2) = append(reverse(l1), l2)
END more_list_props









% SUFFIXE = SUBTERM !
list_subterms[T: TYPE]: THEORY
BEGIN
  IMPORTING more_list_props
  x: VAR T
  P: VAR pred[list[T]]
  l, m, l1, l2: VAR list[T]
  
  % Recursively computes the suffixes of a list
  subterms(l): RECURSIVE list[list[T]] =
    CASES l OF
      null: (: null :),
      cons(h, t): cons(l, subterms(t))
    ENDCASES
  MEASURE length(l)

  % Checks that some suffix satisfy a property
  some_subterm(P, l): bool = some(P)(subterms(l))
  some_subterm(P)(l): bool = some(P)(subterms(l))

  % Checks that every suffix satisfy a property
  every_subterm(P, l): bool = every(P)(subterms(l))
  every_subterm(P)(l): bool = every(P)(subterms(l))
  
  % suffix?(m, l) is TRUE iff m is a suffix/subterm of l
  suffix?(m, l): MACRO bool = subterm(m,l)

  % Currified version
  % WARNING: Arguments order is reverted w.r.t suffix?/2
  suffix?(l)(m): bool = suffix?(m, l)
  AUTO_REWRITE suffix?

  % Characterisation of subterm with append, 
  % Subterm inherit therefore of all properties of append (which is handy)
  subterm_append: LEMMA subterm(l2,l) IFF EXISTS l1: l=append(l1,l2) 

  % Properties on subterms/suffixes
    % Trivials from the characterisation :
  subterm_length: LEMMA subterm(m, l) IMPLIES length(m) <= length(l)
  subterm_reflexive: LEMMA subterm(l, l)
  subterm_null: LEMMA subterm(null, l)
    % Trivials but handy (and not so trivial)
  subterm_cons1: LEMMA subterm(l, cons(x, l))
  subterm_cons2: LEMMA subterm(cons(x, l), m) IMPLIES subterm(l, m)
    % Not trivials
  subterm_transitive: LEMMA
    subterm(l, l1) AND subterm(l1, l2) IMPLIES subterm(l, l2)
  subterm_antisymmetric: LEMMA
    subterm(l1, l2) AND subterm(l2, l1) IMPLIES l1 = l2
  subterm_partial_order: THEOREM partial_order?(suffix?)
    % Should we keep that one or write a subterm_append lemma ?
  subterm_subset: LEMMA subterm(m, l) IMPLIES subset?(m, l)


  % Subtermss is really the list of subterms
  subterm_subterms: THEOREM subterm(m, l) => member(m, subterms(l))
  subterms_subterm: THEOREM member(m, subterms(l)) => subterm(m, l)
END list_subterms

list_filter_props[T: TYPE]: THEORY
BEGIN
  x: VAR T
  p: VAR pred[T]
  l, m: VAR list[T]
  
  member_filter: JUDGEMENT
    filter(l, p) HAS_TYPE { m | FORALL x: member(x, m) IFF p(x) AND member(x, l) }

  filter_append: LEMMA
    filter(append(l, m), p) = append(filter(l, p), filter(m, p))
END list_filter_props

list_map_props[S: TYPE, T: TYPE]: THEORY
BEGIN
  IMPORTING more_list_props
  
  f: VAR [T -> S]
  F: VAR [T -> list[S]]
  l: VAR list[T]
  m: VAR list[S]
  x: VAR T
  s: VAR S

  member_map: THEOREM
    member(x, l) IMPLIES member(f(x), map(f, l))
  
  map_member: THEOREM
    member(s, map(f, l)) IMPLIES (EXISTS x: f(x) = s AND member(x, l))
  
  % ALREADY IN PRELUDE !!!
  %nth_map: THEOREM FORALL (i:below(length(l))):
  %  f(nth(l,i)) =  nth(map(f,l),i)
END list_map_props

concat_map[S: TYPE, T: TYPE]: THEORY
BEGIN
  IMPORTING more_list_props
  IMPORTING list_map_props[list[S], T]

  f: VAR [T -> list[S]]
  x: VAR T
  s: VAR S
  l: VAR list[T]
  m: VAR list[S]

  concat_map(l, f): RECURSIVE list[S] =
    CASES l OF
      null: null,
      cons(h, t): append(f(h), concat_map(t, f))
    ENDCASES
  MEASURE length(l)

  concat_map_flatten: THEOREM concat_map(l, f) = flatten(map(f, l))

  member_concat_map: THEOREM
    member(s, f(x)) AND member(x, l) IMPLIES member(s, concat_map(l, f))

  concat_map_member: THEOREM
    member(s, concat_map(l, f)) IMPLIES (EXISTS x: member(s, f(x)) AND member(x, l))
END concat_map
