(trace_checker
 (build_proof_th0_TCC1 0
  (build_proof_th0_TCC1-1 nil 3483114190 3483451789
   ("" (skolem-typepred) (("" (grind) nil nil)) nil) unchecked
   ((sentence_list? const-decl "bool" fmla nil)
    (append def-decl "list[T]" list_props nil)
    (sentence? const-decl "bool" fmla nil)
    (fmla type-decl nil fmla nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   118 90 t nil))
 (build_proof_th0_TCC2 0
  (build_proof_th0_TCC2-1 nil 3483114190 3483451789
   ("" (skolem-typepred) (("" (flatten) (("" (grind) nil nil)) nil))
    nil)
   unchecked
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (RR_lemma1 const-decl "ne_proof_seq" resolution nil)
    (RR_ax const-decl "ne_proof_seq" resolution nil)
    (concl_ax const-decl "proof_step" resolution nil)
    (ax_proof_step const-decl "proof_step" resolution nil)
    (ne_proof_seq type-eq-decl nil proof nil)
    (proof_seq type-eq-decl nil proof nil)
    (proof_step type-eq-decl nil proof nil)
    (list type-decl nil list_adt nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (sequent type-eq-decl nil sequents nil)
    (rule type-decl nil proof nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (sentence? const-decl "bool" fmla nil)
    (fmla type-decl nil fmla nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   226 120 t nil))
 (build_proof_th0_TCC3 0
  (build_proof_th0_TCC3-1 nil 3483114190 3483451791
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (flatten) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (sentence_list? const-decl "bool" fmla nil)
    (append def-decl "list[T]" list_props nil)
    (RR_norr const-decl "ne_proof_seq" resolution nil)
    (concl_norr const-decl "proof_step" resolution nil)
    (offset_proof_step const-decl "proof_step" resolution nil)
    (RR_lemma1 const-decl "ne_proof_seq" resolution nil)
    (RR_ax const-decl "ne_proof_seq" resolution nil)
    (concl_ax const-decl "proof_step" resolution nil)
    (ax_proof_step const-decl "proof_step" resolution nil)
    (ne_proof_seq type-eq-decl nil proof nil)
    (proof_seq type-eq-decl nil proof nil)
    (proof_step type-eq-decl nil proof nil)
    (list type-decl nil list_adt nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (sequent type-eq-decl nil sequents nil)
    (rule type-decl nil proof nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (sentence? const-decl "bool" fmla nil)
    (fmla type-decl nil fmla nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   1280 710 t nil))
 (build_proof_th0_TCC4 0
  (build_proof_th0_TCC4-1 nil 3483114190 3483451792
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (flatten) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (sentence_list? const-decl "bool" fmla nil)
    (append def-decl "list[T]" list_props nil)
    (RR_norr const-decl "ne_proof_seq" resolution nil)
    (concl_norr const-decl "proof_step" resolution nil)
    (offset_proof_step const-decl "proof_step" resolution nil)
    (RR_lemma1 const-decl "ne_proof_seq" resolution nil)
    (RR_ax const-decl "ne_proof_seq" resolution nil)
    (concl_ax const-decl "proof_step" resolution nil)
    (ax_proof_step const-decl "proof_step" resolution nil)
    (ne_proof_seq type-eq-decl nil proof nil)
    (proof_seq type-eq-decl nil proof nil)
    (proof_step type-eq-decl nil proof nil)
    (list type-decl nil list_adt nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (sequent type-eq-decl nil sequents nil)
    (rule type-decl nil proof nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (sentence? const-decl "bool" fmla nil)
    (fmla type-decl nil fmla nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   1420 670 t nil))
 (build_proof_th0_TCC5 0
  (build_proof_th0_TCC5-1 nil 3483114190 3483451794
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (flatten)
              (("" (skolem-typepred)
                (("" (flatten) (("" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (sentence_list? const-decl "bool" fmla nil)
    (append def-decl "list[T]" list_props nil)
    (RR_subsetr const-decl "ne_proof_seq" resolution nil)
    (concl_subsetr const-decl "proof_step" resolution nil)
    (RR_norr const-decl "ne_proof_seq" resolution nil)
    (concl_norr const-decl "proof_step" resolution nil)
    (offset_proof_step const-decl "proof_step" resolution nil)
    (RR_lemma1 const-decl "ne_proof_seq" resolution nil)
    (RR_ax const-decl "ne_proof_seq" resolution nil)
    (concl_ax const-decl "proof_step" resolution nil)
    (ax_proof_step const-decl "proof_step" resolution nil)
    (ne_proof_seq type-eq-decl nil proof nil)
    (proof_seq type-eq-decl nil proof nil)
    (proof_step type-eq-decl nil proof nil)
    (list type-decl nil list_adt nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (sequent type-eq-decl nil sequents nil)
    (rule type-decl nil proof nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (sentence? const-decl "bool" fmla nil)
    (fmla type-decl nil fmla nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   1455 760 t nil))
 (build_proof_th0_TCC6 0
  (build_proof_th0_TCC6-1 nil 3483114190 3483451795
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (flatten)
              (("" (skolem-typepred)
                (("" (flatten)
                  (("" (skolem-typepred)
                    (("" (flatten)
                      (("" (skolem-typepred)
                        (("" (flatten) (("" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (sentence_list? const-decl "bool" fmla nil)
    (append def-decl "list[T]" list_props nil)
    (RR_subsetr const-decl "ne_proof_seq" resolution nil)
    (concl_subsetr const-decl "proof_step" resolution nil)
    (RR_norr const-decl "ne_proof_seq" resolution nil)
    (concl_norr const-decl "proof_step" resolution nil)
    (offset_proof_step const-decl "proof_step" resolution nil)
    (RR_lemma1 const-decl "ne_proof_seq" resolution nil)
    (RR_ax const-decl "ne_proof_seq" resolution nil)
    (concl_ax const-decl "proof_step" resolution nil)
    (ax_proof_step const-decl "proof_step" resolution nil)
    (ne_proof_seq type-eq-decl nil proof nil)
    (proof_seq type-eq-decl nil proof nil)
    (proof_step type-eq-decl nil proof nil)
    (list type-decl nil list_adt nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (sequent type-eq-decl nil sequents nil)
    (rule type-decl nil proof nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (sentence? const-decl "bool" fmla nil)
    (fmla type-decl nil fmla nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   1497 1040 t nil))
 (build_proof_th0_TCC7 0
  (build_proof_th0_TCC7-1 nil 3483114190 3483451797
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (flatten)
              (("" (skolem-typepred)
                (("" (flatten)
                  (("" (skolem-typepred)
                    (("" (flatten)
                      (("" (skolem-typepred)
                        (("" (flatten) (("" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (sentence_list? const-decl "bool" fmla nil)
    (append def-decl "list[T]" list_props nil)
    (RR_subsetr const-decl "ne_proof_seq" resolution nil)
    (concl_subsetr const-decl "proof_step" resolution nil)
    (RR_norr const-decl "ne_proof_seq" resolution nil)
    (concl_norr const-decl "proof_step" resolution nil)
    (offset_proof_step const-decl "proof_step" resolution nil)
    (RR_lemma1 const-decl "ne_proof_seq" resolution nil)
    (RR_ax const-decl "ne_proof_seq" resolution nil)
    (concl_ax const-decl "proof_step" resolution nil)
    (ax_proof_step const-decl "proof_step" resolution nil)
    (ne_proof_seq type-eq-decl nil proof nil)
    (proof_seq type-eq-decl nil proof nil)
    (proof_step type-eq-decl nil proof nil)
    (list type-decl nil list_adt nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (sequent type-eq-decl nil sequents nil)
    (rule type-decl nil proof nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (sentence? const-decl "bool" fmla nil)
    (fmla type-decl nil fmla nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   1478 1090 t nil))
 (build_proof_th0_TCC8 0
  (build_proof_th0_TCC8-1 nil 3483114190 3483451799
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (flatten)
              (("" (skolem-typepred)
                (("" (flatten)
                  (("" (skolem-typepred)
                    (("" (flatten)
                      (("" (skolem-typepred)
                        (("" (flatten)
                          (("" (skolem-typepred)
                            (("" (flatten) (("" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (sentence_list? const-decl "bool" fmla nil)
    (append def-decl "list[T]" list_props nil)
    (RR_subsetr const-decl "ne_proof_seq" resolution nil)
    (concl_subsetr const-decl "proof_step" resolution nil)
    (RR_norr const-decl "ne_proof_seq" resolution nil)
    (concl_norr const-decl "proof_step" resolution nil)
    (offset_proof_step const-decl "proof_step" resolution nil)
    (RR_lemma1 const-decl "ne_proof_seq" resolution nil)
    (RR_ax const-decl "ne_proof_seq" resolution nil)
    (concl_ax const-decl "proof_step" resolution nil)
    (ax_proof_step const-decl "proof_step" resolution nil)
    (ne_proof_seq type-eq-decl nil proof nil)
    (proof_seq type-eq-decl nil proof nil)
    (proof_step type-eq-decl nil proof nil)
    (list type-decl nil list_adt nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (sequent type-eq-decl nil sequents nil)
    (rule type-decl nil proof nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (sentence? const-decl "bool" fmla nil)
    (fmla type-decl nil fmla nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   2019 1120 t nil))
 (build_proof_th0_TCC9 0
  (build_proof_th0_TCC9-1 nil 3483114190 3483451802
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (flatten)
              (("" (skolem-typepred)
                (("" (flatten)
                  (("" (skolem-typepred)
                    (("" (flatten)
                      (("" (skolem-typepred)
                        (("" (flatten)
                          (("" (skolem-typepred)
                            (("" (flatten)
                              ((""
                                (skolem-typepred)
                                ((""
                                  (flatten)
                                  (("" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (sentence_list? const-decl "bool" fmla nil)
    (append def-decl "list[T]" list_props nil)
    (RR_orr const-decl "ne_proof_seq" resolution nil)
    (concl_orr const-decl "proof_step" resolution nil)
    (RR_subsetr const-decl "ne_proof_seq" resolution nil)
    (concl_subsetr const-decl "proof_step" resolution nil)
    (RR_norr const-decl "ne_proof_seq" resolution nil)
    (concl_norr const-decl "proof_step" resolution nil)
    (offset_proof_step const-decl "proof_step" resolution nil)
    (RR_lemma1 const-decl "ne_proof_seq" resolution nil)
    (RR_ax const-decl "ne_proof_seq" resolution nil)
    (concl_ax const-decl "proof_step" resolution nil)
    (ax_proof_step const-decl "proof_step" resolution nil)
    (ne_proof_seq type-eq-decl nil proof nil)
    (proof_seq type-eq-decl nil proof nil)
    (proof_step type-eq-decl nil proof nil)
    (list type-decl nil list_adt nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (sequent type-eq-decl nil sequents nil)
    (rule type-decl nil proof nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (sentence? const-decl "bool" fmla nil)
    (fmla type-decl nil fmla nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   3046 1170 t nil))
 (build_proof_th0_TCC10 0
  (build_proof_th0_TCC10-1 nil 3483114190 3483451803
   ("" (skolem-typepred) (("" (grind) nil nil)) nil) unchecked
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (sentence_list? const-decl "bool" fmla nil)
    (append def-decl "list[T]" list_props nil)
    (RR_orr const-decl "ne_proof_seq" resolution nil)
    (concl_orr const-decl "proof_step" resolution nil)
    (RR_subsetr const-decl "ne_proof_seq" resolution nil)
    (concl_subsetr const-decl "proof_step" resolution nil)
    (RR_norr const-decl "ne_proof_seq" resolution nil)
    (concl_norr const-decl "proof_step" resolution nil)
    (offset_proof_step const-decl "proof_step" resolution nil)
    (RR_lemma1 const-decl "ne_proof_seq" resolution nil)
    (RR_ax const-decl "ne_proof_seq" resolution nil)
    (concl_ax const-decl "proof_step" resolution nil)
    (ax_proof_step const-decl "proof_step" resolution nil)
    (ne_proof_seq type-eq-decl nil proof nil)
    (proof_seq type-eq-decl nil proof nil)
    (proof_step type-eq-decl nil proof nil)
    (list type-decl nil list_adt nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (sequent type-eq-decl nil sequents nil)
    (rule type-decl nil proof nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (sentence? const-decl "bool" fmla nil)
    (fmla type-decl nil fmla nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   1001 760 t nil))
 (th0 0
  (th0-1 nil 3482703236 3482707989
   ("" (skolem-typepred)
    (("" (split)
      (("1" (grind) nil nil)
       ("2" (expand build_proof_th0)
        (("2" (lemma lemma_subsetr)
          (("2"
            (inst -1
             "cons(f_or(gamma!1, delta!1), cons(f_not(f_or(p!1, gamma!1)), cons(f_not(f_or(f_not(p!1), delta!1)), null)))"
             "cons(f_not(f_or(p!1, gamma!1)), cons(f_not(f_or(f_not(p!1), delta!1)), cons(f_or(gamma!1, delta!1), null)))"
             "RR_orr(gamma!1, delta!1, cons(f_not(f_or(p!1, gamma!1)), cons(f_not(f_or(f_not(p!1), delta!1)), null)),
                                   RR_subsetr(cons(f_not(f_or(p!1, gamma!1)), cons(f_not(f_or(f_not(p!1), delta!1)), cons(gamma!1, cons(delta!1, null)))),
                                              cons(gamma!1, cons(delta!1, cons(f_not(f_or(p!1, gamma!1)), cons(f_not(f_or(f_not(p!1), delta!1)), null)))),
                                              RR_norr(p!1, gamma!1, cons(f_not(f_or(f_not(p!1), delta!1)), cons(gamma!1, cons(delta!1, null))),
                                                      RR_subsetr(cons(f_not(f_or(f_not(p!1), delta!1)), cons(f_not(p!1), cons(gamma!1, cons(delta!1, null)))),
                                                                 cons(f_not(p!1), cons(f_not(f_or(f_not(p!1), delta!1)), cons(gamma!1, cons(delta!1, null)))),
                                                                 RR_norr(f_not(p!1), delta!1, cons(f_not(p!1), cons(gamma!1, cons(delta!1, null))),
                                                                         RR_lemma1(f_not(p!1), cons(f_not(p!1), cons(gamma!1, cons(delta!1, null)))),
                                                                         RR_lemma1(delta!1, cons(f_not(p!1), cons(gamma!1, cons(delta!1, null)))))),
                                                      RR_lemma1(gamma!1, cons(f_not(f_or(f_not(p!1), delta!1)), cons(gamma!1, cons(delta!1, null)))))))")
            (("2" (assert)
              (("2" (delete 2)
                (("2" (split)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)
                   ("3" (grind) nil nil) ("4" (grind) nil nil)
                   ("5" (lemma lemma_orr)
                    (("5"
                      (inst -1 "gamma!1"
                       "cons(f_not(f_or(p!1, gamma!1)), cons(f_not(f_or(f_not(p!1), delta!1)), null))"
                       "delta!1"
                       "RR_subsetr(cons(f_not(f_or(p!1, gamma!1)), cons(f_not(f_or(f_not(p!1), delta!1)), cons(gamma!1, cons(delta!1, null)))),
                                   cons(gamma!1, cons(delta!1, cons(f_not(f_or(p!1, gamma!1)), cons(f_not(f_or(f_not(p!1), delta!1)), null)))),
                                   RR_norr(p!1, gamma!1, cons(f_not(f_or(f_not(p!1), delta!1)), cons(gamma!1, cons(delta!1, null))),
                                           RR_subsetr(cons(f_not(f_or(f_not(p!1), delta!1)), cons(f_not(p!1), cons(gamma!1, cons(delta!1, null)))),
                                                      cons(f_not(p!1), cons(f_not(f_or(f_not(p!1), delta!1)), cons(gamma!1, cons(delta!1, null)))),
                                                      RR_norr(f_not(p!1), delta!1, cons(f_not(p!1), cons(gamma!1, cons(delta!1, null))),
                                                              RR_lemma1(f_not(p!1), cons(f_not(p!1), cons(gamma!1, cons(delta!1, null)))),
                                                              RR_lemma1(delta!1, cons(f_not(p!1), cons(gamma!1, cons(delta!1, null)))))),
                                           RR_lemma1(gamma!1, cons(f_not(f_or(f_not(p!1), delta!1)), cons(gamma!1, cons(delta!1, null))))))")
                      (("5" (assert)
                        (("5" (delete 2)
                          (("5" (split)
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil)
                             ("3" (lemma lemma_subsetr)
                              (("3"
                                (inst
                                 -1
                                 "cons(f_not(f_or(p!1, gamma!1)), cons(f_not(f_or(f_not(p!1), delta!1)), cons(gamma!1, cons(delta!1, null))))"
                                 "cons(gamma!1, cons(delta!1, cons(f_not(f_or(p!1, gamma!1)), cons(f_not(f_or(f_not(p!1), delta!1)), null))))"
                                 "RR_norr(p!1, gamma!1, cons(f_not(f_or(f_not(p!1), delta!1)), cons(gamma!1, cons(delta!1, null))),
                                    RR_subsetr(cons(f_not(f_or(f_not(p!1), delta!1)), cons(f_not(p!1), cons(gamma!1, cons(delta!1, null)))),
                                               cons(f_not(p!1), cons(f_not(f_or(f_not(p!1), delta!1)), cons(gamma!1, cons(delta!1, null)))),
                                               RR_norr(f_not(p!1), delta!1, cons(f_not(p!1), cons(gamma!1, cons(delta!1, null))),
                                                       RR_lemma1(f_not(p!1), cons(f_not(p!1), cons(gamma!1, cons(delta!1, null)))),
                                                       RR_lemma1(delta!1, cons(f_not(p!1), cons(gamma!1, cons(delta!1, null)))))),
                                    RR_lemma1(gamma!1, cons(f_not(f_or(f_not(p!1), delta!1)), cons(gamma!1, cons(delta!1, null)))))")
                                (("3"
                                  (assert)
                                  (("3"
                                    (delete 2)
                                    (("3"
                                      (split)
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil)
                                       ("3" (grind) nil nil)
                                       ("4" (grind) nil nil)
                                       ("5"
                                        (lemma lemma_norr)
                                        (("5"
                                          (inst
                                           -1
                                           "p!1"
                                           "cons(f_not(f_or(f_not(p!1), delta!1)), cons(gamma!1, cons(delta!1, null)))"
                                           "gamma!1"
                                           "RR_subsetr(cons(f_not(f_or(f_not(p!1), delta!1)), cons(f_not(p!1), cons(gamma!1, cons(delta!1, null)))),
                                    cons(f_not(p!1), cons(f_not(f_or(f_not(p!1), delta!1)), cons(gamma!1, cons(delta!1, null)))),
                                    RR_norr(f_not(p!1), delta!1, cons(f_not(p!1), cons(gamma!1, cons(delta!1, null))),
                                            RR_lemma1(f_not(p!1), cons(f_not(p!1), cons(gamma!1, cons(delta!1, null)))),
                                            RR_lemma1(delta!1, cons(f_not(p!1), cons(gamma!1, cons(delta!1, null))))))"
                                           "RR_lemma1(gamma!1, cons(f_not(f_or(f_not(p!1), delta!1)), cons(gamma!1, cons(delta!1, null))))")
                                          (("5"
                                            (assert)
                                            (("5"
                                              (delete 2)
                                              (("5"
                                                (split)
                                                (("1" (grind) nil nil)
                                                 ("2" (grind) nil nil)
                                                 ("3" (grind) nil nil)
                                                 ("4"
                                                  (lemma lemma_subsetr)
                                                  (("4"
                                                    (inst
                                                     -1
                                                     "cons(f_not(f_or(f_not(p!1), delta!1)), cons(f_not(p!1), cons(gamma!1, cons(delta!1, null))))"
                                                     "cons(f_not(p!1), cons(f_not(f_or(f_not(p!1), delta!1)), cons(gamma!1, cons(delta!1, null))))"
                                                     "RR_norr(f_not(p!1), delta!1, cons(f_not(p!1), cons(gamma!1, cons(delta!1, null))),
                                    RR_lemma1(f_not(p!1), cons(f_not(p!1), cons(gamma!1, cons(delta!1, null)))),
                                    RR_lemma1(delta!1, cons(f_not(p!1), cons(gamma!1, cons(delta!1, null)))))")
                                                    (("4"
                                                      (assert)
                                                      (("4"
                                                        (delete 2)
                                                        (("4"
                                                          (split)
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (grind)
                                                            nil
                                                            nil)
                                                           ("3"
                                                            (grind)
                                                            nil
                                                            nil)
                                                           ("4"
                                                            (grind)
                                                            nil
                                                            nil)
                                                           ("5"
                                                            (lemma
                                                             lemma_norr)
                                                            (("5"
                                                              (inst
                                                               -1
                                                               "f_not(p!1)"
                                                               "cons(f_not(p!1), cons(gamma!1, cons(delta!1, null)))"
                                                               "delta!1"
                                                               "RR_lemma1(f_not(p!1), cons(f_not(p!1), cons(gamma!1, cons(delta!1, null))))"
                                                               "RR_lemma1(delta!1, cons(f_not(p!1), cons(gamma!1, cons(delta!1, null))))")
                                                              (("5"
                                                                (assert)
                                                                (("5"
                                                                  (delete
                                                                   2)
                                                                  (("5"
                                                                    (split)
                                                                    (("1"
                                                                      (grind)
                                                                      nil
                                                                      nil)
                                                                     ("2"
                                                                      (grind)
                                                                      nil
                                                                      nil)
                                                                     ("3"
                                                                      (grind)
                                                                      nil
                                                                      nil)
                                                                     ("4"
                                                                      (grind)
                                                                      nil
                                                                      nil)
                                                                     ("5"
                                                                      (lemma
                                                                       lemma1)
                                                                      (("5"
                                                                        (inst
                                                                         -1
                                                                         "f_not(p!1)"
                                                                         "cons(f_not(p!1), cons(gamma!1, cons(delta!1, null)))")
                                                                        (("5"
                                                                          (assert)
                                                                          (("5"
                                                                            (delete
                                                                             2)
                                                                            (("5"
                                                                              (split)
                                                                              (("1"
                                                                                (grind)
                                                                                nil
                                                                                nil)
                                                                               ("2"
                                                                                (grind)
                                                                                nil
                                                                                nil)
                                                                               ("3"
                                                                                (grind)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("6"
                                                                      (lemma
                                                                       lemma1)
                                                                      (("6"
                                                                        (inst
                                                                         -1
                                                                         "delta!1"
                                                                         "cons(f_not(p!1), cons(gamma!1, cons(delta!1, null)))")
                                                                        (("6"
                                                                          (assert)
                                                                          (("6"
                                                                            (delete
                                                                             2)
                                                                            (("6"
                                                                              (grind)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("5"
                                                  (lemma lemma1)
                                                  (("5"
                                                    (inst
                                                     -1
                                                     "gamma!1"
                                                     "cons(f_not(f_or(f_not(p!1), delta!1)), cons(gamma!1, cons(delta!1, null)))")
                                                    (("5"
                                                      (assert)
                                                      (("5"
                                                        (delete 2)
                                                        (("5"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((RR_lemma1 const-decl "ne_proof_seq" resolution nil)
    (offset_proof_step const-decl "proof_step" resolution nil)
    (concl_norr const-decl "proof_step" resolution nil)
    (RR_norr const-decl "ne_proof_seq" resolution nil)
    (concl_subsetr const-decl "proof_step" resolution nil)
    (RR_subsetr const-decl "ne_proof_seq" resolution nil)
    (concl_orr const-decl "proof_step" resolution nil)
    (RR_orr const-decl "ne_proof_seq" resolution nil)
    (build_proof_th0 const-decl "ne_proof_seq" trace_checker nil)
    (conclusion const-decl "sequent" proof nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (lemma_subsetr formula-decl nil resolution nil)
    (append def-decl "list[T]" list_props nil)
    (sentence_list? const-decl "bool" fmla nil)
    (subset def-decl "bool" minlist nil)
    (member def-decl "bool" list_props nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (lemma1 formula-decl nil resolution nil)
    (lemma_norr formula-decl nil resolution nil)
    (lemma_orr formula-decl nil resolution nil)
    (PRED type-eq-decl nil defined_types nil)
    (ne_proof_seq type-eq-decl nil proof nil)
    (> const-decl "bool" reals nil)
    (proof_seq type-eq-decl nil proof nil)
    (proof_step type-eq-decl nil proof nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (sequent type-eq-decl nil sequents nil)
    (rule type-decl nil proof nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (f_not adt-constructor-decl "[fmla -> (f_not?)]" fmla nil)
    (f_not? adt-recognizer-decl "[fmla -> boolean]" fmla nil)
    (f_or adt-constructor-decl "[[fmla, fmla] -> (f_or?)]" fmla nil)
    (f_or? adt-recognizer-decl "[fmla -> boolean]" fmla nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (sentence? const-decl "bool" fmla nil)
    (fmla type-decl nil fmla nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   788108 13850 t shostak))
 (proof_th_TCC1 0
  (proof_th_TCC1-1 nil 3482772790 3483451805
   ("" (skolem-typepred)
    (("" (hide -1 -4 -7) (("" (flatten) (("" (grind) nil nil)) nil))
      nil))
    nil)
   unchecked
   ((tr_neg const-decl "(tr_literal?)" trace_resolution nil)
    (member def-decl "bool" list_props nil)
    (exist_pivot? def-decl "bool" trace_resolution nil)
    (tr_clause_true? def-decl "bool" trace_resolution nil)
    (not_true_clauses const-decl "bool" trace_resolution nil)
    (merge def-decl "{cla: (tr_clause?) |
         FORALL k: member(k, cla) IFF (member(k, ck) OR member(k, cl))}"
           trace_resolution nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (index const-decl "posnat" trace_resolution nil)
    (delete_pivot const-decl "{cl |
         FORALL l:
           member(l, cl) <=>
            member(l, ck) AND (NOT l = pivot) AND (NOT l = tr_neg(pivot))}"
     trace_resolution nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (translate_lit const-decl "(literal?)" trace2fmla nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (nclause? const-decl "bool" resolution nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (n formal-const-decl "nat" trace_checker nil)
    (m formal-const-decl "nat" trace_checker nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   1914 1680 t nil))
 (proof_th_TCC2 0
  (proof_th_TCC2-1 nil 3482800740 3483451806
   ("" (skosimp)
    (("" (typepred ntcB!1)
      (("" (expand nclause?)
        (("" (expand translate_clause)
          (("" (expand ne_tr_clause?) (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((ne_tr_clause? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (n formal-const-decl "nat" trace_checker nil)
    (m formal-const-decl "nat" trace_checker nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (tr_neg const-decl "(tr_literal?)" trace_resolution nil)
    (tr_clause_true? def-decl "bool" trace_resolution nil)
    (not_true_clauses const-decl "bool" trace_resolution nil)
    (delete_pivot const-decl "{cl |
         FORALL l:
           member(l, cl) <=>
            member(l, ck) AND (NOT l = pivot) AND (NOT l = tr_neg(pivot))}"
     trace_resolution nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (translate_lit const-decl "(literal?)" trace2fmla nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (nclause? const-decl "bool" resolution nil))
   1230 1120 t nil))
 (proof_th_TCC3 0
  (proof_th_TCC3-1 nil 3482800740 3483451806
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (typepred res!1)
        (("" (lemma clause_sentence_list)
          (("" (inst -1 "translate_clause[m, n, i](res!1)") nil nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((clause_sentence_list formula-decl nil resolution nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (clause? const-decl "bool" resolution nil)
    (literal? const-decl "bool" resolution nil)
    (fmla type-decl nil fmla nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (n formal-const-decl "nat" trace_checker nil)
    (m formal-const-decl "nat" trace_checker nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   47 40 t nil))
 (proof_th_TCC4 0
  (proof_th_TCC4-1 nil 3482800740 3483451808
   ("" (skolem-typepred) (("" (flatten) (("" (grind) nil nil)) nil))
    nil)
   unchecked
   ((minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nclause? const-decl "bool" resolution nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (translate_lit const-decl "(literal?)" trace2fmla nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (delete_pivot const-decl "{cl |
         FORALL l:
           member(l, cl) <=>
            member(l, ck) AND (NOT l = pivot) AND (NOT l = tr_neg(pivot))}"
     trace_resolution nil)
    (index const-decl "posnat" trace_resolution nil)
    (merge def-decl "{cla: (tr_clause?) |
         FORALL k: member(k, cla) IFF (member(k, ck) OR member(k, cl))}"
           trace_resolution nil)
    (not_true_clauses const-decl "bool" trace_resolution nil)
    (tr_clause_true? def-decl "bool" trace_resolution nil)
    (exist_pivot? def-decl "bool" trace_resolution nil)
    (member def-decl "bool" list_props nil)
    (tr_neg const-decl "(tr_literal?)" trace_resolution nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (n formal-const-decl "nat" trace_checker nil)
    (m formal-const-decl "nat" trace_checker nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   1934 1740 t nil))
 (proof_th_TCC5 0
  (proof_th_TCC5-1 nil 3483107273 3483451809
   ("" (skosimp) (("" (typepred ntcB!1) (("" (grind) nil nil)) nil))
    nil)
   unchecked
   ((ne_tr_clause? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (n formal-const-decl "nat" trace_checker nil)
    (m formal-const-decl "nat" trace_checker nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nclause? const-decl "bool" resolution nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (translate_lit const-decl "(literal?)" trace2fmla nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (not_true_clauses const-decl "bool" trace_resolution nil)
    (tr_clause_true? def-decl "bool" trace_resolution nil)
    (tr_neg const-decl "(tr_literal?)" trace_resolution nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil))
   1186 1080 t nil))
 (proof_th_TCC6 0
  (proof_th_TCC6-1 nil 3483107273 3483451810
   ("" (skosimp)
    (("" (expand not_or_reduction)
      (("" (expand append)
        (("" (expand append)
          (("" (lemma nclause2fmla_sentence)
            (("" (inst -1 "translate_clause[m, n, i](ntcB!1)")
              (("" (lemma clause_sentence_list)
                (("" (inst -1 "translate_clause[m, n, i](res!1)")
                  (("" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((not_or_reduction const-decl "sequent" resolution nil)
    (fmla type-decl nil fmla nil) (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (literal? const-decl "bool" resolution nil)
    (clause? const-decl "bool" resolution nil)
    (nclause? const-decl "bool" resolution nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (/= const-decl "boolean" notequal nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (m formal-const-decl "nat" trace_checker nil)
    (n formal-const-decl "nat" trace_checker nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (not_true_clauses const-decl "bool" trace_resolution nil)
    (sentence? const-decl "bool" fmla nil)
    (sentence_list? const-decl "bool" fmla nil)
    (clause_sentence_list formula-decl nil resolution nil)
    (nclause2fmla_sentence formula-decl nil resolution nil)
    (append def-decl "list[T]" list_props nil))
   1285 1060 t nil))
 (proof_th_TCC7 0
  (proof_th_TCC7-1 nil 3483107273 3483451811
   ("" (skosimp)
    (("" (typepred ntcB!1) (("" (hide -1) (("" (grind) nil nil)) nil))
      nil))
    nil)
   unchecked
   ((ne_tr_clause? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (n formal-const-decl "nat" trace_checker nil)
    (m formal-const-decl "nat" trace_checker nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (tr_neg const-decl "(tr_literal?)" trace_resolution nil)
    (tr_clause_true? def-decl "bool" trace_resolution nil)
    (not_true_clauses const-decl "bool" trace_resolution nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (translate_lit const-decl "(literal?)" trace2fmla nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (nclause? const-decl "bool" resolution nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil))
   1053 980 t nil))
 (proof_th_TCC8 0
  (proof_th_TCC8-1 nil 3483107273 3483451813
   ("" (skosimp)
    (("" (grind) (("" (typepred ntcA!1) (("" (grind) nil nil)) nil))
      nil))
    nil)
   unchecked
   ((not_true_clauses const-decl "bool" trace_resolution nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (nclause? const-decl "bool" resolution nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (tr_neg const-decl "(tr_literal?)" trace_resolution nil)
    (tr_clause_true? def-decl "bool" trace_resolution nil)
    (translate_lit const-decl "(literal?)" trace2fmla nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (/= const-decl "boolean" notequal nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (m formal-const-decl "nat" trace_checker nil)
    (n formal-const-decl "nat" trace_checker nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil))
   1205 1110 t nil))
 (proof_th_TCC9 0
  (proof_th_TCC9-1 nil 3483114190 3483451814
   ("" (skosimp)
    (("" (expand not_or_reduction)
      (("" (expand append)
        (("" (expand append)
          (("" (lemma nclause2fmla_sentence)
            (("" (inst -1 "translate_clause[m, n, i](ntcA!1)")
              (("" (lemma clause_sentence_list)
                (("" (inst -1 "translate_clause[m, n, i](res!1)")
                  (("" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((not_or_reduction const-decl "sequent" resolution nil)
    (fmla type-decl nil fmla nil) (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (literal? const-decl "bool" resolution nil)
    (clause? const-decl "bool" resolution nil)
    (nclause? const-decl "bool" resolution nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (/= const-decl "boolean" notequal nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (m formal-const-decl "nat" trace_checker nil)
    (n formal-const-decl "nat" trace_checker nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (not_true_clauses const-decl "bool" trace_resolution nil)
    (sentence? const-decl "bool" fmla nil)
    (sentence_list? const-decl "bool" fmla nil)
    (clause_sentence_list formula-decl nil resolution nil)
    (nclause2fmla_sentence formula-decl nil resolution nil)
    (append def-decl "list[T]" list_props nil))
   1114 1010 t nil))
 (proof_th_TCC10 0
  (proof_th_TCC10-1 nil 3483114190 3483451815
   ("" (skosimp)
    (("" (skosimp)
      (("" (expand not_or_reduction)
        (("" (expand append)
          (("" (expand append)
            (("" (lemma nclause2fmla_sentence)
              (("" (inst-cp -1 "translate_clause[m, n, i](ntcB!1)")
                (("" (inst -1 "translate_clause[m, n, i](ntcA!1)")
                  (("" (lemma clause_sentence_list)
                    (("" (inst -1 "translate_clause[m, n, i](res!1)")
                      (("" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((append def-decl "list[T]" list_props nil)
    (nclause2fmla_sentence formula-decl nil resolution nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (not_true_clauses const-decl "bool" trace_resolution nil)
    (sentence? const-decl "bool" fmla nil)
    (sentence_list? const-decl "bool" fmla nil)
    (clause_sentence_list formula-decl nil resolution nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (n formal-const-decl "nat" trace_checker nil)
    (m formal-const-decl "nat" trace_checker nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nclause? const-decl "bool" resolution nil)
    (clause? const-decl "bool" resolution nil)
    (literal? const-decl "bool" resolution nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil) (fmla type-decl nil fmla nil)
    (not_or_reduction const-decl "sequent" resolution nil))
   1213 1110 t nil))
 (proof_th_TCC11 0
  (proof_th_TCC11-1 nil 3483114190 3483451816
   ("" (skosimp)
    (("" (skosimp)
      (("" (expand not_or_reduction)
        (("" (expand append)
          (("" (expand append)
            (("" (lemma nclause2fmla_sentence)
              (("" (inst-cp -1 "translate_clause[m, n, i](ntcB!1)")
                (("" (inst -1 "translate_clause[m, n, i](ntcA!1)")
                  (("" (lemma clause_sentence_list)
                    (("" (inst -1 "translate_clause[m, n, i](res!1)")
                      (("" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((append def-decl "list[T]" list_props nil)
    (nclause2fmla_sentence formula-decl nil resolution nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (not_true_clauses const-decl "bool" trace_resolution nil)
    (sentence? const-decl "bool" fmla nil)
    (sentence_list? const-decl "bool" fmla nil)
    (clause_sentence_list formula-decl nil resolution nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (n formal-const-decl "nat" trace_checker nil)
    (m formal-const-decl "nat" trace_checker nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nclause? const-decl "bool" resolution nil)
    (clause? const-decl "bool" resolution nil)
    (literal? const-decl "bool" resolution nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil) (fmla type-decl nil fmla nil)
    (not_or_reduction const-decl "sequent" resolution nil))
   1215 1140 t nil))
 (proof_th_TCC12 0
  (proof_th_TCC12-1 nil 3483114190 3483451817
   ("" (skosimp) (("" (typepred ntcA!1) (("" (grind) nil nil)) nil))
    nil)
   unchecked
   ((ne_tr_clause? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (n formal-const-decl "nat" trace_checker nil)
    (m formal-const-decl "nat" trace_checker nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nclause? const-decl "bool" resolution nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (translate_lit const-decl "(literal?)" trace2fmla nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (delete_pivot const-decl "{cl |
         FORALL l:
           member(l, cl) <=>
            member(l, ck) AND (NOT l = pivot) AND (NOT l = tr_neg(pivot))}"
     trace_resolution nil)
    (exist_pivot? def-decl "bool" trace_resolution nil)
    (merge def-decl "{cla: (tr_clause?) |
         FORALL k: member(k, cla) IFF (member(k, ck) OR member(k, cl))}"
           trace_resolution nil)
    (not_true_clauses const-decl "bool" trace_resolution nil)
    (tr_clause_true? def-decl "bool" trace_resolution nil)
    (tr_neg const-decl "(tr_literal?)" trace_resolution nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil))
   1289 1170 t nil))
 (proof_th_TCC13 0
  (proof_th_TCC13-1 nil 3483114190 3483451819
   ("" (skosimp) (("" (typepred ntcB!1) (("" (grind) nil nil)) nil))
    nil)
   unchecked
   ((ne_tr_clause? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (n formal-const-decl "nat" trace_checker nil)
    (m formal-const-decl "nat" trace_checker nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nclause? const-decl "bool" resolution nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (translate_lit const-decl "(literal?)" trace2fmla nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (delete_pivot const-decl "{cl |
         FORALL l:
           member(l, cl) <=>
            member(l, ck) AND (NOT l = pivot) AND (NOT l = tr_neg(pivot))}"
     trace_resolution nil)
    (not_true_clauses const-decl "bool" trace_resolution nil)
    (tr_clause_true? def-decl "bool" trace_resolution nil)
    (tr_neg const-decl "(tr_literal?)" trace_resolution nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil))
   1486 1120 t nil))
 (proof_th_TCC14 0
  (proof_th_TCC14-1 nil 3483114190 3483451820
   ("" (skosimp)
    (("" (expand not_or_reduction)
      (("" (expand append)
        (("" (expand append)
          (("" (lemma nclause2fmla_sentence)
            (("" (inst -1 "translate_clause[m, n, i](ntcB!1)")
              (("" (lemma clause_sentence_list)
                (("" (inst -1 "translate_clause[m, n, i](res!1)")
                  (("" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((not_or_reduction const-decl "sequent" resolution nil)
    (fmla type-decl nil fmla nil) (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (literal? const-decl "bool" resolution nil)
    (clause? const-decl "bool" resolution nil)
    (nclause? const-decl "bool" resolution nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (/= const-decl "boolean" notequal nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (m formal-const-decl "nat" trace_checker nil)
    (n formal-const-decl "nat" trace_checker nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (not_true_clauses const-decl "bool" trace_resolution nil)
    (sentence? const-decl "bool" fmla nil)
    (sentence_list? const-decl "bool" fmla nil)
    (clause_sentence_list formula-decl nil resolution nil)
    (nclause2fmla_sentence formula-decl nil resolution nil)
    (append def-decl "list[T]" list_props nil))
   1146 1020 t nil))
 (th_TCC1 0
  (th_TCC1-1 nil 3483107273 3483451820
   ("" (skosimp) (("" (typepred ntcA!1) (("" (grind) nil nil)) nil))
    nil)
   unchecked
   ((ne_tr_clause? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (n formal-const-decl "nat" trace_checker nil)
    (m formal-const-decl "nat" trace_checker nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nclause? const-decl "bool" resolution nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (translate_lit const-decl "(literal?)" trace2fmla nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil))
   261 210 t nil))
 (th 0
  (th-1 nil 3482775473 3483147456
   ("" (skosimp)
    (("" (expand proof_th)
      (("" (split)
        (("1" (lift-if)
          (("1" (split)
            (("1" (flatten)
              (("1" (split)
                (("1" (flatten)
                  (("1" (lemma th2)
                    (("1"
                      (inst -1
                       "translate_lit(find_pivot(ntcA!1, ntcB!1))"
                       "translate_clause(ntcA!1)"
                       "translate_clause(ntcB!1)"
                       "translate_clause(resolution(ntcA!1, ntcB!1))")
                      (("1" (assert)
                        (("1" (delete 2)
                          (("1" (split)
                            (("1"
                              (lemma translate_include_res
                               (nck "ntcA!1" ncl "ntcB!1"))
                              (("1" (assert) nil nil)) nil)
                             ("2"
                              (lemma translate_include_res2
                               (nck "ntcA!1" ncl "ntcB!1"))
                              (("2"
                                (lemma
                                 neg_translate
                                 (k "find_pivot(ntcA!1, ntcB!1)"))
                                (("2"
                                  (replace -1 1)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (lemma th1)
                    (("2"
                      (inst -1 "translate_clause(ntcA!1)"
                       "append(not_or_reduction(translate_clause(ntcB!1)),
                               translate_clause(resolution
                                                (ntcA!1, ntcB!1)))")
                      (("2" (assert)
                        (("2" (delete 3)
                          (("2" (expand resolution)
                            (("2" (assert)
                              (("2"
                                (expand not_true_clauses)
                                (("2"
                                  (flatten)
                                  (("2"
                                    (replace 3 1)
                                    (("2"
                                      (replace 4 1)
                                      (("2"
                                        (lemma
                                         append_inclusion
                                         (cl
                                          "ntcA!1"
                                          cm
                                          "merge(ntcA!1, ntcB!1)"
                                          sq
                                          "not_or_reduction(translate_clause(ntcB!1))"))
                                        (("2"
                                          (assert)
                                          (("2"
                                            (lemma merge_includes1)
                                            (("2"
                                              (inst
                                               -1
                                               "ntcA!1"
                                               "ntcB!1")
                                              (("2"
                                                (flatten)
                                                (("2"
                                                  (lemma
                                                   subset_include
                                                   (sAA
                                                    "ntcA!1"
                                                    sBB
                                                    "merge(ntcA!1, ntcB!1)"))
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (split)
                (("1" (flatten)
                  (("1" (lemma lemma_subsetr)
                    (("1"
                      (inst -1 "RR_th1(translate_clause(ntcB!1),
                                   append(not_or_reduction
                                          (translate_clause(ntcA!1)),
                                          translate_clause
                                          (resolution(ntcA!1, ntcB!1))))"
                       "append(not_or_reduction(translate_clause
                                                    (ntcB!1)),
                                   append(not_or_reduction
                                          (translate_clause(ntcA!1)),
                                          translate_clause
                                          (resolution(ntcA!1, ntcB!1))))"
                       "append(not_or_reduction(translate_clause
                                                    (ntcA!1)),
                                   append(not_or_reduction
                                          (translate_clause(ntcB!1)),
                                          translate_clause
                                          (resolution(ntcA!1, ntcB!1))))")
                      (("1" (assert)
                        (("1" (delete 2)
                          (("1" (expand not_or_reduction + 1)
                            (("1" (expand append + 1)
                              (("1"
                                (expand append + 1)
                                (("1"
                                  (expand not_or_reduction + 1)
                                  (("1"
                                    (expand append + 1)
                                    (("1"
                                      (expand append + 1)
                                      (("1"
                                        (expand not_or_reduction + 1)
                                        (("1"
                                          (expand append + 1)
                                          (("1"
                                            (expand append + 1)
                                            (("1"
                                              (expand
                                               not_or_reduction
                                               +
                                               1)
                                              (("1"
                                                (expand append + 1)
                                                (("1"
                                                  (expand append + 1)
                                                  (("1"
                                                    (expand subset + 1)
                                                    (("1"
                                                      (expand
                                                       member
                                                       +
                                                       1)
                                                      (("1"
                                                        (expand
                                                         member
                                                         +
                                                         1)
                                                        (("1"
                                                          (expand
                                                           subset
                                                           +
                                                           1)
                                                          (("1"
                                                            (expand
                                                             member
                                                             +
                                                             1)
                                                            (("1"
                                                              (expand
                                                               resolution)
                                                              (("1"
                                                                (expand
                                                                 not_or_reduction)
                                                                (("1"
                                                                  (expand
                                                                   append)
                                                                  (("1"
                                                                    (expand
                                                                     append)
                                                                    (("1"
                                                                      (use
                                                                       every_member_subset
                                                                       (k
                                                                        "translate_clause(ntcB!1)"
                                                                        l
                                                                        "cons(f_not(nclause2fmla(translate_clause(ntcA!1))),
                   cons(f_not(nclause2fmla(translate_clause(ntcB!1))),
                        translate_clause(ntcB!1)))"))
                                                                      (("1"
                                                                        (replace
                                                                         -1
                                                                         1)
                                                                        (("1"
                                                                          (expand
                                                                           member
                                                                           +
                                                                           2)
                                                                          (("1"
                                                                            (expand
                                                                             member
                                                                             +
                                                                             2)
                                                                            (("1"
                                                                              (assert)
                                                                              (("1"
                                                                                (hide
                                                                                 -1)
                                                                                (("1"
                                                                                  (ground)
                                                                                  (("1"
                                                                                    (skosimp)
                                                                                    nil
                                                                                    nil)
                                                                                   ("2"
                                                                                    (lemma
                                                                                     th1)
                                                                                    (("2"
                                                                                      (expand
                                                                                       not_or_reduction)
                                                                                      (("2"
                                                                                        (expand
                                                                                         append)
                                                                                        (("2"
                                                                                          (expand
                                                                                           append)
                                                                                          (("2"
                                                                                            (inst
                                                                                             -1
                                                                                             "translate_clause(ntcB!1)"
                                                                                             "cons(f_not(nclause2fmla(translate_clause(ntcA!1))),
                             translate_clause(ntcB!1))")
                                                                                            (("2"
                                                                                              (assert)
                                                                                              (("2"
                                                                                                (delete
                                                                                                 2)
                                                                                                (("2"
                                                                                                  (use
                                                                                                   every_member_subset
                                                                                                   (k
                                                                                                    "translate_clause(ntcB!1)"
                                                                                                    l
                                                                                                    "cons(f_not(nclause2fmla(translate_clause(ntcA!1))),
                   translate_clause(ntcB!1))"))
                                                                                                  (("2"
                                                                                                    (replace
                                                                                                     -1
                                                                                                     1)
                                                                                                    (("2"
                                                                                                      (hide
                                                                                                       -1)
                                                                                                      (("2"
                                                                                                        (skosimp)
                                                                                                        (("2"
                                                                                                          (expand
                                                                                                           member
                                                                                                           +)
                                                                                                          (("2"
                                                                                                            (replace
                                                                                                             -1
                                                                                                             1)
                                                                                                            (("2"
                                                                                                              (propax)
                                                                                                              nil
                                                                                                              nil))
                                                                                                            nil))
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil)
                                                                                   ("3"
                                                                                    (lemma
                                                                                     th1)
                                                                                    (("3"
                                                                                      (inst
                                                                                       -1
                                                                                       "translate_clause(ntcB!1)"
                                                                                       "cons(f_not(nclause2fmla(translate_clause(ntcA!1))),
                             translate_clause(ntcB!1))")
                                                                                      (("3"
                                                                                        (assert)
                                                                                        (("3"
                                                                                          (delete
                                                                                           2)
                                                                                          (("3"
                                                                                            (use
                                                                                             every_member_subset
                                                                                             (k
                                                                                              "translate_clause(ntcB!1)"
                                                                                              l
                                                                                              "cons(f_not(nclause2fmla(translate_clause(ntcA!1))),
                   translate_clause(ntcB!1))"))
                                                                                            (("3"
                                                                                              (replace
                                                                                               -1
                                                                                               1)
                                                                                              (("3"
                                                                                                (hide
                                                                                                 -1)
                                                                                                (("3"
                                                                                                  (skosimp)
                                                                                                  (("3"
                                                                                                    (expand
                                                                                                     member
                                                                                                     +)
                                                                                                    (("3"
                                                                                                      (replace
                                                                                                       -1
                                                                                                       1)
                                                                                                      (("3"
                                                                                                        (propax)
                                                                                                        nil
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (delete
                                                                         2)
                                                                        (("2"
                                                                          (typepred
                                                                           ntcB!1)
                                                                          (("2"
                                                                            (grind)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("3"
                                                                        (delete
                                                                         2)
                                                                        (("3"
                                                                          (typepred
                                                                           ntcA!1)
                                                                          (("3"
                                                                            (grind)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (lemma th1)
                    (("2"
                      (inst -1 "translate_clause(ntcA!1)"
                       "append(not_or_reduction(translate_clause(ntcB!1)),
                               translate_clause(resolution
                                                (ntcA!1, ntcB!1)))")
                      (("2" (assert)
                        (("2" (delete 3)
                          (("2" (expand resolution)
                            (("2" (expand not_true_clauses)
                              (("2"
                                (replace -1 1)
                                (("2"
                                  (lemma
                                   append_inclusion
                                   (cl
                                    "ntcA!1"
                                    cm
                                    "ntcA!1"
                                    sq
                                    "not_or_reduction(translate_clause(ntcB!1))"))
                                  (("2"
                                    (assert)
                                    (("2"
                                      (delete 2)
                                      (("2"
                                        (grind)
                                        (("2"
                                          (lemma
                                           every_member_subset
                                           (k "ntcA!1" l "ntcA!1"))
                                          (("2"
                                            (replace -1 1)
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (split)
            (("1" (flatten)
              (("1" (lemma th2)
                (("1"
                  (inst -1 "translate_lit(find_pivot(ntcA!1, ntcB!1))"
                   "translate_clause(ntcA!1)"
                   "translate_clause(ntcB!1)"
                   "translate_clause(resolution(ntcA!1, ntcB!1))")
                  (("1" (assert)
                    (("1" (delete 2)
                      (("1" (split)
                        (("1"
                          (lemma translate_include_res
                           (nck "ntcA!1" ncl "ntcB!1"))
                          (("1" (assert) nil nil)) nil)
                         ("2"
                          (lemma translate_include_res2
                           (nck "ntcA!1" ncl "ntcB!1"))
                          (("2" (assert)
                            (("2" (lemma subset_lit_subset_fmla)
                              (("2"
                                (inst
                                 -1
                                 "translate_clause(ntcB!1)"
                                 "cons(f_neg(translate_lit(find_pivot(ntcA!1, ntcB!1))),
                  translate_clause(resolution(ntcA!1, ntcB!1)))")
                                (("1" (grind) nil nil)
                                 ("2"
                                  (delete 2)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (lemma th1)
                (("2"
                  (inst -1 "translate_clause(ntcA!1)"
                   "append(not_or_reduction(translate_clause(ntcB!1)),
                               translate_clause(resolution
                                                (ntcA!1, ntcB!1)))")
                  (("2" (assert)
                    (("2" (delete 3)
                      (("2" (expand resolution)
                        (("2" (expand not_true_clauses)
                          (("2" (flatten)
                            (("2" (replace 3 1)
                              (("2"
                                (replace 4 1)
                                (("2"
                                  (lemma
                                   append_inclusion
                                   (cl
                                    "ntcA!1"
                                    cm
                                    "merge(ntcA!1, ntcB!1)"
                                    sq
                                    "not_or_reduction(translate_clause(ntcB!1))"))
                                  (("2"
                                    (assert)
                                    (("2"
                                      (delete 2)
                                      (("2"
                                        (lemma merge_includes1)
                                        (("2"
                                          (inst -1 "ntcA!1" "ntcB!1")
                                          (("2"
                                            (flatten)
                                            (("2"
                                              (lemma
                                               subset_include
                                               (sAA
                                                "ntcA!1"
                                                sBB
                                                "merge(ntcA!1, ntcB!1)"))
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (flatten)
          (("3" (split)
            (("1" (flatten)
              (("1" (lemma lemma_subsetr)
                (("1"
                  (inst -1 "RR_th1(translate_clause(ntcB!1),
                                   append(not_or_reduction
                                          (translate_clause(ntcA!1)),
                                          translate_clause
                                          (resolution(ntcA!1, ntcB!1))))"
                   "append(not_or_reduction(translate_clause
                                                    (ntcB!1)),
                                   append(not_or_reduction
                                          (translate_clause(ntcA!1)),
                                          translate_clause
                                          (resolution(ntcA!1, ntcB!1))))"
                   "append(not_or_reduction(translate_clause
                                                    (ntcA!1)),
                                   append(not_or_reduction
                                          (translate_clause(ntcB!1)),
                                          translate_clause
                                          (resolution(ntcA!1, ntcB!1))))")
                  (("1" (assert)
                    (("1" (delete 2)
                      (("1" (split)
                        (("1" (expand not_or_reduction)
                          (("1" (expand append)
                            (("1" (expand append)
                              (("1"
                                (expand subset)
                                (("1"
                                  (expand member + 1)
                                  (("1"
                                    (expand member + 1)
                                    (("1"
                                      (expand subset)
                                      (("1"
                                        (expand member + 1)
                                        (("1"
                                          (expand resolution)
                                          (("1"
                                            (use
                                             every_member_subset
                                             (k
                                              "translate_clause(ntcB!1)"
                                              l
                                              "cons(f_not(nclause2fmla(translate_clause(ntcA!1))),
                   cons(f_not(nclause2fmla(translate_clause(ntcB!1))),
                        translate_clause(ntcB!1)))"))
                                            (("1"
                                              (replace -1 1)
                                              (("1"
                                                (hide -1)
                                                (("1"
                                                  (skosimp)
                                                  (("1"
                                                    (expand member +)
                                                    (("1"
                                                      (expand member +)
                                                      (("1"
                                                        (replace -1 1)
                                                        (("1"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (lemma th1)
                          (("2"
                            (inst -1 "translate_clause(ntcB!1)"
                             "append(not_or_reduction(translate_clause(ntcA!1)),
                               translate_clause(resolution
                                                (ntcA!1, ntcB!1)))")
                            (("2" (assert)
                              (("2"
                                (delete 2)
                                (("2"
                                  (expand resolution)
                                  (("2"
                                    (expand not_or_reduction)
                                    (("2"
                                      (expand append)
                                      (("2"
                                        (expand append)
                                        (("2"
                                          (lemma
                                           cons_cdr_inclusion
                                           (f
                                            "f_not(nclause2fmla(translate_clause(ntcA!1)))"
                                            cl
                                            "ntcB!1"
                                            ck
                                            "ntcB!1"))
                                          (("2"
                                            (assert)
                                            (("2"
                                              (delete 2)
                                              (("2"
                                                (use
                                                 every_member_subset
                                                 (k
                                                  "ntcB!1"
                                                  l
                                                  "ntcB!1"))
                                                (("2"
                                                  (replace -1 1)
                                                  (("2"
                                                    (skosimp)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (lemma th1)
                          (("3"
                            (inst -1 "translate_clause(ntcB!1)"
                             "append(not_or_reduction(translate_clause(ntcA!1)),
                               translate_clause(resolution
                                                (ntcA!1, ntcB!1)))")
                            (("3" (assert)
                              (("3"
                                (delete 2)
                                (("3"
                                  (expand resolution)
                                  (("3"
                                    (expand not_or_reduction)
                                    (("3"
                                      (expand append)
                                      (("3"
                                        (expand append)
                                        (("3"
                                          (lemma
                                           cons_cdr_inclusion
                                           (f
                                            "f_not(nclause2fmla(translate_clause(ntcA!1)))"
                                            cl
                                            "ntcB!1"
                                            ck
                                            "ntcB!1"))
                                          (("3"
                                            (assert)
                                            (("3"
                                              (delete 2)
                                              (("3"
                                                (use
                                                 every_member_subset
                                                 (k
                                                  "ntcB!1"
                                                  l
                                                  "ntcB!1"))
                                                (("3"
                                                  (replace -1 1)
                                                  (("3"
                                                    (skosimp)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (lemma th1)
                (("2"
                  (inst -1 "translate_clause(ntcA!1)"
                   "append(not_or_reduction(translate_clause(ntcB!1)),
                               translate_clause(resolution
                                                (ntcA!1, ntcB!1)))")
                  (("2" (assert)
                    (("2" (delete 3)
                      (("2" (expand not_or_reduction)
                        (("2" (expand append)
                          (("2" (expand append)
                            (("2" (expand resolution)
                              (("2"
                                (expand not_true_clauses)
                                (("2"
                                  (replace -1 1)
                                  (("2"
                                    (lemma
                                     cons_cdr_inclusion
                                     (f
                                      "f_not(nclause2fmla(translate_clause(ntcB!1)))"
                                      cl
                                      "ntcA!1"
                                      ck
                                      "ntcA!1"))
                                    (("2"
                                      (assert)
                                      (("2"
                                        (delete 2)
                                        (("2"
                                          (use
                                           every_member_subset
                                           (k "ntcB!1" l "ntcB!1"))
                                          (("2"
                                            (use
                                             every_member_subset
                                             (k "ntcA!1" l "ntcA!1"))
                                            (("2"
                                              (replace -1 1)
                                              (("2" (skosimp) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((th2 formula-decl nil resolution nil)
    (translate_include_res formula-decl nil trace2fmla nil)
    (neg_translate formula-decl nil trace2fmla nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (translate_include_res2 formula-decl nil trace2fmla nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (sentence_list? const-decl "bool" fmla nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (nclause? const-decl "bool" resolution nil)
    (clause? const-decl "bool" resolution nil)
    (find_pivot def-decl
     "{k | member(k, nck) AND member(tr_neg(k), ncl)}" trace_resolution
     nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (member def-decl "bool" list_props nil)
    (exist_pivot? def-decl "bool" trace_resolution nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (translate_lit const-decl "(literal?)" trace2fmla nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (n formal-const-decl "nat" trace_checker nil)
    (m formal-const-decl "nat" trace_checker nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (literal? const-decl "bool" resolution nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (fmla type-decl nil fmla nil) (th1 formula-decl nil resolution nil)
    (not_true_clauses const-decl "bool" trace_resolution nil)
    (merge def-decl "{cla: (tr_clause?) |
         FORALL k: member(k, cla) IFF (member(k, ck) OR member(k, cl))}"
           trace_resolution nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (append_inclusion formula-decl nil trace2fmla nil)
    (merge_includes1 formula-decl nil trace_resolution nil)
    (index const-decl "posnat" trace_resolution nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (sorted? def-decl "bool" sortedlist nil)
    (subset_include formula-decl nil sortedlist nil)
    (not_or_reduction const-decl "sequent" resolution nil)
    (sequent type-eq-decl nil sequents nil)
    (append def-decl "list[T]" list_props nil)
    (lemma_subsetr formula-decl nil resolution nil)
    (subset def-decl "bool" minlist nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (every_member_subset formula-decl nil minlist nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (f_not? adt-recognizer-decl "[fmla -> boolean]" fmla nil)
    (f_not adt-constructor-decl "[fmla -> (f_not?)]" fmla nil)
    (nclause2fmla def-decl "fmla" resolution nil)
    (RR_th1 def-decl "ne_proof_seq" resolution nil)
    (ne_proof_seq type-eq-decl nil proof nil)
    (proof_seq type-eq-decl nil proof nil)
    (proof_step type-eq-decl nil proof nil)
    (rule type-decl nil proof nil)
    (below type-eq-decl nil nat_types nil)
    (f_neg const-decl "fmla" fmla nil)
    (delete_pivot const-decl "{cl |
         FORALL l:
           member(l, cl) <=>
            member(l, ck) AND (NOT l = pivot) AND (NOT l = tr_neg(pivot))}"
     trace_resolution nil)
    (prop_atom? const-decl "bool" resolution nil)
    (subset_lit_subset_fmla formula-decl nil resolution nil)
    (cons_cdr_inclusion formula-decl nil trace2fmla nil)
    (proof_th const-decl "ne_proof_seq" trace_checker nil))
   538768 7520 t shostak))
 (map_trans_clause_TCC1 0
  (map_trans_clause_TCC1-1 nil 3483364828 3483451822
   ("" (skolem-typepred)
    (("" (split)
      (("1" (generalize lntcA!1 "nt")
        (("1" (induct nt)
          (("1" (assert) nil nil)
           ("2" (skolem-typepred)
            (("2" (flatten)
              (("2" (expand every +)
                (("2" (lift-if 1)
                  (("2" (split 1)
                    (("1" (propax) nil nil)
                     ("2" (flatten)
                      (("2" (split)
                        (("1" (grind) nil nil)
                         ("2" (assert)
                          (("2" (split -5)
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil)
                             ("3" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   unchecked
   ((list_induction formula-decl nil list_adt nil)
    (translate_lit const-decl "(literal?)" trace2fmla nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (fmla type-decl nil fmla nil)
    (literal? const-decl "bool" resolution nil)
    (clause? const-decl "bool" resolution nil)
    (nclause? const-decl "bool" resolution nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (n formal-const-decl "nat" trace_checker nil)
    (m formal-const-decl "nat" trace_checker nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   1351 1100 t nil))
 (map_ncl2fmla_TCC1 0
  (map_ncl2fmla_TCC1-1 nil 3483364828 3483451823
   ("" (skolem-typepred)
    (("" (generalize l!1 l)
      (("" (induct l)
        (("1" (grind) nil nil)
         ("2" (skolem-typepred)
          (("2" (flatten)
            (("2" (expand map +)
              (("2" (expand sentence_list? +)
                (("2" (expand freevars +)
                  (("2" (lemma nclause2fmla_sentence)
                    (("2" (inst -1 "cons1_var!1")
                      (("2" (split -6)
                        (("1" (grind) nil nil) ("2" (propax) nil nil)
                         ("3" (expand freevars + 2)
                          (("3" (lift-if 2)
                            (("3" (split)
                              (("1"
                                (flatten)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("4" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((nclause2fmla def-decl "fmla" resolution nil)
    (sentence_list? const-decl "bool" fmla nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sentence? const-decl "bool" fmla nil)
    (append def-decl "list[T]" list_props nil)
    (nclause2fmla_sentence formula-decl nil resolution nil)
    (list_induction formula-decl nil list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nclause? const-decl "bool" resolution nil)
    (clause? const-decl "bool" resolution nil)
    (literal? const-decl "bool" resolution nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (fmla type-decl nil fmla nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   919 830 t nil))
 (map_fnot_TCC1 0
  (map_fnot_TCC1-1 nil 3483364828 3483451823
   ("" (induct l)
    (("1" (typepred l!1) (("1" (propax) nil nil)) nil)
     ("2" (grind) nil nil)
     ("3" (skolem-typepred)
      (("3" (flatten)
        (("3" (expand sentence_list? +)
          (("3" (expand freevars +)
            (("3" (lift-if +)
              (("3" (split +)
                (("1" (grind) nil nil)
                 ("2" (flatten)
                  (("2" (assert)
                    (("2" (expand map +)
                      (("2" (expand sentence_list? -2)
                        (("2" (expand freevars -2)
                          (("2" (expand sentence_list? -1 1)
                            (("2" (case "null?(freevars(cons2_var!1))")
                              (("1"
                                (replace -1 -2)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (replace 1 -1)
                                (("2"
                                  (lemma
                                   length_append
                                   (l1
                                    "freevars(cons1_var!1)"
                                    l2
                                    "freevars(cons2_var!1)"))
                                  (("2"
                                    (expand length -1 1)
                                    (("2"
                                      (lift-if -1)
                                      (("2"
                                        (replace -2 -1)
                                        (("2"
                                          (case
                                           "length(freevars(cons2_var!1))=0")
                                          (("1" (grind) nil nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((term type-decl nil fmla nil)
    (var? adt-recognizer-decl "[term -> boolean]" fmla nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (length_append formula-decl nil list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length def-decl "nat" list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (fmla type-decl nil fmla nil)
    (f_not adt-constructor-decl "[fmla -> (f_not?)]" fmla nil)
    (PRED type-eq-decl nil defined_types nil)
    (f_not? adt-recognizer-decl "[fmla -> boolean]" fmla nil)
    (sentence_list? const-decl "bool" fmla nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   774 630 t nil))
 (f_TCC1 0
  (f_TCC1-1 nil 3483306244 3483451823 ("" (subtype-tcc) nil nil)
   unchecked
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   67 70 nil nil))
 (f_TCC2 0
  (f_TCC2-1 nil 3483306244 3483451824 ("" (termination-tcc) nil nil)
   unchecked
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   149 130 nil nil))
 (proof_th_list_TCC1 0
  (proof_th_list_TCC1-1 nil 3483306244 3483451824
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (typepred "car(lntcA!1)") (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (translate_lit const-decl "(literal?)" trace2fmla nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (nclause? const-decl "bool" resolution nil)
    (sorted? def-decl "bool" sortedlist nil)
    (prop_atom? const-decl "bool" resolution nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (fmla type-decl nil fmla nil)
    (literal? const-decl "bool" resolution nil)
    (clause? const-decl "bool" resolution nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (n formal-const-decl "nat" trace_checker nil)
    (m formal-const-decl "nat" trace_checker nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   871 800 t nil))
 (proof_th_list_TCC2 0
  (proof_th_list_TCC2-1 nil 3483306244 3483451825
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (lemma clause_sentence_list)
            (("" (inst -1 "translate_clause(car(lntcA!1))")
              (("" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((translate_clause const-decl "(clause?)" trace2fmla nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (sentence_list? const-decl "bool" fmla nil)
    (clause_sentence_list formula-decl nil resolution nil)
    (fmla type-decl nil fmla nil)
    (literal? const-decl "bool" resolution nil)
    (clause? const-decl "bool" resolution nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (n formal-const-decl "nat" trace_checker nil)
    (m formal-const-decl "nat" trace_checker nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   368 320 t nil))
 (proof_th_list_TCC3 0
  (proof_th_list_TCC3-1 nil 3483306244 3483451825
   ("" (subtype-tcc) nil nil) unchecked
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (/= const-decl "boolean" notequal nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (m formal-const-decl "nat" trace_checker nil)
    (n formal-const-decl "nat" trace_checker nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil))
   135 130 nil nil))
 (proof_th_list_TCC4 0
  (proof_th_list_TCC4-1 nil 3483306244 3483451827
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (typepred "car[((ne_tr_clause?))](lntcA!1)")
            (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (tr_neg const-decl "(tr_literal?)" trace_resolution nil)
    (tr_clause_true? def-decl "bool" trace_resolution nil)
    (merge def-decl "{cla: (tr_clause?) |
         FORALL k: member(k, cla) IFF (member(k, ck) OR member(k, cl))}"
           trace_resolution nil)
    (exist_pivot? def-decl "bool" trace_resolution nil)
    (delete_pivot const-decl "{cl |
         FORALL l:
           member(l, cl) <=>
            member(l, ck) AND (NOT l = pivot) AND (NOT l = tr_neg(pivot))}"
     trace_resolution nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (translate_lit const-decl "(literal?)" trace2fmla nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (nclause? const-decl "bool" resolution nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (n formal-const-decl "nat" trace_checker nil)
    (m formal-const-decl "nat" trace_checker nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   1578 1420 t nil))
 (proof_th_list_TCC5 0
  (proof_th_list_TCC5-1 nil 3483306244 3483451829
   ("" (subtype-tcc)
    ((""
      (typepred
       "car[((ne_tr_clause?))](cdr[((ne_tr_clause?))](lntcA!1))")
      (("" (grind) nil nil)) nil))
    nil)
   unchecked
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (translate_lit const-decl "(literal?)" trace2fmla nil)
    (sorted? def-decl "bool" sortedlist nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (delete_pivot const-decl "{cl |
         FORALL l:
           member(l, cl) <=>
            member(l, ck) AND (NOT l = pivot) AND (NOT l = tr_neg(pivot))}"
     trace_resolution nil)
    (tr_clause_true? def-decl "bool" trace_resolution nil)
    (tr_neg const-decl "(tr_literal?)" trace_resolution nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (/= const-decl "boolean" notequal nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (m formal-const-decl "nat" trace_checker nil)
    (n formal-const-decl "nat" trace_checker nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nclause? const-decl "bool" resolution nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil))
   2060 1920 t nil))
 (proof_th_list_TCC6 0
  (proof_th_list_TCC6-1 nil 3483306244 3483451830
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (expand not_or_reduction)
            (("" (expand append)
              (("" (expand append)
                (("" (lemma nclause2fmla_sentence)
                  (("" (hide -4)
                    ((""
                      (inst-cp -1
                       "translate_clause[m, n, i](car[((ne_tr_clause?))](lntcA!1))")
                      ((""
                        (inst-cp -1
                         "translate_clause[m, n, i](car[((ne_tr_clause?))](cdr[((ne_tr_clause?))](lntcA!1)))")
                        (("" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((append def-decl "list[T]" list_props nil)
    (nclause2fmla_sentence formula-decl nil resolution nil)
    (fmla type-decl nil fmla nil)
    (literal? const-decl "bool" resolution nil)
    (clause? const-decl "bool" resolution nil)
    (nclause? const-decl "bool" resolution nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (sentence? const-decl "bool" fmla nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (tr_neg const-decl "(tr_literal?)" trace_resolution nil)
    (delete_pivot const-decl "{cl |
         FORALL l:
           member(l, cl) <=>
            member(l, ck) AND (NOT l = pivot) AND (NOT l = tr_neg(pivot))}"
     trace_resolution nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (sentence_list? const-decl "bool" fmla nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (not_or_reduction const-decl "sequent" resolution nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (n formal-const-decl "nat" trace_checker nil)
    (m formal-const-decl "nat" trace_checker nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   1521 1370 t nil))
 (proof_th_list_TCC7 0
  (proof_th_list_TCC7-1 nil 3483306244 3483451831
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (flatten) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nclause? const-decl "bool" resolution nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (translate_lit const-decl "(literal?)" trace2fmla nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (delete_pivot const-decl "{cl |
         FORALL l:
           member(l, cl) <=>
            member(l, ck) AND (NOT l = pivot) AND (NOT l = tr_neg(pivot))}"
     trace_resolution nil)
    (tr_neg const-decl "(tr_literal?)" trace_resolution nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (n formal-const-decl "nat" trace_checker nil)
    (m formal-const-decl "nat" trace_checker nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   1381 1250 t nil))
 (proof_th_list_TCC8 0
  (proof_th_list_TCC8-1 nil 3483306244 3483451834
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (flatten)
              (("" (typepred lntcA!1)
                (("" (expand every -1)
                  (("" (expand every -1)
                    (("" (flatten)
                      (("" (hide -1)
                        (("" (lift-if -3)
                          (("" (split -3)
                            (("1" (propax) nil nil)
                             ("2" (flatten)
                              (("2"
                                (hide 1)
                                (("2"
                                  (hide -1)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (typepred res!1)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (sorted? def-decl "bool" sortedlist nil)
    (tr_neg const-decl "(tr_literal?)" trace_resolution nil)
    (tr_clause_true? def-decl "bool" trace_resolution nil)
    (merge def-decl "{cla: (tr_clause?) |
         FORALL k: member(k, cla) IFF (member(k, ck) OR member(k, cl))}"
           trace_resolution nil)
    (member def-decl "bool" list_props nil)
    (exist_pivot? def-decl "bool" trace_resolution nil)
    (index const-decl "posnat" trace_resolution nil)
    (delete_pivot const-decl "{cl |
         FORALL l:
           member(l, cl) <=>
            member(l, ck) AND (NOT l = pivot) AND (NOT l = tr_neg(pivot))}"
     trace_resolution nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (translate_lit const-decl "(literal?)" trace2fmla nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (n formal-const-decl "nat" trace_checker nil)
    (m formal-const-decl "nat" trace_checker nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   2619 2440 t nil))
 (proof_th_list_TCC9 0
  (proof_th_list_TCC9-1 nil 3483306244 3483451836
   ("" (termination-tcc) nil nil) unchecked
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (/= const-decl "boolean" notequal nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (m formal-const-decl "nat" trace_checker nil)
    (n formal-const-decl "nat" trace_checker nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (translate_lit const-decl "(literal?)" trace2fmla nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (tr_neg const-decl "(tr_literal?)" trace_resolution nil)
    (delete_pivot const-decl "{cl |
         FORALL l:
           member(l, cl) <=>
            member(l, ck) AND (NOT l = pivot) AND (NOT l = tr_neg(pivot))}"
     trace_resolution nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (length def-decl "nat" list_props nil))
   1923 1760 nil nil))
 (proof_th_list_TCC10 0
  (proof_th_list_TCC10-1 nil 3483306244 3483451840
   ("" (subtype-tcc)
    (("" (typepred "car[((ne_tr_clause?))](lntcA!1)")
      (("" (grind) nil nil)) nil))
    nil)
   unchecked
   ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (translate_lit const-decl "(literal?)" trace2fmla nil)
    (sorted? def-decl "bool" sortedlist nil)
    (resolution_list def-decl "(tr_clause?)" trace_resolution nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (delete_pivot const-decl "{cl |
         FORALL l:
           member(l, cl) <=>
            member(l, ck) AND (NOT l = pivot) AND (NOT l = tr_neg(pivot))}"
     trace_resolution nil)
    (exist_pivot? def-decl "bool" trace_resolution nil)
    (merge def-decl "{cla: (tr_clause?) |
         FORALL k: member(k, cla) IFF (member(k, ck) OR member(k, cl))}"
           trace_resolution nil)
    (tr_clause_true? def-decl "bool" trace_resolution nil)
    (tr_neg const-decl "(tr_literal?)" trace_resolution nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ne_proof_seq type-eq-decl nil proof nil)
    (proof_seq type-eq-decl nil proof nil)
    (proof_step type-eq-decl nil proof nil)
    (sequent type-eq-decl nil sequents nil)
    (rule type-decl nil proof nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (/= const-decl "boolean" notequal nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (m formal-const-decl "nat" trace_checker nil)
    (n formal-const-decl "nat" trace_checker nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nclause? const-decl "bool" resolution nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil))
   3847 3540 t nil))
 (proof_th_list_TCC11 0
  (proof_th_list_TCC11-1 nil 3483306244 3483451844
   ("" (subtype-tcc)
    ((""
      (typepred
       "car[((ne_tr_clause?))](cdr[((ne_tr_clause?))](lntcA!1))")
      (("" (grind) nil nil)) nil))
    nil)
   unchecked
   ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (translate_lit const-decl "(literal?)" trace2fmla nil)
    (sorted? def-decl "bool" sortedlist nil)
    (resolution_list def-decl "(tr_clause?)" trace_resolution nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (delete_pivot const-decl "{cl |
         FORALL l:
           member(l, cl) <=>
            member(l, ck) AND (NOT l = pivot) AND (NOT l = tr_neg(pivot))}"
     trace_resolution nil)
    (tr_clause_true? def-decl "bool" trace_resolution nil)
    (tr_neg const-decl "(tr_literal?)" trace_resolution nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ne_proof_seq type-eq-decl nil proof nil)
    (proof_seq type-eq-decl nil proof nil)
    (proof_step type-eq-decl nil proof nil)
    (sequent type-eq-decl nil sequents nil)
    (rule type-decl nil proof nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (/= const-decl "boolean" notequal nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (m formal-const-decl "nat" trace_checker nil)
    (n formal-const-decl "nat" trace_checker nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nclause? const-decl "bool" resolution nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil))
   4172 3820 t nil))
 (proof_th_list_TCC12 0
  (proof_th_list_TCC12-1 nil 3483306244 3483734745
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (flatten)
              (("" (skolem-typepred)
                (("" (flatten)
                  (("" (skolem-typepred)
                    (("" (flatten)
                      (("" (skolem-typepred)
                        (("" (flatten)
                          (("" (skolem-typepred)
                            (("" (flatten)
                              ((""
                                (skolem-typepred)
                                ((""
                                  (flatten)
                                  ((""
                                    (lemma literal_list_sentence_list)
                                    ((""
                                      (hide -6 -9 -11 -13)
                                      ((""
                                        (inst
                                         -1
                                         "translate_clause[m, n, i](res!1)")
                                        ((""
                                          (expand not_or_reduction +)
                                          ((""
                                            (expand append +)
                                            ((""
                                              (expand append +)
                                              ((""
                                                (lemma
                                                 nclause2fmla_sentence)
                                                ((""
                                                  (inst-cp -1 "l2!1")
                                                  ((""
                                                    (inst-cp -1 "l1!1")
                                                    ((""
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked
   ((not_or_reduction const-decl "sequent" resolution nil)
    (nclause? const-decl "bool" resolution nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sentence? const-decl "bool" fmla nil)
    (sentence_list? const-decl "bool" fmla nil)
    (tr_neg const-decl "(tr_literal?)" trace_resolution nil)
    (delete_pivot const-decl "{cl |
         FORALL l:
           member(l, cl) <=>
            member(l, ck) AND (NOT l = pivot) AND (NOT l = tr_neg(pivot))}"
     trace_resolution nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (translate_lit const-decl "(literal?)" trace2fmla nil) nil
    (resolution_list def-decl "(tr_clause?)" trace_resolution nil) nil
    nil nil (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (nclause2fmla_sentence formula-decl nil resolution nil)
    (append def-decl "list[T]" list_props nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil)
    (literal_list_sentence_list formula-decl nil resolution nil)
    (fmla type-decl nil fmla nil)
    (literal? const-decl "bool" resolution nil)
    (clause? const-decl "bool" resolution nil)
    (> const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (rule type-decl nil proof nil)
    (sequent type-eq-decl nil sequents nil)
    (proof_step type-eq-decl nil proof nil)
    (proof_seq type-eq-decl nil proof nil)
    (ne_proof_seq type-eq-decl nil proof nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (n formal-const-decl "nat" trace_checker nil)
    (m formal-const-decl "nat" trace_checker nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   530916 9470 t nil))
 (proof_th_list_TCC13 0
  (proof_th_list_TCC13-1 nil 3483306244 3483735788
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (flatten)
              (("" (skolem-typepred)
                (("" (flatten)
                  (("" (skolem-typepred)
                    (("" (flatten)
                      (("" (skolem-typepred)
                        (("" (flatten)
                          (("" (skolem-typepred)
                            (("" (flatten)
                              ((""
                                (skolem-typepred)
                                ((""
                                  (flatten)
                                  ((""
                                    (lemma literal_list_sentence_list)
                                    ((""
                                      (hide -13 -11 -9 -6)
                                      ((""
                                        (inst
                                         -1
                                         "translate_clause[m, n, i](res_list!1)")
                                        (("" (postpone) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished
   ((nclause2fmla_sentence formula-decl nil resolution nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (tr_neg const-decl "(tr_literal?)" trace_resolution nil)
    (delete_pivot const-decl "{cl |
         FORALL l:
           member(l, cl) <=>
            member(l, ck) AND (NOT l = pivot) AND (NOT l = tr_neg(pivot))}"
     trace_resolution nil)
    (append def-decl "list[T]" list_props nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (concl_subsetr const-decl "proof_step" resolution nil)
    (RR_subsetr const-decl "ne_proof_seq" resolution nil)
    (proof_th const-decl "ne_proof_seq" trace_checker nil)
    (resolution_list def-decl "(tr_clause?)" trace_resolution nil)
    (fmla type-decl nil fmla nil)
    (literal? const-decl "bool" resolution nil)
    (clause? const-decl "bool" resolution nil)
    (nclause? const-decl "bool" resolution nil)
    (translate_lit const-decl "(literal?)" trace2fmla nil)
    (resolution const-decl "(tr_clause?)" trace_resolution nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ne_proof_seq type-eq-decl nil proof nil)
    (proof_seq type-eq-decl nil proof nil)
    (proof_step type-eq-decl nil proof nil)
    (sequent type-eq-decl nil sequents nil)
    (rule type-decl nil proof nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (/= const-decl "boolean" notequal nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nzint nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (m formal-const-decl "nat" trace_checker nil)
    (n formal-const-decl "nat" trace_checker nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (i formal-const-decl "upto(n)" trace_checker nil)
    (tr_literal? const-decl "bool" trace_resolution nil)
    (tr_clause? const-decl "bool" trace_resolution nil)
    (ne_tr_clause? const-decl "bool" trace_resolution nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (sentence? const-decl "bool" fmla nil)
    (not_true_clauses const-decl "bool" trace_resolution nil)
    (not_or_reduction const-decl "sequent" resolution nil)
    (translate_clause const-decl "(clause?)" trace2fmla nil))
   168950 340 t nil))
 (proof_th_list_TCC14 0
  (proof_th_list_TCC14-3 "" 3483451665 3483452931
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (flatten)
              (("" (skolem-typepred)
                (("" (flatten)
                  (("" (skolem-typepred)
                    (("" (flatten)
                      (("" (skolem-typepred)
                        (("" (flatten)
                          (("" (skolem-typepred)
                            (("" (flatten)
                              ((""
                                (typepred "res_list!1")
                                ((""
                                  (typepred "not_or_map(lntcA!1)")
                                  ((""
                                    (hide -2 -5)
                                    ((""
                                      (lemma
                                       literal_list_sentence_list)
                                      ((""
                                        (inst
                                         -1
                                         "translate_clause[m, n, i](res_list!1)")
                                        ((""
                                          (hide -18 -11 -9)
                                          ((""
                                            (hide -7)
                                            ((""
                                              (hide -5 -6)
                                              (("" (postpone) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unchecked nil 553413 310 t shostak)
  (proof_th_list_TCC14-2 "" 3483392298 3483451069
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (flatten)
              (("" (skolem-typepred)
                (("" (flatten)
                  (("" (skolem-typepred)
                    (("" (flatten)
                      (("" (skolem-typepred)
                        (("" (flatten)
                          (("" (typepred "not_or_map(lntcA!1)")
                            (("" (hide -14 -13)
                              ((""
                                (hide -4 -8)
                                ((""
                                  (typepred "lntcA!1")
                                  ((""
                                    (hide -1)
                                    ((""
                                      (typepred
                                       "resolution_list[m, n, i](lntcA!1)")
                                      (("1" (postpone) nil nil)
                                       ("2" (postpone) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished nil 247 190 t shostak)
  (proof_th_list_TCC14-1 nil 3483313812 3483374131
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (skolem-typepred)
            (("" (flatten)
              (("" (skolem-typepred)
                (("" (flatten)
                  (("" (skolem-typepred)
                    (("" (flatten)
                      (("" (skolem-typepred)
                        (("" (flatten)
                          (("" (lemma clause_sentence_list)
                            (("" (typepred "not_or_map(lntcA!1)")
                              ((""
                                (typepred "lntcA!1")
                                ((""
                                  (hide -1)
                                  ((""
                                    (hide -6 -10)
                                    ((""
                                      (typepred
                                       "resolution_list[m, n, i](lntcA!1)")
                                      (("1" (postpone) nil nil)
                                       ("2" (postpone) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished nil 4940329 2590 t nil))
 (proof_th_list_TCC15 0
  (proof_th_list_TCC15-1 nil 3483734178 nil ("" (subtype-tcc) nil nil)
   unfinished nil nil nil nil nil))
 (proof_th_list_TCC16 0
  (proof_th_list_TCC16-1 nil 3483734178 nil ("" (subtype-tcc) nil nil)
   unfinished nil nil nil nil nil))
 (th_list 0
  (th_list-1 nil 3483452940 3483741165
   ("" (skolem-typepred)
    (("" (hide -1)
      (("" (assert)
        (("" (split)
          (("1" (postpone) nil nil)
           ("2" (expand proof_th_list)
            (("2" (split)
              (("1" (flatten)
                (("1" (lemma th1)
                  (("1"
                    (inst -1 "translate_clause(car(lntcA!1))"
                     "translate_clause(car(lntcA!1))")
                    (("1" (assert)
                      (("1" (delete 2)
                        (("1" (lemma subset_lit_subset_fmla)
                          (("1"
                            (inst -1 "translate_clause(car(lntcA!1))"
                             "translate_clause(car(lntcA!1))")
                            (("1"
                              (lemma every_member_subset
                               (k
                                "translate_clause(car(lntcA!1))"
                                l
                                "translate_clause(car(lntcA!1))"))
                              (("1"
                                (replace -2 1)
                                (("1"
                                  (replace -1 1)
                                  (("1"
                                    (skolem-typepred)
                                    (("1" (flatten) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (split)
                  (("1" (flatten)
                    (("1" (lemma lemma_subsetr)
                      (("1" (postpone) nil nil)) nil))
                    nil)
                   ("2" (postpone) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished nil 173853 300 t shostak)))

