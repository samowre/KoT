%%% ADT file generated from fmla

term_adt: THEORY
 BEGIN

  term: TYPE

  IMPORTING funpred

  var?, apply?: [term -> boolean]

  v_index: [(var?) -> nat]

  fun: [(apply?) -> (fun?)]

  args: [d: (apply?) -> {l: list[term] | length(l) = arity(fun(d))}]

  v: [nat -> (var?)]

  apply:
        [[fun: (fun?), {l: list[term] | length(l) = arity(fun)}] ->
           (apply?)]

  term_ord: [term -> upto(1)]

  term_ord_defaxiom: AXIOM
    (FORALL (v_index: nat): term_ord(v(v_index)) = 0) AND
     (FORALL (fun: (fun?), args: {l: list[term] | length(l) = arity(fun)}):
        term_ord(apply(fun, args)) = 1);

  ord(x: term): [term -> upto(1)] =
      CASES x OF v(v1_var): 0, apply(apply1_var, apply2_var): 1 ENDCASES

  term_v_extensionality: AXIOM
    FORALL (var?_var: (var?), var?_var2: (var?)):
      v_index(var?_var) = v_index(var?_var2) IMPLIES var?_var = var?_var2;

  term_v_eta: AXIOM
    FORALL (var?_var: (var?)): v(v_index(var?_var)) = var?_var;

  term_apply_extensionality: AXIOM
    FORALL (apply?_var: (apply?), apply?_var2: (apply?)):
      fun(apply?_var) = fun(apply?_var2) AND
       args(apply?_var) = args(apply?_var2)
       IMPLIES apply?_var = apply?_var2;

  term_apply_eta: AXIOM
    FORALL (apply?_var: (apply?)):
      apply(fun(apply?_var), args(apply?_var)) = apply?_var;

  term_v_index_v: AXIOM FORALL (v1_var: nat): v_index(v(v1_var)) = v1_var;

  term_fun_apply: AXIOM
    FORALL (apply1_var: (fun?),
            apply2_var: {l: list[term] | length(l) = arity(apply1_var)}):
      fun(apply(apply1_var, apply2_var)) = apply1_var;

  term_args_apply: AXIOM
    FORALL (apply1_var: (fun?),
            apply2_var: {l: list[term] | length(l) = arity(apply1_var)}):
      args(apply(apply1_var, apply2_var)) = apply2_var;

  term_inclusive: AXIOM
    FORALL (term_var: term): var?(term_var) OR apply?(term_var);

  term_induction: AXIOM
    FORALL (p: [term -> boolean]):
      ((FORALL (v1_var: nat): p(v(v1_var))) AND
        (FORALL (apply1_var: (fun?),
                 apply2_var:
                   {l: list[term] | length(l) = arity(apply1_var)}):
           every(p)(apply2_var) IMPLIES p(apply(apply1_var, apply2_var))))
       IMPLIES (FORALL (term_var: term): p(term_var));

  subterm(x: term, y: term):  boolean =
      x = y OR
       CASES y
         OF v(v1_var): FALSE,
            apply(apply1_var, apply2_var):
              some[term]((LAMBDA (z: term): subterm(x, z)))(apply2_var)
         ENDCASES;

  <<:  (strict_well_founded?[term]) =
      LAMBDA (x, y: term):
        CASES y
          OF v(v1_var): FALSE,
             apply(apply1_var, apply2_var):
               some[term](LAMBDA (z: term): x = z OR x << z)(apply2_var)
          ENDCASES;

  term_well_founded: AXIOM strict_well_founded?[term](<<);

  reduce_nat(var?_fun: [nat -> nat],
             apply?_fun: [[apply1_var: (fun?), list[nat]] -> nat]):
        [term -> nat] =
      LAMBDA (term_adtvar: term):
        LET red: [term -> nat] = reduce_nat(var?_fun, apply?_fun) IN
          CASES term_adtvar
            OF v(v1_var): var?_fun(v1_var),
               apply(apply1_var, apply2_var):
                 apply?_fun(apply1_var, map[term, nat](red)(apply2_var))
            ENDCASES;

  REDUCE_nat(var?_fun: [[nat, term] -> nat],
             apply?_fun: [[apply1_var: (fun?), list[nat], term] -> nat]):
        [term -> nat] =
      LAMBDA (term_adtvar: term):
        LET red: [term -> nat] = REDUCE_nat(var?_fun, apply?_fun) IN
          CASES term_adtvar
            OF v(v1_var): var?_fun(v1_var, term_adtvar),
               apply(apply1_var, apply2_var):
                 apply?_fun(apply1_var, map[term, nat](red)(apply2_var),
                            term_adtvar)
            ENDCASES;

  reduce_ordinal(var?_fun: [nat -> ordinal],
                 apply?_fun:
                   [[apply1_var: (fun?), list[ordinal]] -> ordinal]):
        [term -> ordinal] =
      LAMBDA (term_adtvar: term):
        LET red: [term -> ordinal] = reduce_ordinal(var?_fun, apply?_fun)
          IN
          CASES term_adtvar
            OF v(v1_var): var?_fun(v1_var),
               apply(apply1_var, apply2_var):
                 apply?_fun(apply1_var,
                            map[term, ordinal](red)(apply2_var))
            ENDCASES;

  REDUCE_ordinal(var?_fun: [[nat, term] -> ordinal],
                 apply?_fun:
                   [[apply1_var: (fun?), list[ordinal], term] ->
                      ordinal]):
        [term -> ordinal] =
      LAMBDA (term_adtvar: term):
        LET red: [term -> ordinal] = REDUCE_ordinal(var?_fun, apply?_fun)
          IN
          CASES term_adtvar
            OF v(v1_var): var?_fun(v1_var, term_adtvar),
               apply(apply1_var, apply2_var):
                 apply?_fun(apply1_var,
                            map[term, ordinal](red)(apply2_var),
                            term_adtvar)
            ENDCASES;
 END term_adt

term_adt_reduce[range: TYPE]: THEORY
 BEGIN

  IMPORTING term_adt

  IMPORTING funpred

  reduce(var?_fun: [nat -> range],
         apply?_fun: [[apply1_var: (fun?), list[range]] -> range]):
        [term -> range] =
      LAMBDA (term_adtvar: term):
        LET red: [term -> range] = reduce(var?_fun, apply?_fun) IN
          CASES term_adtvar
            OF v(v1_var): var?_fun(v1_var),
               apply(apply1_var, apply2_var):
                 apply?_fun(apply1_var, map[term, range](red)(apply2_var))
            ENDCASES;

  REDUCE(var?_fun: [[nat, term] -> range],
         apply?_fun: [[apply1_var: (fun?), list[range], term] -> range]):
        [term -> range] =
      LAMBDA (term_adtvar: term):
        LET red: [term -> range] = REDUCE(var?_fun, apply?_fun) IN
          CASES term_adtvar
            OF v(v1_var): var?_fun(v1_var, term_adtvar),
               apply(apply1_var, apply2_var):
                 apply?_fun(apply1_var, map[term, range](red)(apply2_var),
                            term_adtvar)
            ENDCASES;
 END term_adt_reduce