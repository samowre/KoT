
Context file /home/toubhans/Documents/STAGE/pvs4.2/lib/PVS2Why-0.1/myexamples/.pvscontext written
Context changed to ~/Documents/STAGE/pvs4.2/lib/PVS2Why-0.1/myexamples/
Loading prelude library context from /home/toubhans/Documents/STAGE/pvs4.2/lib/PVS2Why/...
/home/toubhans/Documents/STAGE/pvs4.2/lib/PVS2Why/.pvscontext is empty
  no PVS files loaded
;;; Compiling file pvs-lib.lisp
;;; Writing fasl file pvs-lib.lfasl
;;; Fasl write complete

Loading pvs-lib.lfasl...
;   Fast loading
;      /home/toubhans/Documents/STAGE/pvs4.2/lib/PVS2Why/pvs-lib.lfasl

Loading prelude library context from /home/toubhans/Documents/STAGE/pvs4.2/lib/ProofLite/...
/home/toubhans/Documents/STAGE/pvs4.2/lib/ProofLite/.pvscontext is empty
  no PVS files loaded
;;; Compiling file pvs-lib.lisp
;;; Writing fasl file pvs-lib.lfasl
;;; Fasl write complete

Loading pvs-lib.lfasl...
;     Fast loading
;        /home/toubhans/Documents/STAGE/pvs4.2/lib/ProofLite/pvs-lib.lfasl

Loading file /home/toubhans/Documents/STAGE/pvs4.2/lib/ProofLite/pregexp.lfasl
;       Fast loading
;          /home/toubhans/Documents/STAGE/pvs4.2/lib/ProofLite/pregexp.lfasl

pregexp.lfasl loaded
Loading file /home/toubhans/Documents/STAGE/pvs4.2/lib/ProofLite/prooflite.lfasl
;       Fast loading
;          /home/toubhans/Documents/STAGE/pvs4.2/lib/ProofLite/prooflite.lfasl

prooflite.lfasl loaded
pvs-lib.lfasl loaded
Loading file /home/toubhans/Documents/STAGE/pvs4.2/lib/PVS2Why/util.lfasl
util.lfasl loaded
Loading file /home/toubhans/Documents/STAGE/pvs4.2/lib/PVS2Why/why.lfasl
Warning: Ignoring declaration of unrecognized ftype: (FUNCTION (T) WHY-GENERIC-TYPE)
Warning: The type subform of the FTYPE declaration must be a subtype of FUNCTION: (FTYPE (FUNCTION (T) WHY-GENERIC-TYPE) PARAMETERS)

why.lfasl loaded
Loading file /home/toubhans/Documents/STAGE/pvs4.2/lib/PVS2Why/pvs2why.lfasl
pvs2why.lfasl loaded
Loading file /home/toubhans/Documents/STAGE/pvs4.2/lib/PVS2Why/why2xml.lfasl
why2xml.lfasl loaded
Loading file /home/toubhans/Documents/STAGE/pvs4.2/lib/PVS2Why/why2java.lfasl
why2java.lfasl loaded
pvs-lib.lfasl loaded
Parsing test_aliasing
test_aliasing parsed in 0.01 seconds
Typechecking test_aliasing

 In declaration g:
  added conversion restrict[nat, below(3), nat]
             
  to f, converting
     [nat -> nat]
  to [below(3) -> nat]

test_aliasing typechecked in 0.12s: 1 TCC, 0 proved, 0 subsumed, 1 unproved; 1 conversion
***
*** Processing ./test_aliasing.pvs via PVS2Why-0.1 (11/10/07)
***
Function: pvs2why-theory: test_aliasing 
Function: pvs2why-one-theory: test_aliasing 
Function: pvs2why-type-parameters:  
Result: nil 
here1Function: pvs2why-imports:  
Function: pvs2why-declaration: #<const-decl test_aliasing.tab>
Function: pvs2why-resolution-destructive #<const-decl test_aliasing.tab>  i:
                                                                            below(3)  nat
Function: pvs2why-type-subtype: below(3)
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
Function: pvs2why*-if-expr: COND i = 0 -> 3, i = 1 -> 42, i = 2 -> 7 ENDCOND nat 
Function: pvs2why*-application: i = 0 nat 
decl-type boolean 
Function: pvs2why-primitive-app:  i  0    number  number  nat 
Function: pvs2why*-list:  i  0   number  number  
Function: pvs2why*-name-expr: i   i: below(3) . i   number 
Function: pvs2why-type-subtype: below(3)
mk-why-primitive-type: int nil nil 
mk-why-name i formal #<why-primitive-type>
Function: pvs2why*-list:  0   number  
Function: pvs2why*-number-expr: 0 number 
mk-why-literal 0 number
Function: pvs2why*-list:   
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-funtype [[number, number] -> boolean]
Function: pvs2why-type-tuple: [number, number]
Function: pvs2why-type-name: number
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-name: number
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-name: boolean
mk-why-primitive-type: bool nil nil 
mk-why-function-type: domain (#<why-primitive-type> #<why-primitive-type>) range #<why-primitive-type>
mk-why-name == constant #<why-function-type>
mk-why-function-application #<why-name> (#<why-name> #<why-literal>) # t nil #<why-primitive-type>  
Function: pvs2why*-number-expr: 3 nat 
mk-why-literal 3 number
Function: pvs2why*-if-expr: COND i = 1 -> 42, i = 2 -> 7 ENDCOND nat 
Function: pvs2why*-application: i = 1 nat 
decl-type boolean 
Function: pvs2why-primitive-app:  i  1    number  number  nat 
Function: pvs2why*-list:  i  1   number  number  
Function: pvs2why*-name-expr: i   i: below(3) . i   number 
Function: pvs2why-type-subtype: below(3)
mk-why-primitive-type: int nil nil 
mk-why-name i formal #<why-primitive-type>
Function: pvs2why*-list:  1   number  
Function: pvs2why*-number-expr: 1 number 
mk-why-literal 1 number
Function: pvs2why*-list:   
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-funtype [[number, number] -> boolean]
Function: pvs2why-type-tuple: [number, number]
Function: pvs2why-type-name: number
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-name: number
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-name: boolean
mk-why-primitive-type: bool nil nil 
mk-why-function-type: domain (#<why-primitive-type> #<why-primitive-type>) range #<why-primitive-type>
mk-why-name == constant #<why-function-type>
mk-why-function-application #<why-name> (#<why-name> #<why-literal>) # t nil #<why-primitive-type>  
Function: pvs2why*-number-expr: 42 nat 
mk-why-literal 42 number
Function: pvs2why*-if-expr: COND i = 2 -> 7 ENDCOND nat 
Function: pvs2why*-application: i = 2 nat 
decl-type boolean 
Function: pvs2why-primitive-app:  i  2    number  number  nat 
Function: pvs2why*-list:  i  2   number  number  
Function: pvs2why*-name-expr: i   i: below(3) . i   number 
Function: pvs2why-type-subtype: below(3)
mk-why-primitive-type: int nil nil 
mk-why-name i formal #<why-primitive-type>
Function: pvs2why*-list:  2   number  
Function: pvs2why*-number-expr: 2 number 
mk-why-literal 2 number
Function: pvs2why*-list:   
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-funtype [[number, number] -> boolean]
Function: pvs2why-type-tuple: [number, number]
Function: pvs2why-type-name: number
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-name: number
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-name: boolean
mk-why-primitive-type: bool nil nil 
mk-why-function-type: domain (#<why-primitive-type> #<why-primitive-type>) range #<why-primitive-type>
mk-why-name == constant #<why-function-type>
mk-why-function-application #<why-name> (#<why-name> #<why-literal>) # t nil #<why-primitive-type>  
Function: pvs2why*-number-expr: 7 nat 
mk-why-literal 7 number
Function: pvs2why*-number-expr: 7 nat 
mk-why-literal 7 number
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-conditional #<why-function-application> #<why-literal> #<why-literal> 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-conditional #<why-function-application> #<why-literal> #<why-conditional> 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-conditional #<why-function-application> #<why-literal> #<why-conditional> 
mk-why-function tab (i) #<why-conditional> #<why-function-type>
mk-why-binding i #<why-primitive-type> 
Function: pvs2why-declaration: #<const-decl test_aliasing.plus>
Function: pvs2why-resolution-destructive #<const-decl test_aliasing.plus>  tab1:
                                                                             T  tab2:
                                                                                  T  [below(3) ->
                                                                                        nat]
Function: pvs2why-type-funtype T
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
Function: pvs2why-type-funtype T
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
Function: pvs2why-type-funtype [below(3) -> nat]
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
mk-why-function-type: domain (#<why-array-type> #<why-array-type>) range #<why-array-type>
Function: pvs2why*-lambda-expr: LAMBDA (i: below(3)): tab1(i) + tab2(i) [below(3) ->
                                                                           nat]
Function: pvs2why-type-subtype: below(3)
mk-why-primitive-type: int nil nil 
mk-why-binding i #<why-primitive-type> 
Recordtype? t1 t2 nat numfield 
Function: pvs2why-coerce-types nat numfield 
Recordtype? t1 t2 nat numfield 
Function: pvs2why-coerce-types nat numfield 
Coerceresult nat 
Recordtype? t1 t2 nil nil 
Function: pvs2why-coerce-types [below(3) -> nat] [below(3) -> numfield] 
Function: pvs2why*-application: tab1(i) + tab2(i) nat 
decl-type numfield 
Function: pvs2why-primitive-app:  tab1(i)  tab2(i)    numfield  numfield  nat 
Function: pvs2why*-list:  tab1(i)  tab2(i)   numfield  numfield  
Function: pvs2why*-application: tab1(i) numfield 
decl-type nat 
Function: pvs2why*-name-expr: tab1   i: below(3) . i   tab2: T . tab2   tab1: T . tab1   T 
Function: pvs2why-type-funtype T
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
mk-why-name tab1 formal #<why-array-type>
Function: pvs2why*-list:  i   below(3)  
Function: pvs2why*-name-expr: i   i: below(3) . i   tab2: T . tab2   tab1: T . tab1   below(3) 
Function: pvs2why-type-subtype: below(3)
mk-why-primitive-type: int nil nil 
mk-why-name i formal #<why-primitive-type>
Function: pvs2why*-list:   
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-subscription #<why-name> #<why-name> 
Function: pvs2why*-list:  tab2(i)   numfield  
Function: pvs2why*-application: tab2(i) numfield 
decl-type nat 
Function: pvs2why*-name-expr: tab2   i: below(3) . i   tab2: T . tab2   tab1: T . tab1   T 
Function: pvs2why-type-funtype T
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
mk-why-name tab2 formal #<why-array-type>
Function: pvs2why*-list:  i   below(3)  
Function: pvs2why*-name-expr: i   i: below(3) . i   tab2: T . tab2   tab1: T . tab1   below(3) 
Function: pvs2why-type-subtype: below(3)
mk-why-primitive-type: int nil nil 
mk-why-name i formal #<why-primitive-type>
Function: pvs2why*-list:   
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-subscription #<why-name> #<why-name> 
Function: pvs2why*-list:   
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-funtype [[numfield, numfield] -> numfield]
Function: pvs2why-type-tuple: [numfield, numfield]
Function: pvs2why-type-subtype: numfield
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-subtype: numfield
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-subtype: numfield
mk-why-primitive-type: real nil nil 
mk-why-function-type: domain (#<why-primitive-type> #<why-primitive-type>) range #<why-primitive-type>
mk-why-name + constant #<why-function-type>
mk-why-function-application #<why-name> (#<why-array-subscription> #<why-array-subscription>) # t nil #<why-primitive-type>  
???????Function: pvs2why-type-funtype [below(3) -> nat]
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
mk-why-lambda-abstraction (#<why-binding>) #<why-function-application> #<why-array-type> 
lower 0 upper 3 - 1Function: pvs2why*-number-expr: 0 nil 
mk-why-literal 0 number
Function: pvs2why*-application: 3 - 1 number_field 
decl-type number_field 
Function: pvs2why-primitive-app:  3  1    numfield  numfield  number_field 
Function: pvs2why*-list:  3  1   numfield  numfield  
Function: pvs2why*-number-expr: 3 numfield 
mk-why-literal 3 number
Function: pvs2why*-list:  1   numfield  
Function: pvs2why*-number-expr: 1 numfield 
mk-why-literal 1 number
Function: pvs2why*-list:   
Function: pvs2why-type-subtype: number_field
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-funtype [[numfield, numfield] -> numfield]
Function: pvs2why-type-tuple: [numfield, numfield]
Function: pvs2why-type-subtype: numfield
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-subtype: numfield
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-subtype: numfield
mk-why-primitive-type: real nil nil 
mk-why-function-type: domain (#<why-primitive-type> #<why-primitive-type>) range #<why-primitive-type>
mk-why-name - constant #<why-function-type>
mk-why-function-application #<why-name> (#<why-literal> #<why-literal>) # t nil #<why-primitive-type>  
Function: pvs2why-type-funtype [below(3) -> nat]
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
mk-why-array-literal #<why-function-application> #<why-literal> #<why-lambda-abstraction> #<why-array-type>
mk-why-function plus (tab1 tab2) #<why-array-literal> #<why-function-type>
mk-why-binding tab1 #<why-array-type> 
mk-why-binding tab2 #<why-array-type> 
Function: pvs2why-declaration: #<const-decl test_aliasing.f>
Function: pvs2why-resolution-destructive #<const-decl test_aliasing.f>  i: nat  nat
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
Function: pvs2why*-name-expr: i   i: nat . i   nat 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-name i variable #<why-primitive-type>
mk-why-function f (i) #<why-name> #<why-function-type>
mk-why-binding i #<why-primitive-type> 
Function: pvs2why-declaration: #<const-decl test_aliasing.g>
Function: pvs2why-resolution-destructive #<const-decl test_aliasing.g>  T
Function: pvs2why-type-funtype T
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
mk-why-function-type: domain nil range #<why-array-type>
Function: pvs2why*-application: plus(restrict[nat, below(3), nat](f), tab) T 
decl-type [below(3) -> nat] 
Function: pvs2why-defn-application: plus(restrict[nat, below(3), nat](f), tab) T 
Declared type: [[T, T] -> [below(3) -> nat]] 
Domain type:  T  T  
Function: pvs2why*-list:  restrict[nat, below(3), nat](f)  tab   T  T  
Function: pvs2why*-application: restrict[nat, below(3), nat](f) T 
decl-type [below(3) -> nat] 
Function: pvs2why-primitive-app:  f    [nat -> nat]  T 
Function: pvs2why*-list:  f   [nat -> nat]  
Function: pvs2why*-name-expr: f   [nat -> nat] 
Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
mk-why-name f constant #<why-function-type>
Function: pvs2why*-list:   
Function: pvs2why-type-funtype T
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
Function: pvs2why-type-funtype [[nat -> nat] -> [below(3) -> nat]]
Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
Function: pvs2why-type-funtype [below(3) -> nat]
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
mk-why-function-type: domain (#<why-function-type>) range #<why-array-type>
mk-why-name pvsrestrict constant #<why-function-type>
mk-why-function-application #<why-name> (#<why-name>) # t nil #<why-array-type>  
Function: pvs2why*-list:  tab   T  
Function: pvs2why*-name-expr: tab   T 
Function: pvs2why-type-funtype [below(3) -> nat]
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
mk-why-name tab constant #<why-array-type>
Function: pvs2why*-list:   
Function: pvs2why*-name-expr: plus   [below(3) -> nat] 
Function: pvs2why-type-funtype [[T, T] -> [below(3) -> nat]]
Function: pvs2why-type-tuple: [T, T]
Function: pvs2why-type-funtype T
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
Function: pvs2why-type-funtype T
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
Function: pvs2why-type-funtype [below(3) -> nat]
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
mk-why-function-type: domain (#<why-array-type> #<why-array-type>) range #<why-array-type>
mk-why-name plus constant #<why-function-type>
Before Declared type: T 
Function: pvs2why-type-funtype T
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
Why Declared type: #<why-array-type> 
mk-why-function-application #<why-name> (#<why-function-application> #<why-name>) # nil nil #<why-array-type>  
mk-why-function g nil #<why-function-application> #<why-function-type>
Function: pvs2why-declaration: #<const-decl test_aliasing.h>
Function: pvs2why-resolution-destructive #<const-decl test_aliasing.h>  i: nat  [nat ->
                                                                                   nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
mk-why-function-type: domain (#<why-primitive-type>) range #<why-function-type>
Function: pvs2why*-lambda-expr: LAMBDA (j: nat): i + j [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-binding j #<why-primitive-type> 
Recordtype? t1 t2 nat numfield 
Function: pvs2why-coerce-types nat numfield 
Recordtype? t1 t2 nat numfield 
Function: pvs2why-coerce-types nat numfield 
Coerceresult nat 
Recordtype? t1 t2 nil nil 
Function: pvs2why-coerce-types [nat -> nat] [nat -> numfield] 
Function: pvs2why*-application: i + j nat 
decl-type numfield 
Function: pvs2why-primitive-app:  i  j    numfield  numfield  nat 
Function: pvs2why*-list:  i  j   numfield  numfield  
Function: pvs2why*-name-expr: i   j: nat . j   i: nat . i   numfield 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-name i formal #<why-primitive-type>
Function: pvs2why*-list:  j   numfield  
Function: pvs2why*-name-expr: j   j: nat . j   i: nat . i   numfield 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-name j formal #<why-primitive-type>
Function: pvs2why*-list:   
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-funtype [[numfield, numfield] -> numfield]
Function: pvs2why-type-tuple: [numfield, numfield]
Function: pvs2why-type-subtype: numfield
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-subtype: numfield
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-subtype: numfield
mk-why-primitive-type: real nil nil 
mk-why-function-type: domain (#<why-primitive-type> #<why-primitive-type>) range #<why-primitive-type>
mk-why-name + constant #<why-function-type>
mk-why-function-application #<why-name> (#<why-name> #<why-name>) # t nil #<why-primitive-type>  
???????Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
mk-why-lambda-abstraction (#<why-binding>) #<why-function-application> #<why-function-type> 
mk-why-function h (i) #<why-lambda-abstraction> #<why-function-type>
mk-why-binding i #<why-primitive-type> 
Function: pvs2why-declaration: #<const-decl test_aliasing.hbis>
Function: pvs2why-resolution-destructive #<const-decl test_aliasing.hbis>  [nat ->
                                                                              [nat ->
                                                                                 nat]]
Function: pvs2why-type-funtype [nat -> [nat -> nat]]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
mk-why-function-type: domain (#<why-primitive-type>) range #<why-function-type>
mk-why-function-type: domain nil range #<why-function-type>
Function: pvs2why*-update-expr h WITH [(0)(0) := 1] [nat -> [nat -> nat]] 
Function: pvs2why*-lambda-expr: LAMBDA (x: nat):
                                  IF x = 0
                                    THEN LAMBDA (x1: nat):
                                           IF x1 = 0 THEN 1 ELSE h(x)(x1) ENDIF
                                  ELSE h(x)
                                  ENDIF [nat -> [nat -> nat]]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-binding x #<why-primitive-type> 
Recordtype? t1 t2 nil nil 
Function: pvs2why-coerce-types [nat -> nat] [nat -> real] 
Recordtype? t1 t2 nil nil 
Function: pvs2why-coerce-types [nat -> nat] [nat -> real] 
Coerceresult [nat -> nat] 
Recordtype? t1 t2 nil nil 
Function: pvs2why-coerce-types [nat -> [nat -> nat]] [nat -> [nat -> real]] 
Function: pvs2why*-if-expr: IF x = 0
                              THEN LAMBDA (x1: nat):
                                     IF x1 = 0 THEN 1 ELSE h(x)(x1) ENDIF
                            ELSE h(x)
                            ENDIF [nat -> nat] 
Function: pvs2why*-application: x = 0 [nat -> nat] 
decl-type boolean 
Function: pvs2why-primitive-app:  x  0    number  number  [nat -> nat] 
Function: pvs2why*-list:  x  0   number  number  
Function: pvs2why*-name-expr: x   x: nat . x   number 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-name x formal #<why-primitive-type>
Function: pvs2why*-list:  0   number  
Function: pvs2why*-number-expr: 0 number 
mk-why-literal 0 number
Function: pvs2why*-list:   
Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
Function: pvs2why-type-funtype [[number, number] -> boolean]
Function: pvs2why-type-tuple: [number, number]
Function: pvs2why-type-name: number
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-name: number
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-name: boolean
mk-why-primitive-type: bool nil nil 
mk-why-function-type: domain (#<why-primitive-type> #<why-primitive-type>) range #<why-primitive-type>
mk-why-name == constant #<why-function-type>
mk-why-function-application #<why-name> (#<why-name> #<why-literal>) # t nil #<why-function-type>  
Function: pvs2why*-lambda-expr: LAMBDA (x1: nat):
                                  IF x1 = 0 THEN 1 ELSE h(x)(x1) ENDIF [nat ->
                                                                          nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-binding x1 #<why-primitive-type> 
Recordtype? t1 t2 nat real 
Function: pvs2why-coerce-types nat real 
Recordtype? t1 t2 nat real 
Function: pvs2why-coerce-types nat real 
Coerceresult nat 
Recordtype? t1 t2 nil nil 
Function: pvs2why-coerce-types [nat -> nat] [nat -> real] 
Function: pvs2why*-if-expr: IF x1 = 0 THEN 1 ELSE h(x)(x1) ENDIF nat 
Function: pvs2why*-application: x1 = 0 nat 
decl-type boolean 
Function: pvs2why-primitive-app:  x1  0    number  number  nat 
Function: pvs2why*-list:  x1  0   number  number  
Function: pvs2why*-name-expr: x1   x1: nat . x1   x: nat . x   number 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-name x1 formal #<why-primitive-type>
Function: pvs2why*-list:  0   number  
Function: pvs2why*-number-expr: 0 number 
mk-why-literal 0 number
Function: pvs2why*-list:   
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-funtype [[number, number] -> boolean]
Function: pvs2why-type-tuple: [number, number]
Function: pvs2why-type-name: number
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-name: number
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-name: boolean
mk-why-primitive-type: bool nil nil 
mk-why-function-type: domain (#<why-primitive-type> #<why-primitive-type>) range #<why-primitive-type>
mk-why-name == constant #<why-function-type>
mk-why-function-application #<why-name> (#<why-name> #<why-literal>) # t nil #<why-primitive-type>  
Function: pvs2why*-number-expr: 1 nat 
mk-why-literal 1 number
Function: pvs2why*-application: h(x)(x1) nat 
decl-type nat 
Function: pvs2why*-application: h(x) [nat -> nat] 
decl-type [nat -> nat] 
Function: pvs2why-defn-application: h(x) [nat -> nat] 
Declared type: [nat -> [nat -> nat]] 
Domain type:  nat  
Function: pvs2why*-list:  x   nat  
Function: pvs2why*-name-expr: x   x1: nat . x1   x: nat . x   nat 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-name x formal #<why-primitive-type>
Function: pvs2why*-list:   
Function: pvs2why*-name-expr: h   x1: nat . x1   x: nat . x   [nat -> nat] 
Function: pvs2why-type-funtype [nat -> [nat -> nat]]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
mk-why-function-type: domain (#<why-primitive-type>) range #<why-function-type>
mk-why-name h constant #<why-function-type>
Before Declared type: [nat -> nat] 
Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
Why Declared type: #<why-function-type> 
mk-why-function-application #<why-name> (#<why-name>) # nil nil #<why-function-type>  
Function: pvs2why*-list:  x1   nat  
Function: pvs2why*-name-expr: x1   x1: nat . x1   x: nat . x   nat 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-name x1 formal #<why-primitive-type>
Function: pvs2why*-list:   
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-application #<why-function-application> (#<why-name>) # nil nil #<why-primitive-type>  
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-conditional #<why-function-application> #<why-literal> #<why-function-application> 
???????Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
mk-why-lambda-abstraction (#<why-binding>) #<why-conditional> #<why-function-type> 
Function: pvs2why*-application: h(x) [nat -> nat] 
decl-type [nat -> nat] 
Function: pvs2why-defn-application: h(x) [nat -> nat] 
Declared type: [nat -> [nat -> nat]] 
Domain type:  nat  
Function: pvs2why*-list:  x   nat  
Function: pvs2why*-name-expr: x   x: nat . x   nat 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-name x formal #<why-primitive-type>
Function: pvs2why*-list:   
Function: pvs2why*-name-expr: h   x: nat . x   [nat -> nat] 
Function: pvs2why-type-funtype [nat -> [nat -> nat]]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
mk-why-function-type: domain (#<why-primitive-type>) range #<why-function-type>
mk-why-name h constant #<why-function-type>
Before Declared type: [nat -> nat] 
Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
Why Declared type: #<why-function-type> 
mk-why-function-application #<why-name> (#<why-name>) # nil nil #<why-function-type>  
Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
mk-why-conditional #<why-function-application> #<why-lambda-abstraction> #<why-function-application> 
???????Function: pvs2why-type-funtype [nat -> [nat -> nat]]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
mk-why-function-type: domain (#<why-primitive-type>) range #<why-function-type>
mk-why-lambda-abstraction (#<why-binding>) #<why-conditional> #<why-function-type> 
mk-why-function hbis nil #<why-lambda-abstraction> #<why-function-type>
Function:pvs2why-record-definition: test 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-binding x #<why-primitive-type> 
Function: pvs2why-type-funtype T
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
mk-why-binding f #<why-array-type> 
mk-why-record test (#<why-binding> #<why-binding>)
Function: pvs2why-declaration: #<const-decl test_aliasing.hj>
Function: pvs2why-resolution-destructive #<const-decl test_aliasing.hj>  test
Function: pvs2why-type-record: test 
mk-why-record-type: test nil 
mk-why-function-type: domain nil range #<why-record-type>
Function: pvs2why*-record-expr: (# x := 0, f := g #)   test 
Function: pvs2why*-number-expr: 0 nat 
mk-why-literal 0 number
mk-why-assignment x #<why-literal> 
Function: pvs2why*-name-expr: g   T 
Function: pvs2why-type-funtype T
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
mk-why-name g constant #<why-array-type>
mk-why-assignment f #<why-name> 
## test ##Function: pvs2why-type-record: test 
mk-why-record-type: test nil 
mk-why-record-literal  #<why-assignment>  #<why-assignment>  #<why-record-type>
mk-why-function hj nil #<why-record-literal> #<why-function-type>
Function: pvs2why-declaration: #<const-decl test_aliasing.hk>
Function: pvs2why-resolution-destructive #<const-decl test_aliasing.hk>  test
Function: pvs2why-type-record: test 
mk-why-record-type: test nil 
mk-why-function-type: domain nil range #<why-record-type>
Function: pvs2why*-update-expr hj WITH [(x) := 1] test 
Function: pvs2why-update hj WITH [(x) := 1] test 
Function: pvs2why*-name-expr: hj   test 
Function: pvs2why-type-record: test 
mk-why-record-type: test nil 
Function: pvs2why-constant: hj #<const-decl test_aliasing.hj>
Function: pvs2why-resolution: hj
Function: pvs2why-declaration: #<const-decl test_aliasing.hj>
Function: pvs2why-type-name: test
Function: pvs2why-type-eq-decl: #<type-eq-decl test_aliasing.test>
mk-why-record-type: test nil 
mk-why-name hj constant #<why-record-type>
mk-why-function-application #<why-name> nil # nil nil nil  
Recordtype? t1 t2 test test 
Function: pvs2why-coerce-types test test 
Function: pvs2why-type-record: test 
mk-why-record-type: test nil 
Function: pvs2why-record-update* test hj  (x) := 1  test 
Function: pvs2why*-number-expr: 1 nat 
mk-why-literal 1 number
mk-why-assignment x #<why-literal> 
Function: pvs2why-type-record: test 
mk-why-record-type: test nil 
mk-why-record-assignment hj  #<why-assignment>  #<why-record-type>
mk-why-function hk nil #<why-record-assignment> #<why-function-type>
mk-why-module test_aliasing nil (#<why-function> #<why-function> #<why-function> #<why-function> #<why-function> #<why-function> #<why-record> #<why-function> #<why-function>) nil nil 
*** test_aliasing (./test_aliasing.pvs) --> ./test_aliasing.xml
Function: pvs2why-theory: test_aliasing 
Function: pvs2why-one-theory: test_aliasing 
Function: pvs2why-type-parameters:  
Result: nil 
here1Function: pvs2why-imports:  
Function: pvs2why-declaration: #<const-decl test_aliasing.tab>
Function: pvs2why-resolution-destructive #<const-decl test_aliasing.tab>  i:
                                                                            below(3)  nat
Function: pvs2why-type-subtype: below(3)
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
Function: pvs2why*-if-expr: COND i = 0 -> 3, i = 1 -> 42, i = 2 -> 7 ENDCOND nat 
Function: pvs2why*-application: i = 0 nat 
decl-type boolean 
Function: pvs2why-primitive-app:  i  0    number  number  nat 
Function: pvs2why*-list:  i  0   number  number  
Function: pvs2why*-name-expr: i   i: below(3) . i   number 
Function: pvs2why-type-subtype: below(3)
mk-why-primitive-type: int nil nil 
mk-why-name i formal #<why-primitive-type>
Function: pvs2why*-list:  0   number  
Function: pvs2why*-number-expr: 0 number 
mk-why-literal 0 number
Function: pvs2why*-list:   
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-funtype [[number, number] -> boolean]
Function: pvs2why-type-tuple: [number, number]
Function: pvs2why-type-name: number
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-name: number
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-name: boolean
mk-why-primitive-type: bool nil nil 
mk-why-function-type: domain (#<why-primitive-type> #<why-primitive-type>) range #<why-primitive-type>
mk-why-name == constant #<why-function-type>
mk-why-function-application #<why-name> (#<why-name> #<why-literal>) # t nil #<why-primitive-type>  
Function: pvs2why*-number-expr: 3 nat 
mk-why-literal 3 number
Function: pvs2why*-if-expr: COND i = 1 -> 42, i = 2 -> 7 ENDCOND nat 
Function: pvs2why*-application: i = 1 nat 
decl-type boolean 
Function: pvs2why-primitive-app:  i  1    number  number  nat 
Function: pvs2why*-list:  i  1   number  number  
Function: pvs2why*-name-expr: i   i: below(3) . i   number 
Function: pvs2why-type-subtype: below(3)
mk-why-primitive-type: int nil nil 
mk-why-name i formal #<why-primitive-type>
Function: pvs2why*-list:  1   number  
Function: pvs2why*-number-expr: 1 number 
mk-why-literal 1 number
Function: pvs2why*-list:   
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-funtype [[number, number] -> boolean]
Function: pvs2why-type-tuple: [number, number]
Function: pvs2why-type-name: number
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-name: number
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-name: boolean
mk-why-primitive-type: bool nil nil 
mk-why-function-type: domain (#<why-primitive-type> #<why-primitive-type>) range #<why-primitive-type>
mk-why-name == constant #<why-function-type>
mk-why-function-application #<why-name> (#<why-name> #<why-literal>) # t nil #<why-primitive-type>  
Function: pvs2why*-number-expr: 42 nat 
mk-why-literal 42 number
Function: pvs2why*-if-expr: COND i = 2 -> 7 ENDCOND nat 
Function: pvs2why*-application: i = 2 nat 
decl-type boolean 
Function: pvs2why-primitive-app:  i  2    number  number  nat 
Function: pvs2why*-list:  i  2   number  number  
Function: pvs2why*-name-expr: i   i: below(3) . i   number 
Function: pvs2why-type-subtype: below(3)
mk-why-primitive-type: int nil nil 
mk-why-name i formal #<why-primitive-type>
Function: pvs2why*-list:  2   number  
Function: pvs2why*-number-expr: 2 number 
mk-why-literal 2 number
Function: pvs2why*-list:   
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-funtype [[number, number] -> boolean]
Function: pvs2why-type-tuple: [number, number]
Function: pvs2why-type-name: number
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-name: number
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-name: boolean
mk-why-primitive-type: bool nil nil 
mk-why-function-type: domain (#<why-primitive-type> #<why-primitive-type>) range #<why-primitive-type>
mk-why-name == constant #<why-function-type>
mk-why-function-application #<why-name> (#<why-name> #<why-literal>) # t nil #<why-primitive-type>  
Function: pvs2why*-number-expr: 7 nat 
mk-why-literal 7 number
Function: pvs2why*-number-expr: 7 nat 
mk-why-literal 7 number
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-conditional #<why-function-application> #<why-literal> #<why-literal> 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-conditional #<why-function-application> #<why-literal> #<why-conditional> 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-conditional #<why-function-application> #<why-literal> #<why-conditional> 
mk-why-function tab (i) #<why-conditional> #<why-function-type>
mk-why-binding i #<why-primitive-type> 
Function: pvs2why-declaration: #<const-decl test_aliasing.plus>
Function: pvs2why-resolution-destructive #<const-decl test_aliasing.plus>  tab1:
                                                                             T  tab2:
                                                                                  T  [below(3) ->
                                                                                        nat]
Function: pvs2why-type-funtype T
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
Function: pvs2why-type-funtype T
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
Function: pvs2why-type-funtype [below(3) -> nat]
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
mk-why-function-type: domain (#<why-array-type> #<why-array-type>) range #<why-array-type>
Function: pvs2why*-lambda-expr: LAMBDA (i: below(3)): tab1(i) + tab2(i) [below(3) ->
                                                                           nat]
Function: pvs2why-type-subtype: below(3)
mk-why-primitive-type: int nil nil 
mk-why-binding i #<why-primitive-type> 
Recordtype? t1 t2 nat numfield 
Function: pvs2why-coerce-types nat numfield 
Recordtype? t1 t2 nat numfield 
Function: pvs2why-coerce-types nat numfield 
Coerceresult nat 
Recordtype? t1 t2 nil nil 
Function: pvs2why-coerce-types [below(3) -> nat] [below(3) -> numfield] 
Function: pvs2why*-application: tab1(i) + tab2(i) nat 
decl-type numfield 
Function: pvs2why-primitive-app:  tab1(i)  tab2(i)    numfield  numfield  nat 
Function: pvs2why*-list:  tab1(i)  tab2(i)   numfield  numfield  
Function: pvs2why*-application: tab1(i) numfield 
decl-type nat 
Function: pvs2why*-name-expr: tab1   i: below(3) . i   tab2: T . tab2   tab1: T . tab1   T 
Function: pvs2why-type-funtype T
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
mk-why-name tab1 formal #<why-array-type>
Function: pvs2why*-list:  i   below(3)  
Function: pvs2why*-name-expr: i   i: below(3) . i   tab2: T . tab2   tab1: T . tab1   below(3) 
Function: pvs2why-type-subtype: below(3)
mk-why-primitive-type: int nil nil 
mk-why-name i formal #<why-primitive-type>
Function: pvs2why*-list:   
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-subscription #<why-name> #<why-name> 
Function: pvs2why*-list:  tab2(i)   numfield  
Function: pvs2why*-application: tab2(i) numfield 
decl-type nat 
Function: pvs2why*-name-expr: tab2   i: below(3) . i   tab2: T . tab2   tab1: T . tab1   T 
Function: pvs2why-type-funtype T
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
mk-why-name tab2 formal #<why-array-type>
Function: pvs2why*-list:  i   below(3)  
Function: pvs2why*-name-expr: i   i: below(3) . i   tab2: T . tab2   tab1: T . tab1   below(3) 
Function: pvs2why-type-subtype: below(3)
mk-why-primitive-type: int nil nil 
mk-why-name i formal #<why-primitive-type>
Function: pvs2why*-list:   
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-subscription #<why-name> #<why-name> 
Function: pvs2why*-list:   
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-funtype [[numfield, numfield] -> numfield]
Function: pvs2why-type-tuple: [numfield, numfield]
Function: pvs2why-type-subtype: numfield
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-subtype: numfield
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-subtype: numfield
mk-why-primitive-type: real nil nil 
mk-why-function-type: domain (#<why-primitive-type> #<why-primitive-type>) range #<why-primitive-type>
mk-why-name + constant #<why-function-type>
mk-why-function-application #<why-name> (#<why-array-subscription> #<why-array-subscription>) # t nil #<why-primitive-type>  
???????Function: pvs2why-type-funtype [below(3) -> nat]
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
mk-why-lambda-abstraction (#<why-binding>) #<why-function-application> #<why-array-type> 
lower 0 upper 3 - 1Function: pvs2why*-number-expr: 0 nil 
mk-why-literal 0 number
Function: pvs2why*-application: 3 - 1 number_field 
decl-type number_field 
Function: pvs2why-primitive-app:  3  1    numfield  numfield  number_field 
Function: pvs2why*-list:  3  1   numfield  numfield  
Function: pvs2why*-number-expr: 3 numfield 
mk-why-literal 3 number
Function: pvs2why*-list:  1   numfield  
Function: pvs2why*-number-expr: 1 numfield 
mk-why-literal 1 number
Function: pvs2why*-list:   
Function: pvs2why-type-subtype: number_field
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-funtype [[numfield, numfield] -> numfield]
Function: pvs2why-type-tuple: [numfield, numfield]
Function: pvs2why-type-subtype: numfield
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-subtype: numfield
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-subtype: numfield
mk-why-primitive-type: real nil nil 
mk-why-function-type: domain (#<why-primitive-type> #<why-primitive-type>) range #<why-primitive-type>
mk-why-name - constant #<why-function-type>
mk-why-function-application #<why-name> (#<why-literal> #<why-literal>) # t nil #<why-primitive-type>  
Function: pvs2why-type-funtype [below(3) -> nat]
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
mk-why-array-literal #<why-function-application> #<why-literal> #<why-lambda-abstraction> #<why-array-type>
mk-why-function plus (tab1 tab2) #<why-array-literal> #<why-function-type>
mk-why-binding tab1 #<why-array-type> 
mk-why-binding tab2 #<why-array-type> 
Function: pvs2why-declaration: #<const-decl test_aliasing.f>
Function: pvs2why-resolution-destructive #<const-decl test_aliasing.f>  i: nat  nat
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
Function: pvs2why*-name-expr: i   i: nat . i   nat 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-name i variable #<why-primitive-type>
mk-why-function f (i) #<why-name> #<why-function-type>
mk-why-binding i #<why-primitive-type> 
Function: pvs2why-declaration: #<const-decl test_aliasing.g>
Function: pvs2why-resolution-destructive #<const-decl test_aliasing.g>  T
Function: pvs2why-type-funtype T
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
mk-why-function-type: domain nil range #<why-array-type>
Function: pvs2why*-application: plus(restrict[nat, below(3), nat](f), tab) T 
decl-type [below(3) -> nat] 
Function: pvs2why-defn-application: plus(restrict[nat, below(3), nat](f), tab) T 
Declared type: [[T, T] -> [below(3) -> nat]] 
Domain type:  T  T  
Function: pvs2why*-list:  restrict[nat, below(3), nat](f)  tab   T  T  
Function: pvs2why*-application: restrict[nat, below(3), nat](f) T 
decl-type [below(3) -> nat] 
Function: pvs2why-primitive-app:  f    [nat -> nat]  T 
Function: pvs2why*-list:  f   [nat -> nat]  
Function: pvs2why*-name-expr: f   [nat -> nat] 
Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
mk-why-name f constant #<why-function-type>
Function: pvs2why*-list:   
Function: pvs2why-type-funtype T
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
Function: pvs2why-type-funtype [[nat -> nat] -> [below(3) -> nat]]
Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
Function: pvs2why-type-funtype [below(3) -> nat]
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
mk-why-function-type: domain (#<why-function-type>) range #<why-array-type>
mk-why-name pvsrestrict constant #<why-function-type>
mk-why-function-application #<why-name> (#<why-name>) # t nil #<why-array-type>  
Function: pvs2why*-list:  tab   T  
Function: pvs2why*-name-expr: tab   T 
Function: pvs2why-type-funtype [below(3) -> nat]
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
mk-why-name tab constant #<why-array-type>
Function: pvs2why*-list:   
Function: pvs2why*-name-expr: plus   [below(3) -> nat] 
Function: pvs2why-type-funtype [[T, T] -> [below(3) -> nat]]
Function: pvs2why-type-tuple: [T, T]
Function: pvs2why-type-funtype T
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
Function: pvs2why-type-funtype T
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
Function: pvs2why-type-funtype [below(3) -> nat]
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
mk-why-function-type: domain (#<why-array-type> #<why-array-type>) range #<why-array-type>
mk-why-name plus constant #<why-function-type>
Before Declared type: T 
Function: pvs2why-type-funtype T
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
Why Declared type: #<why-array-type> 
mk-why-function-application #<why-name> (#<why-function-application> #<why-name>) # nil nil #<why-array-type>  
mk-why-function g nil #<why-function-application> #<why-function-type>
Function: pvs2why-declaration: #<const-decl test_aliasing.h>
Function: pvs2why-resolution-destructive #<const-decl test_aliasing.h>  i: nat  [nat ->
                                                                                   nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
mk-why-function-type: domain (#<why-primitive-type>) range #<why-function-type>
Function: pvs2why*-lambda-expr: LAMBDA (j: nat): i + j [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-binding j #<why-primitive-type> 
Recordtype? t1 t2 nat numfield 
Function: pvs2why-coerce-types nat numfield 
Recordtype? t1 t2 nat numfield 
Function: pvs2why-coerce-types nat numfield 
Coerceresult nat 
Recordtype? t1 t2 nil nil 
Function: pvs2why-coerce-types [nat -> nat] [nat -> numfield] 
Function: pvs2why*-application: i + j nat 
decl-type numfield 
Function: pvs2why-primitive-app:  i  j    numfield  numfield  nat 
Function: pvs2why*-list:  i  j   numfield  numfield  
Function: pvs2why*-name-expr: i   j: nat . j   i: nat . i   numfield 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-name i formal #<why-primitive-type>
Function: pvs2why*-list:  j   numfield  
Function: pvs2why*-name-expr: j   j: nat . j   i: nat . i   numfield 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-name j formal #<why-primitive-type>
Function: pvs2why*-list:   
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-funtype [[numfield, numfield] -> numfield]
Function: pvs2why-type-tuple: [numfield, numfield]
Function: pvs2why-type-subtype: numfield
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-subtype: numfield
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-subtype: numfield
mk-why-primitive-type: real nil nil 
mk-why-function-type: domain (#<why-primitive-type> #<why-primitive-type>) range #<why-primitive-type>
mk-why-name + constant #<why-function-type>
mk-why-function-application #<why-name> (#<why-name> #<why-name>) # t nil #<why-primitive-type>  
???????Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
mk-why-lambda-abstraction (#<why-binding>) #<why-function-application> #<why-function-type> 
mk-why-function h (i) #<why-lambda-abstraction> #<why-function-type>
mk-why-binding i #<why-primitive-type> 
Function: pvs2why-declaration: #<const-decl test_aliasing.hbis>
Function: pvs2why-resolution-destructive #<const-decl test_aliasing.hbis>  [nat ->
                                                                              [nat ->
                                                                                 nat]]
Function: pvs2why-type-funtype [nat -> [nat -> nat]]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
mk-why-function-type: domain (#<why-primitive-type>) range #<why-function-type>
mk-why-function-type: domain nil range #<why-function-type>
Function: pvs2why*-update-expr h WITH [(0)(0) := 1] [nat -> [nat -> nat]] 
Function: pvs2why*-lambda-expr: LAMBDA (x: nat):
                                  IF x = 0
                                    THEN LAMBDA (x1: nat):
                                           IF x1 = 0 THEN 1 ELSE h(x)(x1) ENDIF
                                  ELSE h(x)
                                  ENDIF [nat -> [nat -> nat]]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-binding x #<why-primitive-type> 
Recordtype? t1 t2 nil nil 
Function: pvs2why-coerce-types [nat -> nat] [nat -> real] 
Recordtype? t1 t2 nil nil 
Function: pvs2why-coerce-types [nat -> nat] [nat -> real] 
Coerceresult [nat -> nat] 
Recordtype? t1 t2 nil nil 
Function: pvs2why-coerce-types [nat -> [nat -> nat]] [nat -> [nat -> real]] 
Function: pvs2why*-if-expr: IF x = 0
                              THEN LAMBDA (x1: nat):
                                     IF x1 = 0 THEN 1 ELSE h(x)(x1) ENDIF
                            ELSE h(x)
                            ENDIF [nat -> nat] 
Function: pvs2why*-application: x = 0 [nat -> nat] 
decl-type boolean 
Function: pvs2why-primitive-app:  x  0    number  number  [nat -> nat] 
Function: pvs2why*-list:  x  0   number  number  
Function: pvs2why*-name-expr: x   x: nat . x   number 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-name x formal #<why-primitive-type>
Function: pvs2why*-list:  0   number  
Function: pvs2why*-number-expr: 0 number 
mk-why-literal 0 number
Function: pvs2why*-list:   
Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
Function: pvs2why-type-funtype [[number, number] -> boolean]
Function: pvs2why-type-tuple: [number, number]
Function: pvs2why-type-name: number
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-name: number
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-name: boolean
mk-why-primitive-type: bool nil nil 
mk-why-function-type: domain (#<why-primitive-type> #<why-primitive-type>) range #<why-primitive-type>
mk-why-name == constant #<why-function-type>
mk-why-function-application #<why-name> (#<why-name> #<why-literal>) # t nil #<why-function-type>  
Function: pvs2why*-lambda-expr: LAMBDA (x1: nat):
                                  IF x1 = 0 THEN 1 ELSE h(x)(x1) ENDIF [nat ->
                                                                          nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-binding x1 #<why-primitive-type> 
Recordtype? t1 t2 nat real 
Function: pvs2why-coerce-types nat real 
Recordtype? t1 t2 nat real 
Function: pvs2why-coerce-types nat real 
Coerceresult nat 
Recordtype? t1 t2 nil nil 
Function: pvs2why-coerce-types [nat -> nat] [nat -> real] 
Function: pvs2why*-if-expr: IF x1 = 0 THEN 1 ELSE h(x)(x1) ENDIF nat 
Function: pvs2why*-application: x1 = 0 nat 
decl-type boolean 
Function: pvs2why-primitive-app:  x1  0    number  number  nat 
Function: pvs2why*-list:  x1  0   number  number  
Function: pvs2why*-name-expr: x1   x1: nat . x1   x: nat . x   number 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-name x1 formal #<why-primitive-type>
Function: pvs2why*-list:  0   number  
Function: pvs2why*-number-expr: 0 number 
mk-why-literal 0 number
Function: pvs2why*-list:   
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-funtype [[number, number] -> boolean]
Function: pvs2why-type-tuple: [number, number]
Function: pvs2why-type-name: number
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-name: number
mk-why-primitive-type: real nil nil 
Function: pvs2why-type-name: boolean
mk-why-primitive-type: bool nil nil 
mk-why-function-type: domain (#<why-primitive-type> #<why-primitive-type>) range #<why-primitive-type>
mk-why-name == constant #<why-function-type>
mk-why-function-application #<why-name> (#<why-name> #<why-literal>) # t nil #<why-primitive-type>  
Function: pvs2why*-number-expr: 1 nat 
mk-why-literal 1 number
Function: pvs2why*-application: h(x)(x1) nat 
decl-type nat 
Function: pvs2why*-application: h(x) [nat -> nat] 
decl-type [nat -> nat] 
Function: pvs2why-defn-application: h(x) [nat -> nat] 
Declared type: [nat -> [nat -> nat]] 
Domain type:  nat  
Function: pvs2why*-list:  x   nat  
Function: pvs2why*-name-expr: x   x1: nat . x1   x: nat . x   nat 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-name x formal #<why-primitive-type>
Function: pvs2why*-list:   
Function: pvs2why*-name-expr: h   x1: nat . x1   x: nat . x   [nat -> nat] 
Function: pvs2why-type-funtype [nat -> [nat -> nat]]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
mk-why-function-type: domain (#<why-primitive-type>) range #<why-function-type>
mk-why-name h constant #<why-function-type>
Before Declared type: [nat -> nat] 
Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
Why Declared type: #<why-function-type> 
mk-why-function-application #<why-name> (#<why-name>) # nil nil #<why-function-type>  
Function: pvs2why*-list:  x1   nat  
Function: pvs2why*-name-expr: x1   x1: nat . x1   x: nat . x   nat 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-name x1 formal #<why-primitive-type>
Function: pvs2why*-list:   
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-application #<why-function-application> (#<why-name>) # nil nil #<why-primitive-type>  
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-conditional #<why-function-application> #<why-literal> #<why-function-application> 
???????Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
mk-why-lambda-abstraction (#<why-binding>) #<why-conditional> #<why-function-type> 
Function: pvs2why*-application: h(x) [nat -> nat] 
decl-type [nat -> nat] 
Function: pvs2why-defn-application: h(x) [nat -> nat] 
Declared type: [nat -> [nat -> nat]] 
Domain type:  nat  
Function: pvs2why*-list:  x   nat  
Function: pvs2why*-name-expr: x   x: nat . x   nat 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-name x formal #<why-primitive-type>
Function: pvs2why*-list:   
Function: pvs2why*-name-expr: h   x: nat . x   [nat -> nat] 
Function: pvs2why-type-funtype [nat -> [nat -> nat]]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
mk-why-function-type: domain (#<why-primitive-type>) range #<why-function-type>
mk-why-name h constant #<why-function-type>
Before Declared type: [nat -> nat] 
Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
Why Declared type: #<why-function-type> 
mk-why-function-application #<why-name> (#<why-name>) # nil nil #<why-function-type>  
Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
mk-why-conditional #<why-function-application> #<why-lambda-abstraction> #<why-function-application> 
???????Function: pvs2why-type-funtype [nat -> [nat -> nat]]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-funtype [nat -> nat]
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-function-type: domain (#<why-primitive-type>) range #<why-primitive-type>
mk-why-function-type: domain (#<why-primitive-type>) range #<why-function-type>
mk-why-lambda-abstraction (#<why-binding>) #<why-conditional> #<why-function-type> 
mk-why-function hbis nil #<why-lambda-abstraction> #<why-function-type>
Function:pvs2why-record-definition: test 
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-binding x #<why-primitive-type> 
Function: pvs2why-type-funtype T
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
mk-why-binding f #<why-array-type> 
mk-why-record test (#<why-binding> #<why-binding>)
Function: pvs2why-declaration: #<const-decl test_aliasing.hj>
Function: pvs2why-resolution-destructive #<const-decl test_aliasing.hj>  test
Function: pvs2why-type-record: test 
mk-why-record-type: test nil 
mk-why-function-type: domain nil range #<why-record-type>
Function: pvs2why*-record-expr: (# x := 0, f := g #)   test 
Function: pvs2why*-number-expr: 0 nat 
mk-why-literal 0 number
mk-why-assignment x #<why-literal> 
Function: pvs2why*-name-expr: g   T 
Function: pvs2why-type-funtype T
mk-why-literal 0 int
mk-why-literal 0 int
Function: pvs2why-type-subtype: nat
mk-why-primitive-type: int nil nil 
mk-why-array-type: #<why-literal> #<why-literal> #<why-primitive-type>
mk-why-name g constant #<why-array-type>
mk-why-assignment f #<why-name> 
## test ##Function: pvs2why-type-record: test 
mk-why-record-type: test nil 
mk-why-record-literal  #<why-assignment>  #<why-assignment>  #<why-record-type>
mk-why-function hj nil #<why-record-literal> #<why-function-type>
Function: pvs2why-declaration: #<const-decl test_aliasing.hk>
Function: pvs2why-resolution-destructive #<const-decl test_aliasing.hk>  test
Function: pvs2why-type-record: test 
mk-why-record-type: test nil 
mk-why-function-type: domain nil range #<why-record-type>
Function: pvs2why*-update-expr hj WITH [(x) := 1] test 
Function: pvs2why-update hj WITH [(x) := 1] test 
Function: pvs2why*-name-expr: hj   test 
Function: pvs2why-type-record: test 
mk-why-record-type: test nil 
Function: pvs2why-constant: hj #<const-decl test_aliasing.hj>
Function: pvs2why-resolution: hj
Function: pvs2why-declaration: #<const-decl test_aliasing.hj>
Function: pvs2why-type-name: test
Function: pvs2why-type-eq-decl: #<type-eq-decl test_aliasing.test>
mk-why-record-type: test nil 
mk-why-name hj constant #<why-record-type>
mk-why-function-application #<why-name> nil # nil nil nil  
Recordtype? t1 t2 test test 
Function: pvs2why-coerce-types test test 
Function: pvs2why-type-record: test 
mk-why-record-type: test nil 
Function: pvs2why-record-update* test hj  (x) := 1  test 
Function: pvs2why*-number-expr: 1 nat 
mk-why-literal 1 number
mk-why-assignment x #<why-literal> 
Function: pvs2why-type-record: test 
mk-why-record-type: test nil 
mk-why-record-assignment hj  #<why-assignment>  #<why-record-type>
mk-why-function hk nil #<why-record-assignment> #<why-function-type>
mk-why-module test_aliasing nil (#<why-function> #<why-function> #<why-function> #<why-function> #<why-function> #<why-function> #<why-record> #<why-function> #<why-function>) nil nil 
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-name> #<why-literal>) 
lift-let*-default: #<why-name> 
lift-let*-default: #<why-literal> 
Enter lifted expr: 3
lift-let*-default: #<why-literal> 
Leave lifted-expr : (#<why-literal>)
Translated lifted-expr: 3
Prefix: nil
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-name> #<why-literal>) 
lift-let*-default: #<why-name> 
lift-let*-default: #<why-literal> 
Enter lifted expr: 42
lift-let*-default: #<why-literal> 
Leave lifted-expr : (#<why-literal>)
Translated lifted-expr: 42
Prefix: nil
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-name> #<why-literal>) 
lift-let*-default: #<why-name> 
lift-let*-default: #<why-literal> 
Enter lifted expr: 7
lift-let*-default: #<why-literal> 
Leave lifted-expr : (#<why-literal>)
Translated lifted-expr: 7
Prefix: nil
Enter lifted expr: 7
lift-let*-default: #<why-literal> 
Leave lifted-expr : (#<why-literal>)
Translated lifted-expr: 7
Prefix: nil
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-array-subscription> #<why-array-subscription>) 
lift-let*-default: #<why-array-subscription> 
lift-let*-default: #<why-array-subscription> 
Enter lifted expr: Prelude.new_int(3-1-0+1,    new Lambda<Integer,Integer>(){
      public Integer curry(final Integer i) {
        return tab1[i]+tab2[i];      }
    }
)
lift-let*-why-array-literal: #<why-array-literal> 
lift-let*-default: #<why-lambda-abstraction> 
Leave lifted-expr : (#<why-array-literal>)
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-array-subscription> #<why-array-subscription>) 
lift-let*-default: #<why-array-subscription> 
lift-let*-default: #<why-array-subscription> 
Translated lifted-expr: Prelude.new_int(3-1-0+1,    new Lambda<Integer,Integer>(){
      public Integer curry(final Integer i) {
        return tab1[i]+tab2[i];      }
    }
)
Prefix: nil
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-array-subscription> #<why-array-subscription>) 
lift-let*-default: #<why-array-subscription> 
lift-let*-default: #<why-array-subscription> 
Enter lifted expr: i
lift-let*-default: #<why-name> 
Leave lifted-expr : (#<why-name>)
Translated lifted-expr: i
Prefix: nil
Enter lifted expr: plus(pvsrestrict(f),tab)
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-function-application> #<why-name>) 
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-name>) 
lift-let*-default: #<why-name> 
lift-let*-default: #<why-name> 
Leave lifted-expr : (#<why-function-application>)
Translated lifted-expr: plus(pvsrestrict(f),tab)
Prefix: nil
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-name> #<why-name>) 
lift-let*-default: #<why-name> 
lift-let*-default: #<why-name> 
Enter lifted expr:     new Lambda<Integer,Integer>(){
      public Integer curry(final Integer j) {
        return i+j;      }
    }

lift-let*-default: #<why-lambda-abstraction> 
Leave lifted-expr : (#<why-lambda-abstraction>)
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-name> #<why-name>) 
lift-let*-default: #<why-name> 
lift-let*-default: #<why-name> 
Translated lifted-expr:     new Lambda<Integer,Integer>(){
      public Integer curry(final Integer j) {
        return i+j;      }
    }

Prefix: nil
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-name> #<why-name>) 
lift-let*-default: #<why-name> 
lift-let*-default: #<why-name> 
lift-let*-why-conditional: #<why-conditional> 
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-name> #<why-literal>) 
lift-let*-default: #<why-name> 
lift-let*-default: #<why-literal> 
lift-let*-default: #<why-lambda-abstraction> 
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-name>) 
lift-let*-default: #<why-name> 
lift-let*-why-conditional: #<why-conditional> 
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-name> #<why-literal>) 
lift-let*-default: #<why-name> 
lift-let*-default: #<why-literal> 
lift-let*-default: #<why-literal> 
lift-let*-why-function-application: #<why-function-application> 
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-name>) 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-name>) 
lift-let*-default: #<why-name> 
Enter lifted expr:     new Lambda<Integer,Lambda<Integer,Integer>>(){
      public Lambda<Integer,Integer> curry(final Integer x) {
        return (x == 0 ?     new Lambda<Integer,Integer>(){
      public Integer curry(final Integer x1) {
        return (x1 == 0 ? 1 : h(x).curry(x1));      }
    }
 : h(x));      }
    }

lift-let*-default: #<why-lambda-abstraction> 
Leave lifted-expr : (#<why-lambda-abstraction>)
lift-let*-why-conditional: #<why-conditional> 
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-name> #<why-literal>) 
lift-let*-default: #<why-name> 
lift-let*-default: #<why-literal> 
lift-let*-default: #<why-lambda-abstraction> 
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-name>) 
lift-let*-default: #<why-name> 
lift-let*-why-conditional: #<why-conditional> 
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-name> #<why-literal>) 
lift-let*-default: #<why-name> 
lift-let*-default: #<why-literal> 
lift-let*-default: #<why-literal> 
lift-let*-why-function-application: #<why-function-application> 
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-name>) 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-name>) 
lift-let*-default: #<why-name> 
Translated lifted-expr:     new Lambda<Integer,Lambda<Integer,Integer>>(){
      public Lambda<Integer,Integer> curry(final Integer x) {
        return (x == 0 ?     new Lambda<Integer,Integer>(){
      public Integer curry(final Integer x1) {
        return (x1 == 0 ? 1 : h(x).curry(x1));      }
    }
 : h(x));      }
    }

Prefix: nil
lift-let*-why-conditional: #<why-conditional> 
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-name> #<why-literal>) 
lift-let*-default: #<why-name> 
lift-let*-default: #<why-literal> 
lift-let*-default: #<why-lambda-abstraction> 
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-name>) 
lift-let*-default: #<why-name> 
lift-let*-why-conditional: #<why-conditional> 
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-name> #<why-literal>) 
lift-let*-default: #<why-name> 
lift-let*-default: #<why-literal> 
lift-let*-default: #<why-literal> 
lift-let*-why-function-application: #<why-function-application> 
lift-let*-why-function-application: #<why-function-application> 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-name>) 
lift-let*-default: #<why-name> 
lift-let*-list: (#<why-name>) 
lift-let*-default: #<why-name> 
Enter lifted expr: new test(g,0)
lift-let*-why-record-literal: #<why-record-literal> 
lift-let*-list: (#<why-assignment> #<why-assignment>) 
lift-let*-why-assignment: #<why-assignment> 
lift-let*-default: #<why-name> 
lift-let*-why-assignment: #<why-assignment> 
lift-let*-default: #<why-literal> 
Leave lifted-expr : (#<why-record-literal>)
Translated lifted-expr: new test(g,0)
Prefix: nil
Enter lifted expr: hj.update(1)
lift-let*-why-record-assignment: #<why-record-assignment> 
lift-let*-list: (#<why-assignment>) 
lift-let*-why-assignment: #<why-assignment> 
lift-let*-default: #<why-literal> 
Leave lifted-expr : (#<why-record-assignment>)
Translated lifted-expr: hj.update(1)
Prefix: nil
*** test_aliasing (./test_aliasing.pvs) --> ./test_aliasing.java
