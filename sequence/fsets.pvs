fset[T: TYPE]: THEORY
BEGIN
  
  % TODO accurate intro
  % This theory defines a finite set theory, in an abstract way.
  % The usual set theory will then be defined as this theory plus the missing axioms
  set: TYPE+

  s, t, s1, s2: VAR set
  x, y, z: VAR T
  p: VAR PRED[T]
  f: VAR [T -> T]

  % Membership and = are the elementary functions
  ∈: [T, set -> bool]
  ;∉(x,s): bool = NOT (x ∈ s)

  % linked by the extensionality axiom
  extensionality_ax: AXIOM s1 = s2 IFF FORALL x: (x ∈ s1) IFF (x ∈ s2)


  % There is a predicate is_finite? 
  % and a function card for the finite sets
  is_finite?(s): bool
  card: [(is_finite?) -> nat]

  fs, fs1, fs2: VAR (is_finite?)

  % empty set
  empty_existence: AXIOM EXISTS fs: FORALL x: (x ∉ fs)
  ∅: { fs | FORALL x: (x ∉ fs) }
  empty?(s): bool = s = ∅
  nonempty?(s): bool = NOT empty?(s)

  empty_is_unique: LEMMA FORALL (s | FORALL x: x ∉ s ): s = ∅
  card_empty: AXIOM card(fs) = 0 IFF fs = ∅



  % I - Basic functions and membership axioms
  ;⊂(s1, s2): bool = FORALL x: (x ∈ s1) IMPLIES (x ∈ s2)
  ;⊊(s1, s2): bool = (s1 ≠ s2) AND (s1 ⊂ s2)
% TODO : We want more unicode symbol, add ⊊ as infix symbol !

  ;∪(s1, s2): set
  member_union: AXIOM (x ∈ s1 ∪ s2) IFF (x ∈ s1) OR (x ∈ s2)

  ;∩(s1, s2): set
  member_intersection: AXIOM (x ∈ s1 ∩ s2) IFF (x ∈ s1) AND (x ∈ s2)

  disjoint?(s1, s2): bool = empty?(s1 ∩ s2)
  
  ;-(s1, s2): set
  member_difference: AXIOM (x ∈ s1 - s2) IFF (x ∈ s1) AND (x ∉ s2)

  ;⊖(s1, s2): set 
  member_symmetric_difference: AXIOM  
  	(x ∈ s1 ⊖ s2) IFF (x ∈ s1) AND (x ∉ s2) OR (x ∉ s1) AND (x ∈ s2)



  % II - Properties
    % Commutativity
  union_is_commutative: JUDGEMENT ∪ HAS_TYPE (commutative?[set])
  intersection_is_commutative: JUDGEMENT ∩ HAS_TYPE (commutative?[set])
  symmetric_difference_is_commutative: JUDGEMENT ⊖ HAS_TYPE (commutative?[set])
  disjoint_is_commutative: LEMMA disjoint?(s1, s2) IMPLIES disjoint?(s2, s1)

    % Associativity
  union_is_associative: JUDGEMENT ∪ HAS_TYPE (associative?[set])
  intersection_is_associative: JUDGEMENT ∩ HAS_TYPE (associative?[set])
  symmetric_difference_is_associative: JUDGEMENT ⊖ HAS_TYPE (associative?[set])

    % Order
  subset_is_reflexive: JUDGEMENT ⊂ HAS_TYPE (reflexive?[set])
  subset_is_transitive: JUDGEMENT ⊂ HAS_TYPE (transitive?[set])
  subset_is_antisymmetric: JUDGEMENT ⊂ HAS_TYPE (antisymmetric?[set])
  subset_is_partial_order: JUDGEMENT ⊂ HAS_TYPE (partial_order?[set])


    % Case of invariance of an operator
  union_inv_left: LEMMA (s1 ∪ s2) = s1 IFF s2 ⊂ s1
  union_inv_right: LEMMA (s1 ∪ s2) = s2 IFF s1 ⊂ s2

  intersection_inv_left: LEMMA (s1 ∩ s2) = s1 IFF s1 ⊂ s2
  intersection_inv_right: LEMMA (s1 ∩ s2) = s2 IFF s2 ⊂ s1

  difference_inv_left: LEMMA (s1 - s2) = s1 IFF disjoint?(s1, s2)
  difference_inv_right: LEMMA (s1 - s2) = s2 IFF s1 = ∅ AND s2 = ∅

  symmetric_difference_inv_left: LEMMA (s1 ⊖ s2) = s1 IFF s2 = ∅
  symmetric_difference_inv_right: LEMMA (s1 ⊖ s2) = s2 IFF s1 = ∅


    % With empty
  subset_empty: LEMMA ∅ ⊂ s
  subset__empty: LEMMA (s ⊂ ∅) IFF s = ∅

  disjoint_empty: LEMMA disjoint?(∅, s)
  disjoint__empty: LEMMA disjoint?(s, ∅)

  union_empty2: LEMMA (s1 ∪ s2) = ∅ IFF s1 = ∅ AND s2 = ∅
  union_empty: LEMMA (∅ ∪ s) = s
  union__empty: LEMMA (s ∪ ∅) = s

  intersection_empty: LEMMA (∅ ∩ s) = ∅
  intersection__empty: LEMMA (s ∩ ∅) = ∅

  difference_empty: LEMMA (∅ - s) = ∅
  difference__empty: LEMMA (s - ∅) = s

  symmetric_difference_empty: LEMMA (∅ ⊖ s) = s
  symmetric_difference__empty: LEMMA (s ⊖ ∅) = s


    % Alternative definitions
  equal_as_subset: LEMMA 
  	s1 = s2 IFF (s1 ⊂ s2) AND (s2 ⊂ s1)
  intersection_as_difference : LEMMA
  	(s1 ∩ s2) = s1 - (s1 - s2)
  symmetric_difference_as_difference: LEMMA 
  	(s1 ⊖ s2) = (s1 - s2) ∪ (s2 - s1)
  symmetric_difference_as_union_intersection: LEMMA
  	(s1 ⊖ s2) = (s1 ∪ s2) - (s1 ∩ s2)


  subset_as_union: LEMMA 
  	(s1 ⊂ s2) IFF EXISTS s: disjoint?(s, s1) AND s2 = (s1 ∪ s)
%  st_subset_as_union: LEMMA 
%  	(s1 ⊊ s2) IFF EXISTS (s: (nonempty?)): disjoint?(s, s1) AND s2 = (s1 ∪ s)
  subset_as_intersection: LEMMA 
  	(s1 ⊂ s2) IFF EXISTS s: s1 = (s2 ∩ s)
%  st_subset_as_intersection: LEMMA 
%  	(s1 ⊊ s2) IFF EXISTS (s: (nonempty?)): s1 = (s2 ∩ s)

  union_disjoint: LEMMA EXISTS s: s1 = (s2 ∪ s) IFF 
  		  	EXISTS s: s1 = (s1 ∪ s2) AND disjoint?(s1, s)

  % Props (if * is a commutative operator, props are written only once, on the left)
    % subset 
% TODO : convention non respectee ! 
  subset_union: LEMMA (s1 ⊂ s1 ∪ s2)
  subset__union: LEMMA (s2 ⊂ s1 ∪ s2)
%  st_subset_union: LEMMA (s1 ⊊ s1 ∪ s2) IFF NOT s2 ⊂ s1
%  st_subset_union: LEMMA (s2 ⊊ s1 ∪ s2) IFF NOT s1 ⊂ s1

  subset_intersection: LEMMA (s1 ∩ s2 ⊂ s1)
  subset__intersection: LEMMA (s1 ∩ s2 ⊂ s2)
%  st_subset_intersection: LEMMA (s1 ∩ s2 ⊊ s1) IFF NOT s1 ⊂ s2 
%  st_subset_intersection: LEMMA (s1 ∩ s2 ⊊ s2) IFF NOT s2 ⊂ s1
% END TODO

  subset_difference: LEMMA (s1 - s2 ⊂ s1)
%  st_subset_difference: LEMMA (s1 - s2 ⊊ s1) IFF NOT disjoint?(s1, s2)

  subset_difference_symmetric: LEMMA (s1 ⊖ s2 ⊂ s1 ∪ s2)
%  st_subset_difference_symmetric: LEMMA (s1 ⊖ s2 ⊊ s1 ∪ s2) IFF disjoint?(s1, s2) 

    % union
  union_union: LEMMA ((s1 ∪ s2) ∪ s) = (s1 ∪ (s2 ∪ s))
  union__union: LEMMA (s1 ∪ (s2 ∪ s)) = ((s1 ∪ s2) ∪ s)
  union_intersection: LEMMA ((s1 ∩ s2) ∪ s) = (s1 ∪ s) ∩ (s2 ∪ s)
  union__intersection: LEMMA (s ∪ (s1 ∩ s2)) = (s ∪ s1) ∩ (s ∪ s2)

    % intersection
  intersection_union: LEMMA ((s1 ∪ s2) ∩ s) = (s1 ∩ s) ∪ (s2 ∩ s)
  intersection__union: LEMMA (s ∩ (s1 ∪ s2)) = (s ∩ s1) ∪ (s ∩ s2)
  intersection_intersection: LEMMA ((s1 ∩ s2) ∩ s) = (s1 ∩ (s2 ∩ s))
  intersection__intersection: LEMMA (s ∩ (s1 ∩ s2)) = ((s ∩ s1) ∩ s2)

  intersection_difference: LEMMA ((s1 - s2) ∩ s) = (s1 ∩ s) - s2
  intersection__difference: LEMMA (s ∩ (s1 - s2)) = (s ∩ s1) - s2
  intersection_symmetric_difference: LEMMA ((s1 ⊖ s2) ∩ s) = ((s1 ∩ s) ⊖ (s2 ∩ s))
  intersection__symmetric_difference: LEMMA (s ∩ (s1 ⊖ s2)) = ((s ∩ s1) ⊖ (s ∩ s2))
 
    % difference
  difference_union: LEMMA (s1 ∪ s2) - s = (s1 - s) ∪ (s2 - s)
  difference__union: LEMMA s - (s1 ∪ s2) = (s - s1) - s2
  difference_intersection: LEMMA (s1 ∩ s2) - s = (s1 - s) ∩ (s2 - s)

  difference_difference: LEMMA (s1 - s2) - s = (s - (s1 ∪ s2))
  difference__difference: LEMMA s - (s1 - s2) = (s - s1) ∪ (s ∩ s2)
  difference_symmetric_difference: LEMMA (s1 ⊖ s2) - s = ((s1 - s) ⊖ (s2 - s))

    % symmetric difference
  symmetric_difference_symmetric_difference: LEMMA ((s1 ⊖ s2) ⊖ s) = (s1 ⊖ (s2 ⊖ s))
  symmetric_difference__symmetric_difference: LEMMA (s ⊖ (s1 ⊖ s2)) = ((s ⊖ s1) ⊖ s2)

    % Disjoint
  disjoint_subset: LEMMA disjoint?(s1, s2) AND s1 ⊂ s2 IMPLIES s1 = ∅
  disjoint_difference: LEMMA disjoint?(s1 - s2, s2)
   


    % These functions preserve is_finite
  subset_is_finite: AXIOM s ⊂ fs IMPLIES is_finite?(s)
  union_is_finite: AXIOM is_finite?(fs1 ∪ fs2) 
  intersection_is_finite: AXIOM is_finite?(fs1 ∩ fs2) 
  difference_is_finite: AXIOM is_finite?(fs1 - fs2)
  symmetric_difference_is_finite: AXIOM is_finite?(fs1 ⊖ fs2) 

    % Cardinals
  card_subset: AXIOM s ⊂ fs IMPLIES card(s) <= card(fs) 
  card_union: AXIOM card(fs1 ∪ fs2) = card(fs1) + card(fs2) - card(fs1 ∩ fs2)
  card_intersection: AXIOM card(fs1 ∩ fs2) = card(fs1) + card(fs2) - card(fs1 ∪ fs2)
  card_difference: AXIOM card(fs1 - fs2) = card(fs1) - card(fs1 ∩ fs2)

  
    % More order properties
  st_subset_is_well_founded: JUDGEMENT ⊊ HAS_TYPE (well_founded?[(is_finite?)])



  % Auto rewrite
  AUTO_REWRITE- union__union, intersection__intersection
  AUTO_REWRITE- symmetric_difference__symmetric_difference
  AUTO_REWRITE- intersection_union, intersection__union
  AUTO_REWRITE- difference__union
  AUTO_REWRITE- card_intersection

  



END fset
