(seq_filter_props
 (filter?_as_filter_pos? 0
  (filter?_as_filter_pos?-1 nil 3581175273
   ("" (grind-with-ext) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (filter? const-decl "bool" seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   shostak))
 (filter_is_nonempty 0
  (filter_is_nonempty-1 nil 3581175281
   (""
    (grind :rewrites (filter?_as_filter_pos? filter_pos_is_nonempty))
    nil nil)
   ((filter_pos_is_nonempty formula-decl nil seq_filter_props nil)
    (filter?_as_filter_pos? formula-decl nil seq_filter_props nil))
   shostak))
 (singleton_lemma 0
  (singleton_lemma-1 nil 3581176184
   ("" (skeep)
    (("" (expand filter_pos?)
      (("" (skolem -1 "f1")
        (("" (skolem -2 "f2")
          (("" (expand subword?)
            ((""
              (inst +
               "LAMBDA (i: bl(s1)): choose(LAMBDA (j: bl(s2)): f1(i) = f2(j))")
              (("1" (prop)
                (("1" (typepred f1)
                  (("1" (typepred f2)
                    (("1" (expand preserves)
                      (("1" (skeep)
                        (("1" (inst -3 x1 x2)
                          (("1"
                            (name "y1"
                                  "choose(LAMBDA (j: bl(s2)): f1(x1) = f2(j))")
                            (("1"
                              (name "y2"
                                    "choose(LAMBDA (j: bl(s2)): f1(x2) = f2(j))")
                              (("1"
                                (inst - y2 y1)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (typepred!
                                 "LAMBDA (j: bl[T](s2)): f1(x2) = f2(j)"
                                 :implicit?
                                 t)
                                (("2" (propax) nil nil))
                                nil))
                              nil)
                             ("2"
                              (typepred!
                               "LAMBDA (j: bl[T](s2)): f1(x1) = f2(j)"
                               :implicit? t)
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skeep)
                  (("2" (inst - i_1)
                    (("2" (inst - "f1(i_1)")
                      (("2"
                        (inst -
                         "choose(LAMBDA (j: bl(s2)): f1(i_1) = f2(j))")
                        (("1" (grind) nil nil)
                         ("2"
                          (typepred!
                           "LAMBDA (j: bl[T](s2)): f1(i_1) = f2(j)"
                           :implicit? t)
                          (("2" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skeep)
                (("2" (expand nonempty?)
                  (("2" (expand empty?)
                    (("2" (inst -2 i)
                      (("2" (inst -3 "f1(i)")
                        (("2" (inst -5 "f1(i)")
                          (("2" (prop)
                            (("1" (skeep)
                              (("1"
                                (inst -5 i_1)
                                (("1" (grind) nil nil))
                                nil))
                              nil)
                             ("2" (inst 3 i) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((filter_pos? const-decl "bool" seq_filter_props nil)
    (f2 skolem-const-decl "{f: [bl(s2) -> bl(s)] |
         preserves(f,
                   restrict[[real, real], [bl[T](s2), bl[T](s2)], boolean]
                       (<),
                   <)}" seq_filter_props nil)
    (f1 skolem-const-decl "{f: [bl(s1) -> bl(s)] |
         preserves(f,
                   restrict[[real, real], [bl[T](s1), bl[T](s1)], boolean]
                       (<),
                   <)}" seq_filter_props nil)
    (restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil)
    (PRED type-eq-decl nil defined_types nil)
    (s skolem-const-decl "seq[T]" seq_filter_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (s2 skolem-const-decl "seq[T]" seq_filter_props nil)
    (bl type-eq-decl nil seq_defs nil)
    (s1 skolem-const-decl "seq[T]" seq_filter_props nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (choose const-decl "(p)" sets nil)
    (i_1 skolem-const-decl "bl[T](s1)" seq_filter_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (subword? const-decl "bool" seq_subword_props nil))
   shostak))
 (filter_pos_is_singleton 0
  (filter_pos_is_singleton-1 nil 3581175271
   ("" (skeep)
    (("" (expand singleton?)
      (("" (use filter_pos_is_nonempty)
        (("" (skeep)
          (("" (inst + t)
            (("" (skolem-typepred)
              (("" (lemma singleton_lemma)
                (("" (lemma singleton_lemma)
                  (("" (inst - pi s y!1 t)
                    (("" (inst - pi s t y!1)
                      (("" (use subword_is_antisymmetric)
                        (("" (expand antisymmetric?)
                          (("" (inst - t y!1) (("" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((singleton? const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (antisymmetric? const-decl "bool" relations nil)
    (subword_is_antisymmetric judgement-tcc nil seq_subword_props nil)
    (singleton_lemma formula-decl nil seq_filter_props nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (s skolem-const-decl "seq[T]" seq_filter_props nil)
    (pi skolem-const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (t skolem-const-decl "seq[T]" seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (filter_pos_is_nonempty formula-decl nil seq_filter_props nil))
   nil))
 (filter_is_singleton 0
  (filter_is_singleton-1 nil 3581175271
   ("" (skeep)
    (("" (rewrite filter?_as_filter_pos?)
      (("" (all-typepreds) nil nil)) nil))
    nil)
   ((filter?_as_filter_pos? formula-decl nil seq_filter_props nil)
    (T formal-type-decl nil seq_filter_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (filter_pos_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (singleton? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   nil))
 (filter_pos_unicity 0
  (filter_pos_unicity-1 nil 3581179700
   ("" (skeep)
    (("" (typepred "filter_pos?(s, pi)")
      (("" (expand singleton?)
        (("" (skeep)
          (("" (copy -1)
            (("" (inst - s1)
              (("" (inst - s2) (("" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((filter_pos? const-decl "bool" seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (singleton? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (filter_pos_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (s skolem-const-decl "seq[T]" seq_filter_props nil)
    (pi skolem-const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (s1 skolem-const-decl "seq[T]" seq_filter_props nil)
    (s2 skolem-const-decl "seq[T]" seq_filter_props nil))
   shostak))
 (filter_unicity 0
  (filter_unicity-1 nil 3581179743
   ("" (skeep)
    (("" (typepred "filter?(s, p)")
      (("" (expand singleton?)
        (("" (skeep)
          (("" (copy -1)
            (("" (inst - s1)
              (("" (inst - s2) (("" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((filter? const-decl "bool" seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (singleton? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (filter_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (s skolem-const-decl "seq[T]" seq_filter_props nil)
    (p skolem-const-decl "PRED[T]" seq_filter_props nil)
    (s1 skolem-const-decl "seq[T]" seq_filter_props nil)
    (s2 skolem-const-decl "seq[T]" seq_filter_props nil))
   shostak))
 (filter_TCC1 0
  (filter_TCC1-1 nil 3581178527
   ("" (inst + "LAMBDA (d: [seq[T],PRED[T]]): the(filter?(d`1, d`2))")
    nil nil)
   ((the const-decl "(p)" sets nil)
    (singleton? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (filter? const-decl "bool" seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (filter_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil))
   nil))
 (filter_pos_TCC1 0
  (filter_pos_TCC1-1 nil 3581178527
   (""
    (inst +
     "LAMBDA (d: [seq[T],PRED[[nat, T]]]): the(filter_pos?(d`1, d`2))")
    nil nil)
   ((the const-decl "(p)" sets nil)
    (singleton? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (filter_pos_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil))
   nil))
 (filter_pos_equality 0
  (filter_pos_equality-1 nil 3581179290
   ("" (skeep)
    (("" (typepred "filter_pos(s, pi)")
      (("" (lemma filter_pos_unicity) (("" (grind :defs nil) nil nil))
        nil))
      nil))
    nil)
   ((filter_pos const-decl "(filter_pos?(s, pi))" seq_filter_props nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (filter_pos_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (filter_pos_unicity formula-decl nil seq_filter_props nil))
   shostak))
 (filter_equality 0
  (filter_equality-1 nil 3581180206
   ("" (skeep)
    (("" (typepred "filter(s, p)")
      (("" (lemma filter_unicity) (("" (grind :defs nil) nil nil))
        nil))
      nil))
    nil)
   ((filter const-decl "(filter?(s, p))" seq_filter_props nil)
    (filter? const-decl "bool" seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (filter_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (filter_unicity formula-decl nil seq_filter_props nil))
   shostak))
 (filter_as_filter_pos 0
  (filter_as_filter_pos-1 nil 3581177971
   ("" (skolem-typepred)
    (("" (all-typepreds)
      (("" (hide -2 -3 -5)
        (("" (rewrite filter?_as_filter_pos?)
          (("" (expand singleton?)
            (("" (skeep)
              (("" (copy -3)
                (("" (inst - "filter(s!1, p!1)")
                  ((""
                    (inst - "filter_pos(s!1, LAMBDA (n, x): p!1(x))")
                    (("" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((filter_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (filter_pos_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (set type-eq-decl nil sets nil)
    (singleton? const-decl "bool" sets nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (filter_pos const-decl "(filter_pos?(s, pi))" seq_filter_props nil)
    (filter? const-decl "bool" seq_filter_props nil)
    (filter const-decl "(filter?(s, p))" seq_filter_props nil)
    (filter?_as_filter_pos? formula-decl nil seq_filter_props nil)
    (s!1 skolem-const-decl "seq[T]" seq_filter_props nil)
    (p!1 skolem-const-decl "PRED[T]" seq_filter_props nil))
   shostak))
 (partition_as_partition_pos 0
  (partition_as_partition_pos-1 nil 3581177988
   ("" (grind :rewrites filter_as_filter_pos) nil nil)
   ((partition_pos const-decl "[seq, seq]" seq_filter_props nil)
    (partition const-decl "[seq, seq]" seq_filter_props nil)
    (filter_as_filter_pos formula-decl nil seq_filter_props nil))
   shostak))
 (filter_filter_pos 0
  (filter_filter_pos-1 nil 3581183614
   ("" (skeep)
    (("" (lemma filter_pos_equality)
      ((""
        (inst - "LAMBDA (n, x): pi(n, x) AND p(x)" s
         "filter(filter_pos(s, pi), p)")
        (("" (bddsimp)
          (("1" (grind) nil nil)
           ("2" (hide 1 3)
            (("2" (typepred "filter_pos(s, pi)")
              (("2" (typepred "filter(filter_pos(s, pi), p)")
                (("2" (expand (filter? filter_pos?))
                  (("2" (skeep)
                    (("2" (skeep)
                      (("2"
                        (inst +
                         "LAMBDA (i: bl(filter(filter_pos(s, pi), p))): f!1(f(i))")
                        (("1" (split 1)
                          (("1" (skeep)
                            (("1" (inst - i_1)
                              (("1"
                                (inst -3 "f(i_1)")
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (skeep)
                            (("2" (prop)
                              (("1"
                                (inst -6 j)
                                (("1"
                                  (prop)
                                  (("1"
                                    (skeep)
                                    (("1"
                                      (inst -7 i)
                                      (("1"
                                        (inst -6 i)
                                        (("1"
                                          (prop)
                                          (("1"
                                            (skeep)
                                            (("1"
                                              (inst + i_1)
                                              (("1" (grind) nil nil))
                                              nil))
                                            nil)
                                           ("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (skeep)
                                (("2"
                                  (inst -5 j)
                                  (("2"
                                    (prop)
                                    (("2" (inst + "f(i_1)") nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("3"
                                (skeep)
                                (("3"
                                  (inst -4 "f(i_1)")
                                  (("3"
                                    (inst -3 "f(i_1)")
                                    (("3"
                                      (prop)
                                      (("1" (grind) nil nil)
                                       ("2" (inst + i_1) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (typepred f!1)
                          (("2" (typepred f)
                            (("2" (expand preserves)
                              (("2"
                                (skeep)
                                (("2"
                                  (inst - x1 x2)
                                  (("2"
                                    (inst - "f(x1)" "f(x2)")
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((filter_pos_equality formula-decl nil seq_filter_props nil)
    (filter_pos_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (s skolem-const-decl "seq[T]" seq_filter_props nil)
    (pi skolem-const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (p skolem-const-decl "PRED[T]" seq_filter_props nil)
    (bl type-eq-decl nil seq_defs nil)
    (preserves const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil)
    (f!1 skolem-const-decl "{f: [bl(filter_pos(s, pi)) -> bl(s)] |
         preserves(f,
                   restrict
                       [[real, real],
                        [bl[T](filter_pos(s, pi)),
                         bl[T](filter_pos(s, pi))],
                        boolean]
                       (<),
                   <)}" seq_filter_props nil)
    (f skolem-const-decl
     "{f: [bl(filter(filter_pos(s, pi), p)) -> bl(filter_pos(s, pi))] |
         preserves(f,
                   restrict
                       [[real, real],
                        [bl[T](filter(filter_pos(s, pi), p)),
                         bl[T](filter(filter_pos(s, pi), p))],
                        boolean]
                       (<),
                   <)}" seq_filter_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (filter_pos const-decl "(filter_pos?(s, pi))" seq_filter_props nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (filter const-decl "(filter?(s, p))" seq_filter_props nil)
    (filter? const-decl "bool" seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (T formal-type-decl nil seq_filter_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (filter_filter 0
  (filter_filter-1 nil 3581178002
   ("" (skeep)
    (("" (rewrite filter_as_filter_pos * ("s" "s"))
      (("" (rewrite filter_as_filter_pos * ("s" "s"))
        (("" (rewrite filter_filter_pos) nil nil)) nil))
      nil))
    nil)
   ((filter_as_filter_pos formula-decl nil seq_filter_props nil)
    (T formal-type-decl nil seq_filter_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (filter_filter_pos formula-decl nil seq_filter_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil))
   shostak))
 (filter_pos_true 0
  (filter_pos_true-1 nil 3581181882
   ("" (grind :rewrites filter_pos_equality)
    (("" (inst + "LAMBDA (i: bl(s!1)): i")
      (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bl type-eq-decl nil seq_defs nil)
    (s!1 skolem-const-decl "seq[T]" seq_filter_props nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (preserves const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (filter_pos_equality formula-decl nil seq_filter_props nil)
    (filter_pos? const-decl "bool" seq_filter_props nil))
   shostak))
 (filter_true 0
  (filter_true-1 nil 3581181949
   ("" (grind :rewrites filter_equality)
    (("" (inst + "LAMBDA (i: bl(s!1)): i")
      (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bl type-eq-decl nil seq_defs nil)
    (s!1 skolem-const-decl "seq[T]" seq_filter_props nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (preserves const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (filter_equality formula-decl nil seq_filter_props nil)
    (filter? const-decl "bool" seq_filter_props nil))
   shostak))
 (subword_filter 0
  (subword_filter-1 nil 3581185578
   ("" (grind)
    (("" (typepred "filter(s!1, p!1)")
      (("" (expand filter?)
        (("" (skeep)
          (("" (inst + f)
            (("" (typepred f) (("" (lazy-grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((filter const-decl "(filter?(s, p))" seq_filter_props nil)
    (filter? const-decl "bool" seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bl type-eq-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (subword? const-decl "bool" seq_subword_props nil)
    (T formal-type-decl nil seq_filter_props nil)
    (preserves const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil))
   shostak))
 (subword_filter_pos 0
  (subword_filter_pos-1 nil 3581185737
   ("" (grind)
    (("" (typepred "filter_pos(s!1, pi!1)")
      (("" (expand filter_pos?)
        (("" (skeep)
          (("" (inst + f)
            (("" (typepred f) (("" (lazy-grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((filter_pos const-decl "(filter_pos?(s, pi))" seq_filter_props nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bl type-eq-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (< const-decl "bool" reals nil)
    (subword? const-decl "bool" seq_subword_props nil)
    (T formal-type-decl nil seq_filter_props nil)
    (preserves const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil))
   shostak))
 (member_filter 0
  (member_filter-1 nil 3581185773
   ("" (skeep)
    (("" (typepred "filter(s, p)")
      (("" (expand filter?)
        (("" (expand member)
          (("" (skeep)
            (("" (prop)
              (("1" (skeep)
                (("1" (inst - i)
                  (("1" (inst + "f(i)") (("1" (grind) nil nil)) nil))
                  nil))
                nil)
               ("2" (skeep)
                (("2" (inst - i)
                  (("2" (inst - "f(i)") (("2" (grind) nil nil)) nil))
                  nil))
                nil)
               ("3" (skeep)
                (("3" (inst -4 i)
                  (("3" (prop)
                    (("1" (skeep)
                      (("1" (inst - i_1)
                        (("1" (inst + i_1) (("1" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((filter const-decl "(filter?(s, p))" seq_filter_props nil)
    (filter? const-decl "bool" seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member const-decl "bool" seq_basic_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (bl type-eq-decl nil seq_defs nil)
    (restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil))
   shostak))
 (filter_pos_append 0
  (filter_pos_append-1 nil 3581186021
   ("" (skeep)
    (("" (rewrite filter_pos_equality)
      (("" (expand filter_pos?)
        (("" (typepred "filter_pos(s1, pi)")
          (("" (typepred "filter_pos(s2, pi)")
            (("" (expand filter_pos?)
              (("" (skolem -1 "f2")
                (("" (skolem -2 "f1")
                  ((""
                    (inst + "LAMBDA (i: bl
                     [T](append(filter_pos(s1, pi),
                                filter_pos(s2,
                                           LAMBDA
                                           (n, x):
                                           pi(n + length(s1), x))))): IF i < length(filter_pos(s1, pi)) THEN f1(i) ELSE f2(i) ENDIF")
                    (("1" (split 1)
                      (("1" (skeep)
                        (("1" (rewrite* nth_append)
                          (("1" (lift-if)
                            (("1" (lift-if)
                              (("1"
                                (bddsimp)
                                (("1" (lazy-grind) nil nil)
                                 ("2" (lazy-grind) nil nil)
                                 ("3"
                                  (lift-if)
                                  (("3"
                                    (bddsimp)
                                    (("1" (postpone) nil nil)
                                     ("2" (postpone) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (postpone) nil nil)
                           ("3" (postpone) nil nil)
                           ("4" (postpone) nil nil)
                           ("5" (postpone) nil nil))
                          nil))
                        nil)
                       ("2" (postpone) nil nil))
                      nil)
                     ("2" (postpone) nil nil) ("3" (postpone) nil nil)
                     ("4" (postpone) nil nil) ("5" (postpone) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (append_filter_pos2_TCC1 0
  (append_filter_pos2_TCC1-1 nil 3581166167 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (filter_pos_reverse_TCC1 0
  (filter_pos_reverse_TCC1-1 nil 3581166167 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil)))

