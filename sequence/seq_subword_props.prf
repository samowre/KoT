(seq_subword_props
 (incr_inj_ge_id 0
  (incr_inj_ge_id-1 nil 3580057465
   ("" (skeep)
    (("" (induct i)
      (("1" (grind) nil nil)
       ("2" (grind :if-match nil)
        (("2" (inst - jb!1 "1+jb!1") (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (<= const-decl "bool" reals nil)
    (injective? const-decl "bool" functions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below_induction formula-decl nil bounded_nat_inductions nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil))
   shostak))
 (incr_bij_is_id 0
  (incr_bij_is_id-1 nil 3580057841
   ("" (use incr_inj_ge_id)
    (("" (use incr_inj_ge_id)
      (("" (skeep)
        (("" (inst - n n f)
          (("" (inst - n n "inverse(f)")
            (("1" (prop)
              (("1" (skeep)
                (("1" (inst - "f(i)")
                  (("1" (inst - i)
                    (("1"
                      (lemma "bijective_inverse[below(n),below(n)]")
                      (("1" (inst - i "f(i)" f)
                        (("1" (grind) nil nil)
                         ("2" (use inj_equiv_bij)
                          (("2" (grind) nil nil)) nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand preserves)
                (("2" (skeep)
                  (("2" (inst -3 "inverse(f)(x2)" "inverse(f)(x1)")
                    (("1" (prop)
                      (("1" (rewrite inverse_surjective)
                        (("1" (rewrite inverse_surjective)
                          (("1" (grind) nil nil)
                           ("2" (use surj_equiv_inj)
                            (("2" (grind) nil nil)) nil)
                           ("3" (grind) nil nil))
                          nil)
                         ("2" (use surj_equiv_inj)
                          (("2" (grind) nil nil)) nil)
                         ("3" (grind) nil nil))
                        nil)
                       ("2" (case "inverse(f)(x2) = inverse(f)(x1)")
                        (("1" (typepred "inverse(f)")
                          (("1" (use surj_equiv_inj)
                            (("1" (grind :if-match all) nil nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil) ("3" (grind) nil nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("3" (grind) nil nil) ("4" (grind) nil nil))
              nil)
             ("2" (use inj_equiv_bij)
              (("1" (lemma inj_equiv_bij)
                (("1" (inst - n f)
                  (("1"
                    (use "bijective_inverse_is_bijective[below(n),below(n)]")
                    (("1" (grind) nil nil) ("2" (grind) nil nil)
                     ("3" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil)
             ("3" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (injective? const-decl "bool" functions nil)
    (bijective_inverse_is_bijective judgement-tcc nil function_inverse
     nil)
    (bijective_inverse formula-decl nil function_inverse nil)
    (inj_equiv_bij formula-decl nil nat_fun_props nil)
    (surjective? const-decl "bool" functions nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (preserves const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil)
    (bijective? const-decl "bool" functions nil)
    (surj_equiv_inj formula-decl nil nat_fun_props nil)
    (inverse_surjective formula-decl nil function_inverse nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (epsilon const-decl "T" epsilons nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (inverse const-decl "D" function_inverse nil)
    (f skolem-const-decl "(injective?[below(n), below(n)])"
     seq_subword_props nil)
    (TRUE const-decl "bool" booleans nil)
    (n skolem-const-decl "nat" seq_subword_props nil)
    (inv_inj_is_surj application-judgement "(surjective?[R, D])"
     function_inverse nil)
    (incr_inj_ge_id formula-decl nil seq_subword_props nil))
   shostak))
 (length_subword 0
  (length_subword-1 nil 3580009901
   ("" (grind :rewrites subword_as_nth)
    (("" (use injection_n_to_m) (("" (grind) nil nil)) nil)) nil)
   ((injection_n_to_m formula-decl nil nat_fun_props nil)
    (injective? const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (T formal-type-decl nil seq_subword_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (bl type-eq-decl nil seq_defs nil)
    (subword_as_nth formula-decl nil seq_subword_props nil))
   shostak))
 (length_st_subword 0
  (length_st_subword-1 nil 3580061323
   ("" (skeep)
    (("" (expand <<)
      (("" (use length_subword)
        (("" (prop)
          (("" (rewrite subword_as_nth)
            (("" (skeep)
              (("" (use incr_bij_is_id)
                (("1" (prop)
                  (("1" (grind :rewrites nth_equal) nil nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((<< const-decl "bool" seq_subword_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nth_equal formula-decl nil seq_defs nil)
    (restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (below type-eq-decl nil naturalnumbers nil)
    (f skolem-const-decl "[bl[T](s1) -> bl[T](s2)]" seq_subword_props
     nil)
    (s2 skolem-const-decl "seq[T]" seq_subword_props nil)
    (bl type-eq-decl nil seq_defs nil)
    (s1 skolem-const-decl "seq[T]" seq_subword_props nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (incr_bij_is_id formula-decl nil seq_subword_props nil)
    (subword_as_nth formula-decl nil seq_subword_props nil)
    (T formal-type-decl nil seq_subword_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (length_subword formula-decl nil seq_subword_props nil))
   shostak))
 (subword_is_reflexive 0
  (subword_is_reflexive-1 nil 3580010309
   ("" (grind :rewrites subword_as_nth)
    (("" (inst + "LAMBDA (i:bl(x!1)): i") (("" (grind) nil nil)) nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (T formal-type-decl nil seq_subword_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (bl type-eq-decl nil seq_defs nil)
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (reflexive? const-decl "bool" relations nil)
    (subword_as_nth formula-decl nil seq_subword_props nil))
   shostak))
 (subword_is_transitive 0
  (subword_is_transitive-1 nil 3580010359
   ("" (grind :rewrites subword_as_nth :if-match nil)
    (("" (inst + "LAMBDA (i:bl(x!1)): f!2(f!1(i))")
      (("" (prop)
        (("1" (expand injective?)
          (("1" (skeep)
            (("1" (inst -4 x1 x2)
              (("1" (inst -7 "f!1(x1)" "f!1(x2)")
                (("1" (grind) nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (expand preserves)
          (("2" (skeep)
            (("2" (inst -5 x1 x2)
              (("2" (inst -8 "f!1(x1)" "f!1(x2)")
                (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil)
         ("3" (grind) nil nil))
        nil))
      nil))
    nil)
   ((i!1 skolem-const-decl "bl[T](x!1)" seq_subword_props nil)
    (y!1 skolem-const-decl "seq[T]" seq_subword_props nil)
    (i!1 skolem-const-decl "bl[T](x!1)" seq_subword_props nil)
    (x!1 skolem-const-decl "seq[T]" seq_subword_props nil)
    (z!1 skolem-const-decl "seq[T]" seq_subword_props nil)
    (preserves const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil)
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (T formal-type-decl nil seq_subword_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (bl type-eq-decl nil seq_defs nil)
    (transitive? const-decl "bool" relations nil)
    (subword_as_nth formula-decl nil seq_subword_props nil))
   shostak))
 (subword_is_antisymmetric 0
  (subword_is_antisymmetric-2 nil 3580067296
   ("" (expand antisymmetric?)
    (("" (skolem!)
      (("" (prop)
        (("" (rewrite nth_equal)
          (("" (use length_subword)
            (("" (use length_subword (s1 y!1))
              (("" (prop)
                (("1" (grind) nil nil)
                 ("2" (rewrite subword_as_nth)
                  (("2" (skeep)
                    (("2" (skeep)
                      (("2" (use incr_bij_is_id)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nth_equal formula-decl nil seq_defs nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_subword_props nil)
    (subword_as_nth formula-decl nil seq_subword_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (preserves const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (below type-eq-decl nil naturalnumbers nil)
    (f skolem-const-decl "[bl[T](x!1) -> bl[T](y!1)]" seq_subword_props
     nil)
    (y!1 skolem-const-decl "seq[T]" seq_subword_props nil)
    (bl type-eq-decl nil seq_defs nil)
    (x!1 skolem-const-decl "seq[T]" seq_subword_props nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (incr_bij_is_id formula-decl nil seq_subword_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (length_subword formula-decl nil seq_subword_props nil)
    (antisymmetric? const-decl "bool" relations nil))
   nil)
  (subword_is_antisymmetric-1 nil 3580055273
   ("" (expand antisymmetric?)
    (("" (skolem!)
      (("" (prop)
        (("" (rewrite nth_equal)
          (("" (use length_subword)
            (("" (use length_subword (s1 y!1))
              (("" (prop)
                (("1" (grind) nil nil)
                 ("2" (rewrite subword_as_nth)
                  (("2" (skeep)
                    (("2" (skeep)
                      (("2" (use incr_bij_is_id)
                        (("1" (prop)
                          (("1" (grind) nil nil) ("2" (grind) nil nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nth_equal formula-decl nil seq_defs nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_subword_props nil)
    (subword_as_nth formula-decl nil seq_subword_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (below type-eq-decl nil naturalnumbers nil)
    (bl type-eq-decl nil seq_defs nil) (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (incr_bij_is_id formula-decl nil seq_subword_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (length_subword formula-decl nil seq_subword_props nil)
    (antisymmetric? const-decl "bool" relations nil))
   shostak))
 (subword_is_partial_order 0
  (subword_is_partial_order-1 nil 3580060394
   ("" (use subword_is_reflexive)
    (("" (use subword_is_transitive)
      (("" (use subword_is_antisymmetric) (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((subword_is_transitive formula-decl nil seq_subword_props nil)
    (partial_order? const-decl "bool" orders nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (antisymmetric? const-decl "bool" relations nil)
    (subword_is_antisymmetric formula-decl nil seq_subword_props nil)
    (subword_is_reflexive formula-decl nil seq_subword_props nil))
   shostak))
 (subword_is_well_founded 0
  (subword_is_well_founded-1 nil 3580060865
   ("" (case "well_founded?(LAMBDA s1,s2: length(s1) < length(s2))")
    (("1" (expand well_founded?)
      (("1" (skeep)
        (("1" (inst - p)
          (("1" (prop)
            (("1" (skeep)
              (("1" (inst + y)
                (("1" (skeep)
                  (("1" (inst - x)
                    (("1" (use length_st_subword)
                      (("1" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (hide 2)
      (("2" (use wf_nat)
        (("2" (expand well_founded?)
          (("2" (skeep)
            (("2"
              (inst -
               "LAMBDA (n:nat): EXISTS s: length(s) = n AND p(s)")
              (("2" (prop)
                (("1" (skeep)
                  (("1" (typepred "y::nat")
                    (("1" (skeep)
                      (("1" (inst + s)
                        (("1" (skeep)
                          (("1" (inst - "length(x)")
                            (("1" (grind) nil nil)
                             ("2" (inst + x) (("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skeep)
                  (("2" (inst + "length(y)") (("2" (inst + y) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (x skolem-const-decl "(p)" seq_subword_props nil)
    (s skolem-const-decl "seq[T]" seq_subword_props nil)
    (p skolem-const-decl "pred[seq[T]]" seq_subword_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (length_st_subword formula-decl nil seq_subword_props nil)
    (T formal-type-decl nil seq_subword_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length const-decl "[seq -> nat]" seq_defs nil))
   shostak))
 (subword_empty 0
  (subword_empty-1 nil 3580010052
   ("" (grind :theories seq_defs :rewrites subword_as_nth)
    (("" (inst + "LAMBDA (x:bl(empty)): 0")
      (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((s!1 skolem-const-decl "seq[T]" seq_subword_props nil)
    (bl type-eq-decl nil seq_defs nil)
    (empty const-decl "{s | length(s) = 0}" seq_defs nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_subword_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (injective? const-decl "bool" functions nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subword_as_nth formula-decl nil seq_subword_props nil))
   shostak))
 (subword__empty 0
  (subword__empty-1 nil 3580067394
   ("" (skeep)
    (("" (use subword_is_antisymmetric)
      (("" (use subword_empty)
        (("" (grind :theories seq_defs) nil nil)) nil))
      nil))
    nil)
   ((subword_is_antisymmetric formula-decl nil seq_subword_props nil)
    (empty_as_empty formula-decl nil seq_defs nil)
    (antisymmetric? const-decl "bool" relations nil)
    (nth_equal formula-decl nil seq_defs nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (empty const-decl "{s | length(s) = 0}" seq_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil) (bl type-eq-decl nil seq_defs nil)
    (T formal-type-decl nil seq_subword_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (subword_empty formula-decl nil seq_subword_props nil))
   shostak))
 (member_subword 0
  (member_subword-1 nil 3580041512
   ("" (grind :rewrites (member_as_nth subword_as_nth)) nil nil)
   ((subword_as_nth formula-decl nil seq_subword_props nil)
    (member const-decl "bool" seq_basic_props nil)
    (T formal-type-decl nil seq_subword_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (bl type-eq-decl nil seq_defs nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (subword_append 0
  (subword_append-1 nil 3580041549
   ("" (skeep)
    (("" (rewrite subword_as_nth)
      (("" (inst + "LAMBDA (i:bl(s1)): i")
        (("1" (grind :theories seq_basic_props) nil nil)
         ("2" (grind :theories seq_basic_props) nil nil))
        nil))
      nil))
    nil)
   ((subword_as_nth formula-decl nil seq_subword_props nil)
    (T formal-type-decl nil seq_subword_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (append const-decl "seq" seq_basic_props nil)
    (length_append formula-decl nil seq_basic_props nil)
    (injective? const-decl "bool" functions nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth_append formula-decl nil seq_basic_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (s1 skolem-const-decl "seq[T]" seq_subword_props nil)
    (bl type-eq-decl nil seq_defs nil)
    (s2 skolem-const-decl "seq[T]" seq_subword_props nil))
   shostak))
 (subword__append 0
  (subword__append-1 nil 3580041628
   ("" (skeep)
    (("" (rewrite subword_as_nth)
      (("" (inst + "LAMBDA (i:bl(s2)): i+length(s1)")
        (("1" (grind :theories seq_basic_props) nil nil)
         ("2" (grind :theories seq_basic_props) nil nil))
        nil))
      nil))
    nil)
   ((subword_as_nth formula-decl nil seq_subword_props nil)
    (T formal-type-decl nil seq_subword_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (append const-decl "seq" seq_basic_props nil)
    (length_append formula-decl nil seq_basic_props nil)
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nth_append formula-decl nil seq_basic_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (s2 skolem-const-decl "seq[T]" seq_subword_props nil)
    (bl type-eq-decl nil seq_defs nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (s1 skolem-const-decl "seq[T]" seq_subword_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (subword_reverse2 0
  (subword_reverse2-1 nil 3580041664
   ("" (skeep)
    (("" (rewrite subword_as_nth)
      (("" (rewrite subword_as_nth)
        (("" (prop)
          (("1" (skeep)
            (("1"
              (inst +
               "LAMBDA (i:bl(s1)): length(s2) - 1 - f(length(s1)-1-i)")
              (("1" (prop)
                (("1" (expand injective?)
                  (("1" (skeep)
                    (("1" (inst - "length(s1)-1-x1" "length(s1)-1-x2")
                      (("1" (grind) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (expand preserves)
                  (("2" (skeep)
                    (("2" (inst - "length(s1)-1-x2" "length(s1)-1-x1")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil)
                 ("3" (skeep)
                  (("3" (inst - "length(s1) - 1 -i_1")
                    (("3" (rewrite nth_reverse)
                      (("3" (rewrite nth_reverse)
                        (("3" (typepred "f(length(s1)-1-i_1)")
                          (("3" (grind :rewrites length_reverse) nil
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skeep)
                (("2" (typepred "f(length(s1)-1-i)")
                  (("1" (grind :rewrites length_reverse) nil nil)
                   ("2" (typepred "f(length(s1)-1-i)")
                    (("1" (grind :rewrites length_reverse) nil nil)
                     ("2" (typepred "f(length(s1)-1-i)")
                      (("1" (grind :rewrites length_reverse) nil nil)
                       ("2" (typepred "f(length(s1)-1-i)")
                        (("1" (grind :rewrites length_reverse) nil nil)
                         ("2" (typepred "f(length(s1)-1-i)")
                          (("1" (grind :rewrites length_reverse) nil
                            nil)
                           ("2" (grind :rewrites length_reverse) nil
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (grind :rewrites length_reverse) nil nil))
              nil))
            nil)
           ("2" (skeep)
            (("2"
              (inst +
               "LAMBDA (i:bl(s1)): length(s2) - 1 - f(length(s1)-1-i)")
              (("1" (prop)
                (("1" (expand injective?)
                  (("1" (skeep)
                    (("1" (inst - "length(s1)-1-x1" "length(s1)-1-x2")
                      (("1" (grind) nil nil)
                       ("2" (typepred x2)
                        (("2" (grind :rewrites length_reverse) nil
                          nil))
                        nil)
                       ("3" (typepred x1)
                        (("3" (grind :rewrites length_reverse) nil
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand preserves)
                  (("2" (skeep)
                    (("2" (inst - "length(s1)-1-x2" "length(s1)-1-x1")
                      (("1" (grind) nil nil)
                       ("2" (typepred x1)
                        (("2" (grind :rewrites length_reverse) nil
                          nil))
                        nil)
                       ("3" (typepred x2)
                        (("3" (grind :rewrites length_reverse) nil
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (skeep)
                  (("3" (inst - "length(s1)-1-i_1")
                    (("1" (rewrite nth_reverse)
                      (("1" (rewrite nth_reverse)
                        (("1" (typepred i_1)
                          (("1" (grind :rewrites length_reverse) nil
                            nil))
                          nil))
                        nil)
                       ("2" (typepred i_1)
                        (("2" (grind :rewrites length_reverse) nil
                          nil))
                        nil))
                      nil)
                     ("2" (typepred i_1)
                      (("2" (grind :rewrites length_reverse) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind :rewrites length_reverse) nil nil)
               ("3" (grind :rewrites length_reverse) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subword_as_nth formula-decl nil seq_subword_props nil)
    (T formal-type-decl nil seq_subword_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (reverse const-decl "seq" seq_basic_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (bl type-eq-decl nil seq_defs nil)
    (s1 skolem-const-decl "seq[T]" seq_subword_props nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (f skolem-const-decl "[bl[T](reverse(s1)) -> bl[T](reverse(s2))]"
     seq_subword_props nil)
    (s2 skolem-const-decl "seq[T]" seq_subword_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nth_reverse formula-decl nil seq_basic_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (length_reverse formula-decl nil seq_basic_props nil)
    (preserves const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (f skolem-const-decl "[bl[T](s1) -> bl[T](s2)]" seq_subword_props
     nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (i_1 skolem-const-decl "bl[T](reverse(s1))" seq_subword_props nil)
    (x2 skolem-const-decl "bl[T](reverse(s1))" seq_subword_props nil)
    (x1 skolem-const-decl "bl[T](reverse(s1))" seq_subword_props nil)
    (x1 skolem-const-decl "bl[T](reverse(s1))" seq_subword_props nil)
    (x2 skolem-const-decl "bl[T](reverse(s1))" seq_subword_props nil))
   shostak))
 (subword_reverse 0
  (subword_reverse-1 nil 3580042823
   ("" (use subword_reverse2)
    (("" (skeep)
      (("" (inst - "s1" "reverse(s2)")
        (("" (lemma reverse_reverse)
          (("" (inst - s2)
            (("" (lemma subword_preserves_eq)
              ((""
                (inst - "reverse(s1)" "reverse(s1)"
                 "reverse(reverse(s2))" s2)
                (("" (rewrite -1)
                  (("" (typepred =) (("" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((reverse_reverse formula-decl nil seq_basic_props nil)
    (reverse const-decl "seq" seq_basic_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_subword_props nil)
    (subword_reverse2 formula-decl nil seq_subword_props nil))
   shostak))
 (subword__reverse 0
  (subword__reverse-1 nil 3580043027
   ("" (use subword_reverse2)
    (("" (skeep)
      (("" (inst - "reverse(s1)" s2)
        (("" (lemma reverse_reverse)
          (("" (inst - s1)
            (("" (lemma subword_preserves_eq)
              ((""
                (inst - "reverse(reverse(s1))" s1 "reverse(s2)"
                 "reverse(s2)")
                (("" (rewrite -1 :dir rl)
                  (("1" (typepred =)
                    (("1" (grind :if-match all) nil nil)) nil)
                   ("2" (typepred =)
                    (("2" (grind :if-match all) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((reverse_reverse formula-decl nil seq_basic_props nil)
    (reverse const-decl "seq" seq_basic_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_subword_props nil)
    (subword_reverse2 formula-decl nil seq_subword_props nil))
   shostak))
 (every_subword 0
  (every_subword-1 nil 3580043283
   ("" (skeep)
    (("" (rewrite every_as_forall)
      (("" (rewrite every_as_forall)
        (("" (skeep)
          (("" (inst - x)
            (("" (typepred x)
              (("" (lemma member_subword)
                (("" (inst - s1 s2 x) (("" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every_as_forall formula-decl nil seq_basic_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_subword_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (member_subword formula-decl nil seq_subword_props nil)
    (s1 skolem-const-decl "seq[T]" seq_subword_props nil)
    (x skolem-const-decl "{x | member(x, s1)}" seq_subword_props nil)
    (s2 skolem-const-decl "seq[T]" seq_subword_props nil)
    (member const-decl "bool" seq_basic_props nil))
   shostak))
 (some_subword 0
  (some_subword-1 nil 3580043404
   ("" (skeep)
    (("" (rewrite some_as_exists)
      (("" (rewrite some_as_exists)
        (("" (skeep)
          (("" (inst + x)
            (("" (lemma member_subword)
              (("" (inst - s1 s2 x)
                (("" (typepred x) (("" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((some_as_exists formula-decl nil seq_basic_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_subword_props nil)
    (member_subword formula-decl nil seq_subword_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (s1 skolem-const-decl "seq[T]" seq_subword_props nil)
    (x skolem-const-decl "{x | member(x, s1)}" seq_subword_props nil)
    (s2 skolem-const-decl "seq[T]" seq_subword_props nil)
    (member const-decl "bool" seq_basic_props nil))
   shostak)))

