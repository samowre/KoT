(seq_filter_props
 (singleton_unicity 0
  (singleton_unicity-1 nil 3581435984
   ("" (skolem-typepred)
    (("" (expand singleton?)
      (("" (skeep)
        (("" (copy -1)
          (("" (inst - a!1)
            (("" (inst - b!1) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((b!1 skolem-const-decl "S" seq_filter_props nil)
    (s!1 skolem-const-decl "(singleton?[S])" seq_filter_props nil)
    (a!1 skolem-const-decl "S" seq_filter_props nil)
    (singleton? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (S decl-formal-type nil seq_filter_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (below_is_finite 0
  (below_is_finite-1 nil 3581349080
   ("" (skeep)
    (("" (expand is_finite)
      (("" (inst + n "LAMBDA (j: nat | j < n AND p(j)): j")
        (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (PRED type-eq-decl nil defined_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (st_incr_is_injective 0
  (st_incr_is_injective-1 nil 3581951082
   ("" (grind :if-match nil)
    (("" (copy -5)
      (("" (inst - x1!1 x2!1)
        (("" (inst - x2!1 x1!1) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (preserves const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil)
    (injective? const-decl "bool" functions nil))
   shostak))
 (st_incr_ge_id 0
  (st_incr_ge_id-1 nil 3581951099
   ("" (skeep)
    (("" (induct-and-simplify i :if-match nil)
      (("" (inst - jb!1 "jb!1+1") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((below_induction formula-decl nil bounded_nat_inductions nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (pred type-eq-decl nil defined_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (preserves const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields
       nil))
   shostak))
 (incr_bij_is_id 0
  (incr_bij_is_id-1 nil 3581951118
   ("" (skeep)
    (("" (lemma st_incr_ge_id)
      (("" (lemma st_incr_ge_id)
        (("" (inst - n n f)
          (("" (inst - n n "LAMBDA (i:below(n)): n - 1 - f(n - 1 - i)")
            (("1" (prop)
              (("1" (skeep)
                (("1" (inst - "n - 1 -i")
                  (("1" (inst - i) (("1" (grind) nil nil)) nil)) nil))
                nil)
               ("2" (grind :if-match nil)
                (("2" (inst -6 "n - 1 - x2!1" "n - 1 - x1!1")
                  (("2" (grind) nil nil)) nil))
                nil)
               ("3" (grind) nil nil) ("4" (grind) nil nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((st_incr_ge_id formula-decl nil seq_filter_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (n skolem-const-decl "nat" seq_filter_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (f skolem-const-decl "[below(n) -> below(n)]" seq_filter_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (nth_filter_pos?_TCC1 0
  (nth_filter_pos?_TCC1-1 nil 3581263133 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (bl type-eq-decl nil seq_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (nth_filter_pos?_TCC2 0
  (nth_filter_pos?_TCC2-1 nil 3581263133
   ("" (skeep)
    ((""
      (use below_is_finite
           ("n" "i" "p" "LAMBDA (j: below(i)): pi(j, nth[T](s, j))"))
      nil nil))
    nil)
   ((below_is_finite formula-decl nil seq_filter_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (T formal-type-decl nil seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (bl type-eq-decl nil seq_defs nil)
    (below type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (nth const-decl "[s: seq, bl(s) -> T]" seq_defs nil))
   nil))
 (nth_filter?_TCC1 0
  (nth_filter?_TCC1-1 nil 3581263133 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (bl type-eq-decl nil seq_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (nth_filter?_TCC2 0
  (nth_filter?_TCC2-1 nil 3581263133
   ("" (skeep)
    ((""
      (use below_is_finite
           ("n" "i" "p" "LAMBDA (j: below(i)): p(nth[T](s, j))"))
      nil nil))
    nil)
   ((below_is_finite formula-decl nil seq_filter_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (T formal-type-decl nil seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (bl type-eq-decl nil seq_defs nil)
    (below type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (nth const-decl "[s: seq, bl(s) -> T]" seq_defs nil))
   nil))
 (nth_filter_as_nth_filter_pos 0
  (nth_filter_as_nth_filter_pos-1 nil 3581263333
   ("" (grind-with-ext) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (bl type-eq-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (< const-decl "bool" reals nil)
    (C1 const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (nth_filter_pos? const-decl "bool" seq_filter_props nil)
    (nth_filter? const-decl "bool" seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil))
   shostak))
 (filter?_as_filter_pos? 0
  (filter?_as_filter_pos?-1 nil 3581693000 ("" (grind) nil nil)
   ((restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil)
    (filter? const-decl "bool" seq_filter_props nil)
    (C1 const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (filter_pos? const-decl "bool" seq_filter_props nil))
   shostak))
 (nth_filter_pos_existence 0
  (nth_filter_pos_existence-1 nil 3581263826
   ("" (skolem 1 (pi s "_"))
    (("" (induct n)
      (("1" (flatten)
        (("1" (use wf_nat)
          (("1" (expand well_founded?)
            (("1"
              (inst -
               "LAMBDA (i: nat): i < length(s) AND pi(i, nth(s, i))")
              (("1" (prop)
                (("1" (skolem -1 i)
                  (("1" (inst + i)
                    (("1" (grind)
                      (("1" (stop-rewrite is_finite)
                        (("1" (rewrite card_empty?)
                          (("1" (skeep)
                            (("1" (inst - x) (("1" (grind) nil nil))
                              nil))
                            nil)
                           ("2"
                            (use below_is_finite
                                 ("n"
                                  "i"
                                  "p"
                                  "LAMBDA (j: below(i)): pi(j, nth[T](s, j))"))
                            nil nil)
                           ("3" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (use "card_empty?[nat]")
                  (("1" (iff)
                    (("1" (prop)
                      (("1" (grind) nil nil)
                       ("2" (expand empty?)
                        (("2" (skeep)
                          (("2" (inst + x) (("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2"
                    (use below_is_finite
                         ("n" "length[T](s)" "p"
                          "LAMBDA (j: below(length[T](s))): pi(j, nth[T](s, j))"))
                    nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep)
        (("2" (skeep)
          (("2"
            (case "NOT empty?(difference({j | j < length(s) AND pi(j, nth(s, j))} , {j | j <= i AND pi(j, nth(s, j))}))")
            (("1" (expand empty?)
              (("1" (skeep)
                (("1" (use wf_nat)
                  (("1" (expand well_founded?)
                    (("1"
                      (inst -
                       "LAMBDA (j: nat): i < j AND j < length(s) AND pi(j, nth(s, j))")
                      (("1" (prop)
                        (("1" (skolem -1 k)
                          (("1" (inst + k)
                            (("1" (expand nth_filter_pos?)
                              (("1"
                                (case
                                 "{j | j < k AND pi(j, nth(s, j))} = add(i,{j | j < i AND pi(j, nth(s, j))})")
                                (("1"
                                  (grind :rewrites card_add)
                                  nil
                                  nil)
                                 ("2"
                                  (expand add)
                                  (("2"
                                    (decompose-equality 1)
                                    (("1"
                                      (iff)
                                      (("1"
                                        (prop)
                                        (("1"
                                          (inst - x!1)
                                          (("1" (grind) nil nil))
                                          nil)
                                         ("2" (grind) nil nil)
                                         ("3" (grind) nil nil)
                                         ("4" (grind) nil nil)
                                         ("5" (grind) nil nil))
                                        nil))
                                      nil)
                                     ("2" (grind) nil nil)
                                     ("3" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("3" (grind) nil nil)
                                 ("4" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (inst + x) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (rewrite card_empty? :dir rl)
              (("1"
                (case "subset?( {j | j <= i AND pi(j, nth(s, j))}, {j | j < length(s) AND pi(j, nth(s, j))})")
                (("1" (rewrite card_diff_subset)
                  (("1"
                    (case "{j | j <= i AND pi(j, nth(s, j))} = add(i,{j | j < i AND pi(j, nth(s, j))})")
                    (("1" (grind :rewrites card_add) nil nil)
                     ("2" (grind-with-ext) nil nil)
                     ("3" (grind) nil nil))
                    nil)
                   ("2"
                    (use below_is_finite
                         ("n" "length[T](s)" "p"
                          "LAMBDA (j: below(length[T](s))): pi(j, nth[T](s, j))"))
                    nil nil)
                   ("3" (expand is_finite)
                    (("3"
                      (inst + "i+1"
                       "LAMBDA (j: nat | j <= i AND pi(j, nth(s, j))): j")
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil)
               ("2" (rewrite finite_difference)
                (("2"
                  (use below_is_finite
                       ("n" "length[T](s)" "p"
                        "LAMBDA (j: below(length[T](s))): pi(j, nth[T](s, j))"))
                  nil nil))
                nil))
              nil)
             ("3" (grind) nil nil))
            nil))
          nil))
        nil)
       ("3"
        (use below_is_finite
             ("n" "length[T](s)" "p"
              "LAMBDA (j: below(length[T](s))): pi(j, nth[T](s, j))"))
        nil nil))
      nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (nth_filter_pos? const-decl "bool" seq_filter_props nil)
    (nth const-decl "[s: seq, bl(s) -> T]" seq_defs nil)
    (bl type-eq-decl nil seq_defs nil)
    (PRED type-eq-decl nil defined_types nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below_induction formula-decl nil bounded_nat_inductions nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (card_empty? formula-decl nil finite_sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (x skolem-const-decl "nat" seq_filter_props nil)
    (s skolem-const-decl "seq[T]" seq_filter_props nil)
    (pi skolem-const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (below_is_finite formula-decl nil seq_filter_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (well_founded? const-decl "bool" orders nil)
    (card_diff_subset formula-decl nil finite_sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (below type-eq-decl nil nat_types nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (injective? const-decl "bool" functions nil)
    (subset? const-decl "bool" sets nil)
    (finite_difference judgement-tcc nil finite_sets nil)
    (x!1 skolem-const-decl "nat" seq_filter_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (k skolem-const-decl
     "(LAMBDA (j: nat): i < j AND j < length(s) AND pi(j, nth(s, j)))"
     seq_filter_props nil)
    (i skolem-const-decl "bl[T](s)" seq_filter_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (card_add formula-decl nil finite_sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (<= const-decl "bool" reals nil)
    (difference const-decl "set" sets nil))
   shostak))
 (nth_filter_existence 0
  (nth_filter_existence-1 nil 3581263404
   ("" (use nth_filter_pos_existence)
    (("" (grind :rewrites (nth_filter_as_nth_filter_pos))
      (("" (expand C1) (("" (propax) nil nil)) nil)) nil))
    nil)
   ((nth_filter_pos? const-decl "bool" seq_filter_props nil)
    (nth_filter_as_nth_filter_pos formula-decl nil seq_filter_props
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth const-decl "[s: seq, bl(s) -> T]" seq_defs nil)
    (bl type-eq-decl nil seq_defs nil)
    (PRED type-eq-decl nil defined_types nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (n!1 skolem-const-decl
     "below(card({j | j < length(s!1) AND p!1(nth(s!1, j))}))"
     seq_filter_props nil)
    (p!1 skolem-const-decl "PRED[T]" seq_filter_props nil)
    (s!1 skolem-const-decl "seq[T]" seq_filter_props nil)
    (C1 const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (nth_filter_pos_existence formula-decl nil seq_filter_props nil))
   shostak))
 (nth_filter_pos_is_singleton_TCC1 0
  (nth_filter_pos_is_singleton_TCC1-1 nil 3581263133
   ("" (skeep)
    ((""
      (use below_is_finite
           ("n" "length[T](s)" "p"
            "LAMBDA (j: below(length[T](s))): pi(j, nth[T](s, j))"))
      nil nil))
    nil)
   ((below_is_finite formula-decl nil seq_filter_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (bl type-eq-decl nil seq_defs nil)
    (nth const-decl "[s: seq, bl(s) -> T]" seq_defs nil))
   nil))
 (nth_filter_pos_is_singleton 0
  (nth_filter_pos_is_singleton-2 nil 3581337947
   ("" (skeep)
    (("" (expand singleton?)
      (("" (use nth_filter_pos_existence)
        (("" (skeep)
          (("" (inst + i)
            (("" (skolem 1 k)
              (("" (typepred k)
                (("" (expand nth_filter_pos?)
                  ((""
                    (case "FORALL (i, k: bl(s)): pi(i, nth(s, i)) AND card( { j | j < i AND pi(j, nth(s, j)) }) = n AND pi(k, nth(s, k)) AND card( { j | j < k AND pi(j, nth(s, j)) }) = n IMPLIES i <= k")
                    (("1" (copy -1)
                      (("1" (inst - i k)
                        (("1" (inst - k i) (("1" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide-all-but 1)
                      (("2" (skeep)
                        (("2"
                          (case "strict_subset?({j | j < k!1 AND pi(j, nth(s, j))} , {j | j < i!1 AND pi(j, nth(s, j))} )")
                          (("1" (use "card_strict_subset[nat]")
                            (("1" (grind) nil nil)
                             ("2"
                              (use below_is_finite
                                   ("n"
                                    "i!1"
                                    "p"
                                    "LAMBDA (j: below(i!1)): pi(j, nth[T](s, j))"))
                              nil nil)
                             ("3" (grind) nil nil)
                             ("4"
                              (use below_is_finite
                                   ("n"
                                    "k!1"
                                    "p"
                                    "LAMBDA (j: below(k!1)): pi(j, nth[T](s, j))"))
                              nil nil)
                             ("5" (grind) nil nil))
                            nil)
                           ("2" (expand strict_subset?)
                            (("2" (split)
                              (("1" (grind) nil nil)
                               ("2"
                                (prop)
                                (("2"
                                  (decompose-equality -1)
                                  (("2"
                                    (inst - k!1)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (grind) nil nil) ("4" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("3" (skeep)
                      (("3"
                        (use below_is_finite
                             ("n" "k!1" "p"
                              "LAMBDA (j: below(k!1)): pi(j, nth[T](s, j))"))
                        nil nil))
                      nil)
                     ("4" (grind) nil nil)
                     ("5" (skeep)
                      (("5"
                        (use below_is_finite
                             ("n" "i!1" "p"
                              "LAMBDA (j: below(i!1)): pi(j, nth[T](s, j))"))
                        nil nil))
                      nil)
                     ("6" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((singleton? const-decl "bool" sets nil)
    (strict_subset? const-decl "bool" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below_is_finite formula-decl nil seq_filter_props nil)
    (strict_subset_is_strict_order name-judgement
     "(strict_order?[set[T]])" sets_lemmas nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (/= const-decl "boolean" notequal nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (k!1 skolem-const-decl "bl[T](s)" seq_filter_props nil)
    (i!1 skolem-const-decl "bl[T](s)" seq_filter_props nil)
    (card_strict_subset formula-decl nil finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nth_filter_pos? const-decl "bool" seq_filter_props nil)
    (s skolem-const-decl "seq[T]" seq_filter_props nil)
    (pi skolem-const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (n skolem-const-decl
     "below(card({j | j < length(s) AND pi(j, nth(s, j))}))"
     seq_filter_props nil)
    (i skolem-const-decl "bl[T](s)" seq_filter_props nil)
    (< const-decl "bool" reals nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (bl type-eq-decl nil seq_defs nil)
    (nth const-decl "[s: seq, bl(s) -> T]" seq_defs nil)
    (below type-eq-decl nil naturalnumbers nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (nth_filter_pos_existence formula-decl nil seq_filter_props nil))
   nil)
  (nth_filter_pos_is_singleton-1 nil 3581263133
   ("" (skeep)
    (("" (split 1)
      (("1" (skeep)
        (("1" (grind)
          (("1" (typepred! "x::nat" :implicit? t)
            (("1" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (expand singleton?)
        (("2" (use nth_filter_pos_existence)
          (("2" (skeep)
            (("2" (inst + i)
              (("2" (skeep)
                (("2" (typepred "y::nat")
                  (("2" (expand nth_filter_pos?)
                    (("2"
                      (case "FORALL (i, ii: bl(s)): pi(i, nth(s, i)) AND card( { j: below(i) | pi(j, nth(s, j)) }) = n AND pi(ii, nth(s, ii)) AND card( { j: below(ii) | pi(j, nth(s, j)) }) = n IMPLIES i < ii")
                      (("1" (copy -1)
                        (("1" (inst - i y)
                          (("1" (inst - y i) (("1" (grind) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide-all-but 1)
                        (("2" (skeep) (("2" (postpone) nil nil)) nil))
                        nil)
                       ("3" (skeep)
                        (("3" (expand is_finite)
                          (("3"
                            (inst + ii
                             "LAMBDA (j: below(ii) | pi(j, nth[T](s, j))): j")
                            (("3" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("4" (skeep)
                        (("4" (expand is_finite)
                          (("4"
                            (inst + i!1
                             "LAMBDA (j: below(i!1) | pi(j, nth[T](s, j))): j")
                            (("4" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil nil))
 (nth_filter_is_singleton_TCC1 0
  (nth_filter_is_singleton_TCC1-1 nil 3581263133
   ("" (skeep)
    ((""
      (use below_is_finite
           ("n" "length[T](s)" "p"
            "LAMBDA (j: below(length[T](s))): p(nth[T](s, j))"))
      nil nil))
    nil)
   ((below_is_finite formula-decl nil seq_filter_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (bl type-eq-decl nil seq_defs nil)
    (nth const-decl "[s: seq, bl(s) -> T]" seq_defs nil))
   nil))
 (nth_filter_is_singleton 0
  (nth_filter_is_singleton-1 nil 3581263133
   ("" (skeep)
    (("" (rewrite nth_filter_as_nth_filter_pos)
      (("" (use nth_filter_pos_is_singleton) (("" (grind) nil nil))
        nil))
      nil))
    nil)
   ((nth_filter_as_nth_filter_pos formula-decl nil seq_filter_props
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (PRED type-eq-decl nil defined_types nil)
    (bl type-eq-decl nil seq_defs nil)
    (nth const-decl "[s: seq, bl(s) -> T]" seq_defs nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (C1 const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (n skolem-const-decl
     "below(card({j | j < length(s) AND p(nth(s, j))}))"
     seq_filter_props nil)
    (p skolem-const-decl "PRED[T]" seq_filter_props nil)
    (s skolem-const-decl "seq[T]" seq_filter_props nil)
    (nth_filter_pos_is_singleton judgement-tcc nil seq_filter_props
     nil))
   nil))
 (filter_pos_as_nth_filter_pos 0
  (filter_pos_as_nth_filter_pos-1 nil 3581693034
   ("" (skeep)
    (("" (prop)
      (("1" (expand filter_pos?)
        (("1" (skeep)
          (("1" (lemma "card_injective_image[nat,nat]")
            (("1"
              (inst -
               "LAMBDA n: IF n < length(t) THEN f(n) ELSE n + length(s) ENDIF"
               "{ j | j < length(t)}")
              (("1"
                (name-replace a
                 "image[nat,nat](LAMBDA n: IF n < length(t) THEN f(n) ELSE n + length(s) ENDIF, {j | j < length(t)})")
                (("1" (name-extract b (~ + "card(%1)"))
                  (("1" (reveal -1)
                    (("1" (case "a = b")
                      (("1" (lemma "card_bij_inv[nat]")
                        (("1" (name-extract c (~ "card(%) = card(%1)"))
                          (("1" (inst - "length(t)" c)
                            (("1" (prop)
                              (("1" (grind) nil nil)
                               ("2"
                                (inst + "LAMBDA (i: bl(t)): i")
                                (("1"
                                  (hide-all-but (1 -1))
                                  (("1"
                                    (grind)
                                    (("1"
                                      (rewrite -2 :dir rl)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (rewrite -1 :dir rl)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (rewrite -1 :dir rl)
                        (("2" (rewrite -1 :dir rl)
                          (("2" (expand image)
                            (("2" (decompose-equality 1)
                              (("2"
                                (iff)
                                (("2"
                                  (prop)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (skeep)
                                    (("2"
                                      (inst - x!1)
                                      (("2"
                                        (prop)
                                        (("2"
                                          (inst + x)
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (inst - x!1)
                                    (("3"
                                      (prop)
                                      (("3"
                                        (skeep)
                                        (("3"
                                          (inst + j)
                                          (("3" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand is_finite)
                (("2"
                  (inst + "length(t)" "LAMBDA (j | j < length(t)): j")
                  (("2" (grind) nil nil)) nil))
                nil)
               ("3" (expand injective?)
                (("3" (skeep)
                  (("3" (lift-if)
                    (("3" (lift-if)
                      (("3" (prop)
                        (("1" (expand preserves)
                          (("1" (copy -4)
                            (("1" (inst - x1 x2)
                              (("1"
                                (inst - x2 x1)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil) ("3" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep)
        (("2" (expand filter_pos?)
          (("2" (skeep)
            (("2" (inst + "f(n)")
              (("2" (inst -3 n)
                (("2" (split)
                  (("1" (propax) nil nil)
                   ("2" (expand nth_filter_pos?)
                    (("2" (inst -2 "f(n)")
                      (("2" (prop)
                        (("1" (inst + n) nil nil)
                         ("2" (lemma "card_injective_image[nat,nat]")
                          (("2"
                            (inst -
                             "LAMBDA n: IF n < length(t) THEN f(n) ELSE n + length(s) ENDIF"
                             "{ j | j < n }")
                            (("1"
                              (case "image[nat,nat](LAMBDA n: IF n < length(t) THEN f(n) ELSE n + length(s) ENDIF, {j | j < n}) = {j | j < f(n) AND pi(j, nth(s, j))}")
                              (("1"
                                (rewrite -1)
                                (("1"
                                  (rewrite -1)
                                  (("1"
                                    (use "card_bij_inv[nat]")
                                    (("1"
                                      (prop)
                                      (("1"
                                        (inst
                                         +
                                         "LAMBDA (j | j < n): j")
                                        (("1"
                                          (hide-all-but 1)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (expand is_finite)
                                      (("2"
                                        (inst
                                         +
                                         n
                                         "LAMBDA (j | j < n): j")
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (expand image)
                                (("2"
                                  (decompose-equality 1)
                                  (("1"
                                    (iff)
                                    (("1"
                                      (prop)
                                      (("1"
                                        (skeep)
                                        (("1" (grind) nil nil))
                                        nil)
                                       ("2"
                                        (reveal -3)
                                        (("2" (grind) nil nil))
                                        nil)
                                       ("3"
                                        (reveal -3)
                                        (("3" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil)
                               ("3" (grind) nil nil))
                              nil)
                             ("2" (expand is_finite)
                              (("2"
                                (inst + n "LAMBDA (j | j < n): j")
                                (("2" (grind) nil nil))
                                nil))
                              nil)
                             ("3" (expand injective?)
                              (("3"
                                (skeep)
                                (("3"
                                  (lift-if)
                                  (("3"
                                    (prop)
                                    (("1"
                                      (lift-if)
                                      (("1"
                                        (prop)
                                        (("1"
                                          (expand preserves)
                                          (("1"
                                            (copy -6)
                                            (("1"
                                              (inst - x1 x2)
                                              (("1"
                                                (inst - x2 x1)
                                                (("1" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (inst + n) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (expand filter_pos?)
        (("3"
          (inst +
           "LAMBDA (n: bl(t)): choose(nth_filter_pos?(s, pi, n))")
          (("1" (split)
            (("1" (expand preserves)
              (("1" (skeep)
                (("1" (all-typepreds)
                  (("1" (hide -1 -2 -3 -4 -5 -7 -8)
                    (("1" (rewrite nth_filter_pos?)
                      (("1" (rewrite nth_filter_pos?)
                        (("1" (flatten)
                          (("1" (name-extract a (~ "choose(%)"))
                            (("1" (name-extract b (~ + "choose(%)"))
                              (("1"
                                (case
                                 "subset?({j | j < b AND pi(j, nth(s, j))} , {j | j < a AND pi(j, nth(s, j))} )")
                                (("1"
                                  (use "card_subset[nat]")
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (use
                                     below_is_finite
                                     (n
                                      a
                                      p
                                      "LAMBDA (j: below(a)): pi(j, nth(s, j))"))
                                    (("2" (grind) nil nil))
                                    nil)
                                   ("3" (grind) nil nil)
                                   ("4"
                                    (use
                                     below_is_finite
                                     (n
                                      b
                                      p
                                      "LAMBDA (j: below(b)): pi(j, nth(s, j))"))
                                    (("4" (grind) nil nil))
                                    nil)
                                   ("5" (grind) nil nil))
                                  nil)
                                 ("2"
                                  (expand subset?)
                                  (("2"
                                    (skeep)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("3" (grind) nil nil)
                                 ("4" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skeep)
              (("2" (prop)
                (("1"
                  (inst + "card({ j | j < i AND pi(j, nth(s, j))})")
                  (("1" (invoke (typepred "%1") (~ "choose(%)"))
                    (("1" (expand nth_filter_pos? -2 1)
                      (("1" (flatten)
                        (("1" (name-extract a (~ + "choose(%)"))
                          (("1" (case "a < i")
                            (("1" (lemma "card_strict_subset[nat]")
                              (("1"
                                (name-extract
                                 c1
                                 (~ "card(%1) = card(%)"))
                                (("1"
                                  (name-extract
                                   c2
                                   (~ "card(%) = card(%1)"))
                                  (("1"
                                    (inst -3 c1 c2)
                                    (("1"
                                      (split -3)
                                      (("1" (grind) nil nil)
                                       ("2"
                                        (expand strict_subset?)
                                        (("2"
                                          (split)
                                          (("1"
                                            (expand subset?)
                                            (("1"
                                              (skeep)
                                              (("1"
                                                (expand member)
                                                (("1"
                                                  (rewrite -2 :dir rl)
                                                  (("1"
                                                    (rewrite
                                                     -2
                                                     :dir
                                                     rl)
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (prop)
                                            (("2"
                                              (rewrite -2 :dir rl)
                                              (("2"
                                                (rewrite -2 :dir rl)
                                                (("2"
                                                  (decompose-equality
                                                   -1)
                                                  (("2"
                                                    (inst - a)
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil)
                             ("2" (lemma "card_strict_subset[nat]")
                              (("2"
                                (name-extract
                                 c1
                                 (~ "card(%1) = card(%)"))
                                (("1"
                                  (name-extract
                                   c2
                                   (~ "card(%) = card(%1)"))
                                  (("1"
                                    (inst - c2 c1)
                                    (("1"
                                      (split -3)
                                      (("1" (grind) nil nil)
                                       ("2"
                                        (expand strict_subset?)
                                        (("2"
                                          (split 1)
                                          (("1"
                                            (rewrite -1 :dir rl)
                                            (("1"
                                              (rewrite -1 :dir rl)
                                              (("1" (grind) nil nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (prop)
                                            (("2"
                                              (decompose-equality -1)
                                              (("2"
                                                (rewrite -2 :dir rl)
                                                (("2"
                                                  (rewrite -2 :dir rl)
                                                  (("2"
                                                    (inst - i)
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2"
                            (use below_is_finite
                                 ("n"
                                  "i"
                                  "p"
                                  "LAMBDA (j: below(i)): pi(j, nth[T](s, j))"))
                            nil nil)
                           ("3" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2"
                      (use below_is_finite
                           ("n" "i" "p"
                            "LAMBDA (j: below(i)): pi(j, nth[T](s, j))"))
                      nil nil)
                     ("3" (grind) nil nil))
                    nil)
                   ("2" (typepred i)
                    (("2" (rewrite -3)
                      (("2"
                        (name-extract c1 (~ + "card[%](%1) < card(%)"))
                        (("1"
                          (name-extract c2
                           (~ + "card[%](%) < card(%1)"))
                          (("1" (lemma "card_strict_subset[nat]")
                            (("1" (inst - c1 c2)
                              (("1"
                                (prop)
                                (("1"
                                  (rewrite -1 :dir rl)
                                  (("1"
                                    (rewrite -1 :dir rl)
                                    (("1"
                                      (expand strict_subset?)
                                      (("1"
                                        (split 1)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (prop)
                                          (("2"
                                            (decompose-equality -1)
                                            (("2"
                                              (inst - i)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil)
                   ("3"
                    (use below_is_finite
                         ("n" "i" "p"
                          "LAMBDA (j: below(i)): pi(j, nth[T](s, j))"))
                    nil nil)
                   ("4" (grind) nil nil))
                  nil)
                 ("2" (skeep)
                  (("2" (invoke (typepred "%1") (~ "choose(%)"))
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("3" (skeep)
              (("3" (invoke (typepred "%1") (~ "choose(%)"))
                (("3" (rewrite nth_filter_pos?)
                  (("3" (flatten)
                    (("3" (inst - j)
                      (("3" (skeep)
                        (("3" (use nth_filter_pos_is_singleton)
                          (("1" (lemma "singleton_unicity[bl(s)]")
                            (("1" (name-extract a (~ "choose(%)"))
                              (("1"
                                (inst
                                 -
                                 "nth_filter_pos?(s, pi, j)"
                                 i
                                 a)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (typepred j)
                            (("2" (lemma "card_strict_subset[nat]")
                              (("2"
                                (name-extract
                                 c1
                                 (~ + "% < card[%](%1)"))
                                (("2"
                                  (name-extract c2 (~ -6 "card(%1)"))
                                  (("1"
                                    (inst - c2 c1)
                                    (("1"
                                      (split -3)
                                      (("1" (grind) nil nil)
                                       ("2"
                                        (expand strict_subset?)
                                        (("2"
                                          (split 1)
                                          (("1"
                                            (rewrite -1 :dir rl)
                                            (("1"
                                              (rewrite -1 :dir rl)
                                              (("1" (grind) nil nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (prop)
                                            (("2"
                                              (decompose-equality -1)
                                              (("2"
                                                (inst
                                                 -
                                                 "choose(nth_filter_pos?(s, pi, j))")
                                                (("2"
                                                  (rewrite -2 :dir rl)
                                                  (("2"
                                                    (rewrite
                                                     -2
                                                     :dir
                                                     rl)
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (skeep)
            (("2" (inst - n)
              (("2" (expand nonempty?)
                (("2" (expand empty?)
                  (("2" (skeep)
                    (("2" (inst - i) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (f skolem-const-decl "[bl[T](t) -> bl[T](s)]" seq_filter_props nil)
    (s skolem-const-decl "seq[T]" seq_filter_props nil)
    (bl type-eq-decl nil seq_defs nil)
    (t skolem-const-decl "seq[T]" seq_filter_props nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (< const-decl "bool" reals nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (nth const-decl "[s: seq, bl(s) -> T]" seq_defs nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (preserves const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (y!1 skolem-const-decl "(c)" seq_filter_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (surjective? const-decl "bool" functions nil)
    (bijective? const-decl "bool" functions nil)
    (below type-eq-decl nil nat_types nil)
    (c skolem-const-decl "[nat -> bool]" seq_filter_props nil)
    (card_bij_inv formula-decl nil finite_sets nil)
    (x!1 skolem-const-decl "nat" seq_filter_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (image const-decl "set[R]" function_image nil)
    (x2 skolem-const-decl "nat" seq_filter_props nil)
    (card_injective_image formula-decl nil function_image_aux nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (x2 skolem-const-decl "nat" seq_filter_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (j!2 skolem-const-decl "bl[T](t)" seq_filter_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (n skolem-const-decl "bl[T](t)" seq_filter_props nil)
    (f skolem-const-decl "[bl[T](t) -> bl[T](s)]" seq_filter_props nil)
    (nth_filter_pos? const-decl "bool" seq_filter_props nil)
    (pi skolem-const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (nth_filter_pos_is_singleton judgement-tcc nil seq_filter_props
     nil)
    (j skolem-const-decl "bl[T](t)" seq_filter_props nil)
    (singleton? const-decl "bool" sets nil)
    (singleton_unicity formula-decl nil seq_filter_props nil)
    (i skolem-const-decl "bl[T](s)" seq_filter_props nil)
    (card_strict_subset formula-decl nil finite_sets nil)
    (a skolem-const-decl
     "(nth_filter_pos?(s, pi, card({j | j < i AND pi(j, nth(s, j))})))"
     seq_filter_props nil)
    (x skolem-const-decl "nat" seq_filter_props nil)
    (strict_subset? const-decl "bool" sets nil)
    (/= const-decl "boolean" notequal nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (card_subset formula-decl nil finite_sets nil)
    (a skolem-const-decl "(nth_filter_pos?(s, pi, x1))"
     seq_filter_props nil)
    (x1 skolem-const-decl "bl[T](t)" seq_filter_props nil)
    (b skolem-const-decl "(nth_filter_pos?(s, pi, x2))"
     seq_filter_props nil)
    (x2 skolem-const-decl "bl[T](t)" seq_filter_props nil)
    (member const-decl "bool" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (below_is_finite formula-decl nil seq_filter_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (subset? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil))
   shostak))
 (filter_as_nth_filter 0
  (filter_as_nth_filter-1 nil 3581696784
   ("" (skeep)
    (("" (rewrite* filter?_as_filter_pos?)
      (("" (use filter_pos_as_nth_filter_pos)
        (("" (grind :rewrites nth_filter_as_nth_filter_pos) nil nil))
        nil))
      nil))
    nil)
   ((seq nonempty-type-decl nil seq_defs nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil seq_filter_props nil)
    (filter?_as_filter_pos? formula-decl nil seq_filter_props nil)
    (restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (nth_filter_pos? const-decl "bool" seq_filter_props nil)
    (nth_filter_as_nth_filter_pos formula-decl nil seq_filter_props
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (C1 const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (filter_pos_as_nth_filter_pos formula-decl nil seq_filter_props
     nil))
   shostak))
 (filter_pos_existence 0
  (filter_pos_existence-1 nil 3581806312
   ("" (skeep)
    (("" (name lt "card({ j | j < length(s) AND pi(j, nth(s, j)) })")
      (("1"
        (inst +
         "mk_seq(lt, LAMBDA (j: below(lt)): nth(s, choose(nth_filter_pos?(s, pi, j))))")
        (("1" (use filter_pos_as_nth_filter_pos)
          (("1" (prop)
            (("1" (rewrite length_mk_seq) (("1" (grind) nil nil)) nil)
             ("2" (skeep)
              (("2" (use nth_filter_pos_existence)
                (("1" (skeep)
                  (("1" (inst + i)
                    (("1" (rewrite nth_mk_seq)
                      (("1" (split 1)
                        (("1" (use nth_filter_pos_is_singleton)
                          (("1" (lemma "singleton_unicity[bl(s)]")
                            (("1"
                              (invoke
                               (inst
                                -
                                "nth_filter_pos?(s, pi, n)"
                                "i"
                                "%1")
                               (~ "choose(%)"))
                              (("1" (grind) nil nil)) nil))
                            nil)
                           ("2" (typepred n)
                            (("2" (rewrite length_mk_seq)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil))
                        nil)
                       ("2" (skeep)
                        (("2" (expand nonempty?)
                          (("2" (expand empty?)
                            (("2" (use nth_filter_pos_existence)
                              (("2"
                                (skeep)
                                (("2"
                                  (inst - i!1)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (skeep)
            (("2" (expand nonempty?)
              (("2" (expand empty?)
                (("2" (use nth_filter_pos_existence)
                  (("1" (skeep)
                    (("1" (inst - i) (("1" (grind) nil nil)) nil)) nil)
                   ("2" (typepred j) (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (expand nonempty?)
            (("2" (expand empty?)
              (("2" (use nth_filter_pos_existence)
                (("1" (skeep)
                  (("1" (inst - i) (("1" (grind) nil nil)) nil)) nil)
                 ("2" (typepred j) (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2"
        (use below_is_finite
             (n "length(s)" p "LAMBDA (j: bl(s)): pi(j, nth(s, j))"))
        nil nil))
      nil))
    nil)
   ((nth const-decl "[s: seq, bl(s) -> T]" seq_defs nil)
    (bl type-eq-decl nil seq_defs nil)
    (PRED type-eq-decl nil defined_types nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (j skolem-const-decl "below(lt)" seq_filter_props nil)
    (filter_pos_as_nth_filter_pos formula-decl nil seq_filter_props
     nil)
    (nth_mk_seq formula-decl nil seq_defs nil)
    (nth_filter_pos_is_singleton judgement-tcc nil seq_filter_props
     nil)
    (singleton? const-decl "bool" sets nil)
    (singleton_unicity formula-decl nil seq_filter_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (preserves const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (n skolem-const-decl "bl
    [T](mk_seq(lt,
               LAMBDA (j: below(lt)):
                 nth(s, choose(nth_filter_pos?(s, pi, j)))))"
     seq_filter_props nil)
    (nth_filter_pos_existence formula-decl nil seq_filter_props nil)
    (length_mk_seq formula-decl nil seq_defs nil)
    (j skolem-const-decl "below(lt)" seq_filter_props nil)
    (choose const-decl "(p)" sets nil)
    (mk_seq const-decl
     "{s | length(s) = length AND (FORALL (i: below(length)): nth(s, i) = f(i))}"
     seq_defs nil)
    (s skolem-const-decl "seq[T]" seq_filter_props nil)
    (pi skolem-const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (lt skolem-const-decl
        "{n: nat | n = Card[nat]({j | j < length(s) AND pi(j, nth(s, j))})}"
        seq_filter_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nonempty? const-decl "bool" sets nil)
    (nth_filter_pos? const-decl "bool" seq_filter_props nil)
    (below_is_finite formula-decl nil seq_filter_props nil))
   shostak))
 (filter_existence 0
  (filter_existence-1 nil 3581814543
   (""
    (grind-with-lemmas :rewrites filter?_as_filter_pos? :lemmas
     filter_pos_existence)
    nil nil)
   ((filter_pos_existence formula-decl nil seq_filter_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (C1 const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (filter?_as_filter_pos? formula-decl nil seq_filter_props nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (preserves const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil))
   shostak))
 (filter_pos_is_singleton 0
  (filter_pos_is_singleton-1 nil 3581712545
   ("" (skeep)
    (("" (expand singleton?)
      (("" (use filter_pos_existence)
        (("" (skeep)
          (("" (inst + t)
            (("" (skolem 1 "u")
              (("" (typepred u)
                (("" (use filter_pos_as_nth_filter_pos)
                  (("" (use-with "filter_pos_as_nth_filter_pos" -3)
                    (("" (rewrite nth_equal)
                      (("" (prop)
                        (("1" (grind) nil nil)
                         ("2" (skeep)
                          (("2" (inst - i)
                            (("2" (inst - i)
                              (("2"
                                (skeep)
                                (("2"
                                  (skeep)
                                  (("2"
                                    (use nth_filter_pos_is_singleton)
                                    (("1"
                                      (use
                                       "singleton_unicity[bl(s)]"
                                       (s
                                        "nth_filter_pos?(s, pi, i)"
                                        a
                                        i_1
                                        b
                                        i_1!1))
                                      (("1" (grind) nil nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((singleton? const-decl "bool" sets nil)
    (filter_pos_as_nth_filter_pos formula-decl nil seq_filter_props
     nil)
    (nth_equal formula-decl nil seq_defs nil)
    (nth_filter_pos? const-decl "bool" seq_filter_props nil)
    (singleton_unicity formula-decl nil seq_filter_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (i skolem-const-decl "bl[T](t)" seq_filter_props nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nth const-decl "[s: seq, bl(s) -> T]" seq_defs nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth_filter_pos_is_singleton judgement-tcc nil seq_filter_props
     nil)
    (< const-decl "bool" reals nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (bl type-eq-decl nil seq_defs nil)
    (preserves const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (s skolem-const-decl "seq[T]" seq_filter_props nil)
    (pi skolem-const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (t skolem-const-decl "seq[T]" seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (filter_pos_existence formula-decl nil seq_filter_props nil))
   nil))
 (filter_is_singleton 0
  (filter_is_singleton-1 nil 3581712545
   ("" (skeep)
    (("" (expand singleton?)
      (("" (use filter_pos_is_singleton)
        (("" (inst - "C1(p)")
          (("" (expand singleton?)
            (("" (skolem -1 "s1")
              (("" (inst + s1)
                (("1" (skolem 1 "s2")
                  (("1" (inst - s2)
                    (("1" (typepred s2)
                      (("1" (rewrite* filter?_as_filter_pos?) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (typepred s1)
                  (("2" (rewrite* filter?_as_filter_pos?) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((singleton? const-decl "bool" sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (C1 const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (filter?_as_filter_pos? formula-decl nil seq_filter_props nil)
    (s2 skolem-const-decl "(filter?(s, p))" seq_filter_props nil)
    (filter_pos_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (filter? const-decl "bool" seq_filter_props nil)
    (s skolem-const-decl "seq[T]" seq_filter_props nil)
    (p skolem-const-decl "PRED[T]" seq_filter_props nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (s1 skolem-const-decl "(filter_pos?(s, C1(p)))" seq_filter_props
     nil)
    (T formal-type-decl nil seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (filter_pos_is_singleton judgement-tcc nil seq_filter_props nil))
   nil))
 (filter_pos_TCC1 0
  (filter_pos_TCC1-1 nil 3581856144
   (""
    (inst +
     "LAMBDA (d: [seq, PRED[[nat, T]]]): choose(filter_pos?(d))")
    (("" (skeep)
      (("" (invoke (typepred "%1") (~ + "choose[%](%)"))
        (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (choose const-decl "(p)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (filter_pos_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil))
   nil))
 (filter_TCC1 0
  (filter_TCC1-1 nil 3581856144
   ("" (inst + "LAMBDA (d: [seq, PRED[T]]): choose(filter?(d))")
    (("" (skeep)
      (("" (invoke (typepred "%1") (~ + "choose[%](%)"))
        (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (choose const-decl "(p)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (filter? const-decl "bool" seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (filter_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil))
   nil))
 (length_filter_pos 0
  (length_filter_pos-1 nil 3581857627
   ("" (skeep)
    (("" (use filter_pos_as_nth_filter_pos) (("" (grind) nil nil))
      nil))
    nil)
   ((filter_pos_as_nth_filter_pos formula-decl nil seq_filter_props
     nil)
    (filter_pos const-decl "(filter_pos?(s, pi))" seq_filter_props nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (PRED type-eq-decl nil defined_types nil)
    (T formal-type-decl nil seq_filter_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (filter_pos_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil))
   shostak))
 (nth_filter_pos 0
  (nth_filter_pos-1 nil 3581856669
   ("" (skeep)
    (("" (use filter_pos_as_nth_filter_pos (s s t "filter_pos(s, pi)"))
      (("" (grind) nil nil)) nil))
    nil)
   ((filter_pos_as_nth_filter_pos formula-decl nil seq_filter_props
     nil)
    (T formal-type-decl nil seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (filter_pos const-decl "(filter_pos?(s, pi))" seq_filter_props nil)
    (filter_pos_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil)
    (nth_filter_pos? const-decl "bool" seq_filter_props nil)
    (bl type-eq-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (< const-decl "bool" reals nil))
   shostak))
 (length_filter 0
  (length_filter-1 nil 3581338987
   ("" (skeep)
    (("" (use filter_as_nth_filter) (("" (grind) nil nil)) nil)) nil)
   ((filter_as_nth_filter formula-decl nil seq_filter_props nil)
    (filter const-decl "(filter?(s, p))" seq_filter_props nil)
    (filter? const-decl "bool" seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil seq_filter_props nil)
    (filter_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil))
   shostak))
 (nth_filter 0
  (nth_filter-1 nil 3581339269
   ("" (skeep)
    (("" (use filter_as_nth_filter (s s t "filter(s, p)"))
      (("" (grind) nil nil)) nil))
    nil)
   ((filter_as_nth_filter formula-decl nil seq_filter_props nil)
    (T formal-type-decl nil seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (filter? const-decl "bool" seq_filter_props nil)
    (filter const-decl "(filter?(s, p))" seq_filter_props nil)
    (filter_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil)
    (nth_filter? const-decl "bool" seq_filter_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (bl type-eq-decl nil seq_defs nil))
   shostak))
 (filter_as_filter_pos 0
  (filter_as_filter_pos-1 nil 3581856821
   ("" (skeep)
    (("" (all-typepreds)
      (("" (hide -2 -3 -5 -6)
        (("" (rewrite filter?_as_filter_pos?)
          ((""
            (use "singleton_unicity[seq]"
                 (s "filter_pos?(s, C1(p))" a "filter(s, p)" b
                  "filter_pos(s, C1(p))"))
            (("" (prop) (("" (expand C1) (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((filter_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (filter_pos_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (set type-eq-decl nil sets nil)
    (singleton? const-decl "bool" sets nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (filter_pos const-decl "(filter_pos?(s, pi))" seq_filter_props nil)
    (filter? const-decl "bool" seq_filter_props nil)
    (filter const-decl "(filter?(s, p))" seq_filter_props nil)
    (filter?_as_filter_pos? formula-decl nil seq_filter_props nil)
    (singleton_unicity formula-decl nil seq_filter_props nil)
    (C1 const-decl "PRED[[nat, T]]" seq_filter_props nil))
   shostak))
 (partition_as_partition_pos 0
  (partition_as_partition_pos-1 nil 3581339310
   ("" (skeep)
    (("" (expand (partition partition_pos))
      (("" (rewrite* filter_as_filter_pos) nil nil)) nil))
    nil)
   ((partition_pos const-decl "[seq, seq]" seq_filter_props nil)
    (partition const-decl "[seq, seq]" seq_filter_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil seq_filter_props nil)
    (filter_as_filter_pos formula-decl nil seq_filter_props nil))
   shostak))
 (filter_pos_as_filter_pos 0
  (filter_pos_as_filter_pos-1 nil 3581857910
   ("" (skeep)
    (("" (prop)
      (("1" (all-typepreds) (("1" (grind) nil nil)) nil)
       ("2" (typepred "filter_pos(s, pi)")
        (("2"
          (use "singleton_unicity[seq]"
               (s "filter_pos?(s, pi)" a "t" b "filter_pos(s, pi)"))
          (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil)
    (bl type-eq-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (< const-decl "bool" reals nil)
    (filter_pos const-decl "(filter_pos?(s, pi))" seq_filter_props nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (singleton? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (filter_pos_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (singleton_unicity formula-decl nil seq_filter_props nil))
   shostak))
 (filter_as_filter 0
  (filter_as_filter-1 nil 3581858011
   ("" (skeep)
    (("" (rewrite filter_as_filter_pos)
      (("" (rewrite filter?_as_filter_pos?)
        (("" (use filter_pos_as_filter_pos)
          (("" (expand C1) (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((filter_as_filter_pos formula-decl nil seq_filter_props nil)
    (T formal-type-decl nil seq_filter_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (filter_pos_as_filter_pos formula-decl nil seq_filter_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (C1 const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (filter_pos_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (filter?_as_filter_pos? formula-decl nil seq_filter_props nil))
   shostak))
 (nth_filter_pos_as_nth_filter_pos_TCC1 0
  (nth_filter_pos_as_nth_filter_pos_TCC1-1 nil 3581430689
   ("" (skeep)
    (("" (expand nth_filter_pos?)
      (("" (flatten)
        (("" (rewrite -2 :dir rl)
          (("" (rewrite length_filter_pos)
            (("" (use card_strict_subset[nat])
              (("1" (prop)
                (("1" (expand strict_subset?)
                  (("1" (split)
                    (("1" (grind) nil nil)
                     ("2" (prop)
                      (("2" (decompose-equality -1)
                        (("2" (inst - i) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2"
                (typepred!
                 "{j | j < length[T](s) AND pi(j, nth[T](s, j))}"
                 :implicit? t)
                (("2" (propax) nil nil)) nil)
               ("3"
                (typepred! "{j | j < i AND pi(j, nth[T](s, j))}"
                 :implicit? t)
                (("3" (propax) nil nil)) nil)
               ("4" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nth_filter_pos? const-decl "bool" seq_filter_props nil)
    (card_strict_subset formula-decl nil finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pi skolem-const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (nth const-decl "[s: seq, bl(s) -> T]" seq_defs nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (s skolem-const-decl "seq[T]" seq_filter_props nil)
    (bl type-eq-decl nil seq_defs nil)
    (i skolem-const-decl "bl[T](s)" seq_filter_props nil)
    (strict_subset? const-decl "bool" sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (PRED type-eq-decl nil defined_types nil)
    (T formal-type-decl nil seq_filter_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (length_filter_pos formula-decl nil seq_filter_props nil))
   nil))
 (nth_filter_pos_as_nth_filter_pos 0
  (nth_filter_pos_as_nth_filter_pos-1 nil 3581430690
   ("" (skeep)
    (("" (use nth_filter_pos)
      (("" (skeep)
        (("" (use nth_filter_pos_is_singleton)
          (("1" (expand singleton?)
            (("1" (skeep)
              (("1" (copy -1)
                (("1" (inst - i!1)
                  (("1" (inst - i) (("1" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil)
           ("2" (typepred! n :implicit? t)
            (("2" (grind :rewrites length_filter_pos) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((nth_filter_pos formula-decl nil seq_filter_props nil)
    (bl type-eq-decl nil seq_defs nil)
    (filter_pos const-decl "(filter_pos?(s, pi))" seq_filter_props nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (< const-decl "bool" reals nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (PRED type-eq-decl nil defined_types nil)
    (T formal-type-decl nil seq_filter_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nth_filter_pos_is_singleton judgement-tcc nil seq_filter_props
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (n skolem-const-decl "nat" seq_filter_props nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Card const-decl "nat" finite_sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (s skolem-const-decl "seq[T]" seq_filter_props nil)
    (pi skolem-const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (nth const-decl "[s: seq, bl(s) -> T]" seq_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth_filter_pos? const-decl "bool" seq_filter_props nil)
    (i!1 skolem-const-decl "bl[T](s)" seq_filter_props nil)
    (i skolem-const-decl "bl[T](s)" seq_filter_props nil)
    (singleton? const-decl "bool" sets nil)
    (length_filter_pos formula-decl nil seq_filter_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   shostak))
 (nth_filter_as_nth_filter_TCC1 0
  (nth_filter_as_nth_filter_TCC1-1 nil 3581430689
   ("" (use nth_filter_pos_as_nth_filter_pos_TCC1)
    ((""
      (lazy-grind :rewrites
       (nth_filter_as_nth_filter_pos filter_as_filter_pos C1))
      nil nil))
    nil)
   ((filter_as_filter_pos formula-decl nil seq_filter_props nil)
    (C1 const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (nth_filter_as_nth_filter_pos formula-decl nil seq_filter_props
     nil)
    (nth_filter_pos? const-decl "bool" seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bl type-eq-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nth_filter_pos_as_nth_filter_pos_TCC1 subtype-tcc nil
     seq_filter_props nil))
   nil))
 (nth_filter_as_nth_filter 0
  (nth_filter_as_nth_filter-1 nil 3581432915
   (""
    (grind-with-lemmas :rewrites
     (nth_filter_as_nth_filter_pos filter_as_filter_pos
      nth_filter_pos_as_nth_filter_pos C1)
     :lemmas nth_filter_pos_as_nth_filter_pos)
    nil nil)
   ((nth_filter_pos_as_nth_filter_pos formula-decl nil seq_filter_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nth_filter_as_nth_filter_pos formula-decl nil seq_filter_props
     nil)
    (C1 const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (nth_filter_pos? const-decl "bool" seq_filter_props nil)
    (filter_as_filter_pos formula-decl nil seq_filter_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (T formal-type-decl nil seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (bl type-eq-decl nil seq_defs nil))
   shostak))
 (filter_pos_below_length 0
  (filter_pos_below_length-1 nil 3581900088
   ("" (skeep)
    (("" (rewrite nth_equal)
      (("" (split)
        (("1" (rewrite* length_filter_pos)
          (("1" (invoke (case "%1 = %2") (~ "card(%1) = card(%2)"))
            (("1" (grind) nil nil)
             ("2" (decompose-equality 1) (("2" (grind) nil nil)) nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (use nth_filter_pos)
            (("2" (use nth_filter_pos (pi qi))
              (("2" (skeep)
                (("2" (skeep)
                  (("2" (expand nth_filter_pos?)
                    (("2" (case "i_1 = i_1!1")
                      (("1" (grind) nil nil)
                       ("2" (case "i_1 < i_1!1")
                        (("1"
                          (invoke (case "strict_subset?(%1, %2)")
                           (~ -3 "card(%1)") (~ -5 "card(%1)"))
                          (("1" (use "card_strict_subset[nat]")
                            (("1" (grind) nil nil)
                             ("2"
                              (invoke (typepred! "%1" :implicit? t)
                               (~ "is_finite[%](%1)"))
                              nil nil)
                             ("3" (grind) nil nil)
                             ("4"
                              (invoke (typepred! "%1" :implicit? t)
                               (~ "is_finite[%](%1)"))
                              nil nil)
                             ("5" (grind) nil nil))
                            nil)
                           ("2" (expand strict_subset?)
                            (("2" (split)
                              (("1"
                                (expand subset?)
                                (("1"
                                  (skeep)
                                  (("1"
                                    (inst - x)
                                    (("1" (grind) nil nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (prop)
                                (("2"
                                  (decompose-equality -1)
                                  (("2"
                                    (inst - i_1)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (grind) nil nil) ("4" (grind) nil nil))
                          nil)
                         ("2"
                          (invoke (case "strict_subset?(%2, %1)")
                           (~ -2 "card(%1)") (~ -4 "card(%1)"))
                          (("1" (use "card_strict_subset[nat]")
                            (("1" (grind) nil nil)
                             ("2"
                              (invoke (typepred! "%1" :implicit? t)
                               (~ "is_finite[%](%1)"))
                              nil nil)
                             ("3" (grind) nil nil)
                             ("4"
                              (invoke (typepred! "%1" :implicit? t)
                               (~ "is_finite[%](%1)"))
                              nil nil)
                             ("5" (grind) nil nil))
                            nil)
                           ("2" (expand strict_subset?)
                            (("2" (split)
                              (("1"
                                (expand subset?)
                                (("1"
                                  (skeep)
                                  (("1"
                                    (inst - x)
                                    (("1" (grind) nil nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (prop)
                                (("2"
                                  (decompose-equality -1)
                                  (("2"
                                    (inst - i_1!1)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (grind) nil nil) ("4" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nth_equal formula-decl nil seq_defs nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (filter_pos const-decl "(filter_pos?(s, pi))" seq_filter_props nil)
    (T formal-type-decl nil seq_filter_props nil)
    (x skolem-const-decl "nat" seq_filter_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (strict_subset? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (strict_subset_is_strict_order name-judgement
     "(strict_order?[set[T]])" sets_lemmas nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (/= const-decl "boolean" notequal nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (s skolem-const-decl "seq[T]" seq_filter_props nil)
    (i_1 skolem-const-decl "bl[T](s)" seq_filter_props nil)
    (is_finite const-decl "bool" finite_sets nil)
    (qi skolem-const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (i_1!1 skolem-const-decl "bl[T](s)" seq_filter_props nil)
    (pi skolem-const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (card_strict_subset formula-decl nil finite_sets nil)
    (x skolem-const-decl "nat" seq_filter_props nil)
    (nth_filter_pos? const-decl "bool" seq_filter_props nil)
    (nth_filter_pos formula-decl nil seq_filter_props nil)
    (length_filter_pos formula-decl nil seq_filter_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth const-decl "[s: seq, bl(s) -> T]" seq_defs nil)
    (bl type-eq-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   shostak))
 (filter_filter_pos 0
  (filter_filter_pos-2 "" 3581857710
   ("" (skeep)
    (("" (rewrite filter_as_filter)
      (("" (all-typepreds)
        (("" (hide -1 -3 -4 -6)
          (("" (expand filter_pos?)
            (("" (skolem -1 f1)
              (("" (skolem -2 f2)
                (("" (flatten)
                  (("" (expand filter?)
                    ((""
                      (inst +
                       "LAMBDA (j: bl(filter_pos(s, LAMBDA (n, x): pi(n, x) AND p(x)))):
              choose({ jj: bl(filter_pos(s, pi)) | f1(jj) = f2(j) })")
                      (("1" (split)
                        (("1" (expand preserves)
                          (("1" (skeep)
                            (("1" (inst -5 x1 x2)
                              (("1"
                                (name-extract a (~ + "choose(%)"))
                                (("1"
                                  (name-extract b (~ + "choose(%)"))
                                  (("1"
                                    (inst -4 b a)
                                    (("1" (grind) nil nil))
                                    nil)
                                   ("2"
                                    (expand nonempty?)
                                    (("2"
                                      (expand empty?)
                                      (("2"
                                        (inst -8 "f2(x2)")
                                        (("2"
                                          (bddsimp -8)
                                          (("1"
                                            (inst -8 "f2(x2)")
                                            (("1"
                                              (bddsimp -8)
                                              (("1"
                                                (skeep)
                                                (("1"
                                                  (inst - j)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2" (propax) nil nil))
                                              nil))
                                            nil)
                                           ("2" (inst + x2) nil nil)
                                           ("3" (inst + x2) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (typepred!
                                   "{jj: bl[T](filter_pos(s, pi)) | f1(jj) = f2(x1)}"
                                   :implicit?
                                   t)
                                  (("2" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skeep)
                          (("2" (prop)
                            (("1"
                              (typepred "filter(filter_pos(s, pi), p)")
                              (("1"
                                (expand filter?)
                                (("1"
                                  (skolem -1 f3)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (inst -2 i)
                                      (("1"
                                        (inst -7 i)
                                        (("1"
                                          (inst -6 "f1(i)")
                                          (("1"
                                            (bddsimp -6)
                                            (("1"
                                              (inst -10 "f1(i)")
                                              (("1"
                                                (bddsimp -10)
                                                (("1"
                                                  (skeep)
                                                  (("1"
                                                    (inst + j)
                                                    (("1"
                                                      (lemma
                                                       st_incr_is_injective)
                                                      (("1"
                                                        (inst
                                                         -
                                                         "length[T](filter_pos(s, pi))"
                                                         "length(s)"
                                                         "f1")
                                                        (("1"
                                                          (invoke
                                                           (typepred
                                                            "%1")
                                                           (~
                                                            +
                                                            "choose(%)"))
                                                          (("1"
                                                            (expand
                                                             injective?)
                                                            (("1"
                                                              (invoke
                                                               (inst
                                                                -
                                                                i
                                                                "%1")
                                                               (~
                                                                +
                                                                "choose(%)"))
                                                              (("1"
                                                                (grind)
                                                                nil
                                                                nil)
                                                               ("2"
                                                                (typepred!
                                                                 "{jj: bl[T](filter_pos(s, pi)) | f1(jj) = f2(j)}"
                                                                 :implicit?
                                                                 t)
                                                                (("2"
                                                                  (propax)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (hide
                                                             -7
                                                             -14
                                                             -12)
                                                            (("2"
                                                              (typepred!
                                                               "{jj: bl[T](filter_pos(s, pi)) | f1(jj) = f2(j)}"
                                                               :implicit?
                                                               t)
                                                              (("2"
                                                                (propax)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (grind) nil nil)
                                                 ("3"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (inst + i) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (skeep)
                              (("2"
                                (inst -4 i)
                                (("2"
                                  (invoke
                                   (typepred "%1")
                                   (~ "choose(%)"))
                                  (("1"
                                    (rewrite -3)
                                    (("1"
                                      (rewrite -5)
                                      (("1"
                                        (inst -6 "f1(i)")
                                        (("1"
                                          (bddsimp -6)
                                          (("1" (propax) nil nil)
                                           ("2"
                                            (inst + j_1)
                                            (("2" (grind) nil nil))
                                            nil)
                                           ("3"
                                            (inst + j_1)
                                            (("3" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (typepred!
                                     "{jj: bl[T](filter_pos(s, pi)) | f1(jj) = f2(j_1)}"
                                     :implicit?
                                     t)
                                    (("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (skeep)
                          (("3" (hide -1 -4)
                            (("3" (inst -4 j_1)
                              (("3"
                                (rewrite -4)
                                (("3"
                                  (invoke
                                   (typepred "%1")
                                   (~ + "choose(%)"))
                                  (("1"
                                    (invoke
                                     (inst -4 "%1")
                                     (~ + "choose(%)"))
                                    (("1"
                                      (rewrite -4)
                                      (("1" (rewrite -2) nil nil))
                                      nil)
                                     ("2"
                                      (typepred!
                                       "{jj: bl[T](filter_pos(s, pi)) | f1(jj) = f2(j_1)}"
                                       :implicit?
                                       t)
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (typepred!
                                     "{jj: bl[T](filter_pos(s, pi)) | f1(jj) = f2(j_1)}"
                                     :implicit?
                                     t)
                                    (("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (skeep)
                        (("2" (expand nonempty?)
                          (("2" (expand empty?)
                            (("2" (inst -6 "f2(j)")
                              (("2"
                                (bddsimp -6)
                                (("1"
                                  (inst -6 "f2(j)")
                                  (("1"
                                    (bddsimp -6)
                                    (("1"
                                      (skeep)
                                      (("1"
                                        (inst - j_1)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil)
                                     ("2" (propax) nil nil))
                                    nil))
                                  nil)
                                 ("2" (inst + j) nil nil)
                                 ("3" (inst + j) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((filter_as_filter formula-decl nil seq_filter_props nil)
    (T formal-type-decl nil seq_filter_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (filter_pos const-decl "(filter_pos?(s, pi))" seq_filter_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (filter_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (f2 skolem-const-decl
     "[bl[T](filter_pos(s, LAMBDA (n, x): pi(n, x) AND p(x))) -> bl[T](s)]"
     seq_filter_props nil)
    (f1 skolem-const-decl "[bl[T](filter_pos(s, pi)) -> bl[T](s)]"
     seq_filter_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nonempty? const-decl "bool" sets nil)
    (bl type-eq-decl nil seq_defs nil)
    (p skolem-const-decl "PRED[T]" seq_filter_props nil)
    (pi skolem-const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (s skolem-const-decl "seq[T]" seq_filter_props nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (< const-decl "bool" reals nil) (choose const-decl "(p)" sets nil)
    (j_1 skolem-const-decl
     "bl[T](filter_pos(s, LAMBDA (n, x): pi(n, x) AND p(x)))"
     seq_filter_props nil)
    (filter const-decl "(filter?(s, p))" seq_filter_props nil)
    (st_incr_is_injective formula-decl nil seq_filter_props nil)
    (j skolem-const-decl
     "bl[T](filter_pos(s, LAMBDA (n, x): pi(n, x) AND p(x)))"
     seq_filter_props nil)
    (injective? const-decl "bool" functions nil)
    (below type-eq-decl nil naturalnumbers nil)
    (preserves const-decl "bool" functions nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (restrict const-decl "R" restrict nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (filter? const-decl "bool" seq_filter_props nil)
    (filter_pos_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (singleton? const-decl "bool" sets nil))
   shostak)
  (filter_filter_pos-1 nil 3581344011
   ("" (skeep)
    (("" (rewrite nth_equal)
      ((""
        (case "length(filter(filter_pos(s, pi), p)) = length(filter_pos(s, LAMBDA (n, x): pi(n, x) AND p(x)))")
        (("1" (split)
          (("1" (propax) nil nil)
           ("2" (skeep)
            (("2" (use nth_filter)
              (("2" (use nth_filter_pos)
                (("2" (skolem -1 i2)
                  (("2" (skolem -2 i1)
                    (("2" (use-with "nth_filter_pos" -2)
                      (("2" (skolem -1 i3)
                        (("2" (case "i2 = i3")
                          (("1" (grind) nil nil)
                           ("2" (hide 2)
                            (("2"
                              (expand (nth_filter_pos? nth_filter?))
                              (("2"
                                (case "i2 < i3")
                                (("1"
                                  (name-extract
                                   a1
                                   (~ "{ j | j < i1 AND % }"))
                                  (("1"
                                    (name-extract
                                     a2
                                     (~ "{ j | j < i2 AND % AND % }"))
                                    (("1"
                                      (name-extract
                                       a3
                                       (~ "{ j | j < i3 AND % }"))
                                      (("1"
                                        (case
                                         "strict_subset?( a2 , { j | j < length(s) AND EXISTS (i: nat): member(i, a1) AND nth(filter_pos(s, pi), i) = nth(s, j) })")
                                        (("1" (postpone) nil nil)
                                         ("2" (postpone) nil nil)
                                         ("3"
                                          (skeep)
                                          (("3"
                                            (skeep)
                                            (("3"
                                              (expand member)
                                              (("3"
                                                (expand a1)
                                                (("3"
                                                  (typepred i1)
                                                  (("3"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2" (grind) nil nil))
                                      nil)
                                     ("2" (grind) nil nil)
                                     ("3" (grind) nil nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil)
                                 ("2" (postpone) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (postpone) nil nil))
        nil))
      nil))
    nil)
   nil shostak))
 (filter_filter 0
  (filter_filter-1 nil 3581886753
   ("" (skeep)
    (("" (rewrite filter_as_filter_pos 1 (p p))
      ((""
        (rewrite filter_as_filter_pos 1 (p "LAMBDA x: p(x) AND q(x)"))
        (("" (rewrite filter_filter_pos) nil nil)) nil))
      nil))
    nil)
   ((filter_as_filter_pos formula-decl nil seq_filter_props nil)
    (T formal-type-decl nil seq_filter_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (filter_filter_pos formula-decl nil seq_filter_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil))
   shostak))
 (filter_pos_true 0
  (filter_pos_true-2 nil 3581434485
   ("" (skeep)
    (("" (rewrite filter_pos_as_filter_pos)
      (("" (expand filter_pos?)
        (("" (inst + "LAMBDA (i: bl(s)): i") (("" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((filter_pos_as_filter_pos formula-decl nil seq_filter_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (TRUE const-decl "bool" booleans nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (filter_pos_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (bl type-eq-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (< const-decl "bool" reals nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (filter_pos? const-decl "bool" seq_filter_props nil))
   nil)
  (filter_pos_true-1 nil 3581425484
   ("" (skeep)
    (("" (rewrite nth_equal)
      (("" (split)
        (("1" (rewrite length_filter_pos)
          (("1" (grind)
            (("1" (stop-rewrite is_finite)
              (("1" (rewrite card_bij_inv)
                (("1" (inst + "LAMBDA (i: bl(s)): i")
                  (("1" (grind) nil nil)) nil)
                 ("2" (expand is_finite)
                  (("2"
                    (inst + "length(s)"
                     "LAMBDA (j | j < length(s)): j")
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (use nth_filter_pos)
            (("2" (skeep)
              (("2" (expand nth_filter_pos?)
                (("2" (lemma card_bij[nat])
                  (("2" (typepred! "{ j | j < i_1 }" :implicit? t)
                    (("2" (inst - "i_1" "{ j | j < i_1 }")
                      (("2" (bddsimp)
                        (("1" (grind) nil nil)
                         ("2" (inst + "LAMBDA (j | j < i_1): j")
                          (("2" (expand bijective?)
                            (("2" (split 2)
                              (("1"
                                (hide-all-but 1)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (hide-all-but 1)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nth_equal formula-decl nil seq_defs nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (filter_pos const-decl "(filter_pos?(s, pi))" seq_filter_props nil)
    (TRUE const-decl "bool" booleans nil)
    (card_bij formula-decl nil finite_sets nil)
    (nth_filter_pos? const-decl "bool" seq_filter_props nil)
    (nth_filter_pos formula-decl nil seq_filter_props nil)
    (bl type-eq-decl nil seq_defs nil)
    (below type-eq-decl nil nat_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (< const-decl "bool" reals nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (card_bij_inv formula-decl nil finite_sets nil))
   shostak))
 (filter_true 0
  (filter_true-1 nil 3581434701
   ("" (grind :rewrites (filter_as_filter_pos filter_pos_true)) nil
    nil)
   ((filter_as_filter_pos formula-decl nil seq_filter_props nil)
    (filter_pos_true formula-decl nil seq_filter_props nil))
   shostak))
 (member_filter_pos 0
  (member_filter_pos-1 nil 3581952385
   ("" (skeep)
    (("" (typepred "filter_pos(s, pi)")
      (("" (expand filter_pos?)
        (("" (skeep)
          (("" (expand member)
            (("" (skeep)
              (("" (inst -3 i)
                (("" (inst + "f(i)") (("" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((filter_pos const-decl "(filter_pos?(s, pi))" seq_filter_props nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (preserves const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil)
    (bl type-eq-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (< const-decl "bool" reals nil)
    (member const-decl "bool" seq_basic_props nil))
   shostak))
 (member_filter 0
  (member_filter-1 nil 3581429101
   ("" (skeep)
    (("" (expand member)
      (("" (prop)
        (("1" (skeep)
          (("1" (typepred "filter(s, p)")
            (("1" (expand filter?)
              (("1" (skeep)
                (("1" (inst -3 i)
                  (("1" (inst + "f(i)") (("1" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (typepred "filter(s, p)")
            (("2" (expand filter?)
              (("2" (skeep)
                (("2" (inst -2 "f(i)")
                  (("2" (inst -3 i) (("2" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (skeep)
          (("3" (typepred "filter(s, p)")
            (("3" (expand filter?)
              (("3" (skeep)
                (("3" (inst -2 i)
                  (("3" (bddsimp -2)
                    (("1" (skeep)
                      (("1" (inst + j) (("1" (grind) nil nil)) nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((member const-decl "bool" seq_basic_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (bl type-eq-decl nil seq_defs nil)
    (restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (PRED type-eq-decl nil defined_types nil)
    (filter? const-decl "bool" seq_filter_props nil)
    (filter const-decl "(filter?(s, p))" seq_filter_props nil))
   shostak))
 (filter_pos_append 0
  (filter_pos_append-1 nil 3581345028
   ("" (skeep)
    (("" (rewrite filter_pos_as_filter_pos)
      (("" (invoke (typepred "%1") (~ "filter_pos(%, %)"))
        (("" (invoke (typepred "%1") (~ "filter_pos(s2, %)"))
          (("" (expand filter_pos?)
            (("" (skolem -1 f2)
              (("" (skolem -2 f1)
                ((""
                  (inst + "LAMBDA (x: bl(append(filter_pos(s1, pi),
                           filter_pos(s2,
                                      LAMBDA
                                      (n, x):
                                      pi(n + length(s1), x))))): IF x < length(filter_pos(s1, pi)) THEN f1(x) ELSE f2(x - length(filter_pos(s1, pi))) + length(s1) ENDIF")
                  (("1" (split)
                    (("1" (expand preserves)
                      (("1" (skeep)
                        (("1" (lift-if)
                          (("1" (lift-if)
                            (("1" (prop)
                              (("1"
                                (inst -7 x1 x2)
                                (("1" (grind) nil nil))
                                nil)
                               ("2" (grind) nil nil)
                               ("3"
                                (lift-if)
                                (("3"
                                  (prop)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (inst
                                     -2
                                     "x1 - length(filter_pos(s1, pi))"
                                     "x2 - length(filter_pos(s1, pi))")
                                    (("1" (grind) nil nil)
                                     ("2" (grind) nil nil)
                                     ("3" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skeep)
                      (("2" (hide -1 -4)
                        (("2" (prop)
                          (("1" (rewrite nth_append)
                            (("1" (lift-if)
                              (("1"
                                (prop)
                                (("1"
                                  (inst -5 i)
                                  (("1"
                                    (bddsimp -5)
                                    (("1"
                                      (skeep)
                                      (("1"
                                        (inst + j)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (grind
                                           :rewrites
                                           length_append)
                                          nil
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (propax) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (inst -2 "i - length(s1)")
                                  (("1"
                                    (bddsimp -2)
                                    (("1"
                                      (skeep)
                                      (("1"
                                        (inst
                                         +
                                         "j + length(filter_pos(s1, pi))")
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (grind
                                           :rewrites
                                           length_append)
                                          nil
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (assert) nil nil))
                                    nil)
                                   ("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (typepred i)
                              (("2"
                                (grind :rewrites length_append)
                                nil
                                nil))
                              nil))
                            nil)
                           ("2" (skeep)
                            (("2" (lift-if)
                              (("2"
                                (prop)
                                (("1"
                                  (inst -5 i)
                                  (("1"
                                    (rewrite nth_append)
                                    (("1"
                                      (typepred "f1(j)")
                                      (("1"
                                        (lift-if)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (typepred "f1(j)")
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (rewrite nth_append)
                                  (("2"
                                    (lift-if)
                                    (("2"
                                      (bddsimp +)
                                      (("1" (assert) nil nil)
                                       ("2"
                                        (inst -2 "i - length(s1)")
                                        (("1" (grind) nil nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("3" (skeep)
                      (("3" (hide -1 -4)
                        (("3" (rewrite nth_append)
                          (("1" (lift-if)
                            (("1" (prop)
                              (("1"
                                (typepred "f1(j)")
                                (("1"
                                  (inst -6 j)
                                  (("1"
                                    (grind :rewrites nth_append)
                                    nil
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (inst
                                 -2
                                 "j - length(filter_pos(s1, pi))")
                                (("1"
                                  (grind :rewrites nth_append)
                                  nil
                                  nil)
                                 ("2"
                                  (grind :rewrites length_append)
                                  nil
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (typepred j)
                            (("2" (grind :rewrites length_append) nil
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (skeep)
                    (("2" (hide -1 -4)
                      (("2" (grind :rewrites length_append) nil nil))
                      nil))
                    nil)
                   ("3" (grind :rewrites length_append) nil nil)
                   ("4" (grind :rewrites length_append) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (filter_pos_as_filter_pos formula-decl nil seq_filter_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (append const-decl "seq" seq_basic_props nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (filter_pos const-decl "(filter_pos?(s, pi))" seq_filter_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (filter_pos_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (f1 skolem-const-decl "[bl[T](filter_pos(s1, pi)) -> bl[T](s1)]"
     seq_filter_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bl type-eq-decl nil seq_defs nil)
    (s2 skolem-const-decl "seq[T]" seq_filter_props nil)
    (pi skolem-const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (s1 skolem-const-decl "seq[T]" seq_filter_props nil)
    (< const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (f2 skolem-const-decl
     "[bl[T](filter_pos(s2, LAMBDA (n, x): pi(n + length(s1), x))) -> bl[T](s2)]"
     seq_filter_props nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (j skolem-const-decl "bl
    [T](append(filter_pos(s1, pi),
               filter_pos(s2, LAMBDA (n, x): pi(n + length(s1), x))))"
     seq_filter_props nil)
    (i skolem-const-decl "bl[T](append(s1, s2))" seq_filter_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (j skolem-const-decl
     "bl[T](filter_pos(s2, LAMBDA (n, x): pi(n + length(s1), x)))"
     seq_filter_props nil)
    (length_append formula-decl nil seq_basic_props nil)
    (j skolem-const-decl "bl[T](filter_pos(s1, pi))" seq_filter_props
     nil)
    (nth_append formula-decl nil seq_basic_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (j skolem-const-decl "bl
    [T](append(filter_pos(s1, pi),
               filter_pos(s2, LAMBDA (n, x): pi(n + length(s1), x))))"
     seq_filter_props nil)
    (preserves const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (restrict const-decl "R" restrict nil)
    (x2 skolem-const-decl "bl
    [T](append(filter_pos(s1, pi),
               filter_pos(s2, LAMBDA (n, x): pi(n + length(s1), x))))"
     seq_filter_props nil)
    (x1 skolem-const-decl "bl
    [T](append(filter_pos(s1, pi),
               filter_pos(s2, LAMBDA (n, x): pi(n + length(s1), x))))"
     seq_filter_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   shostak))
 (append_filter_pos2_TCC1 0
  (append_filter_pos2_TCC1-1 nil 3581263133 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (append_filter_pos2 0
  (append_filter_pos2-1 nil 3581891593
   ("" (skeep)
    (("" (rewrite filter_pos_append)
      (("1" (lemma filter_pos_below_length)
        (("1" (copy -1)
          (("1" (invoke (inst - pi "%1" s1) (~ "LAMBDA (n, x): %"))
            (("1"
              (invoke (inst - qi "%1" s2) (~ "LAMBDA (n_1: %, %): %"))
              (("1" (split -1)
                (("1" (split -2)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (filter_pos_append formula-decl nil seq_filter_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (< const-decl "bool" reals nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (s1 skolem-const-decl "seq[T]" seq_filter_props nil)
    (filter_pos_below_length formula-decl nil seq_filter_props nil))
   shostak))
 (append_filter_pos 0
  (append_filter_pos-1 nil 3581893302
   ("" (skeep)
    (("" (lemma append_filter_pos2)
      (("" (inst - pi "LAMBDA (n, x): TRUE" s1 s2)
        (("" (grind :rewrites filter_pos_true) nil nil)) nil))
      nil))
    nil)
   ((append_filter_pos2 formula-decl nil seq_filter_props nil)
    (filter_pos_true formula-decl nil seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (TRUE const-decl "bool" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (T formal-type-decl nil seq_filter_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (append__filter_pos 0
  (append__filter_pos-1 nil 3581896716
   ("" (skeep)
    (("" (lemma append_filter_pos2)
      (("" (inst - "LAMBDA (n, x): TRUE" pi s1 s2)
        (("" (rewrite filter_pos_true) nil nil)) nil))
      nil))
    nil)
   ((append_filter_pos2 formula-decl nil seq_filter_props nil)
    (filter_pos_true formula-decl nil seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (TRUE const-decl "bool" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (T formal-type-decl nil seq_filter_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (filter_append 0
  (filter_append-1 nil 3581901435
   ("" (skeep)
    (("" (grind :rewrites (filter_as_filter_pos filter_pos_append)) nil
      nil))
    nil)
   ((filter_pos_append formula-decl nil seq_filter_props nil)
    (filter_as_filter_pos formula-decl nil seq_filter_props nil))
   shostak))
 (append_filter2 0
  (append_filter2-1 nil 3581901457
   ("" (grind :rewrites (filter_as_filter_pos append_filter_pos2)) nil
    nil)
   ((append_filter_pos2 formula-decl nil seq_filter_props nil)
    (filter_as_filter_pos formula-decl nil seq_filter_props nil))
   shostak))
 (append_filter 0
  (append_filter-1 nil 3581901481
   ("" (grind :rewrites (filter_as_filter_pos append_filter_pos)) nil
    nil)
   ((append_filter_pos formula-decl nil seq_filter_props nil)
    (filter_as_filter_pos formula-decl nil seq_filter_props nil))
   shostak))
 (append__filter 0
  (append__filter-1 nil 3581901489
   ("" (grind :rewrites (filter_as_filter_pos append__filter_pos)) nil
    nil)
   ((append__filter_pos formula-decl nil seq_filter_props nil)
    (filter_as_filter_pos formula-decl nil seq_filter_props nil))
   shostak))
 (filter_pos_reverse_TCC1 0
  (filter_pos_reverse_TCC1-1 nil 3581263133 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (filter_pos_reverse 0
  (filter_pos_reverse-1 nil 3581901507
   ("" (skeep)
    (("" (rewrite filter_pos_as_filter_pos)
      (("1" (invoke (typepred "%1") (~ "filter_pos(%, %)"))
        (("1" (expand filter_pos?)
          (("1" (skolem -1 f)
            (("1"
              (inst + "LAMBDA (j: bl(reverse(filter_pos(s,
                                       LAMBDA
                                       (n, x):
                                       IF n < length(s)
                                       THEN pi(length(s) - 1 - n, x)
                                       ELSE FALSE
                                       ENDIF)))): length(s) - 1 - f(  length(reverse(filter_pos(s,
                                       LAMBDA
                                       (n, x):
                                       IF n < length(s)
                                       THEN pi(length(s) - 1 - n, x)
                                       ELSE FALSE
                                       ENDIF))) - 1 - j ) ")
              (("1" (prop)
                (("1" (expand preserves)
                  (("1" (skeep)
                    (("1"
                      (inst - "length(reverse(filter_pos(s,
                                     LAMBDA
                                     (n, x):
                                     IF n < length(s)
                                     THEN pi(length(s) - 1 - n, x)
                                     ELSE FALSE
                                     ENDIF)))
            - 1
            - x2" "length(reverse(filter_pos(s,
                                    LAMBDA
                                    (n, x):
                                    IF n < length(s)
                                    THEN pi(length(s) - 1 - n, x)
                                    ELSE FALSE
                                    ENDIF)))
           - 1
           - x1")
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide -1)
                  (("2" (skeep)
                    (("2" (prop)
                      (("1" (rewrite nth_reverse)
                        (("1" (inst -2 "length(s) - 1 -i")
                          (("1" (prop)
                            (("1" (skeep)
                              (("1"
                                (inst
                                 +
                                 "length(reverse(filter_pos(s,
                                     LAMBDA
                                     (n, x):
                                     IF n < length(s)
                                     THEN pi(length(s) - 1 - n, x)
                                     ELSE FALSE
                                     ENDIF)))
            - 1
            - j")
                                (("1" (grind) nil nil)
                                 ("2"
                                  (grind :rewrites length_reverse)
                                  nil
                                  nil)
                                 ("3"
                                  (grind :rewrites length_reverse)
                                  nil
                                  nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil)
                           ("2" (typepred i)
                            (("2" (grind :rewrites length_reverse) nil
                              nil))
                            nil))
                          nil)
                         ("2" (typepred i)
                          (("2" (grind :rewrites length_reverse) nil
                            nil))
                          nil))
                        nil)
                       ("2" (inst -2 "length(s) - 1 -i")
                        (("1" (prop)
                          (("1" (grind :rewrites nth_reverse) nil nil)
                           ("2" (skeep)
                            (("2"
                              (inst + "length(reverse(filter_pos(s,
                                     LAMBDA
                                     (n, x):
                                     IF n < length(s)
                                     THEN pi(length(s) - 1 - n, x)
                                     ELSE FALSE
                                     ENDIF)))
            - 1
            - j_1")
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (skeep)
                  (("3" (hide -1)
                    (("3" (rewrite* nth_reverse)
                      (("1" (rewrite* length_reverse)
                        (("1"
                          (inst -2 "length(filter_pos(s,
                            LAMBDA (n, x):
                              IF n < length(s)
                                THEN pi(length(s) - 1 - n, x)
                              ELSE FALSE
                              ENDIF))
           - 1
           - j_1")
                          (("1" (typepred j_1)
                            (("1" (grind :rewrites length_reverse) nil
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil)
                       ("2" (grind) nil nil)
                       ("3" (typepred j_1)
                        (("3" (grind :rewrites length_reverse) nil
                          nil))
                        nil)
                       ("4" (grind :rewrites length_reverse) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind :rewrites length_reverse) nil nil)
               ("3" (grind :rewrites length_reverse) nil nil)
               ("4" (grind :rewrites length_reverse) nil nil))
              nil))
            nil))
          nil)
         ("2" (grind :rewrites length_reverse) nil nil))
        nil)
       ("2" (grind :rewrites length_reverse) nil nil))
      nil))
    nil)
   ((IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (filter_pos_as_filter_pos formula-decl nil seq_filter_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (reverse const-decl "seq" seq_basic_props nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (filter_pos const-decl "(filter_pos?(s, pi))" seq_filter_props nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (< const-decl "bool" reals nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (FALSE const-decl "bool" booleans nil)
    (filter_pos_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (s skolem-const-decl "seq[T]" seq_filter_props nil)
    (pi skolem-const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (bl type-eq-decl nil seq_defs nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (f skolem-const-decl "[bl
     [T](filter_pos(s,
                    LAMBDA (n, x):
                      IF n < length(s) THEN pi(length(s) - 1 - n, x)
                      ELSE FALSE
                      ENDIF)) ->
   bl[T](s)]" seq_filter_props nil)
    (j_1 skolem-const-decl "bl
    [T](reverse(filter_pos(s,
                           LAMBDA (n, x):
                             IF n < length(s) THEN pi(length(s) - 1 - n, x)
                             ELSE FALSE
                             ENDIF)))" seq_filter_props nil)
    (i skolem-const-decl "bl[T](reverse(s))" seq_filter_props nil)
    (length_reverse formula-decl nil seq_basic_props nil)
    (j skolem-const-decl "bl
    [T](filter_pos(s,
                   LAMBDA (n, x):
                     IF n < length(s) THEN pi(length(s) - 1 - n, x)
                     ELSE FALSE
                     ENDIF))" seq_filter_props nil)
    (nth_reverse formula-decl nil seq_basic_props nil)
    (preserves const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (restrict const-decl "R" restrict nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (reverse_filter_pos 0
  (reverse_filter_pos-1 nil 3581905535
   ("" (skeep)
    (("" (rewrite filter_pos_reverse)
      (("1" (lemma filter_pos_below_length)
        (("1" (invoke (inst - pi "%1" s) (~ "LAMBDA (n_1: %, %): %"))
          (("1" (grind) nil nil)) nil))
        nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (filter_pos_reverse formula-decl nil seq_filter_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (< const-decl "bool" reals nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (FALSE const-decl "bool" booleans nil)
    (filter_pos_below_length formula-decl nil seq_filter_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (filter_reverse 0
  (filter_reverse-1 nil 3581905933
   ("" (grind :rewrites (filter_as_filter_pos filter_pos_reverse))
    (("" (lemma filter_pos_below_length)
      (("" (invoke (inst - p!1 "%1" s!1) (~ "LAMBDA (n_1: %, %): %"))
        (("" (grind) (("" (expand C1) (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((filter_pos_below_length formula-decl nil seq_filter_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (C1 const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (< const-decl "bool" reals nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (FALSE const-decl "bool" booleans nil)
    (filter_as_filter_pos formula-decl nil seq_filter_props nil)
    (filter_pos_reverse formula-decl nil seq_filter_props nil))
   shostak))
 (reverse_filter 0
  (reverse_filter-1 nil 3581905893
   ("" (grind :rewrites filter_reverse) nil nil)
   ((filter_reverse formula-decl nil seq_filter_props nil)) shostak))
 (every_filter 0
  (every_filter-1 nil 3581906477
   ("" (grind :rewrites (every_as_forall member_filter)) nil nil)
   ((every_as_forall formula-decl nil seq_basic_props nil)
    (T formal-type-decl nil seq_filter_props nil)
    (member_filter formula-decl nil seq_filter_props nil)
    (filter const-decl "(filter?(s, p))" seq_filter_props nil)
    (filter? const-decl "bool" seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (member const-decl "bool" seq_basic_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (filter_when_every 0
  (filter_when_every-1 nil 3581906742
   ("" (skeep)
    (("" (prop)
      (("1" (rewrite filter_as_filter)
        (("1" (expand filter?)
          (("1" (inst + "LAMBDA (j: bl(s)): j")
            (("1" (split)
              (("1" (grind) nil nil)
               ("2" (grind :rewrites every) nil nil)
               ("3" (grind) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (grind :rewrites (every_as_forall member_filter))
        (("2" (rewrite -2 :dir rl)
          (("2" (rewrite member_filter) nil nil)) nil))
        nil))
      nil))
    nil)
   ((filter? const-decl "bool" seq_filter_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (every const-decl "bool" seq_basic_props nil)
    (preserves const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bl type-eq-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (filter_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil seq_filter_props nil)
    (filter_as_filter formula-decl nil seq_filter_props nil)
    (member_filter formula-decl nil seq_filter_props nil)
    (member const-decl "bool" seq_basic_props nil)
    (every_as_forall formula-decl nil seq_basic_props nil))
   shostak))
 (filter_when_some 0
  (filter_when_some-1 nil 3581907201
   ("" (skeep)
    (("" (prop)
      (("1" (expand nonempty?)
        (("1" (rewrite some_as_exists)
          (("1" (skeep)
            (("1" (use member_empty)
              (("1" (rewrite empty_as_empty)
                (("1" (rewrite -2 :dir rl)
                  (("1" (rewrite member_filter) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand nonempty?)
        (("2" (rewrite empty_as_member)
          (("2" (skeep)
            (("2" (grind :rewrites (some_as_exists member_filter)) nil
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((some_as_exists formula-decl nil seq_basic_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (member_empty formula-decl nil seq_basic_props nil)
    (member const-decl "bool" seq_basic_props nil)
    (member_filter formula-decl nil seq_filter_props nil)
    (empty_as_empty formula-decl nil seq_defs nil)
    (filter? const-decl "bool" seq_filter_props nil)
    (filter const-decl "(filter?(s, p))" seq_filter_props nil)
    (nonempty? const-decl "bool" seq_defs nil)
    (empty_as_member formula-decl nil seq_basic_props nil)
    (x skolem-const-decl "T" seq_filter_props nil)
    (nth const-decl "[s: seq, bl(s) -> T]" seq_defs nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bl type-eq-decl nil seq_defs nil)
    (s skolem-const-decl "seq[T]" seq_filter_props nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (filter_pos_empty 0
  (filter_pos_empty-1 nil 3581952821
   ("" (skeep)
    (("" (rewrite filter_pos_as_filter_pos)
      (("" (expand filter_pos?)
        (("" (inst + "LAMBDA (x: bl(empty)): x") (("" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((filter_pos_as_filter_pos formula-decl nil seq_filter_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (empty const-decl "{s | length(s) = 0}" seq_defs nil)
    (filter_pos_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (bl type-eq-decl nil seq_defs nil) (< const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil)
    (filter_pos? const-decl "bool" seq_filter_props nil))
   shostak))
 (filter_empty 0
  (filter_empty-1 nil 3581913712
   ("" (skeep)
    (("" (rewrite filter_as_filter)
      (("" (expand filter?)
        (("" (inst + "LAMBDA (j: bl(empty)): j") (("" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((filter_as_filter formula-decl nil seq_filter_props nil)
    (T formal-type-decl nil seq_filter_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (empty const-decl "{s | length(s) = 0}" seq_defs nil)
    (filter_is_singleton application-judgement "(singleton?[seq])"
     seq_filter_props nil)
    (bl type-eq-decl nil seq_defs nil) (< const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (restrict const-decl "R" restrict nil)
    (preserves const-decl "bool" functions nil)
    (filter? const-decl "bool" seq_filter_props nil))
   shostak))
 (filter_empty_when 0
  (filter_empty_when-1 nil 3581913771
   ("" (use filter_when_some) (("" (grind) nil nil)) nil)
   ((nonempty? const-decl "bool" seq_defs nil)
    (empty? const-decl "bool" seq_defs nil)
    (some const-decl "bool" seq_basic_props nil)
    (T formal-type-decl nil seq_filter_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bl type-eq-decl nil seq_defs nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (filter_when_some formula-decl nil seq_filter_props nil))
   shostak))
 (length_filter_pos_le 0
  (length_filter_pos_le-1 nil 3581913857
   ("" (skeep)
    (("" (typepred "filter_pos(s, pi)")
      (("" (expand filter_pos?)
        (("" (skeep)
          (("" (use injection_n_to_m)
            (("" (prop)
              (("" (inst + f) (("" (use st_incr_is_injective) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((filter_pos const-decl "(filter_pos?(s, pi))" seq_filter_props nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (T formal-type-decl nil seq_filter_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (f skolem-const-decl "[bl[T](filter_pos(s, pi)) -> bl[T](s)]"
     seq_filter_props nil)
    (pi skolem-const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (s skolem-const-decl "seq[T]" seq_filter_props nil)
    (preserves const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (st_incr_is_injective formula-decl nil seq_filter_props nil)
    (bl type-eq-decl nil seq_defs nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (injection_n_to_m formula-decl nil nat_fun_props nil))
   shostak))
 (length_filter_le 0
  (length_filter_le-1 nil 3581913960
   ("" (grind :rewrites (filter_as_filter_pos length_filter_pos_le))
    nil nil)
   ((length_filter_pos_le formula-decl nil seq_filter_props nil)
    (filter_as_filter_pos formula-decl nil seq_filter_props nil))
   shostak))
 (filter_pos_when_length 0
  (filter_pos_when_length-1 nil 3581952508
   ("" (skeep)
    (("" (prop)
      (("1" (typepred "filter_pos(s, pi)")
        (("1" (expand filter_pos?)
          (("1" (skeep)
            (("1" (use incr_bij_is_id)
              (("1" (split -1)
                (("1" (rewrite nth_equal 1)
                  (("1" (split 1)
                    (("1" (propax) nil nil)
                     ("2" (skeep)
                      (("2" (inst -4 i)
                        (("2" (inst - i) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((incr_bij_is_id formula-decl nil seq_filter_props nil)
    (length const-decl "[seq -> nat]" seq_defs nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (s skolem-const-decl "seq[T]" seq_filter_props nil)
    (pi skolem-const-decl "PRED[[nat, T]]" seq_filter_props nil)
    (bl type-eq-decl nil seq_defs nil)
    (f skolem-const-decl "[bl[T](filter_pos(s, pi)) -> bl[T](s)]"
     seq_filter_props nil)
    (nth_equal formula-decl nil seq_defs nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (preserves const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil seq_filter_props nil)
    (seq nonempty-type-decl nil seq_defs nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (filter_pos? const-decl "bool" seq_filter_props nil)
    (filter_pos const-decl "(filter_pos?(s, pi))" seq_filter_props
     nil))
   shostak))
 (filter_when_length 0
  (filter_when_length-1 nil 3581952741
   ("" (grind :rewrites (filter_as_filter_pos filter_pos_when_length))
    nil nil)
   ((filter_pos_when_length formula-decl nil seq_filter_props nil)
    (filter_as_filter_pos formula-decl nil seq_filter_props nil))
   shostak)))

