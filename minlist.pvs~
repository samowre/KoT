minlist   [T : TYPE ]
		: THEORY

  BEGIN

   a, b, c: VAR T
   l, l1, l2, k: VAR list[T]

   minlistx(l,  (key : [T -> real]), a, (m : real | key(a) = m)): RECURSIVE
     {c | member(c, cons(a, l)) AND (FORALL b: member(b,cons(a,l)) IMPLIES key(c) <= key(b))}
   = (CASES l OF
       cons(c, l1):
         LET k = key(c)
          IN IF k < m
              THEN minlistx(l1, key, c, k)
              ELSE minlistx(l1, key, a, m)
             ENDIF,
        null: a
       ENDCASES)
     MEASURE length(l)

   func : VAR [T -> real]

   minlist((l: (cons?[T])), (key : [T -> real])):
      {c | member(c, l) AND (FORALL b: member(b, l) IMPLIES key(c)<=key(b))}
    = minlistx(cdr(l), key, car(l), key(car(l)))

  equal_min:  LEMMA
  	      member(c, cons(a, l)) =>
	      func(minlist(cons(a, l), func)) <= func(c)

  recursive_min:  LEMMA
  		  func(minlistx(cons(b, l), func,a,func(a))) = min(func(a), func(minlistx( l, func, b, func(b))))
		     	      
		   

  P, Q: VAR PRED[T]

  every_and: LEMMA
       every(LAMBDA a: P(a) AND Q(a))(l) =
         (every(P)(l) AND every(Q)(l))

  pp, qq: VAR [(cons?[T])-> bool]

  every_suffix?(pp)(l): RECURSIVE bool =
   CASES l OF
    null: TRUE,
    cons(e, k): pp(l) AND every_suffix?(pp)(k)
   ENDCASES
    MEASURE length(l)

  every_suffix_impl: LEMMA
     (FORALL (k: (cons?[T])): pp(k) IMPLIES qq(k)) AND
      every_suffix?(pp)(l)
  IMPLIES every_suffix?(qq)(l)

  member_nth: LEMMA
    (FORALL (n: below(length(l))): 
      member(nth(l, n), l))

  nthcdr(l, (n:below[length(l)])): RECURSIVE (cons?[T]) =
    IF n = 0 THEN l ELSE nthcdr(cdr(l), n-1) ENDIF
   MEASURE length(l)

  length_nthcdr: LEMMA
   FORALL (n: below(length(l))): 
     length(nthcdr(l, n)) = length(l) - n

  nth_nthcdr: LEMMA
    FORALL (i: below(length(l))), (j: below(length(l) - i)): 
     nth(l, i + j) = nth(nthcdr(l, i), j)

  nthcdr_nthcdr: LEMMA
     FORALL (i: below(length(l))), (j: below(length(l) - i)): 
     nthcdr(nthcdr(l, i), j) = nthcdr(l, i+ j)
     
  nth(l)(i:below(length(l))): T = nth(l, i)

  nthcdr_every_suffix: LEMMA
    every_suffix?(pp)(l) IMPLIES
       (FORALL (i: below(length(l))):
           every_suffix?(pp)(nthcdr(l, i)))

  every_suffix_nthcdr: LEMMA
      every_suffix?(pp)(l) IMPLIES
       (FORALL (i: below(length(l))):
         cons?(nthcdr(l, i)) IMPLIES
           pp(nthcdr(l, i)))

  nthcar(l, (n:below[length(l)])): RECURSIVE list[T] =
    IF n = 0 THEN null ELSE cons(car(l), nthcar(cdr(l), n-1)) ENDIF
   MEASURE length(l)

  nthcar_cdr: LEMMA
   (FORALL (i:below(length(l))): 
    append(nthcar(l, i), nthcdr(l, i)) = l)

  car_nthcar: LEMMA
  FORALL (l: (cons?[T])), (i: below(length(l))): 
    i > 0 => 
     car(nthcar(l, i)) = car(l)

  car_nthcdr: LEMMA
     FORALL (l: (cons?[T])), (i: below(length(l))): 
      car(nthcdr(l, i)) = nth(l, i)

    length_nthcar: LEMMA FORALL (l: (cons?[T])), (i: below(length(l))): length(nthcar(l, i)) = i;

   nthcdr_append: LEMMA
     FORALL (l: (cons?[T])), (i: below(length(l))):
      nthcdr(append(l, k), i) = append(nthcdr(l, i), k)

   delete(a, l): RECURSIVE
      {l1 | (FORALL c: member(c, l1) = (c /= a AND member(c, l)))} = 
    CASES l OF
     null: null,
     cons(b, k): IF a = b
                  THEN delete(a, k)
                 ELSE cons(b, delete(a, k))
              ENDIF
    ENDCASES
    MEASURE length(l)

   member_append: LEMMA
    member(a, append(k, l)) = (member(a, k) OR member(a, l))

   subset(k, l): RECURSIVE bool =
    (CASES k OF
     null: TRUE,
     cons(a, l1): member(a, l) AND subset(l1, l)
     ENDCASES)
    MEASURE length(k)

   suffix?(l2)(l1): RECURSIVE bool =
    (CASES l2 OF
      null: null?(l1),
      cons(a, k): l1 = l2 OR suffix?(k)(l1)
     ENDCASES)
   MEASURE length(l2)

   suffix_transitivity: LEMMA suffix?(l)(l1) AND suffix?(l1)(l2) 
     IMPLIES suffix?(l)(l2)

   suffix_transitivity_induction: LEMMA 
     suffix?(l2)(l1) IMPLIES suffix?(cons(a,l2))(l1)

   suffix_null: LEMMA null?(l1) IMPLIES suffix?(l2)(l1)

   suffix_length: LEMMA suffix?(l2)(l1) IMPLIES length(l1) <=  length(l2)

   suffix_cons: LEMMA
     suffix?(l1)(cons(a, l2)) => suffix?(l1)(l2)

   presuffix(l1, l2): RECURSIVE list[T] =
    (CASES l2 OF
      null: null,
      cons(a, k): IF l1 = l2 THEN null
                   ELSE cons(a, presuffix(l1, k))
                 ENDIF
     ENDCASES)
    MEASURE length(l2)
     
   suffix_member: LEMMA suffix?(l2)(l1) AND cons?(l1) IMPLIES member(car(l1), l2)

   some_member: LEMMA some(P)(l) = (EXISTS a: member(a, l) AND P(a))

    presuffix_nil: LEMMA presuffix(null, l) = l    

    some_nth: LEMMA
       some(P)(l) IFF (EXISTS (i : below(length(l))): P(nth(l, i)))


    find(P, l): RECURSIVE {i : upto(length(l)) |
                             (i > 0 => (P(nth(l, i-1)) &
                                        (FORALL (j: below(i-1)):
					    NOT P(nth(l, j)))))
	                    & (i = 0 => NOT some(P)(l))}
     = CASES l OF
        null: 0,
	cons(b, k): IF P(b) THEN 1 ELSIF find(P, k) = 0 THEN 0 ELSE 1 + find(P, k) ENDIF
       ENDCASES
       MEASURE length(l)

     CONVERSION+ K_conversion

     some_every: LEMMA
       some(P)(l) IFF NOT every(NOT P)(l)

     find_zero: LEMMA
       find(P, l) = 0 IFF every(NOT P)(l);

     find_nonzero: LEMMA
       find(P, l) > 0 IMPLIES
            P(nth(l, find(P, l) - 1)) AND
            (FORALL (j : below(find(P, l) - 1)): NOT P(nth(l, j)))

     rassoc2(a, k, l): RECURSIVE T =
       CASES k OF
         null: a,
	 cons(b, k1): (IF cons?(l)
	                THEN IF a = b
			     THEN car(l)
			     ELSE rassoc2(a, k1, cdr(l))
			     ENDIF
			ELSE a ENDIF)
       ENDCASES
      MEASURE length(k)

     maxlist((l | cons?(l)), (key : [T -> real])): T =
       minlist(l, (LAMBDA a: -key(a)))

     setlist?(l): RECURSIVE bool =
     CASES l OF
      null: TRUE,
      cons(a, k): NOT member(a, k) AND setlist?(k)
     ENDCASES
     MEASURE length(l)

     list2set_member: LEMMA list2set(k)(a) = member(a, k)

     subset_member: LEMMA subset(k, l) = subset?(k, l)

     setify(l): RECURSIVE {k | setlist?(k) AND subset(k, l) AND subset(l, k)} =
     CASES l OF
       null: null,
       cons(a, k): IF member(a, k)
                    THEN setify(k)
		    ELSE cons(a, setify(k))
		   ENDIF
     ENDCASES
     MEASURE length(l)

     setify_null: LEMMA
       null?(setify(l)) = null?(l)

     delete_append: LEMMA
       delete(a, append(k, l)) = append(delete(a, k), delete(a, l))

     every_forall: LEMMA
       every(P)(l) = (FORALL a: member(a, l) => P(a))

     some_exists: LEMMA
       some(P)(l) = (EXISTS a: member(a, l) AND P(a))

     member_suffix: LEMMA
       suffix?(l1)(l2) AND member(a, l2) => member(a, l1)

  END minlist
