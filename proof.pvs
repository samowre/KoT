proof	: THEORY

%A proof is an array where each element is a semi-proof of a sequent, i.e., 
%a proof from other sequents.  A semi-proof consists of an array consisting of
%a sequent and proof rule.  The sequent must follow from prior sequents
%by the proof rules.  Some of the sequents in a semi-proof can be lemmas
%in which case, they are linked to semi-proofs in the larger proof.  Thus
%a proof is 2-dimensional.  The reason is so that we try to keep proofs
%parametric with respect to proofs of lemmas.

  BEGIN
  
  %for fmla type
  importing fmla
  % added with subtypes...
  rule: DATATYPE WITH SUBTYPES no_premise?, one_premise?, two_premise? 
  BEGIN
   ax: ax?	: no_premise?
   orr: orr?	: one_premise?
   norr : norr?	: two_premise?
   neg : neg? 	: one_premise?
   cut(cut_fmla: fmla) : cut?		: two_premise?
   existsr(witness: term): existsr?	: one_premise?
   allr(skoconst: (ufun?)): allr? 	: one_premise?
   fschema(fun: (ufun?), vars: list[(var?)], body: term): fscheme?  : one_premise?
   pschema(fun: (upred?), vars: list[(var?)], body: fmla): pscheme? : one_premise?
   reflex: reflex? 	  	        : no_premise?
   % renamed to lemma_
   lemma_(index: nat) : lemma?		: no_premise?
  END rule

  %for sequent type
  importing sequents

  proof_step : TYPE
   = [# sequent: sequent,
        rule: rule,
	subs: list[nat] #]
  
  %replaced finite_seq with finseq
  proof_seq: TYPE =  finseq[proof_step]

  R, S: VAR proof_step
  RR, SS: VAR proof_seq

  ne_proof_seq: TYPE = {RR | RR`length > 0}

  nRR, nSS: VAR ne_proof_seq
  
  %deleted :nRR
  %added `sequent at the end
  conclusion(nRR): sequent =
    (nRR`seq(nRR`length - 1))`sequent
  
  checkProof(lemmas: finseq[sequent])(RR): bool =
    (FORALL (i: below(RR`length)):
     % checks if rule has enough parameters
     (LET R = RR`seq(i) IN
      (one_premise?(R`rule) OR two_premise?(R`rule)
       => (cons?(R`subs) AND car(R`subs) < i)) AND
      (two_premise?(R`rule) => (cons?(cdr(R`subs)) AND
				car(cdr(R`subs)) < i )) AND
      (CASES R`rule OF
       ax : ax_rule?(R`sequent),
       %replaced R`sequence with RR.seq
       orr : or_rule?(RR`seq(car(R`subs))`sequent, R`sequent),
       norr: nor_rule?(RR`seq(car(R`subs))`sequent,
	               RR`seq(car(cdr(R`subs)))`sequent,
	               R`sequent),
       neg : neg_rule?(RR`seq(car(R`subs))`sequent, R`sequent),
       cut(A): cut_rule?(A, RR`seq(car(R`subs))`sequent,
                            RR`seq(car(cdr(R`subs)))`sequent,
			    R`sequent),
       existsr(u):
         exists_rule?(u, RR`seq(car(R`subs))`sequent, R`sequent),
       allr(f): forall_rule?(f, RR`seq(car(R`subs))`sequent, R`sequent),
       fschema(u, vars, s): fschema_rule?(u, vars, s, RR`seq(car(R`subs))`sequent, R`sequent),
       pschema(p, vars, A): pschema_rule?(p, vars, A, RR`seq(car(R`subs))`sequent, R`sequent),
       reflex: reflex_rule?(R`sequent),
       lemma_(i): (i < lemmas`length AND
                  R`sequent = lemmas(i))
      ENDCASES)))


    proof: DATATYPE
     BEGIN
       compose(lemma_proofs : finseq[proof_seq], 
               main : (checkProof(map(conclusion)(lemma_proofs)))): compose?
     END proof
  
%Each proof_entry can be independently checked.  We can then
%compose these into a proof where we associate proofs with
%the lemmas.  Since we are not actually interested in running
%the proof checker, we can live with tree-like proofs.
%The lemmas include function and predicate definitions.
%A whole proof is then relative to these definitions.
%A predicate definition is given as p(x, y, z) <-> A, whereas a
%function definition has the form (all x: exists! y: A(x, y)) => A(x, f(x)).

		  

  					  

  					  
  

  END proof
