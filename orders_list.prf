(lex_list
 (lesseqp_TCC1 0
  (lesseqp_TCC1-1 nil 3578400254 ("" (termination-tcc) nil nil)
   ((length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (reflexive 0
  (reflexive-1 nil 3578400278
   ("" (expand reflexive?) (("" (induct-and-simplify x) nil nil)) nil)
   ((list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil lex_list nil)
    (<= def-decl "bool" lex_list nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (reflexive? const-decl "bool" relations nil))
   shostak))
 (transitive 0
  (transitive-1 nil 3578400350
   ("" (expand transitive?)
    (("" (prop)
      (("" (induct z)
        (("1" (grind) nil nil)
         ("2" (skeep)
          (("2" (skeep)
            (("2" (expand <= -2)
              (("2" (lift-if)
                (("2" (prop)
                  (("1" (grind) nil nil)
                   ("2" (lift-if)
                    (("2" (prop)
                      (("1" (grind) nil nil) ("2" (grind) nil nil)
                       ("3" (expand <= -3)
                        (("3" (lift-if)
                          (("3" (prop)
                            (("1" (grind) nil nil)
                             ("2" (lift-if)
                              (("2"
                                (prop)
                                (("1" (grind) nil nil)
                                 ("2"
                                  (inst
                                   -
                                   "car(x)"
                                   "car(y)"
                                   "cons1_var")
                                  (("2"
                                    (expand antisymmetric?)
                                    (("2"
                                      (inst -5 cons1_var "car(y)")
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (antisymmetric? const-decl "bool" relations nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil lex_list nil)
    (<= def-decl "bool" lex_list nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (transitive? const-decl "bool" relations nil))
   shostak))
 (antisymmetric 0
  (antisymmetric-1 nil 3578401741
   ("" (expand antisymmetric?)
    (("" (prop)
      (("" (induct-and-simplify x :if-match nil)
        (("1" (inst - "cdr(y!1)")
          (("1" (decompose-equality 2) nil nil)) nil)
         ("2" (grind :if-match all) nil nil))
        nil))
      nil))
    nil)
   ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= def-decl "bool" lex_list nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil lex_list nil)
    (list_induction formula-decl nil list_adt nil)
    (antisymmetric? const-decl "bool" relations nil))
   shostak))
 (dichotomous 0
  (dichotomous-1 nil 3578401283
   ("" (expand trichotomous?)
    (("" (expand dichotomous?)
      (("" (prop)
        (("" (induct x)
          (("1" (grind) nil nil)
           ("2" (skeep)
            (("2" (skeep)
              (("2" (inst - "cons1_var" "car(y)")
                (("1" (inst - "cdr(y)")
                  (("1" (grind)
                    (("1" (expand "<=" +) (("1" (grind) nil nil)) nil)
                     ("2" (expand "<=" +) (("2" (grind) nil nil)) nil)
                     ("3" (expand "<=" +) (("3" (grind) nil nil)) nil)
                     ("4" (expand "<=" +) (("4" (grind) nil nil)) nil)
                     ("5" (expand <= 2) (("5" (grind) nil nil)) nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((dichotomous? const-decl "bool" orders nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= def-decl "bool" lex_list nil)
    (T formal-type-decl nil lex_list nil)
    (list_induction formula-decl nil list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (y skolem-const-decl "list[T]" lex_list nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (trichotomous? const-decl "bool" orders nil))
   shostak))
 (irreflexive 0
  (irreflexive-1 nil 3578400344 ("" (grind) nil nil)
   ((< const-decl "bool" lex_list nil)
    (irreflexive? const-decl "bool" relations nil))
   shostak))
 (transitive_strict 0
  (transitive_strict-1 nil 3578400687
   ("" (use transitive)
    (("" (prop)
      (("" (expand transitive?)
        (("" (skeep)
          (("" (inst - x y z)
            (("" (expand <)
              (("" (grind)
                (("" (use antisymmetric) (("" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((< const-decl "bool" lex_list nil)
    (antisymmetric formula-decl nil lex_list nil)
    (antisymmetric? const-decl "bool" relations nil)
    (/= const-decl "boolean" notequal nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil lex_list nil)
    (transitive? const-decl "bool" relations nil)
    (transitive formula-decl nil lex_list nil))
   shostak))
 (trichotomous 0
  (trichotomous-1 nil 3578407692
   ("" (use dichotomous) (("" (grind) nil nil)) nil)
   ((list type-decl nil list_adt nil)
    (T formal-type-decl nil lex_list nil)
    (trichotomous? const-decl "bool" orders nil)
    (dichotomous? const-decl "bool" orders nil)
    (/= const-decl "boolean" notequal nil)
    (< const-decl "bool" lex_list nil)
    (dichotomous formula-decl nil lex_list nil))
   shostak))
 (partial_order 0
  (partial_order-1 nil 3578410108
   ("" (use reflexive)
    (("" (use transitive)
      (("" (use antisymmetric) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((transitive formula-decl nil lex_list nil)
    (antisymmetric? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (partial_order? const-decl "bool" orders nil)
    (antisymmetric formula-decl nil lex_list nil)
    (reflexive formula-decl nil lex_list nil))
   shostak))
 (total_order 0
  (total_order-1 nil 3578410140
   ("" (use partial_order)
    (("" (use dichotomous) (("" (grind) nil nil)) nil)) nil)
   ((dichotomous formula-decl nil lex_list nil)
    (trichotomous? const-decl "bool" orders nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil lex_list nil)
    (total_order? const-decl "bool" orders nil)
    (partial_order? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (dichotomous? const-decl "bool" orders nil)
    (partial_order formula-decl nil lex_list nil))
   shostak))
 (strict_order 0
  (strict_order-1 nil 3578410159
   ("" (use transitive_strict)
    (("" (use irreflexive)
      (("" (expand strict_order?)
        (("" (prop)
          (("" (expand antisymmetric?)
            (("" (skeep)
              (("" (expand transitive? -)
                (("" (expand irreflexive?)
                  (("" (inst -4 x)
                    (("" (inst -4 x y x) (("" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((irreflexive formula-decl nil lex_list nil)
    (irreflexive? const-decl "bool" relations nil)
    (T formal-type-decl nil lex_list nil)
    (transitive? const-decl "bool" relations nil)
    (antisymmetric? const-decl "bool" relations nil)
    (strict_order? const-decl "bool" orders nil)
    (transitive_strict formula-decl nil lex_list nil))
   shostak))
 (strict_total_order 0
  (strict_total_order-1 nil 3578410267
   ("" (use strict_order)
    (("" (use trichotomous) (("" (grind) nil nil)) nil)) nil)
   ((trichotomous formula-decl nil lex_list nil)
    (strict_total_order? const-decl "bool" orders nil)
    (strict_order? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (irreflexive? const-decl "bool" relations nil)
    (trichotomous? const-decl "bool" orders nil)
    (< const-decl "bool" lex_list nil)
    (/= const-decl "boolean" notequal nil)
    (strict_order formula-decl nil lex_list nil))
   shostak)))
(before_list
 (irreflexive 0
  (irreflexive-1 nil 3578414630 ("" (grind) nil nil)
   ((< const-decl "bool" before_list nil)
    (irreflexive? const-decl "bool" relations nil)
    (T formal-type-decl nil before_list nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (member def-decl "bool" list_props nil))
   shostak))
 (transitive 0
  (transitive-1 nil 3578414635
   ("" (expand transitive?)
    (("" (prop)
      (("" (skeep)
        (("" (expand <)
          (("" (prop)
            (("" (skeep)
              (("" (inst - x_1 "car(y)" y!1)
                (("" (inst - x_1 "car(y)")
                  (("" (inst - "car(y)" y!1) (("" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((< const-decl "bool" before_list nil)
    (member def-decl "bool" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (T formal-type-decl nil before_list nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (y skolem-const-decl "list[T]" before_list nil)
    (transitive? const-decl "bool" relations nil))
   shostak))
 (well_founded 0
  (well_founded-1 nil 3578414856
   ("" (expand well_founded?)
    (("" (prop)
      (("" (skeep)
        ((""
          (inst -
           "LAMBDA (x:T): EXISTS (l:list[T]): cons?(l) AND car(l)=x AND p(l)")
          (("" (prop)
            (("1" (skeep)
              (("1" (typepred y)
                (("1" (skeep)
                  (("1" (inst + l)
                    (("1" (skeep)
                      (("1" (inst - "car(x)")
                        (("1" (expand < -5)
                          (("1" (prop)
                            (("1" (inst - "car(x)" y)
                              (("1"
                                (expand member -6)
                                (("1"
                                  (grind)
                                  (("1"
                                    (reveal *)
                                    (("1"
                                      (inst + x)
                                      (("1"
                                        (typepred "x::(p)")
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (inst + x)
                          (("2" (grind)
                            (("2" (reveal *)
                              (("2"
                                (inst 2 x)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (reveal *)
                          (("3" (inst + x) (("3" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skeep)
              (("2" (inst + "car(y)")
                (("1" (inst + y) (("1" (grind) nil nil)) nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil before_list nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (y skolem-const-decl "list[T]" before_list nil)
    (< const-decl "bool" before_list nil)
    (member def-decl "bool" list_props nil)
    (x skolem-const-decl "(p)" before_list nil)
    (l skolem-const-decl "list[T]" before_list nil)
    (p skolem-const-decl "pred[list[T]]" before_list nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (well_founded? const-decl "bool" orders nil))
   shostak))
 (strict_order 0
  (strict_order-1 nil 3578415589
   ("" (use irreflexive)
    (("" (use transitive) (("" (grind) nil nil)) nil)) nil)
   ((transitive formula-decl nil before_list nil)
    (strict_order? const-decl "bool" orders nil)
    (irreflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (< const-decl "bool" before_list nil)
    (irreflexive formula-decl nil before_list nil))
   shostak))
 (strict_well_founded 0
  (strict_well_founded-1 nil 3578415608
   ("" (use strict_order)
    (("" (use well_founded) (("" (grind) nil nil)) nil)) nil)
   ((well_founded formula-decl nil before_list nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (strict_order? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (irreflexive? const-decl "bool" relations nil)
    (well_founded? const-decl "bool" orders nil)
    (< const-decl "bool" before_list nil)
    (strict_order formula-decl nil before_list nil))
   shostak))
 (before_rcons 0
  (before_rcons-1 nil 3578415623
   ("" (lazy-grind :if-match all) nil nil)
   ((< const-decl "bool" before_list nil)
    (member def-decl "bool" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil before_list nil))
   shostak))
 (before_lcons 0
  (before_lcons-1 nil 3578415711
   ("" (lazy-grind :if-match all) nil nil)
   ((< const-decl "bool" before_list nil)
    (member def-decl "bool" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil before_list nil))
   shostak))
 (lcons_before 0
  (lcons_before-1 nil 3578415727
   ("" (lazy-grind :if-match all :rewrites every_forall) nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (< const-decl "bool" before_list nil)
    (T formal-type-decl nil before_list nil)
    (every_forall formula-decl nil more_list_props nil)
    (member def-decl "bool" list_props nil))
   shostak))
 (rcons_before 0
  (rcons_before-1 nil 3578415812
   ("" (lazy-grind :if-match all :rewrites every_forall) nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (< const-decl "bool" before_list nil)
    (T formal-type-decl nil before_list nil)
    (every_forall formula-decl nil more_list_props nil)
    (member def-decl "bool" list_props nil))
   shostak))
 (before_rappend 0
  (before_rappend-1 nil 3578415816
   ("" (lazy-grind :if-match all :rewrites member_append) nil nil)
   ((member def-decl "bool" list_props nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (T formal-type-decl nil before_list nil)
    (member_append formula-decl nil more_list_props nil)
    (< const-decl "bool" before_list nil))
   shostak))
 (before_lappend 0
  (before_lappend-1 nil 3578416096
   ("" (lazy-grind :if-match all :rewrites member_append) nil nil)
   ((member def-decl "bool" list_props nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (T formal-type-decl nil before_list nil)
    (member_append formula-decl nil more_list_props nil)
    (< const-decl "bool" before_list nil))
   shostak))
 (before_lreverse 0
  (before_lreverse-1 nil 3578416171
   (""
    (lazy-grind :if-match all :rewrites member_reverse :exclude
     reverse)
    nil nil)
   ((< const-decl "bool" before_list nil)
    (member_reverse formula-decl nil more_list_props nil)
    (T formal-type-decl nil before_list nil))
   shostak)))
(before_min
 (before_char 0
  (before_char-1 nil 3578419445
   ("" (skeep)
    (("" (prop)
      (("1" (expand <)
        (("1" (all-typepreds)
          (("1" (grind :if-match all :exclude (min max)) nil nil))
          nil))
        nil)
       ("2" (expand <)
        (("2" (all-typepreds)
          (("2" (skeep)
            (("2" (inst - x)
              (("2" (inst - y) (("2" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil before_min nil)
    (list type-decl nil list_adt nil)
    (member def-decl "bool" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (injective? const-decl "bool" functions nil)
    (key formal-const-decl "{k: [T -> real] | injective?(k)}"
     before_min nil)
    (min const-decl
         "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES key(x) <= key(y))}"
         minlist nil)
    (max const-decl
         "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES key(y) <= key(x))}"
         maxlist nil)
    (< const-decl "bool" reals nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (irreflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (strict_order? const-decl "bool" orders nil)
    (trichotomous? const-decl "bool" orders nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (< const-decl "bool" before_list nil)
    (< const-decl "PRED[[T, T]]" before_min nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (rev_key const-decl "real" maxlist nil))
   shostak))
 (before_lchar 0
  (before_lchar-1 nil 3578420599
   ("" (skeep)
    (("" (use before_char)
      (("" (all-typepreds)
        (("" (lazy-grind :if-match all :exclude (min max)) nil nil))
        nil))
      nil))
    nil)
   ((before_char formula-decl nil before_min nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil before_min nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (< const-decl "bool" before_list nil)
    (PRED type-eq-decl nil defined_types nil)
    (< const-decl "PRED[[T, T]]" before_min nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (max const-decl
         "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES key(y) <= key(x))}"
         maxlist nil)
    (min const-decl
         "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES key(x) <= key(y))}"
         minlist nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (key formal-const-decl "{k: [T -> real] | injective?(k)}"
     before_min nil)
    (injective? const-decl "bool" functions nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   shostak))
 (before_rchar 0
  (before_rchar-1 nil 3578420687
   ("" (skeep)
    (("" (use before_char)
      (("" (all-typepreds)
        (("" (lazy-grind :if-match all :exclude (min max)) nil nil))
        nil))
      nil))
    nil)
   ((before_char formula-decl nil before_min nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil before_min nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (< const-decl "bool" before_list nil)
    (PRED type-eq-decl nil defined_types nil)
    (< const-decl "PRED[[T, T]]" before_min nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (max const-decl
         "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES key(y) <= key(x))}"
         maxlist nil)
    (min const-decl
         "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES key(x) <= key(y))}"
         minlist nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (key formal-const-decl "{k: [T -> real] | injective?(k)}"
     before_min nil)
    (injective? const-decl "bool" functions nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   shostak)))
(subword_list)

