(sequents (exists_rule?_TCC1 0 (exists_rule?_TCC1-1 nil 3474915816 ("" (skolem-typepred) (("" (flatten) (("" (generalize "body(car[fmla](G!1))" t) (("" (induct "t") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil) ((s!1 skolem-const-decl "term" sequents nil) (G!1 skolem-const-decl "sequent" sequents nil) (fmla_induction formula-decl nil fmla nil) (member def-decl "bool" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (term type-decl nil fmla nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (var? adt-recognizer-decl "[term -> boolean]" fmla nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (termvars def-decl "list[(var?)]" fmla nil) (f_exists? adt-recognizer-decl "[fmla -> boolean]" fmla nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (freefor def-decl "bool" fmla nil) (body adt-accessor-decl "[(f_exists?) -> fmla]" fmla nil) (sequent type-eq-decl nil sequents nil) (sentence_list? const-decl "bool" fmla nil) (list type-decl nil list_adt nil) (fmla type-decl nil fmla nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (forall_rule?_TCC1 0 (forall_rule?_TCC1-1 nil 3480966110 ("" (skolem-typepred) (("" (flatten) (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil) ((freevars def-decl "list[(var?)]" fmla nil) (freevars def-decl "list[(var?)]" fmla nil) (freesymbols def-decl "list[(usymb?)]" fmla nil) (freesymbols def-decl "list[(usymb?)]" fmla nil) (fun? adt-def-decl "boolean" funpred_adt nil) (sequent type-eq-decl nil sequents nil) (sentence_list? const-decl "bool" fmla nil) (list type-decl nil list_adt nil) (fmla type-decl nil fmla nil) (ufun? adt-recognizer-decl "[funpred -> boolean]" funpred_adt nil) (funpred type-decl nil funpred_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (forall_rule?_TCC2 0 (forall_rule?_TCC2-1 nil 3480966110 ("" (skolem-typepred) (("" (flatten) (("" (grind) nil nil)) nil)) nil) ((length def-decl "nat" list_props nil) (sequent type-eq-decl nil sequents nil) (sentence_list? const-decl "bool" fmla nil) (list type-decl nil list_adt nil) (fmla type-decl nil fmla nil) (ufun? adt-recognizer-decl "[funpred -> boolean]" funpred_adt nil) (funpred type-decl nil funpred_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (forall_rule?_TCC3 0 (forall_rule?_TCC3-1 nil 3480966110 ("" (skolem-typepred) (("" (flatten) (("" (generalize "body(arg(car[fmla](G!1)))" t) (("" (induct t) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil)) nil) ((f!1 skolem-const-decl "(ufun?)" sequents nil) (G!1 skolem-const-decl "sequent" sequents nil) (fmla_induction formula-decl nil fmla nil) (reduce adt-def-decl "[list -> range]" list_adt_reduce nil) (freesymbols def-decl "list[(usymb?)]" fmla nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (arity shared-adt-accessor-decl "[funpred -> nat]" funpred_adt nil) (f_exists? adt-recognizer-decl "[fmla -> boolean]" fmla nil) (f_not? adt-recognizer-decl "[fmla -> boolean]" fmla nil) (arg adt-accessor-decl "[(f_not?) -> fmla]" fmla nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (usymb? const-decl "bool" fmla nil) (freesymbols def-decl "list[(usymb?)]" fmla nil) (term type-decl nil fmla nil) (var? adt-recognizer-decl "[term -> boolean]" fmla nil) (freefor def-decl "bool" fmla nil) (body adt-accessor-decl "[(f_exists?) -> fmla]" fmla nil) (termvars def-decl "list[(var?)]" fmla nil) (fun? adt-def-decl "boolean" funpred_adt nil) (length def-decl "nat" list_props nil) (apply? adt-recognizer-decl "[term -> boolean]" fmla nil) (apply adt-constructor-decl "[[fun: (fun?), {ss: list[term] | length(ss) = arity(fun)}] -> (apply?)]" fmla nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (sequent type-eq-decl nil sequents nil) (sentence_list? const-decl "bool" fmla nil) (list type-decl nil list_adt nil) (fmla type-decl nil fmla nil) (ufun? adt-recognizer-decl "[funpred -> boolean]" funpred_adt nil) (funpred type-decl nil funpred_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (f_eq_TCC1 0 (f_eq_TCC1-1 nil 3480966110 ("" (grind) nil nil) ((pred? adt-def-decl "boolean" funpred_adt nil)) nil)) (f_eq_TCC2 0 (f_eq_TCC2-1 nil 3480966110 ("" (subtype-tcc) (("" (grind) nil nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) nil)) (f_lhs_TCC1 0 (f_lhs_TCC1-1 nil 3480966110 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (fmla type-decl nil fmla nil) (equality? const-decl "bool" sequents nil)) nil)) (f_lhs_TCC2 0 (f_lhs_TCC2-1 nil 3480966110 ("" (skolem-typepred) (("" (expand equality?) (("" (flatten) (("" (assert) (("" (tcc) (("" (auto-rewrite-theory "fmla") (("" (decompose-equality -2) (("" (typepred "args(A!1)") (("" (replace -3 -1) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((args adt-accessor-decl "[d: (atom?) -> {ss: list[term] | length(ss) = arity(pred(d))}]" fmla nil) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (term type-decl nil fmla nil) (arity shared-adt-accessor-decl "[funpred -> nat]" funpred_adt nil) (ipred adt-constructor-decl "[[nat, nat] -> (ipred?)]" funpred_adt nil) (index shared-adt-accessor-decl "[funpred -> nat]" funpred_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (pred adt-accessor-decl "[(atom?) -> (pred?)]" fmla nil) (pred? adt-def-decl "boolean" funpred_adt nil) (atom? adt-recognizer-decl "[fmla -> boolean]" fmla nil) (ipred? adt-recognizer-decl "[funpred -> boolean]" funpred_adt nil) (funpred type-decl nil funpred_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (equality? const-decl "bool" sequents nil) (fmla type-decl nil fmla nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (f_rhs_TCC1 0 (f_rhs_TCC1-1 nil 3480966110 ("" (subtype-tcc) (("" (decompose-equality -2) (("" (typepred "args(A!1)") (("" (replace -3 -1) (("" (grind) (("" (expand length) (("" (lift-if) (("" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((AND const-decl "[bool, bool -> bool]" booleans nil) (funpred type-decl nil funpred_adt nil) (ipred? adt-recognizer-decl "[funpred -> boolean]" funpred_adt nil) (atom? adt-recognizer-decl "[fmla -> boolean]" fmla nil) (pred? adt-def-decl "boolean" funpred_adt nil) (pred adt-accessor-decl "[(atom?) -> (pred?)]" fmla nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index shared-adt-accessor-decl "[funpred -> nat]" funpred_adt nil) (ipred adt-constructor-decl "[[nat, nat] -> (ipred?)]" funpred_adt nil) (arity shared-adt-accessor-decl "[funpred -> nat]" funpred_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (term type-decl nil fmla nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (args adt-accessor-decl "[d: (atom?) -> {ss: list[term] | length(ss) = arity(pred(d))}]" fmla nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (fmla type-decl nil fmla nil) (equality? const-decl "bool" sequents nil)) nil)) (refl_equality?_TCC1 0 (refl_equality?_TCC1-1 nil 3474915816 ("" (subtype-tcc) nil nil) ((equality? const-decl "bool" sequents nil)) nil)) (refl_equality?_TCC2 0 (refl_equality?_TCC2-1 nil 3474915816 ("" (subtype-tcc) (("" (decompose-equality -2) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (funpred type-decl nil funpred_adt nil) (ipred? adt-recognizer-decl "[funpred -> boolean]" funpred_adt nil) (fmla type-decl nil fmla nil) (atom? adt-recognizer-decl "[fmla -> boolean]" fmla nil) (pred? adt-def-decl "boolean" funpred_adt nil) (pred adt-accessor-decl "[(atom?) -> (pred?)]" fmla nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index shared-adt-accessor-decl "[funpred -> nat]" funpred_adt nil) (ipred adt-constructor-decl "[[nat, nat] -> (ipred?)]" funpred_adt nil) (arity shared-adt-accessor-decl "[funpred -> nat]" funpred_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (equality? const-decl "bool" sequents nil)) nil)) (refl_equality?_TCC3 0 (refl_equality?_TCC3-1 nil 3474915816 ("" (subtype-tcc) (("" (decompose-equality -2) nil nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (funpred type-decl nil funpred_adt nil) (ipred? adt-recognizer-decl "[funpred -> boolean]" funpred_adt nil) (fmla type-decl nil fmla nil) (atom? adt-recognizer-decl "[fmla -> boolean]" fmla nil) (pred? adt-def-decl "boolean" funpred_adt nil) (pred adt-accessor-decl "[(atom?) -> (pred?)]" fmla nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index shared-adt-accessor-decl "[funpred -> nat]" funpred_adt nil) (ipred adt-constructor-decl "[[nat, nat] -> (ipred?)]" funpred_adt nil) (arity shared-adt-accessor-decl "[funpred -> nat]" funpred_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (equality? const-decl "bool" sequents nil)) nil)) (fcongruence_rule?_TCC1 0 (fcongruence_rule?_TCC1-1 nil 3480966110 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (fmla type-decl nil fmla nil) (list type-decl nil list_adt nil) (sentence_list? const-decl "bool" fmla nil) (sequent type-eq-decl nil sequents nil) (equality? const-decl "bool" sequents nil)) nil)) (fcongruence_rule?_TCC2 0 (fcongruence_rule?_TCC2-1 nil 3480966110 ("" (skolem-typepred) (("" (flatten) (("" (expand equality?) (("" (flatten) (("" (decompose-equality -3) (("" (typepred "args(car(G!1))") (("" (replace -4 -1) (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((term type-decl nil fmla nil) (length def-decl "nat" list_props nil) (args adt-accessor-decl "[d: (atom?) -> {ss: list[term] | length(ss) = arity(pred(d))}]" fmla nil) (arity shared-adt-accessor-decl "[funpred -> nat]" funpred_adt nil) (ipred adt-constructor-decl "[[nat, nat] -> (ipred?)]" funpred_adt nil) (index shared-adt-accessor-decl "[funpred -> nat]" funpred_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (pred adt-accessor-decl "[(atom?) -> (pred?)]" fmla nil) (pred? adt-def-decl "boolean" funpred_adt nil) (atom? adt-recognizer-decl "[fmla -> boolean]" fmla nil) (ipred? adt-recognizer-decl "[funpred -> boolean]" funpred_adt nil) (funpred type-decl nil funpred_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (equality? const-decl "bool" sequents nil) (sequent type-eq-decl nil sequents nil) (sentence_list? const-decl "bool" fmla nil) (list type-decl nil list_adt nil) (fmla type-decl nil fmla nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (fcongruence_rule?_TCC3 0 (fcongruence_rule?_TCC3-1 nil 3480966110 ("" (subtype-tcc) (("" (decompose-equality -3) (("" (typepred "args(car(G!1))") (("" (replace -3 -1) (("" (expand length) (("" (lift-if) (("" (split) (("1" (assert) nil nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((AND const-decl "[bool, bool -> bool]" booleans nil) (funpred type-decl nil funpred_adt nil) (ipred? adt-recognizer-decl "[funpred -> boolean]" funpred_adt nil) (atom? adt-recognizer-decl "[fmla -> boolean]" fmla nil) (pred? adt-def-decl "boolean" funpred_adt nil) (pred adt-accessor-decl "[(atom?) -> (pred?)]" fmla nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index shared-adt-accessor-decl "[funpred -> nat]" funpred_adt nil) (ipred adt-constructor-decl "[[nat, nat] -> (ipred?)]" funpred_adt nil) (arity shared-adt-accessor-decl "[funpred -> nat]" funpred_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (args adt-accessor-decl "[d: (atom?) -> {ss: list[term] | length(ss) = arity(pred(d))}]" fmla nil) (length def-decl "nat" list_props nil) (term type-decl nil fmla nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (fmla type-decl nil fmla nil) (list type-decl nil list_adt nil) (sentence_list? const-decl "bool" fmla nil) (sequent type-eq-decl nil sequents nil) (equality? const-decl "bool" sequents nil)) nil)))
