(smap
 (smap_length 0
  (smap_length-1 nil 3578330746 ("" (grind) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (smap const-decl "{vs | vs`length = ks`length}" smap nil))
   shostak))
 (smap_seq_TCC1 0
  (smap_seq_TCC1-1 nil 3578325651 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (smap const-decl "{vs | vs`length = ks`length}" smap nil))
   nil))
 (smap_seq 0
  (smap_seq-1 nil 3578330751 ("" (grind) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (smap const-decl "{vs | vs`length = ks`length}" smap nil))
   shostak)))
(setmap)
(set_props)
(more_finseq_props
 (findi_TCC1 0
  (findi_TCC1-1 nil 3578323667 ("" (subtype-tcc) nil nil) nil nil))
 (findi_TCC2 0
  (findi_TCC2-1 nil 3578323667 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (T formal-type-decl nil more_finseq_props nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (findi_TCC3 0
  (findi_TCC3-1 nil 3578323667 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (T formal-type-decl nil more_finseq_props nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (findi_TCC4 0
  (findi_TCC4-1 nil 3578323667 ("" (termination-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (findi_exists_TCC1 0
  (findi_exists_TCC1-1 nil 3578323967 ("" (subtype-tcc) nil nil) nil
   nil))
 (findi_exists 0
  (findi_exists-1 nil 3578324082
   ("" (measure-induct "s`length - i" (s i))
    (("1" (grind :if-match nil)
      (("1" (inst - "x!1" "2 + x!2") (("1" (grind) nil nil)) nil)) nil)
     ("2" (grind) nil nil) ("3" (grind) nil nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    nil nil nil
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (findi def-decl
     "lift[{i: below(s`length) | p(finseq_appl[T](s)(i))}]"
     more_finseq_props nil)
    (up? adt-recognizer-decl "[lift -> boolean]" lift_adt nil)
    (below type-eq-decl nil naturalnumbers nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (lift type-decl nil lift_adt nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (subrange type-eq-decl nil integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (T formal-type-decl nil more_finseq_props nil)
    (measure_induction formula-decl nil measure_induction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (find_TCC1 0
  (find_TCC1-1 nil 3578323667 ("" (subtype-tcc) nil nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (find_exists 0
  (find_exists-1 nil 3578324273
   ("" (expand find)
    (("" (lemma findi_exists) (("" (grind) nil nil)) nil)) nil)
   ((findi_exists formula-decl nil more_finseq_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (findi def-decl
     "lift[{i: below(s`length) | p(finseq_appl[T](s)(i))}]"
     more_finseq_props nil)
    nil nil (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (subrange type-eq-decl nil integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pred type-eq-decl nil defined_types nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (T formal-type-decl nil more_finseq_props nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (find const-decl
          "lift[{i: below(s`length) | p(finseq_appl[T](s)(i))}]"
      more_finseq_props nil))
   shostak))
 (every_aux_TCC1 0
  (every_aux_TCC1-1 nil 3578756616 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (T formal-type-decl nil more_finseq_props nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (every_aux_TCC2 0
  (every_aux_TCC2-1 nil 3578756616 ("" (termination-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (every_aux_forall_TCC1 0
  (every_aux_forall_TCC1-1 nil 3578756616
   ("" (recursive-judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (T formal-type-decl nil more_finseq_props nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (subrange type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil))
   nil))
 (every_aux_forall_TCC2 0
  (every_aux_forall_TCC2-1 nil 3578756616
   ("" (grind :if-match nil)
    (("1" (grind :if-match all) nil nil)
     ("2" (rewrite -1) (("2" (skeep) (("2" (grind) nil nil)) nil)) nil)
     ("3" (grind) nil nil))
    nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (subrange type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (T formal-type-decl nil more_finseq_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields
       nil))
   nil))
 (every_forall 0
  (every_forall-1 nil 3578756616
   ("" (expand every)
    (("" (use every_aux_forall)
      (("" (skeep)
        (("" (inst?)
          (("" (rewrite -1)
            (("" (iff)
              (("" (prop)
                (("1" (skeep) (("1" (inst -1 i) nil nil)) nil)
                 ("2" (skeep) (("2" (inst -1 j) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((every_aux_forall recursive-judgement-axiom nil more_finseq_props
     nil)
    (T formal-type-decl nil more_finseq_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (subrange type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (every const-decl "bool" more_finseq_props nil))
   nil)))
(wf_pair
 (wf_pair 0
  (wf_pair-1 nil 3578676333
   ("" (comment "Introduce well-foundedness hypothesis")
    (("" (typepred le_l)
      (("" (typepred le_r)
        (("" (comment "Use well-foundedness on left-hand side")
          (("" (expand well_founded?)
            (("" (skeep)
              (("" (inst -2 "LAMBDA (l: L): EXISTS (r: R): p(l, r)")
                (("" (prop)
                  (("1"
                    (comment "Use well-foundedness on right-hand side")
                    (("1" (skeep)
                      (("1" (typepred y)
                        (("1" (inst -3 "LAMBDA (r: R): p(y, r)")
                          (("1" (prop)
                            (("1" (skeep)
                              (("1"
                                (typepred y_1)
                                (("1"
                                  (inst 1 "(y, y_1)")
                                  (("1"
                                    (skeep)
                                    (("1"
                                      (typepred x)
                                      (("1"
                                        (comment
                                         "Deduce well-foundedness on pair")
                                        (("1"
                                          (expand le)
                                          (("1"
                                            (eta "[L, R]")
                                            (("1"
                                              (prop)
                                              (("1" (grind) nil nil)
                                               ("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          ";;; Deduce well-foundedness on pair"))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      ";;; Use well-foundedness on right-hand side"))
                    nil)
                   ("2"
                    (comment "Prove that p(x) => p(x`1, x`2). So fun.")
                    (("2" (skeep)
                      (("2" (inst 1 "y`1")
                        (("2" (inst 1 "y`2") (("2" (grind) nil nil))
                          nil))
                        nil))
                      ";;; Prove that p(x) => p(x`1, x`2). So fun."))
                    nil))
                  nil))
                nil))
              nil))
            ";;; Use well-foundedness on left-hand side"))
          nil))
        nil))
      ";;; Introduce well-foundedness hypothesis"))
    nil)
   ((le_l formal-const-decl "(well_founded?[L])" wf_pair nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (L formal-type-decl nil wf_pair nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (le const-decl "bool" wf_pair nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (R formal-type-decl nil wf_pair nil)
    (le_r formal-const-decl "(well_founded?[R])" wf_pair nil))
   nil)))
(more_relations_props
 (TC_left_is_TC 0
  (TC_left_is_TC-1 nil 3579465258
   ("" (apply-extensionality :hide? t)
    (("" (apply-extensionality :hide? t)
      (("" (iff)
        (("" (prop)
          (("1" (rule-induct TC_left)
            (("1" (grind)
              (("1" (expand TC) (("1" (propax) nil nil)) nil)
               ("2" (expand TC 1)
                (("2" (grind)
                  (("2" (expand TC 2) (("2" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (rule-induct TC)
            (("2" (grind :if-match nil)
              (("1" (expand TC_left) (("1" (propax) nil nil)) nil)
               ("2" (hide -1)
                (("2" (rule-induct TC_left)
                  (("2" (reveal *)
                    (("2" (skosimp*)
                      (("2" (prop)
                        (("1" (expand TC_left +)
                          (("1" (grind) nil nil)) nil)
                         ("2" (expand TC_left +)
                          (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TC_left_weak_induction formula-decl nil more_relations_props nil)
    (TC_weak_induction formula-decl nil relations nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (TC_left inductive-decl "bool" more_relations_props nil)
    (TC inductive-decl "bool" relations nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil more_relations_props nil))
   shostak))
 (TC_right_is_TC 0
  (TC_right_is_TC-1 nil 3579465688
   ("" (apply-extensionality :hide? t)
    (("" (apply-extensionality :hide? t)
      (("" (iff)
        (("" (prop)
          (("1" (rule-induct TC_right)
            (("1" (grind)
              (("1" (expand TC) (("1" (propax) nil nil)) nil)
               ("2" (expand TC +)
                (("2" (grind)
                  (("2" (expand TC +) (("2" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (rule-induct TC)
            (("2" (grind :if-match nil)
              (("1" (expand TC_right) (("1" (propax) nil nil)) nil)
               ("2" (rule-induct TC_right)
                (("2" (reveal *)
                  (("2" (skosimp*)
                    (("2" (prop)
                      (("1" (expand TC_right +) (("1" (grind) nil nil))
                        nil)
                       ("2" (expand TC_right +) (("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TC_right_weak_induction formula-decl nil more_relations_props nil)
    (TC_weak_induction formula-decl nil relations nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (TC_right inductive-decl "bool" more_relations_props nil)
    (TC inductive-decl "bool" relations nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil more_relations_props nil))
   shostak))
 (TC_expand_left 0
  (TC_expand_left-1 nil 3579465804
   ("" (rewrite TC_left_is_TC :dir rl)
    (("" (expand TC_left 1 1) (("" (propax) nil nil)) nil)) nil)
   ((TC_left inductive-decl "bool" more_relations_props nil)
    (TC_left_is_TC formula-decl nil more_relations_props nil))
   shostak))
 (TC_expand_right 0
  (TC_expand_right-1 nil 3579465901
   ("" (rewrite TC_right_is_TC :dir rl)
    (("" (expand TC_right 1 1) (("" (propax) nil nil)) nil)) nil)
   ((TC_right inductive-decl "bool" more_relations_props nil)
    (TC_right_is_TC formula-decl nil more_relations_props nil))
   shostak))
 (TC_is_extension 0
  (TC_is_extension-1 nil 3579466107
   ("" (grind) (("" (expand TC) (("" (propax) nil nil)) nil)) nil)
   ((TC inductive-decl "bool" relations nil)) shostak))
 (TC_is_transitive 0
  (TC_is_transitive-1 nil 3579466107
   ("" (grind) (("" (expand TC +) (("" (grind) nil nil)) nil)) nil)
   ((TC inductive-decl "bool" relations nil)
    (T formal-type-decl nil more_relations_props nil)
    (transitive? const-decl "bool" relations nil))
   nil))
 (TC_LFP 0
  (TC_LFP-1 nil 3579466142
   ("" (grind :if-match nil)
    (("" (rule-induct TC)
      (("" (grind :if-match nil)
        (("1" (grind) nil nil)
         ("2" (inst -4 "x!2" "z!1" "y!2") (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((TC_weak_induction formula-decl nil relations nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (T formal-type-decl nil more_relations_props nil)
    (TC_is_transitive application-judgement "(transitive?[T])"
     more_relations_props nil)
    (transitive? const-decl "bool" relations nil))
   shostak))
 (TC_idempotent 0
  (TC_idempotent-1 nil 3579466225
   ("" (skeep)
    (("" (apply-extensionality :hide? t)
      (("" (iff)
        (("" (prop)
          (("1" (rule-induct TC)
            (("1" (grind :if-match nil)
              (("1" (inst -3 "x!3" "z!1" "y!1") (("1" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (expand TC) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil more_relations_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (TC inductive-decl "bool" relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TC_is_transitive application-judgement "(transitive?[T])"
     more_relations_props nil)
    (transitive? const-decl "bool" relations nil)
    (TC_weak_induction formula-decl nil relations nil))
   shostak))
 (TC_preserves_reflexive 0
  (TC_preserves_reflexive-1 nil 3579466378
   ("" (grind) (("" (expand TC) (("" (propax) nil nil)) nil)) nil)
   ((TC inductive-decl "bool" relations nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_relations_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (TC_is_transitive application-judgement "(transitive?[T])"
     more_relations_props nil)
    (reflexive? const-decl "bool" relations nil))
   nil))
 (TC_preserves_symmetric 0
  (TC_preserves_symmetric-1 nil 3579466378
   ("" (grind :if-match nil)
    (("" (rule-induct TC)
      (("" (grind :if-match nil)
        (("1" (inst -2 x!2 y!2)
          (("1" (expand TC) (("1" (grind) nil nil)) nil)) nil)
         ("2" (expand TC +) (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((TC_weak_induction formula-decl nil relations nil)
    (TC inductive-decl "bool" relations nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_relations_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (TC_is_transitive application-judgement "(transitive?[T])"
     more_relations_props nil)
    (symmetric? const-decl "bool" relations nil))
   nil))
 (TC_preserves_connected 0
  (TC_preserves_connected-1 nil 3579466378
   ("" (grind)
    (("1" (expand TC +) (("1" (propax) nil nil)) nil)
     ("2" (expand TC +) (("2" (propax) nil nil)) nil))
    nil)
   ((TC inductive-decl "bool" relations nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_relations_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (TC_is_transitive application-judgement "(transitive?[T])"
     more_relations_props nil)
    (connected? const-decl "bool" relations nil)
    (/= const-decl "boolean" notequal nil))
   nil))
 (RC_is_extension 0
  (RC_is_extension-1 nil 3579466645 ("" (judgement-tcc) nil nil)
   ((RC const-decl "bool" relations nil)) shostak))
 (RC_is_reflexive 0
  (RC_is_reflexive-1 nil 3579466644 ("" (judgement-tcc) nil nil)
   ((RC const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil))
   nil))
 (RC_LFP 0
  (RC_LFP-1 nil 3579466663 ("" (judgement-tcc) nil nil)
   ((T formal-type-decl nil more_relations_props nil)
    (reflexive? const-decl "bool" relations nil)
    (RC const-decl "bool" relations nil))
   shostak))
 (RC_idempotent 0
  (RC_idempotent-1 nil 3579466672 ("" (grind-with-ext) nil nil)
   ((bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (RC const-decl "bool" relations nil)
    (RC_is_reflexive application-judgement "(reflexive?[T])"
     more_relations_props nil)
    (T formal-type-decl nil more_relations_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (reflexive? const-decl "bool" relations nil))
   shostak))
 (RC_preserves_transitive 0
  (RC_preserves_transitive-1 nil 3579466740
   ("" (grind :if-match nil)
    (("" (inst -1 x!1 y!1 z!1) (("" (grind) nil nil)) nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_relations_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (RC_is_reflexive application-judgement "(reflexive?[T])"
     more_relations_props nil)
    (transitive? const-decl "bool" relations nil)
    (RC const-decl "bool" relations nil))
   nil))
 (RC_preserves_symmetric 0
  (RC_preserves_symmetric-1 nil 3579466740
   ("" (grind :if-match all) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_relations_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (RC const-decl "bool" relations nil)
    (symmetric? const-decl "bool" relations nil)
    (RC_is_reflexive application-judgement "(reflexive?[T])"
     more_relations_props nil))
   nil))
 (RC_preserves_connected 0
  (RC_preserves_connected-1 nil 3579466740 ("" (judgement-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_relations_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (/= const-decl "boolean" notequal nil)
    (RC const-decl "bool" relations nil)
    (connected? const-decl "bool" relations nil)
    (RC_is_reflexive application-judgement "(reflexive?[T])"
     more_relations_props nil))
   nil))
 (RTC_is_RC_TC 0
  (RTC_is_RC_TC-1 nil 3579466897 ("" (grind-with-ext) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil more_relations_props nil)
    (RC_is_reflexive application-judgement "(reflexive?[T])"
     more_relations_props nil)
    (RC_preserves_transitive application-judgement "(transitive?[T])"
     more_relations_props nil)
    (TC_is_transitive application-judgement "(transitive?[T])"
     more_relations_props nil)
    (TC inductive-decl "bool" relations nil)
    (RC const-decl "bool" relations nil)
    (RTC const-decl "bool" relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil))
   shostak))
 (RTC_is_TC_RC 0
  (RTC_is_TC_RC-1 nil 3579466909
   ("" (grind-with-ext :if-match nil)
    (("1" (all-typepreds) (("1" (grind) nil nil)) nil)
     ("2" (rule-induct TC)
      (("2" (grind)
        (("1" (lemma RC_is_extension)
          (("1" (lemma TC_is_extension) (("1" (grind) nil nil)) nil))
          nil)
         ("2" (all-typepreds)
          (("2" (expand transitive?)
            (("2" (inst -2 x!3 z!1 y!1) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (rule-induct TC)
      (("3" (grind)
        (("1" (expand TC) (("1" (propax) nil nil)) nil)
         ("2" (all-typepreds)
          (("2" (expand transitive?)
            (("2" (inst -1 x!3 z!1 y!1) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (TC_weak_induction formula-decl nil relations nil)
    (RC_is_extension formula-decl nil more_relations_props nil)
    (TC_is_extension formula-decl nil more_relations_props nil)
    (reflexive? const-decl "bool" relations nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (transitive? const-decl "bool" relations nil)
    (RC_is_reflexive application-judgement "(reflexive?[T])"
     more_relations_props nil)
    (TC_preserves_reflexive application-judgement "(reflexive?[T])"
     more_relations_props nil)
    (TC_is_transitive application-judgement "(transitive?[T])"
     more_relations_props nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (RTC const-decl "bool" relations nil)
    (TC inductive-decl "bool" relations nil)
    (RC const-decl "bool" relations nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil more_relations_props nil))
   shostak))
 (RTC_is_extension 0
  (RTC_is_extension-1 nil 3579467212
   (""
    (grind-with-lemmas :rewrites RTC_is_RC_TC :lemmas
     (TC_is_extension RC_is_extension))
    nil nil)
   ((TC_is_extension formula-decl nil more_relations_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil more_relations_props nil)
    (RC const-decl "bool" relations nil)
    (RTC_is_RC_TC formula-decl nil more_relations_props nil)
    (RC_is_reflexive application-judgement "(reflexive?[T])"
     more_relations_props nil)
    (RC_preserves_transitive application-judgement "(transitive?[T])"
     more_relations_props nil)
    (TC_is_transitive application-judgement "(transitive?[T])"
     more_relations_props nil)
    (TC inductive-decl "bool" relations nil)
    (RC_is_extension formula-decl nil more_relations_props nil))
   shostak))
 (RTC_is_reflexive 0
  (RTC_is_reflexive-1 nil 3579467210
   ("" (grind :rewrites RTC_is_RC_TC) nil nil)
   ((RTC_is_RC_TC formula-decl nil more_relations_props nil)
    (RC_is_reflexive application-judgement "(reflexive?[T])"
     more_relations_props nil)
    (RC_preserves_transitive application-judgement "(transitive?[T])"
     more_relations_props nil))
   nil))
 (RTC_is_transitive 0
  (RTC_is_transitive-1 nil 3579467210
   ("" (grind :rewrites RTC_is_TC_RC) nil nil)
   ((RTC_is_TC_RC formula-decl nil more_relations_props nil)
    (TC_is_transitive application-judgement "(transitive?[T])"
     more_relations_props nil)
    (TC_preserves_reflexive application-judgement "(reflexive?[T])"
     more_relations_props nil))
   nil))
 (RTC_LFP 0
  (RTC_LFP-1 nil 3579467334
   (""
    (grind-with-lemmas :rewrites RTC_is_RC_TC :lemmas (TC_LFP RC_LFP))
    nil nil)
   ((TC_LFP formula-decl nil more_relations_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil more_relations_props nil)
    (RC const-decl "bool" relations nil)
    (RTC_is_RC_TC formula-decl nil more_relations_props nil)
    (transitive? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (RTC_is_transitive application-judgement "(transitive?[T])"
     more_relations_props nil)
    (RTC_is_reflexive application-judgement "(reflexive?[T])"
     more_relations_props nil)
    (RC_preserves_transitive application-judgement "(transitive?[T])"
     more_relations_props nil)
    (RC_is_reflexive application-judgement "(reflexive?[T])"
     more_relations_props nil)
    (TC_is_transitive application-judgement "(transitive?[T])"
     more_relations_props nil)
    (TC inductive-decl "bool" relations nil)
    (RC_LFP formula-decl nil more_relations_props nil))
   shostak))
 (RTC_idempotent 0
  (RTC_idempotent-1 nil 3579467354
   (""
    (grind-with-lemmas :rewrites RTC_is_RC_TC :lemmas
     (TC_idempotent RC_idempotent))
    nil nil)
   ((TC_idempotent formula-decl nil more_relations_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil more_relations_props nil)
    (reflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (RTC_is_RC_TC formula-decl nil more_relations_props nil)
    (RC_preserves_transitive application-judgement "(transitive?[T])"
     more_relations_props nil)
    (RTC_is_reflexive application-judgement "(reflexive?[T])"
     more_relations_props nil)
    (RTC_is_transitive application-judgement "(transitive?[T])"
     more_relations_props nil)
    (TC_is_transitive application-judgement "(transitive?[T])"
     more_relations_props nil)
    (RC_is_reflexive application-judgement "(reflexive?[T])"
     more_relations_props nil)
    (RC_idempotent formula-decl nil more_relations_props nil))
   shostak))
 (RTC_preserves_symmetric 0
  (RTC_preserves_symmetric-1 nil 3579467210
   ("" (grind :rewrites RTC_is_RC_TC) nil nil)
   ((RTC_is_RC_TC formula-decl nil more_relations_props nil)
    (RC_is_reflexive application-judgement "(reflexive?[T])"
     more_relations_props nil)
    (RC_preserves_transitive application-judgement "(transitive?[T])"
     more_relations_props nil)
    (RC_preserves_symmetric application-judgement "(symmetric?[T])"
     more_relations_props nil))
   nil))
 (RTC_preserves_connected 0
  (RTC_preserves_connected-1 nil 3579467210
   ("" (grind :rewrites RTC_is_RC_TC) nil nil)
   ((RTC_is_RC_TC formula-decl nil more_relations_props nil)
    (RC_is_reflexive application-judgement "(reflexive?[T])"
     more_relations_props nil)
    (RC_preserves_transitive application-judgement "(transitive?[T])"
     more_relations_props nil)
    (RC_preserves_connected application-judgement "(connected?[T])"
     more_relations_props nil))
   nil)))
(more_orders_props
 (decreasing_seq_TCC1 0
  (decreasing_seq_TCC1-1 nil 3579464544 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_orders_props nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (decreasing_seq_TCC2 0
  (decreasing_seq_TCC2-1 nil 3579464544 ("" (termination-tcc) nil nil)
   nil nil))
 (decreasing_seq_TCC3 0
  (decreasing_seq_TCC3-1 nil 3579464544 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_orders_props nil)
    (set type-eq-decl nil sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (extend const-decl "R" extend nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil))
   nil))
 (decreasing_seq_TCC4 0
  (decreasing_seq_TCC4-1 nil 3579468036
   ("" (grind) (("" (all-typepreds) (("" (grind) nil nil)) nil)) nil)
   ((choose const-decl "(p)" sets nil)
    (extend const-decl "R" extend nil)
    (FALSE const-decl "bool" booleans nil)
    (even? const-decl "bool" integers nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (odd? const-decl "bool" integers nil)
    (> const-decl "bool" reals nil)
    (strict_total_order? const-decl "bool" orders nil)
    (irreflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (strict_order? const-decl "bool" orders nil)
    (trichotomous? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (partial_order? const-decl "bool" orders nil)
    (dichotomous? const-decl "bool" orders nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_orders_props nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil))
   nil))
 (decreasing_seq_decreases 0
  (decreasing_seq_decreases-1 nil 3579468036
   ("" (grind) (("" (all-typepreds) (("" (grind) nil nil)) nil)) nil)
   ((choose const-decl "(p)" sets nil)
    (extend const-decl "R" extend nil)
    (FALSE const-decl "bool" booleans nil)
    (even? const-decl "bool" integers nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (reflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (partial_order? const-decl "bool" orders nil)
    (dichotomous? const-decl "bool" orders nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_orders_props nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (decreasing_seq def-decl "(S)" more_orders_props nil))
   shostak))
 (well_founded_decreasing 0
  (well_founded_decreasing-1 nil 3579369429
   ("" (expand well_founded?)
    (("" (skeep)
      (("" (prop)
        (("1" (skeep)
          (("1" (inst -1 "{ x | EXISTS n: x = f(n) }")
            (("1" (grind :if-match nil)
              (("1" (inst -4 n!1)
                (("1" (inst -3 "f(n!1 + 1)")
                  (("1" (grind) nil nil)
                   ("2" (inst 1 "1 + n!1") nil nil))
                  nil))
                nil)
               ("2" (inst 1 "f(42)") (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (inst 1 "decreasing_seq(<)(p)")
            (("1" (skeep)
              (("1" (use decreasing_seq_decreases ("n" "n"))
                (("1" (grind) nil nil)) nil))
              nil)
             ("2" (prop)
              (("1" (grind) nil nil)
               ("2" (skeep)
                (("2" (inst 2 x)
                  (("2" (skeep) (("2" (inst 1 x_1) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (decreasing_seq_decreases judgement-tcc nil more_orders_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (decreasing_seq def-decl "(S)" more_orders_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil) nil
    (PRED type-eq-decl nil defined_types nil) nil
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    nil (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil more_orders_props nil)
    (well_founded? const-decl "bool" orders nil))
   shostak))
 (well_founded_is_irreflexive 0
  (well_founded_is_irreflexive-1 nil 3579271081
   ("" (skolem 1 "<" :skolem-typepreds? t)
    (("" (expand (well_founded? irreflexive?))
      (("" (skeep)
        (("" (inst -1 "LAMBDA y: y = x") (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((irreflexive? const-decl "bool" relations nil)
    (well_founded? const-decl "bool" orders nil)
    (T formal-type-decl nil more_orders_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   nil))
 (well_founded_is_antisymmetric 0
  (well_founded_is_antisymmetric-1 nil 3579271081
   ("" (skolem 1 "<" :skolem-typepreds? t)
    (("" (expand (well_founded? antisymmetric?))
      (("" (skeep)
        (("" (inst -1 "LAMBDA (z: T): z = x OR z = y")
          (("" (grind :if-match nil)
            (("1" (inst -2 y) nil nil) ("2" (inst -2 x) nil nil)
             ("3" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((antisymmetric? const-decl "bool" relations nil)
    (well_founded? const-decl "bool" orders nil)
    (T formal-type-decl nil more_orders_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   nil))
 (restrict_well_founded 0
  (restrict_well_founded-1 nil 3579458062
   ("" (skeep)
    (("" (expand well_founded?)
      (("" (skeep)
        (("" (inst -1 p)
          (("" (prop)
            (("" (skolem-typepred)
              (("" (inst 1 y!1)
                (("" (skolem-typepred 1)
                  (("" (inst -3 x!1) (("" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((well_founded? const-decl "bool" orders nil)
    (T formal-type-decl nil more_orders_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   shostak))
 (TC_preserves_well_founded 0
  (TC_preserves_well_founded-1 nil 3579369063
   ("" (skeep)
    (("" (typepred R)
      (("" (expand well_founded?)
        (("" (skeep)
          ((""
            (inst -1
             "{ x | p(x) OR EXISTS (y, z): p(y) AND p(z) AND TC(R)(y, x) AND TC(R)(x, z) }")
            (("" (prop)
              (("1" (skolem-typepred)
                (("1" (prop)
                  (("1" (inst 1 y!1)
                    (("1" (skolem-typepred 1)
                      (("1" (rewrite TC_expand_left -5)
                        (("1" (prop)
                          (("1" (grind) nil nil)
                           ("2" (skeep)
                            (("2" (inst -5 z)
                              (("2"
                                (flatten)
                                (("2"
                                  (inst 2 "x!1" "y!1")
                                  (("2"
                                    (grind)
                                    (("2"
                                      (expand TC 2)
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (skeep)
                    (("2" (inst 1 y)
                      (("2" (skolem-typepred 1)
                        (("2" (rewrite TC_expand_left -4)
                          (("2" (prop)
                            (("1" (grind) nil nil)
                             ("2" (skeep)
                              (("2"
                                (inst -7 z!1)
                                (("2"
                                  (flatten)
                                  (("2"
                                    (inst 2 y z)
                                    (("2"
                                      (grind)
                                      (("2"
                                        (typepred "TC(R)")
                                        (("2"
                                          (expand transitive?)
                                          (("2"
                                            (inst -1 "z!1" "y!1" "z")
                                            (("2"
                                              (grind)
                                              (("2"
                                                (expand TC 1)
                                                (("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skeep) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (T formal-type-decl nil more_orders_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil) nil
    (TC_is_transitive application-judgement "(transitive?[T])"
     more_orders_props nil)
    (TC_expand_left formula-decl nil more_relations_props nil) nil nil
    nil nil (transitive? const-decl "bool" relations nil) nil
    (TC inductive-decl "bool" relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil))
   nil))
 (well_founded_TC 0
  (well_founded_TC-1 nil 3579458508
   ("" (skeep)
    (("" (prop)
      (("1" (use TC_preserves_well_founded) nil nil)
       ("2" (use TC_is_extension)
        (("2" (lemma restrict_well_founded)
          (("2" (inst -1 "R" "TC(R)") (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((TC_preserves_well_founded judgement-tcc nil more_orders_props nil)
    (TC_is_transitive application-judgement "(transitive?[T])"
     more_orders_props nil)
    (T formal-type-decl nil more_orders_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (PRED type-eq-decl nil defined_types nil) nil
    (restrict_well_founded formula-decl nil more_orders_props nil)
    (TC inductive-decl "bool" relations nil)
    (TC_is_extension formula-decl nil more_relations_props nil))
   shostak))
 (is_finite_union 0
  (is_finite_union-1 nil 3579438568
   ("" (skeep)
    (("" (iff)
      (("" (prop)
        (("1" (lemma finite_subset[T])
          (("1" (inst -1 "{ x | p(x) OR q(x) }" "{ x | p(x) }")
            (("1" (grind) nil nil)) nil))
          nil)
         ("2" (lemma finite_subset[T])
          (("2" (inst -1 "{ x | p(x) OR q(x) }" "{ x | q(x) }")
            (("2" (grind) nil nil)) nil))
          nil)
         ("3" (lemma finite_union[T])
          (("3" (inst -1 "{ x | p(x) }" "{ x | q(x) }")
            (("3" (expand union -1)
              (("3" (expand member) (("3" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_union judgement-tcc nil finite_sets nil)
    (union const-decl "set" sets nil)
    (T formal-type-decl nil more_orders_props nil)
    (finite_subset formula-decl nil finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil) nil nil)
   shostak))
 (prout 0
  (prout-1 nil 3579525549
   ("" (grind-with-ext :if-match nil)
    (("1" (grind-with-ext :if-match all) nil nil)
     ("2" (grind-with-ext :if-match all) nil nil))
    nil)
   (nil nil nil nil (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil more_orders_props nil))
   shostak))
 (is_finite_exists 0
  (is_finite_exists-1 nil 3579446659
   ("" (skeep)
    (("" (lemma finite_Union_finite[T])
      ((""
        (inst -1
         "{ s: set[T] | EXISTS (z: T | p(z)): s = { x | Q(x, z) } }")
        (("" (expand every)
          (("" (prop)
            (("1" (expand Union)
              (("1" (expand is_finite (-1 1))
                (("1" (skeep)
                  (("1" (inst 1 N f)
                    (("1" (grind) nil nil)
                     ("2" (skeep)
                      (("2" (prop)
                        (("1" (skolem-typepred)
                          (("1" (skeep)
                            (("1" (inst 1 z) (("1" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skeep)
                          (("2" (inst 1 "{ x | Q(x, z) }")
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (rewrite is_finite_surj[T] :dir rl)
              (("2" (rewrite is_finite_surj[set[T]] :dir rl)
                (("2" (skeep)
                  (("2"
                    (inst 1 N
                     "LAMBDA (n: below[N]): { x | Q(x, f(n)) }")
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("3" (skolem-typepred)
              (("3" (skeep)
                (("3" (inst -3 z) (("3" (rewrite -1) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil more_orders_props nil)
    (finite_Union_finite formula-decl nil finite_sets_of_sets nil) nil
    (is_finite_surj formula-decl nil finite_sets nil)
    (surjective? const-decl "bool" functions nil) nil nil
    (Union const-decl "set" sets nil) nil
    (injective? const-decl "bool" functions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil) nil nil
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (set type-eq-decl nil sets nil)
    (setofsets type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (konigs 0
  (konigs-1 nil 3579459649
   ("" (skeep)
    (("" (all-typepreds)
      (("" (expand (well_founded? finitely_branching?))
        (("" (skeep)
          (("" (inst -1 "LAMBDA y: NOT is_finite({ z | TC(<)(z, y) })")
            (("" (prop)
              (("1" (skolem-typepred)
                (("1" (rewrite TC_left_is_TC :dir rl)
                  (("1" (expand TC_left 1)
                    (("1" (rewrite TC_left_is_TC)
                      (("1" (rewrite is_finite_union)
                        (("1" (prop)
                          (("1" (inst -3 y!1) nil nil)
                           ("2" (lemma is_finite_exists)
                            (("2" (inst -1 "TC(<)" "LAMBDA z: z < y!1")
                              (("2"
                                (prop)
                                (("1"
                                  (expand is_finite (-1 1))
                                  (("1"
                                    (skeep)
                                    (("1"
                                      (inst 1 N f)
                                      (("1"
                                        (expand injective?)
                                        (("1"
                                          (skeep)
                                          (("1"
                                            (inst -1 x1 x2)
                                            (("1" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (skeep)
                                        (("2"
                                          (prop)
                                          (("1"
                                            (skeep)
                                            (("1"
                                              (inst 1 z_1)
                                              (("1" (grind) nil nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (skeep)
                                            (("2"
                                              (inst 1 z_1)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (inst -3 y!1) nil nil)
                                 ("3"
                                  (skolem-typepred)
                                  (("3"
                                    (inst -2 z!1)
                                    (("3"
                                      (expand TC 3)
                                      (("3" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (inst 1 x) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TC_preserves_well_founded application-judgement
     "(well_founded?[T])" more_orders_props nil)
    (TC_is_transitive application-judgement "(transitive?[T])"
     more_orders_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_orders_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (finitely_branching? const-decl "bool" more_orders_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (TC inductive-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (TC_left_is_TC formula-decl nil more_relations_props nil) nil
    (IFF const-decl "[bool, bool -> bool]" booleans nil) nil nil
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (injective? const-decl "bool" functions nil) nil
    (is_finite_exists formula-decl nil more_orders_props nil)
    (is_finite_union formula-decl nil more_orders_props nil)
    (TC_left inductive-decl "bool" more_relations_props nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil))
   nil))
 (konigs_or 0
  (konigs_or-1 nil 3579469724
   ("" (lemma konigs) (("" (grind) nil nil)) nil)
   ((well_founded? const-decl "bool" orders nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finitely_branching? const-decl "bool" more_orders_props nil)
    (TC_is_transitive application-judgement "(transitive?[T])"
     more_orders_props nil)
    (TC_preserves_well_founded application-judgement
     "(well_founded?[T])" more_orders_props nil)
    (konigs application-judgement "(finitely_branching?)"
     more_orders_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (T formal-type-decl nil more_orders_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (konigs judgement-tcc nil more_orders_props nil))
   shostak)))
(lex_order
 (lex_wf 0
  (lex_wf-1 nil 3580575630
   ("" (skolem-typepred)
    (("" (expand well_founded?)
      (("" (skolem-typepred)
        (("" (inst -1 "LAMBDA(t: T): EXISTS (s: S): p!1(t, s)")
          (("" (bddsimp)
            (("1" (skolem-typepred)
              (("1" (inst -3 "LAMBDA (s:S): p!1(y!1, s)")
                (("1" (bddsimp)
                  (("1" (skolem-typepred -3)
                    (("1" (inst 1 "(y!1, y!2)")
                      (("1" (skolem-typepred 1)
                        (("1" (expand lex)
                          (("1" (split -7)
                            (("1" (inst -5 "x!1`1")
                              (("1"
                                (inst 1 "x!1`2")
                                (("1"
                                  (eta "[T, S]")
                                  (("1" (grind) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (inst -7 "x!1`2")
                                (("2"
                                  (rewrite -1 :dir rl)
                                  (("2"
                                    (eta "[T, S]")
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skeep)
              (("2" (inst 1 "y`1")
                (("2" (inst 1 "y`2") (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lex const-decl "bool" lex_order nil)
    (y!1 skolem-const-decl "(LAMBDA (t: T): EXISTS (s: S): p!1(t, s))"
     lex_order nil)
    (p!1 skolem-const-decl "pred[[T, S]]" lex_order nil)
    (x!1 skolem-const-decl "(p!1)" lex_order nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (S formal-type-decl nil lex_order nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (T formal-type-decl nil lex_order nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil)))

