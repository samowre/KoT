(subword
 (prec_TCC1 0
  (prec_TCC1-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC2 0
  (prec_TCC2-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC3 0
  (prec_TCC3-1 nil 3582902491 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil)
    (weight def-decl "nat" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (prec_TCC4 0
  (prec_TCC4-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC5 0
  (prec_TCC5-1 nil 3582902491 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil)
    (weight def-decl "nat" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (prec_TCC6 0
  (prec_TCC6-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC7 0
  (prec_TCC7-1 nil 3582902491 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (weight def-decl "nat" language nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC8 0
  (prec_TCC8-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC9 0
  (prec_TCC9-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC10 0
  (prec_TCC10-1 nil 3582902491 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil)
    (weight def-decl "nat" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (prec_TCC11 0
  (prec_TCC11-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC12 0
  (prec_TCC12-1 nil 3582902491 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil)
    (weight def-decl "nat" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (prec_TCC13 0
  (prec_TCC13-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (prec_TCC14 0
  (prec_TCC14-1 nil 3582902491 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (weight def-decl "nat" language nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC15 0
  (prec_TCC15-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC16 0
  (prec_TCC16-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC17 0
  (prec_TCC17-1 nil 3582902491 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil)
    (weight def-decl "nat" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (prec_TCC18 0
  (prec_TCC18-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC19 0
  (prec_TCC19-1 nil 3582902491 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil)
    (weight def-decl "nat" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (prec_TCC20 0
  (prec_TCC20-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC21 0
  (prec_TCC21-1 nil 3582902491 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (weight def-decl "nat" language nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC22 0
  (prec_TCC22-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC23 0
  (prec_TCC23-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC24 0
  (prec_TCC24-1 nil 3582902491 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil)
    (weight def-decl "nat" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (prec_TCC25 0
  (prec_TCC25-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC26 0
  (prec_TCC26-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC27 0
  (prec_TCC27-1 nil 3582902491 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil)
    (weight def-decl "nat" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (prec_TCC28 0
  (prec_TCC28-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC29 0
  (prec_TCC29-1 nil 3582902491 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil)
    (weight def-decl "nat" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (prec_TCC30 0
  (prec_TCC30-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (prec_TCC31 0
  (prec_TCC31-1 nil 3582902491 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (weight def-decl "nat" language nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC32 0
  (prec_TCC32-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC33 0
  (prec_TCC33-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC34 0
  (prec_TCC34-1 nil 3582902491 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil)
    (weight def-decl "nat" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (prec_TCC35 0
  (prec_TCC35-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC36 0
  (prec_TCC36-1 nil 3582902491 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil)
    (weight def-decl "nat" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (prec_TCC37 0
  (prec_TCC37-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (prec_TCC38 0
  (prec_TCC38-1 nil 3582902491 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (weight def-decl "nat" language nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC39 0
  (prec_TCC39-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC40 0
  (prec_TCC40-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC41 0
  (prec_TCC41-1 nil 3582902491 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil)
    (weight def-decl "nat" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (prec_TCC42 0
  (prec_TCC42-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC43 0
  (prec_TCC43-1 nil 3582902491 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil)
    (weight def-decl "nat" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (prec_TCC44 0
  (prec_TCC44-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (prec_TCC45 0
  (prec_TCC45-1 nil 3582902491 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (weight def-decl "nat" language nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC46 0
  (prec_TCC46-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC47 0
  (prec_TCC47-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC48 0
  (prec_TCC48-1 nil 3582902491 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil)
    (weight def-decl "nat" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (prec_TCC49 0
  (prec_TCC49-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC50 0
  (prec_TCC50-1 nil 3582902491 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil)
    (weight def-decl "nat" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (prec_TCC51 0
  (prec_TCC51-1 nil 3582902491 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (prec_TCC52 0
  (prec_TCC52-1 nil 3582902491 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (weight def-decl "nat" language nil)
    (context formula-decl nil language nil))
   nil))
 (prec_TCC53 0
  (prec_TCC53-1 nil 3582902491 ("" (cases-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil))
   nil))
 (member_symbol_when_subword 0
  (member_symbol_when_subword-1 nil 3582905396
   ("" (induct "Γ" :name "context_induction")
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skosimp* :preds? t)
      (("3" (expand ≺ -6)
        (("3" (lift-if)
          (("3" (bddsimp -6)
            (("1" (bddsimp -7)
              (("1" (inst - s!2 "rest(Δ!2)") (("1" (grind) nil nil))
                nil)
               ("2" (grind) nil nil))
              nil)
             ("2" (bddsimp -5)
              (("1" (inst - s!2 Δ!2) (("1" (grind) nil nil)) nil)
               ("2" (grind) nil nil))
              nil)
             ("3" (bddsimp -5)
              (("1" (inst - s!2 Δ!2) (("1" (grind) nil nil)) nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skosimp* :preds? t)
      (("4"
        (invoke (then (expand ≺ $1n) (lift-if) (bddsimp $1n))
         (~ "^Δ!2 ≺ %"))
        (("1"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (inst - s!2 "rest(Δ!2)") (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil)
         ("2"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (inst - s!2 Δ!2) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil)
         ("3"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (inst - s!2 Δ!2) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("5" (skosimp* :preds? t)
      (("5"
        (invoke (then (expand ≺ $1n) (lift-if) (bddsimp $1n))
         (~ "^Δ!2 ≺ %"))
        (("1"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (inst - s!2 "rest(Δ!2)") (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil)
         ("2"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (inst - s!2 Δ!2) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil)
         ("3"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (inst - s!2 Δ!2) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("6" (skosimp* :preds? t)
      (("6" (expand ≺ -7)
        (("6" (lift-if)
          (("6" (bddsimp -7)
            (("6" (bddsimp -8)
              (("1" (inst - s!1 "rest(Δ!2)") (("1" (grind) nil nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skosimp* :preds? t)
      (("7"
        (invoke (then (expand ≺ $1n) (lift-if) (bddsimp $1n))
         (~ "^Δ!2 ≺ %"))
        (("1"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (inst - s!2 "rest(Δ!2)") (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil)
         ("2"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (inst - s!2 Δ!2) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil)
         ("3"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (inst - s!2 Δ!2) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("8" (skosimp* :preds? t)
      (("8"
        (invoke (then (expand ≺ $1n) (lift-if) (bddsimp $1n))
         (~ "^Δ!2 ≺ %"))
        (("1"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (inst - s!2 "rest(Δ!2)") (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil)
         ("2"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (inst - s!2 Δ!2) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil)
         ("3"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (inst - s!2 Δ!2) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("9" (skosimp* :preds? t)
      (("9"
        (invoke (then (expand ≺ $1n) (lift-if) (bddsimp $1n))
         (~ "^Δ!2 ≺ %"))
        (("1"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (inst - s!2 "rest(Δ!2)") (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil)
         ("2"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (inst - s!2 Δ!2) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil)
         ("3"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (inst - s!2 Δ!2) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("10" (skosimp* :preds? t)
      (("10"
        (invoke (then (expand ≺ $1n) (lift-if) (bddsimp $1n))
         (~ "^Δ!2 ≺ %"))
        (("1"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (inst - s!2 "rest(Δ!2)") (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil)
         ("2"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (inst - s!2 Δ!2) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil)
         ("3"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (inst - s!2 Δ!2) (("1" (grind) nil nil)) nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((pretheory? const-decl "[semantic -> bool]" language nil)
    (pretheory type-eq-decl nil language nil)
    (preterm? const-decl "[semantic -> bool]" language nil)
    (preterm type-eq-decl nil language nil)
    (pretype? const-decl "[semantic -> bool]" language nil)
    (pretype type-eq-decl nil language nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (rest shared-adt-accessor-decl "[{x: semantic |
              ktype_decl?(x) OR ktype_def?(x) OR ktype_ext?(x) OR kvar?(x)
           OR kconst_decl?(x) OR kconst_def?(x) OR kconst_ext?(x)
           OR ktheory?(x) OR itype?(x) OR iconst?(x)} ->
   semantic]" language nil)
    (iconst? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (ktheory? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (kconst_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kvar? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (ktype_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (context_induction formula-decl nil inductions nil)
    (map type-eq-decl nil language nil)
    (map? const-decl "[semantic -> bool]" language nil)
    (≺ def-decl "bool" subword nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (symbol nonempty-type-decl nil language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (syntaxic type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (context type-eq-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (semantic type-decl nil language nil)
    (context formula-decl nil language nil))
   shostak))
 (member_var_when_subword 0
  (member_var_when_subword-1 nil 3582909678
   ("" (induct "Γ" :name "context_induction")
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skosimp* :preds? t)
      (("3"
        (invoke (then (expand ≺ $1n) (lift-if) (bddsimp $1n))
         (~ "^Δ!2 ≺ %"))
        (("1"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
         ("2"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
         ("3"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil)
     ("4" (skosimp* :preds? t)
      (("4"
        (invoke (then (expand ≺ $1n) (lift-if) (bddsimp $1n))
         (~ "^Δ!2 ≺ %"))
        (("1"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
         ("2"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
         ("3"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil)
     ("5" (skosimp* :preds? t)
      (("5"
        (invoke (then (expand ≺ $1n) (lift-if) (bddsimp $1n))
         (~ "^Δ!2 ≺ %"))
        (("1"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
         ("2"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
         ("3"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil)
     ("6" (skosimp* :preds? t)
      (("6" (expand ≺ -8)
        (("6" (lift-if)
          (("6" (bddsimp -8)
            (("6" (bddsimp -9)
              (("1" (inst - "x!1 - 1" "rest(Δ!2)")
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skosimp* :preds? t)
      (("7"
        (invoke (then (expand ≺ $1n) (lift-if) (bddsimp $1n))
         (~ "^Δ!2 ≺ %"))
        (("1"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
         ("2"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
         ("3"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil)
     ("8" (skosimp* :preds? t)
      (("8"
        (invoke (then (expand ≺ $1n) (lift-if) (bddsimp $1n))
         (~ "^Δ!2 ≺ %"))
        (("1"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
         ("2"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
         ("3"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil)
     ("9" (skosimp* :preds? t)
      (("9"
        (invoke (then (expand ≺ $1n) (lift-if) (bddsimp $1n))
         (~ "^Δ!2 ≺ %"))
        (("1"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
         ("2"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
         ("3"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil)
     ("10" (skosimp* :preds? t)
      (("10"
        (invoke (then (expand ≺ $1n) (lift-if) (bddsimp $1n))
         (~ "^Δ!2 ≺ %"))
        (("1"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
         ("2"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
         ("3"
          (invoke (bddsimp $1n) (~ "^well_formed?(%)(Δ!1) IMPLIES %"))
          (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((pretheory? const-decl "[semantic -> bool]" language nil)
    (pretheory type-eq-decl nil language nil)
    (preterm? const-decl "[semantic -> bool]" language nil)
    (preterm type-eq-decl nil language nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (pretype? const-decl "[semantic -> bool]" language nil)
    (pretype type-eq-decl nil language nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (rest shared-adt-accessor-decl "[{x: semantic |
              ktype_decl?(x) OR ktype_def?(x) OR ktype_ext?(x) OR kvar?(x)
           OR kconst_decl?(x) OR kconst_def?(x) OR kconst_ext?(x)
           OR ktheory?(x) OR itype?(x) OR iconst?(x)} ->
   semantic]" language nil)
    (iconst? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (ktheory? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (kconst_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kvar? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (ktype_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (context_induction formula-decl nil inductions nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (≺ def-decl "bool" subword nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (syntaxic type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (context type-eq-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (semantic type-decl nil language nil)
    (context formula-decl nil language nil))
   shostak))
 (length_subword 0
  (length_subword-1 nil 3582907781
   ("" (induct "Γ" :name "context_induction")
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (grind)
      (("3" (reveal -1)
        (("3" (inst - "rest(Δ!2)") (("3" (assert) nil nil)) nil)) nil))
      nil)
     ("4" (grind)
      (("4" (reveal -1)
        (("4" (inst - "rest(Δ!2)") (("4" (assert) nil nil)) nil)) nil))
      nil)
     ("5" (grind)
      (("5" (reveal -1)
        (("5" (inst - "rest(Δ!2)") (("5" (assert) nil nil)) nil)) nil))
      nil)
     ("6" (grind)
      (("6" (reveal -1)
        (("6" (inst - "rest(Δ!2)") (("6" (assert) nil nil)) nil)) nil))
      nil)
     ("7" (grind)
      (("7" (reveal -1)
        (("7" (inst - "rest(Δ!2)") (("7" (assert) nil nil)) nil)) nil))
      nil)
     ("8" (grind)
      (("8" (reveal -1)
        (("8" (inst - "rest(Δ!2)") (("8" (assert) nil nil)) nil)) nil))
      nil)
     ("9" (grind)
      (("9" (reveal -1)
        (("9" (inst - "rest(Δ!2)") (("9" (assert) nil nil)) nil)) nil))
      nil)
     ("10" (grind)
      (("10" (reveal -1)
        (("10" (inst - "rest(Δ!2)") (("10" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((pretheory? const-decl "[semantic -> bool]" language nil)
    (pretheory type-eq-decl nil language nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (preterm? const-decl "[semantic -> bool]" language nil)
    (preterm type-eq-decl nil language nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pretype? const-decl "[semantic -> bool]" language nil)
    (pretype type-eq-decl nil language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (rest shared-adt-accessor-decl "[{x: semantic |
              ktype_decl?(x) OR ktype_def?(x) OR ktype_ext?(x) OR kvar?(x)
           OR kconst_decl?(x) OR kconst_def?(x) OR kconst_ext?(x)
           OR ktheory?(x) OR itype?(x) OR iconst?(x)} ->
   semantic]" language nil)
    (iconst? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (ktheory? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (kconst_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kvar? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (ktype_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (context_induction formula-decl nil inductions nil)
    (length def-decl "nat" context nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (≺ def-decl "bool" subword nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (syntaxic type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (context type-eq-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (semantic type-decl nil language nil)
    (context formula-decl nil language nil))
   shostak))
 (pos_symbol_subword_TCC1 0
  (pos_symbol_subword_TCC1-1 nil 3582907779
   ("" (subtype-tcc)
    (("" (use member_symbol_when_subword :polarity? t)
      (("" (assert) nil nil)) nil))
    nil)
   ((member_symbol_when_subword formula-decl nil subword nil)
    (symbol nonempty-type-decl nil language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil))
   nil))
 (pos_symbol_subword 0
  (pos_symbol_subword-1 nil 3582907952
   ("" (induct "Γ" :name "context_induction")
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (grind)
      (("1" (use length_subword) (("1" (assert) nil nil)) nil)
       ("2" (reveal -1)
        (("2" (inst - s!2 "rest(Δ!2)") (("2" (assert) nil nil)) nil))
        nil))
      nil)
     ("4" (grind)
      (("1" (use length_subword) (("1" (assert) nil nil)) nil)
       ("2" (reveal -1)
        (("2" (inst - s!2 "rest(Δ!2)") (("2" (assert) nil nil)) nil))
        nil))
      nil)
     ("5" (grind)
      (("1" (use length_subword) (("1" (assert) nil nil)) nil)
       ("2" (reveal -1)
        (("2" (inst - s!2 "rest(Δ!2)") (("2" (assert) nil nil)) nil))
        nil))
      nil)
     ("6" (grind)
      (("6" (reveal -1)
        (("6" (inst - s!1 "rest(Δ!2)") (("6" (assert) nil nil)) nil))
        nil))
      nil)
     ("7" (grind)
      (("1" (use length_subword) (("1" (assert) nil nil)) nil)
       ("2" (reveal -1)
        (("2" (inst - s!2 "rest(Δ!2)") (("2" (assert) nil nil)) nil))
        nil))
      nil)
     ("8" (grind)
      (("1" (use length_subword) (("1" (assert) nil nil)) nil)
       ("2" (reveal -1)
        (("2" (inst - s!2 "rest(Δ!2)") (("2" (assert) nil nil)) nil))
        nil))
      nil)
     ("9" (grind)
      (("1" (use length_subword) (("1" (assert) nil nil)) nil)
       ("2" (reveal -1)
        (("2" (inst - s!2 "rest(Δ!2)") (("2" (assert) nil nil)) nil))
        nil))
      nil)
     ("10" (grind)
      (("1" (use length_subword) (("1" (assert) nil nil)) nil)
       ("2" (reveal -1)
        (("2" (inst - s!2 "rest(Δ!2)") (("2" (assert) nil nil)) nil))
        nil))
      nil)
     ("11" (skosimp* :preds? t)
      (("11" (use member_symbol_when_subword :polarity? t)
        (("11" (assert) nil nil)) nil))
      nil))
    nil)
   ((member_symbol_when_subword formula-decl nil subword nil)
    (pretheory? const-decl "[semantic -> bool]" language nil)
    (pretheory type-eq-decl nil language nil)
    (preterm? const-decl "[semantic -> bool]" language nil)
    (preterm type-eq-decl nil language nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pretype? const-decl "[semantic -> bool]" language nil)
    (pretype type-eq-decl nil language nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rest shared-adt-accessor-decl "[{x: semantic |
              ktype_decl?(x) OR ktype_def?(x) OR ktype_ext?(x) OR kvar?(x)
           OR kconst_decl?(x) OR kconst_def?(x) OR kconst_ext?(x)
           OR ktheory?(x) OR itype?(x) OR iconst?(x)} ->
   semantic]" language nil)
    (iconst? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (ktheory? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (kconst_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kvar? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (ktype_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (length_subword formula-decl nil subword nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (context_induction formula-decl nil inductions nil)
    (below type-eq-decl nil nat_types nil)
    (length def-decl "nat" context nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (context formula-decl nil language nil)
    (semantic type-decl nil language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (symbol nonempty-type-decl nil language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (≺ def-decl "bool" subword nil)
    (map? const-decl "[semantic -> bool]" language nil)
    (map type-eq-decl nil language nil))
   shostak))
 (pos_var_subword_TCC1 0
  (pos_var_subword_TCC1-1 nil 3582907779
   ("" (subtype-tcc)
    (("" (use member_var_when_subword :polarity? t)
      (("" (grind) nil nil)) nil))
    nil)
   ((member_var_when_subword formula-decl nil subword nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil))
   nil))
 (pos_var_subword 0
  (pos_var_subword-1 nil 3582910261
   ("" (induct "Γ" :name "context_induction")
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (grind)
      (("3" (reveal -1)
        (("3" (inst - x!1 "rest(Δ!2)") (("3" (assert) nil nil)) nil))
        nil))
      nil)
     ("4" (grind)
      (("4" (reveal -1)
        (("4" (inst - x!1 "rest(Δ!2)") (("4" (assert) nil nil)) nil))
        nil))
      nil)
     ("5" (grind)
      (("5" (reveal -1)
        (("5" (inst - x!1 "rest(Δ!2)") (("5" (assert) nil nil)) nil))
        nil))
      nil)
     ("6" (skosimp* :preds? t)
      (("6" (bddsimp -6)
        (("1" (expand ≺ -8)
          (("1" (lift-if)
            (("1" (bddsimp -8)
              (("1" (expand pos 1 2)
                (("1" (lift-if)
                  (("1" (assert)
                    (("1" (flatten)
                      (("1" (assert)
                        (("1" (split 1)
                          (("1" (use length_subword)
                            (("1" (assert)
                              (("1"
                                (flatten)
                                (("1"
                                  (assert)
                                  (("1"
                                    (auto-rewrite pos)
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (inst - "x!1 - 1" "rest(Δ!2)")
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil)
     ("7" (grind)
      (("7" (reveal -1)
        (("7" (inst - x!1 "rest(Δ!2)") (("7" (assert) nil nil)) nil))
        nil))
      nil)
     ("8" (grind)
      (("8" (reveal -1)
        (("8" (inst - x!1 "rest(Δ!2)") (("8" (assert) nil nil)) nil))
        nil))
      nil)
     ("9" (grind)
      (("9" (reveal -1)
        (("9" (inst - x!1 "rest(Δ!2)") (("9" (assert) nil nil)) nil))
        nil))
      nil)
     ("10" (grind)
      (("10" (reveal -1)
        (("10" (inst - x!1 "rest(Δ!2)") (("10" (assert) nil nil)) nil))
        nil))
      nil)
     ("11" (grind)
      (("11" (use member_var_when_subword :polarity? t)
        (("11" (grind) nil nil)) nil))
      nil))
    nil)
   ((member_var_when_subword formula-decl nil subword nil)
    (pretheory? const-decl "[semantic -> bool]" language nil)
    (pretheory type-eq-decl nil language nil)
    (preterm? const-decl "[semantic -> bool]" language nil)
    (preterm type-eq-decl nil language nil)
    (length_subword formula-decl nil subword nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pretype? const-decl "[semantic -> bool]" language nil)
    (pretype type-eq-decl nil language nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rest shared-adt-accessor-decl "[{x: semantic |
              ktype_decl?(x) OR ktype_def?(x) OR ktype_ext?(x) OR kvar?(x)
           OR kconst_decl?(x) OR kconst_def?(x) OR kconst_ext?(x)
           OR ktheory?(x) OR itype?(x) OR iconst?(x)} ->
   semantic]" language nil)
    (iconst? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (ktheory? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (kconst_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kvar? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (ktype_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (context_induction formula-decl nil inductions nil)
    (below type-eq-decl nil nat_types nil)
    (length def-decl "nat" context nil) (< const-decl "bool" reals nil)
    (<= const-decl "bool" reals nil)
    (context formula-decl nil language nil)
    (semantic type-decl nil language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (≺ def-decl "bool" subword nil))
   shostak))
 (subword_is_reflexive 0
  (subword_is_reflexive-1 nil 3582902491
   ("" (expand reflexive?)
    (("" (induct-and-simplify "x" :name "context_induction") nil nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (context_induction formula-decl nil inductions nil)
    (≺ def-decl "bool" subword nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (syntaxic type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (context type-eq-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (semantic type-decl nil language nil)
    (context formula-decl nil language nil)
    (reflexive? const-decl "bool" relations nil))
   nil))
 (subword_rest_TCC1 0
  (subword_rest_TCC1-1 nil 3582991881 ("" (subtype-tcc) nil nil) nil
   nil))
 (subword_rest_TCC2 0
  (subword_rest_TCC2-1 nil 3582991881 ("" (subtype-tcc) nil nil) nil
   nil))
 (subword_rest 0
  (subword_rest-1 nil 3582991881
   ("" (induct "Γ" :name "context_induction")
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (use subword_is_reflexive) (("3" (lazy-grind) nil nil)) nil)
     ("4" (use subword_is_reflexive) (("4" (lazy-grind) nil nil)) nil)
     ("5" (use subword_is_reflexive) (("5" (lazy-grind) nil nil)) nil)
     ("6" (use subword_is_reflexive) (("6" (lazy-grind) nil nil)) nil)
     ("7" (use subword_is_reflexive) (("7" (lazy-grind) nil nil)) nil)
     ("8" (use subword_is_reflexive) (("8" (lazy-grind) nil nil)) nil)
     ("9" (use subword_is_reflexive) (("9" (lazy-grind) nil nil)) nil)
     ("10" (use subword_is_reflexive) (("10" (lazy-grind) nil nil))
      nil)
     ("11" (skosimp* :preds? t)
      (("11" (hide 4)
        (("11" (grind)
          (("1" (expand well_formed? -3) (("1" (grind) nil nil)) nil)
           ("2" (rewrite context -1) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("12" (skosimp* :preds? t)
      (("12" (rewrite context -1) (("12" (grind) nil nil)) nil)) nil))
    nil)
   ((∈ def-decl "bool" map nil)
    (definition const-decl "{x: semantic |
         (type_kind?(S) IMPLIES pretype?(x)) AND
          (const_kind?(S) IMPLIES preterm?(x)) AND
           (theory_kind?(S) IMPLIES pretheory?(x)) AND
            weight(F)(x) + weight(F)(rest(S)) < weight(F)(S)}" decl
                nil)
    (kind const-decl "{r: keyword | nonempty?(S) IFF r ≠ ⊥}" decl nil)
    (app_symbol def-decl "{T: nonempty |
         (interp?(S) => interp?(T)) AND
          (context?(S) => context?(T)) AND
           (pretheory?(S) => pretheory?(T)) AND
            weight(F)(T) <= weight(F)(S)}" map nil)
    (pretheory? const-decl "[semantic -> bool]" language nil)
    (pretheory type-eq-decl nil language nil)
    (preterm? const-decl "[semantic -> bool]" language nil)
    (preterm type-eq-decl nil language nil)
    (++ def-decl
     "{Θ | weight(F)(Θ) = weight(F)(Γ) + weight(F)(Δ) - F(ord_empty) - 1}"
     context nil)
    (pretype? const-decl "[semantic -> bool]" language nil)
    (pretype type-eq-decl nil language nil)
    (subword_is_reflexive judgement-tcc nil subword nil)
    (subword_is_reflexive name-judgement
     "(reflexive?[well_formed_context])" subword nil)
    (∈ def-decl "bool" map nil)
    (reflexive? const-decl "bool" relations nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (interp formula-decl nil language nil)
    (nonempty formula-decl nil language nil)
    (context_induction formula-decl nil inductions nil)
    (≺ def-decl "bool" subword nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (context formula-decl nil language nil)
    (rest shared-adt-accessor-decl "[{x: semantic |
              ktype_decl?(x) OR ktype_def?(x) OR ktype_ext?(x) OR kvar?(x)
           OR kconst_decl?(x) OR kconst_def?(x) OR kconst_ext?(x)
           OR ktheory?(x) OR itype?(x) OR iconst?(x)} ->
   semantic]" language nil)
    (semantic type-decl nil language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonempty? const-decl "[semantic -> bool]" language nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (kvar? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ktype_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktheory? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (iconst? adt-recognizer-decl "[semantic -> boolean]" language nil))
   shostak))
 (subword_app_symbol_TCC1 0
  (subword_app_symbol_TCC1-1 nil 3582902491
   ("" (subtype-tcc)
    (("" (use member_nonempty) (("" (assert) nil nil)) nil)) nil)
   ((member_nonempty formula-decl nil map nil)
    (map type-eq-decl nil language nil)
    (map? const-decl "[semantic -> bool]" language nil)
    (symbol nonempty-type-decl nil language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil))
   nil))
 (subword_app_symbol_TCC2 0
  (subword_app_symbol_TCC2-1 nil 3582902491
   ("" (subtype-tcc)
    (("" (use well_formed_app_symbol) (("" (assert) nil nil)) nil))
    nil)
   ((well_formed_app_symbol formula-decl nil well_formed nil)
    (symbol nonempty-type-decl nil language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil))
   nil))
 (subword_app_symbol 0
  (subword_app_symbol-1 nil 3582909963
   ("" (induct "Γ" :name "context_induction")
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (grind)
      (("3" (use subword_is_reflexive) (("3" (grind) nil nil)) nil))
      nil)
     ("4" (grind)
      (("4" (use subword_is_reflexive) (("4" (grind) nil nil)) nil))
      nil)
     ("5" (grind)
      (("5" (use subword_is_reflexive) (("5" (grind) nil nil)) nil))
      nil)
     ("6" (postpone) nil nil) ("7" (postpone) nil nil)
     ("8" (postpone) nil nil) ("9" (postpone) nil nil)
     ("10" (postpone) nil nil) ("11" (postpone) nil nil)
     ("12" (postpone) nil nil))
    nil)
   nil shostak))
 (subword_symbol_definition?_TCC1 0
  (subword_symbol_definition?_TCC1-1 nil 3582979443
   ("" (grind) nil nil) ((context formula-decl nil language nil)) nil))
 (subword_symbol_definition?_TCC2 0
  (subword_symbol_definition?_TCC2-1 nil 3582979443
   ("" (grind)
    (("" (use member_nonempty :polarity? t) (("" (grind) nil nil))
      nil))
    nil)
   ((member_nonempty formula-decl nil map nil)
    (map type-eq-decl nil language nil)
    (map? const-decl "[semantic -> bool]" language nil)
    (symbol nonempty-type-decl nil language nil)
    (subword_is_reflexive name-judgement
     "(reflexive?[well_formed_context])" subword nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil))
   nil))
 (subword_symbol_definition?_TCC3 0
  (subword_symbol_definition?_TCC3-1 nil 3582979443
   ("" (skosimp* :preds? t)
    (("" (use member_symbol_when_subword :polarity? t)
      (("" (prop)
        (("" (use member_nonempty :polarity? t) (("" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((member_symbol_when_subword formula-decl nil subword nil)
    (symbol nonempty-type-decl nil language nil)
    (member_nonempty formula-decl nil map nil)
    (map? const-decl "[semantic -> bool]" language nil)
    (map type-eq-decl nil language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil))
   nil))
 (subword_symbol_definition? 0
  (subword_symbol_definition?-1 nil 3582979444
   ("" (induct "Γ" :name "context_induction")
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skosimp* :preds? t)
      (("3" (expand app_symbol +)
        (("3" (bddsimp 1)
          (("1" (assert)
            (("1" (lift-if)
              (("1" (bddsimp -8)
                (("1" (grind) nil nil)
                 ("2" (use member_symbol_when_subword :polarity? t)
                  (("2" (grind) nil nil)) nil)
                 ("3" (use member_symbol_when_subword :polarity? t)
                  (("3" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (assert)
            (("2" (lift-if)
              (("2" (bddsimp -4)
                (("1" (bddsimp -7)
                  (("1" (inst - s!2 "rest(Δ!2)")
                    (("1" (grind) nil nil)) nil)
                   ("2" (inst - s!2 Δ!2) (("2" (grind) nil nil)) nil)
                   ("3" (inst - s!2 Δ!2) (("3" (grind) nil nil)) nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skosimp* :preds? t)
      (("4" (expand app_symbol +)
        (("4" (bddsimp 1)
          (("1" (assert) nil nil)
           ("2" (assert)
            (("2" (lift-if)
              (("2" (bddsimp -5)
                (("1" (assert)
                  (("1"
                    (invoke (bddsimp $1n)
                     (~ "IF % THEN % ELSE % ENDIF"))
                    (("1" (inst - s!2 "rest(Δ!2)")
                      (("1" (grind) nil nil)) nil)
                     ("2" (inst - s!2 Δ!2) (("2" (grind) nil nil)) nil)
                     ("3" (inst - s!2 Δ!2) (("3" (grind) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skosimp* :preds? t)
      (("5" (expand app_symbol +)
        (("5" (bddsimp 1)
          (("1" (assert)
            (("1" (lift-if)
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (use member_symbol_when_subword :polarity? t)
                  (("1" (grind) nil nil)) nil)
                 ("2" (use member_symbol_when_subword :polarity? t)
                  (("2" (grind) nil nil)) nil)
                 ("3" (use member_symbol_when_subword :polarity? t)
                  (("3" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2"
            (invoke (bddsimp $1n) (~ "^well_formed?(%)(%) IMPLIES %"))
            (("1" (assert)
              (("1" (lift-if)
                (("1"
                  (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                  (("1" (inst - s!2 "rest(Δ!2)")
                    (("1" (grind) nil nil)) nil)
                   ("2" (inst - s!2 Δ!2) (("2" (grind) nil nil)) nil)
                   ("3" (inst - s!2 Δ!2) (("3" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skosimp* :preds? t)
      (("6" (expand app_symbol +)
        (("6" (assert)
          (("6" (lift-if)
            (("6" (bddsimp -8)
              (("6" (bddsimp -8)
                (("1" (inst - s!1 "rest(Δ!2)") (("1" (grind) nil nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skosimp* :preds? t)
      (("7" (expand app_symbol +)
        (("7" (bddsimp 1)
          (("1" (assert)
            (("1" (lift-if)
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (use member_symbol_when_subword :polarity? t)
                  (("1" (grind) nil nil)) nil)
                 ("2" (use member_symbol_when_subword :polarity? t)
                  (("2" (grind) nil nil)) nil)
                 ("3" (use member_symbol_when_subword :polarity? t)
                  (("3" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2"
            (invoke (bddsimp $1n) (~ "^well_formed?(%)(%) IMPLIES %"))
            (("1" (assert)
              (("1" (lift-if)
                (("1"
                  (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                  (("1" (inst - s!2 "rest(Δ!2)")
                    (("1" (grind) nil nil)) nil)
                   ("2" (inst - s!2 Δ!2) (("2" (grind) nil nil)) nil)
                   ("3" (inst - s!2 Δ!2) (("3" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skosimp* :preds? t)
      (("8" (expand app_symbol +)
        (("8" (bddsimp 1)
          (("1" (assert) nil nil)
           ("2"
            (invoke (bddsimp $1n) (~ "^well_formed?(%)(%) IMPLIES %"))
            (("1" (assert)
              (("1" (lift-if)
                (("1"
                  (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                  (("1" (inst - s!2 "rest(Δ!2)")
                    (("1" (grind) nil nil)) nil)
                   ("2" (inst - s!2 Δ!2) (("2" (grind) nil nil)) nil)
                   ("3" (inst - s!2 Δ!2) (("3" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("9" (skosimp* :preds? t)
      (("9" (expand app_symbol +)
        (("9" (bddsimp 1)
          (("1" (assert)
            (("1" (lift-if)
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (use member_symbol_when_subword :polarity? t)
                  (("1" (grind) nil nil)) nil)
                 ("2" (use member_symbol_when_subword :polarity? t)
                  (("2" (grind) nil nil)) nil)
                 ("3" (use member_symbol_when_subword :polarity? t)
                  (("3" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2"
            (invoke (bddsimp $1n) (~ "^well_formed?(%)(%) IMPLIES %"))
            (("1" (assert)
              (("1" (lift-if)
                (("1"
                  (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                  (("1" (inst - s!2 "rest(Δ!2)")
                    (("1" (grind) nil nil)) nil)
                   ("2" (inst - s!2 Δ!2) (("2" (grind) nil nil)) nil)
                   ("3" (inst - s!2 Δ!2) (("3" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("10" (skosimp* :preds? t)
      (("10" (expand app_symbol +)
        (("10" (bddsimp 1)
          (("1" (assert) nil nil)
           ("2"
            (invoke (bddsimp $1n) (~ "^well_formed?(%)(%) IMPLIES %"))
            (("1" (assert)
              (("1" (lift-if)
                (("1"
                  (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                  (("1" (inst - s!2 "rest(Δ!2)")
                    (("1" (grind) nil nil)) nil)
                   ("2" (inst - s!2 Δ!2) (("2" (grind) nil nil)) nil)
                   ("3" (inst - s!2 Δ!2) (("3" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("11" (skosimp* :preds? t)
      (("11" (use member_symbol_when_subword :polarity? t)
        (("11" (prop)
          (("11" (use member_nonempty :polarity? t)
            (("11" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("12" (skosimp* :preds? t)
      (("12" (use member_symbol_when_subword :polarity? t)
        (("12" (grind) nil nil)) nil))
      nil)
     ("13" (skosimp* :preds? t)
      (("13" (use member_nonempty :polarity? t)
        (("13" (grind) nil nil)) nil))
      nil))
    nil)
   ((member_nonempty formula-decl nil map nil)
    (pretheory type-eq-decl nil language nil)
    (preterm type-eq-decl nil language nil)
    (preterm? const-decl "[semantic -> bool]" language nil)
    (pretype type-eq-decl nil language nil)
    (pretype? const-decl "[semantic -> bool]" language nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (member_symbol_when_subword formula-decl nil subword nil)
    (subword_is_reflexive name-judgement
     "(reflexive?[well_formed_context])" subword nil)
    (rest shared-adt-accessor-decl "[{x: semantic |
              ktype_decl?(x) OR ktype_def?(x) OR ktype_ext?(x) OR kvar?(x)
           OR kconst_decl?(x) OR kconst_def?(x) OR kconst_ext?(x)
           OR ktheory?(x) OR itype?(x) OR iconst?(x)} ->
   semantic]" language nil)
    (iconst? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (ktheory? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (kconst_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kvar? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (ktype_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (context_induction formula-decl nil inductions nil)
    (context formula-decl nil language nil)
    (nonempty type-eq-decl nil language nil)
    (definition? const-decl "bool" decl nil)
    (interp? const-decl "[semantic -> bool]" language nil)
    (pretheory? const-decl "[semantic -> bool]" language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil) (ord type-decl nil language nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (weight def-decl "nat" language nil)
    (ord_nil? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_nil adt-constructor-decl "(ord_nil?)" language nil)
    (ord_symbol? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_symbol adt-constructor-decl "(ord_symbol?)" language nil)
    (ord_dot? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_dot adt-constructor-decl "(ord_dot?)" language nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ord_ktype_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_ktype_def adt-constructor-decl "(ord_ktype_def?)" language
     nil)
    (ord_itype? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_itype adt-constructor-decl "(ord_itype?)" language nil)
    (ord_ktype_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_ktype_decl adt-constructor-decl "(ord_ktype_decl?)" language
     nil)
    (ord_kconst_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_kconst_def adt-constructor-decl "(ord_kconst_def?)" language
     nil)
    (ord_iconst? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_iconst adt-constructor-decl "(ord_iconst?)" language nil)
    (ord_kconst_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_kconst_decl adt-constructor-decl "(ord_kconst_decl?)" language
     nil)
    (F const-decl "(LAMBDA (F: [ord -> nat]):
   (F(ord_nil) <= F(ord_symbol)) AND
    (F(ord_nil) <= F(ord_dot)) AND
     (F(ord_ktype_def) + F(ord_itype) <= F(ord_ktype_decl)) AND
      (F(ord_kconst_def) + F(ord_iconst) <= F(ord_kconst_decl)))"
     language nil)
    (app_symbol def-decl "{T: nonempty |
         (interp?(S) => interp?(T)) AND
          (context?(S) => context?(T)) AND
           (pretheory?(S) => pretheory?(T)) AND
            weight(F)(T) <= weight(F)(S)}" map nil)
    (semantic type-decl nil language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (symbol nonempty-type-decl nil language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (map? const-decl "[semantic -> bool]" language nil)
    (map type-eq-decl nil language nil) (≺ def-decl "bool" subword nil)
    (nonempty? const-decl "[semantic -> bool]" language nil))
   shostak))
 (subword_symbol_typed?_TCC1 0
  (subword_symbol_typed?_TCC1-1 nil 3582979443
   ("" (skosimp* :preds? t)
    (("" (invoke (typepred "%1") (~ + "app_symbol(%)(%)"))
      (("" (rewrite nonempty_context_as_context) (("" (grind) nil nil))
        nil))
      nil))
    nil)
   ((nonempty? const-decl "[semantic -> bool]" language nil)
    (nonempty type-eq-decl nil language nil)
    (symbol nonempty-type-decl nil language nil)
    (map? const-decl "[semantic -> bool]" language nil)
    (map type-eq-decl nil language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (interp? const-decl "[semantic -> bool]" language nil)
    (pretheory? const-decl "[semantic -> bool]" language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil) (ord type-decl nil language nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (weight def-decl "nat" language nil)
    (ord_nil? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_nil adt-constructor-decl "(ord_nil?)" language nil)
    (ord_symbol? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_symbol adt-constructor-decl "(ord_symbol?)" language nil)
    (ord_dot? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_dot adt-constructor-decl "(ord_dot?)" language nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ord_ktype_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_ktype_def adt-constructor-decl "(ord_ktype_def?)" language
     nil)
    (ord_itype? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_itype adt-constructor-decl "(ord_itype?)" language nil)
    (ord_ktype_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_ktype_decl adt-constructor-decl "(ord_ktype_decl?)" language
     nil)
    (ord_kconst_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_kconst_def adt-constructor-decl "(ord_kconst_def?)" language
     nil)
    (ord_iconst? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_iconst adt-constructor-decl "(ord_iconst?)" language nil)
    (ord_kconst_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_kconst_decl adt-constructor-decl "(ord_kconst_decl?)" language
     nil)
    (F const-decl "(LAMBDA (F: [ord -> nat]):
   (F(ord_nil) <= F(ord_symbol)) AND
    (F(ord_nil) <= F(ord_dot)) AND
     (F(ord_ktype_def) + F(ord_itype) <= F(ord_ktype_decl)) AND
      (F(ord_kconst_def) + F(ord_iconst) <= F(ord_kconst_decl)))"
     language nil)
    (app_symbol def-decl "{T: nonempty |
         (interp?(S) => interp?(T)) AND
          (context?(S) => context?(T)) AND
           (pretheory?(S) => pretheory?(T)) AND
            weight(F)(T) <= weight(F)(S)}" map nil)
    (nonempty formula-decl nil language nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (subword_is_reflexive name-judgement
     "(reflexive?[well_formed_context])" subword nil)
    (nonempty_context_as_context formula-decl nil subtype nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil))
   nil))
 (subword_symbol_typed?_TCC2 0
  (subword_symbol_typed?_TCC2-1 nil 3582979443
   ("" (skosimp* :preds? t)
    (("" (use member_symbol_when_subword :polarity? t)
      (("" (prop)
        (("" (use member_nonempty :polarity? t) (("" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((member_symbol_when_subword formula-decl nil subword nil)
    (symbol nonempty-type-decl nil language nil)
    (member_nonempty formula-decl nil map nil)
    (map? const-decl "[semantic -> bool]" language nil)
    (map type-eq-decl nil language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil))
   nil))
 (subword_symbol_typed?_TCC3 0
  (subword_symbol_typed?_TCC3-1 nil 3582979443
   ("" (skosimp* :preds? t)
    (("" (invoke (typepred "%1") (~ + "app_symbol(%)(%)"))
      (("" (rewrite nonempty_context_as_context) (("" (grind) nil nil))
        nil))
      nil))
    nil)
   ((nonempty? const-decl "[semantic -> bool]" language nil)
    (nonempty type-eq-decl nil language nil)
    (symbol nonempty-type-decl nil language nil)
    (map? const-decl "[semantic -> bool]" language nil)
    (map type-eq-decl nil language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (interp? const-decl "[semantic -> bool]" language nil)
    (pretheory? const-decl "[semantic -> bool]" language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil) (ord type-decl nil language nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (weight def-decl "nat" language nil)
    (ord_nil? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_nil adt-constructor-decl "(ord_nil?)" language nil)
    (ord_symbol? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_symbol adt-constructor-decl "(ord_symbol?)" language nil)
    (ord_dot? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_dot adt-constructor-decl "(ord_dot?)" language nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ord_ktype_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_ktype_def adt-constructor-decl "(ord_ktype_def?)" language
     nil)
    (ord_itype? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_itype adt-constructor-decl "(ord_itype?)" language nil)
    (ord_ktype_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_ktype_decl adt-constructor-decl "(ord_ktype_decl?)" language
     nil)
    (ord_kconst_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_kconst_def adt-constructor-decl "(ord_kconst_def?)" language
     nil)
    (ord_iconst? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_iconst adt-constructor-decl "(ord_iconst?)" language nil)
    (ord_kconst_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_kconst_decl adt-constructor-decl "(ord_kconst_decl?)" language
     nil)
    (F const-decl "(LAMBDA (F: [ord -> nat]):
   (F(ord_nil) <= F(ord_symbol)) AND
    (F(ord_nil) <= F(ord_dot)) AND
     (F(ord_ktype_def) + F(ord_itype) <= F(ord_ktype_decl)) AND
      (F(ord_kconst_def) + F(ord_iconst) <= F(ord_kconst_decl)))"
     language nil)
    (app_symbol def-decl "{T: nonempty |
         (interp?(S) => interp?(T)) AND
          (context?(S) => context?(T)) AND
           (pretheory?(S) => pretheory?(T)) AND
            weight(F)(T) <= weight(F)(S)}" map nil)
    (nonempty formula-decl nil language nil)
    (typed? const-decl "bool" decl nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (subword_is_reflexive name-judgement
     "(reflexive?[well_formed_context])" subword nil)
    (nonempty_context_as_context formula-decl nil subtype nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil))
   nil))
 (subword_symbol_typed? 0
  (subword_symbol_typed?-1 nil 3582985305
   ("" (induct "Γ" :name "context_induction")
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skosimp* :preds? t)
      (("3" (expand app_symbol +)
        (("3" (bddsimp 1)
          (("1" (assert)
            (("1" (lift-if)
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (use member_symbol_when_subword :polarity? t)
                  (("1" (grind) nil nil)) nil)
                 ("2" (use member_symbol_when_subword :polarity? t)
                  (("2" (grind) nil nil)) nil)
                 ("3" (use member_symbol_when_subword :polarity? t)
                  (("3" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2"
            (invoke (bddsimp $1n) (~ "^well_formed?(%)(%) IMPLIES %"))
            (("1" (assert)
              (("1" (lift-if)
                (("1"
                  (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                  (("1" (inst - s!2 "rest(Δ!2)")
                    (("1" (grind) nil nil)) nil)
                   ("2" (inst - s!2 Δ!2) (("2" (grind) nil nil)) nil)
                   ("3" (inst - s!2 Δ!2) (("3" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skosimp* :preds? t)
      (("4" (expand app_symbol +)
        (("4" (bddsimp 1)
          (("1" (assert)
            (("1" (lift-if)
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (use member_symbol_when_subword :polarity? t)
                  (("1" (grind) nil nil)) nil)
                 ("2" (use member_symbol_when_subword :polarity? t)
                  (("2" (grind) nil nil)) nil)
                 ("3" (use member_symbol_when_subword :polarity? t)
                  (("3" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2"
            (invoke (bddsimp $1n) (~ "^well_formed?(%)(%) IMPLIES %"))
            (("1" (assert)
              (("1" (lift-if)
                (("1"
                  (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                  (("1" (inst - s!2 "rest(Δ!2)")
                    (("1" (grind) nil nil)) nil)
                   ("2" (inst - s!2 Δ!2) (("2" (grind) nil nil)) nil)
                   ("3" (inst - s!2 Δ!2) (("3" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skosimp* :preds? t)
      (("5" (expand app_symbol +)
        (("5" (bddsimp 1)
          (("1" (assert)
            (("1" (lift-if)
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (use member_symbol_when_subword :polarity? t)
                  (("1" (grind) nil nil)) nil)
                 ("2" (use member_symbol_when_subword :polarity? t)
                  (("2" (grind) nil nil)) nil)
                 ("3" (use member_symbol_when_subword :polarity? t)
                  (("3" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2"
            (invoke (bddsimp $1n) (~ "^well_formed?(%)(%) IMPLIES %"))
            (("1" (assert)
              (("1" (lift-if)
                (("1"
                  (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                  (("1" (inst - s!2 "rest(Δ!2)")
                    (("1" (grind) nil nil)) nil)
                   ("2" (inst - s!2 Δ!2) (("2" (grind) nil nil)) nil)
                   ("3" (inst - s!2 Δ!2) (("3" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skosimp* :preds? t)
      (("6" (assert)
        (("6" (lift-if)
          (("6" (bddsimp -8)
            (("6" (bddsimp -8)
              (("1" (inst - s!1 "rest(Δ!2)") (("1" (grind) nil nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skosimp* :preds? t)
      (("7" (expand app_symbol +)
        (("7" (bddsimp 1)
          (("1" (assert) nil nil)
           ("2"
            (invoke (bddsimp $1n) (~ "^well_formed?(%)(%) IMPLIES %"))
            (("1" (assert)
              (("1" (lift-if)
                (("1"
                  (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                  (("1" (inst - s!2 "rest(Δ!2)")
                    (("1" (grind) nil nil)) nil)
                   ("2" (inst - s!2 Δ!2) (("2" (grind) nil nil)) nil)
                   ("3" (inst - s!2 Δ!2) (("3" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skosimp* :preds? t)
      (("8" (expand app_symbol +)
        (("8" (bddsimp 1)
          (("1" (assert) nil nil)
           ("2"
            (invoke (bddsimp $1n) (~ "^well_formed?(%)(%) IMPLIES %"))
            (("1" (assert)
              (("1" (lift-if)
                (("1"
                  (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                  (("1" (inst - s!2 "rest(Δ!2)")
                    (("1" (grind) nil nil)) nil)
                   ("2" (inst - s!2 Δ!2) (("2" (grind) nil nil)) nil)
                   ("3" (inst - s!2 Δ!2) (("3" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("9" (skosimp* :preds? t)
      (("9" (expand app_symbol +)
        (("9" (bddsimp 1)
          (("1" (assert) nil nil)
           ("2"
            (invoke (bddsimp $1n) (~ "^well_formed?(%)(%) IMPLIES %"))
            (("1" (assert)
              (("1" (lift-if)
                (("1"
                  (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                  (("1" (inst - s!2 "rest(Δ!2)")
                    (("1" (grind) nil nil)) nil)
                   ("2" (inst - s!2 Δ!2) (("2" (grind) nil nil)) nil)
                   ("3" (inst - s!2 Δ!2) (("3" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("10" (skosimp* :preds? t)
      (("10" (expand app_symbol +)
        (("10" (bddsimp 1)
          (("1" (assert)
            (("1" (lift-if)
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (use member_symbol_when_subword :polarity? t)
                  (("1" (grind) nil nil)) nil)
                 ("2" (use member_symbol_when_subword :polarity? t)
                  (("2" (grind) nil nil)) nil)
                 ("3" (use member_symbol_when_subword :polarity? t)
                  (("3" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2"
            (invoke (bddsimp $1n) (~ "^well_formed?(%)(%) IMPLIES %"))
            (("1" (assert)
              (("1" (lift-if)
                (("1"
                  (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                  (("1" (inst - s!2 "rest(Δ!2)")
                    (("1" (grind) nil nil)) nil)
                   ("2" (inst - s!2 Δ!2) (("2" (grind) nil nil)) nil)
                   ("3" (inst - s!2 Δ!2) (("3" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("11" (skosimp* :preds? t)
      (("11" (invoke (typepred "%1") (~ + "app_symbol(%)(%)"))
        (("11" (rewrite nonempty_context_as_context)
          (("11" (grind) nil nil)) nil))
        nil))
      nil)
     ("12" (skosimp* :preds? t)
      (("12" (use member_symbol_when_subword :polarity? t)
        (("12" (prop)
          (("12" (use member_nonempty :polarity? t)
            (("12" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("13" (skosimp* :preds? t)
      (("13" (use member_symbol_when_subword :polarity? t)
        (("13" (grind) nil nil)) nil))
      nil)
     ("14" (skosimp* :preds? t)
      (("14" (invoke (typepred "%1") (~ + "app_symbol(%)(%)"))
        (("14" (rewrite nonempty_context_as_context)
          (("14" (grind) nil nil)) nil))
        nil))
      nil)
     ("15" (skosimp* :preds? t)
      (("15" (use member_nonempty :polarity? t)
        (("15" (grind) nil nil)) nil))
      nil))
    nil)
   ((member_nonempty formula-decl nil map nil)
    (nonempty_context_as_context formula-decl nil subtype nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonempty formula-decl nil language nil)
    (pretheory type-eq-decl nil language nil)
    (preterm type-eq-decl nil language nil)
    (preterm? const-decl "[semantic -> bool]" language nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pretype type-eq-decl nil language nil)
    (pretype? const-decl "[semantic -> bool]" language nil)
    (subword_is_reflexive name-judgement
     "(reflexive?[well_formed_context])" subword nil)
    (rest shared-adt-accessor-decl "[{x: semantic |
              ktype_decl?(x) OR ktype_def?(x) OR ktype_ext?(x) OR kvar?(x)
           OR kconst_decl?(x) OR kconst_def?(x) OR kconst_ext?(x)
           OR ktheory?(x) OR itype?(x) OR iconst?(x)} ->
   semantic]" language nil)
    (iconst? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (ktheory? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (kconst_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kvar? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (ktype_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (member_symbol_when_subword formula-decl nil subword nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (context_induction formula-decl nil inductions nil)
    (context formula-decl nil language nil)
    (nonempty_context type-eq-decl nil language nil)
    (typed? const-decl "bool" decl nil)
    (nonempty_context? const-decl "[semantic -> bool]" language nil)
    (nonempty type-eq-decl nil language nil)
    (interp? const-decl "[semantic -> bool]" language nil)
    (pretheory? const-decl "[semantic -> bool]" language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil) (ord type-decl nil language nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (weight def-decl "nat" language nil)
    (ord_nil? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_nil adt-constructor-decl "(ord_nil?)" language nil)
    (ord_symbol? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_symbol adt-constructor-decl "(ord_symbol?)" language nil)
    (ord_dot? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_dot adt-constructor-decl "(ord_dot?)" language nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ord_ktype_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_ktype_def adt-constructor-decl "(ord_ktype_def?)" language
     nil)
    (ord_itype? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_itype adt-constructor-decl "(ord_itype?)" language nil)
    (ord_ktype_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_ktype_decl adt-constructor-decl "(ord_ktype_decl?)" language
     nil)
    (ord_kconst_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_kconst_def adt-constructor-decl "(ord_kconst_def?)" language
     nil)
    (ord_iconst? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_iconst adt-constructor-decl "(ord_iconst?)" language nil)
    (ord_kconst_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_kconst_decl adt-constructor-decl "(ord_kconst_decl?)" language
     nil)
    (F const-decl "(LAMBDA (F: [ord -> nat]):
   (F(ord_nil) <= F(ord_symbol)) AND
    (F(ord_nil) <= F(ord_dot)) AND
     (F(ord_ktype_def) + F(ord_itype) <= F(ord_ktype_decl)) AND
      (F(ord_kconst_def) + F(ord_iconst) <= F(ord_kconst_decl)))"
     language nil)
    (app_symbol def-decl "{T: nonempty |
         (interp?(S) => interp?(T)) AND
          (context?(S) => context?(T)) AND
           (pretheory?(S) => pretheory?(T)) AND
            weight(F)(T) <= weight(F)(S)}" map nil)
    (semantic type-decl nil language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (symbol nonempty-type-decl nil language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (map? const-decl "[semantic -> bool]" language nil)
    (map type-eq-decl nil language nil) (≺ def-decl "bool" subword nil)
    (nonempty? const-decl "[semantic -> bool]" language nil))
   shostak))
 (subword_symbol_kind_TCC1 0
  (subword_symbol_kind_TCC1-1 nil 3582902491
   ("" (skosimp* :preds? t)
    (("" (use member_symbol_when_subword :polarity? t)
      (("" (prop)
        (("" (use member_nonempty :polarity? t) (("" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((member_symbol_when_subword formula-decl nil subword nil)
    (symbol nonempty-type-decl nil language nil)
    (member_nonempty formula-decl nil map nil)
    (map type-eq-decl nil language nil)
    (map? const-decl "[semantic -> bool]" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil))
   nil))
 (subword_symbol_kind 0
  (subword_symbol_kind-1 nil 3582985759
   ("" (induct "Γ" :name "context_induction")
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skosimp* :preds? t)
      (("3" (assert)
        (("3" (lift-if)
          (("3" (bddsimp 1)
            (("1" (bddsimp -8)
              (("1" (grind) nil nil)
               ("2" (use member_symbol_when_subword :polarity? t)
                (("2" (assert) nil nil)) nil)
               ("3" (use member_symbol_when_subword :polarity? t)
                (("3" (assert) nil nil)) nil))
              nil)
             ("2" (bddsimp -4)
              (("1" (bddsimp -7)
                (("1" (inst - s!2 "rest(Δ!2)") (("1" (assert) nil nil))
                  nil)
                 ("2" (inst - s!2 Δ!2) (("2" (assert) nil nil)) nil)
                 ("3" (assert)
                  (("3" (inst - s!2 Δ!2) (("3" (assert) nil nil)) nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skosimp* :preds? t)
      (("4" (assert)
        (("4" (lift-if)
          (("4" (bddsimp 1)
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (use member_symbol_when_subword :polarity? t)
                (("2" (assert) nil nil)) nil)
               ("3" (use member_symbol_when_subword :polarity? t)
                (("3" (assert) nil nil)) nil))
              nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (inst - s!2 "rest(Δ!2)") (("1" (assert) nil nil))
                  nil)
                 ("2" (inst - s!2 Δ!2) (("2" (assert) nil nil)) nil)
                 ("3" (inst - s!2 Δ!2) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skosimp* :preds? t)
      (("5" (assert)
        (("5" (lift-if)
          (("5" (bddsimp 1)
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (use member_symbol_when_subword :polarity? t)
                (("2" (assert) nil nil)) nil)
               ("3" (use member_symbol_when_subword :polarity? t)
                (("3" (assert) nil nil)) nil))
              nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (inst - s!2 "rest(Δ!2)") (("1" (assert) nil nil))
                  nil)
                 ("2" (inst - s!2 Δ!2) (("2" (assert) nil nil)) nil)
                 ("3" (inst - s!2 Δ!2) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skosimp* :preds? t)
      (("6" (assert)
        (("6" (lift-if)
          (("6" (bddsimp -8)
            (("6" (bddsimp -8)
              (("1" (inst - s!1 "rest(Δ!2)") (("1" (assert) nil nil))
                nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skosimp* :preds? t)
      (("7" (assert)
        (("7" (lift-if)
          (("7" (bddsimp 1)
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (use member_symbol_when_subword :polarity? t)
                (("2" (assert) nil nil)) nil)
               ("3" (use member_symbol_when_subword :polarity? t)
                (("3" (assert) nil nil)) nil))
              nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (inst - s!2 "rest(Δ!2)") (("1" (assert) nil nil))
                  nil)
                 ("2" (inst - s!2 Δ!2) (("2" (assert) nil nil)) nil)
                 ("3" (inst - s!2 Δ!2) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skosimp* :preds? t)
      (("8" (assert)
        (("8" (lift-if)
          (("8" (bddsimp 1)
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (use member_symbol_when_subword :polarity? t)
                (("2" (assert) nil nil)) nil)
               ("3" (use member_symbol_when_subword :polarity? t)
                (("3" (assert) nil nil)) nil))
              nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (inst - s!2 "rest(Δ!2)") (("1" (assert) nil nil))
                  nil)
                 ("2" (inst - s!2 Δ!2) (("2" (assert) nil nil)) nil)
                 ("3" (inst - s!2 Δ!2) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("9" (skosimp* :preds? t)
      (("9" (assert)
        (("9" (lift-if)
          (("9" (bddsimp 1)
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (use member_symbol_when_subword :polarity? t)
                (("2" (assert) nil nil)) nil)
               ("3" (use member_symbol_when_subword :polarity? t)
                (("3" (assert) nil nil)) nil))
              nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (inst - s!2 "rest(Δ!2)") (("1" (assert) nil nil))
                  nil)
                 ("2" (inst - s!2 Δ!2) (("2" (assert) nil nil)) nil)
                 ("3" (inst - s!2 Δ!2) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("10" (skosimp* :preds? t)
      (("10" (assert)
        (("10" (lift-if)
          (("10" (bddsimp 1)
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (use member_symbol_when_subword :polarity? t)
                (("2" (assert) nil nil)) nil)
               ("3" (use member_symbol_when_subword :polarity? t)
                (("3" (assert) nil nil)) nil))
              nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (inst - s!2 "rest(Δ!2)") (("1" (assert) nil nil))
                  nil)
                 ("2" (inst - s!2 Δ!2) (("2" (assert) nil nil)) nil)
                 ("3" (inst - s!2 Δ!2) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("11" (skosimp* :preds? t)
      (("11" (use member_symbol_when_subword :polarity? t)
        (("11" (prop)
          (("11" (use member_nonempty :polarity? t)
            (("11" (assert) nil nil)) nil))
          nil))
        nil))
      nil)
     ("12" (skosimp* :preds? t)
      (("12" (use member_symbol_when_subword :polarity? t)
        (("12" (assert) nil nil)) nil))
      nil)
     ("13" (skosimp* :preds? t)
      (("13" (use member_nonempty :polarity? t)
        (("13" (assert) nil nil)) nil))
      nil))
    nil)
   ((member_nonempty formula-decl nil map nil)
    (pretheory type-eq-decl nil language nil)
    (preterm type-eq-decl nil language nil)
    (preterm? const-decl "[semantic -> bool]" language nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pretype type-eq-decl nil language nil)
    (pretype? const-decl "[semantic -> bool]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ktype_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kvar? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (kconst_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktheory? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (iconst? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (rest shared-adt-accessor-decl "[{x: semantic |
              ktype_decl?(x) OR ktype_def?(x) OR ktype_ext?(x) OR kvar?(x)
           OR kconst_decl?(x) OR kconst_def?(x) OR kconst_ext?(x)
           OR ktheory?(x) OR itype?(x) OR iconst?(x)} ->
   semantic]" language nil)
    (member_symbol_when_subword formula-decl nil subword nil)
    (subword_is_reflexive name-judgement
     "(reflexive?[well_formed_context])" subword nil)
    (kind_nonempty application-judgement "kind" decl nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (context_induction formula-decl nil inductions nil)
    (app_symbol def-decl "{T: nonempty |
         (interp?(S) => interp?(T)) AND
          (context?(S) => context?(T)) AND
           (pretheory?(S) => pretheory?(T)) AND
            weight(F)(T) <= weight(F)(S)}" map nil)
    (F const-decl "(LAMBDA (F: [ord -> nat]):
   (F(ord_nil) <= F(ord_symbol)) AND
    (F(ord_nil) <= F(ord_dot)) AND
     (F(ord_ktype_def) + F(ord_itype) <= F(ord_ktype_decl)) AND
      (F(ord_kconst_def) + F(ord_iconst) <= F(ord_kconst_decl)))"
     language nil)
    (ord_kconst_decl adt-constructor-decl "(ord_kconst_decl?)" language
     nil)
    (ord_kconst_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_iconst adt-constructor-decl "(ord_iconst?)" language nil)
    (ord_iconst? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_kconst_def adt-constructor-decl "(ord_kconst_def?)" language
     nil)
    (ord_kconst_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_ktype_decl adt-constructor-decl "(ord_ktype_decl?)" language
     nil)
    (ord_ktype_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_itype adt-constructor-decl "(ord_itype?)" language nil)
    (ord_itype? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_ktype_def adt-constructor-decl "(ord_ktype_def?)" language
     nil)
    (ord_ktype_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (ord_dot adt-constructor-decl "(ord_dot?)" language nil)
    (ord_dot? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_symbol adt-constructor-decl "(ord_symbol?)" language nil)
    (ord_symbol? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_nil adt-constructor-decl "(ord_nil?)" language nil)
    (ord_nil? adt-recognizer-decl "[ord -> boolean]" language nil)
    (weight def-decl "nat" language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (ord type-decl nil language nil) (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pretheory? const-decl "[semantic -> bool]" language nil)
    (interp? const-decl "[semantic -> bool]" language nil)
    (nonempty type-eq-decl nil language nil)
    (kind const-decl "{r: keyword | nonempty?(S) IFF r ≠ ⊥}" decl nil)
    (⊥ adt-constructor-decl "(undefined?)" language nil)
    (undefined? adt-recognizer-decl "[keyword -> boolean]" language
     nil)
    (≠ const-decl "[T, T -> bool]" notequal nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (keyword type-decl nil language nil)
    (context formula-decl nil language nil)
    (semantic type-decl nil language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (symbol nonempty-type-decl nil language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (≺ def-decl "bool" subword nil)
    (map? const-decl "[semantic -> bool]" language nil)
    (map type-eq-decl nil language nil)
    (nonempty? const-decl "[semantic -> bool]" language nil))
   shostak))
 (subword_symbol_definition_TCC1 0
  (subword_symbol_definition_TCC1-1 nil 3582902491
   ("" (skosimp* :preds? t)
    (("" (use subword_symbol_definition? :polarity? t)
      (("" (assert) nil nil)) nil))
    nil)
   ((subword_symbol_definition? formula-decl nil subword nil)
    (symbol nonempty-type-decl nil language nil)
    (subword_is_reflexive name-judgement
     "(reflexive?[well_formed_context])" subword nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil))
   nil))
 (subword_symbol_definition 0
  (subword_symbol_definition-1 nil 3582986960
   ("" (induct "Γ" :name "context_induction")
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skosimp* :preds? t)
      (("3" (assert)
        (("3" (lift-if)
          (("3" (bddsimp 1)
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (use member_symbol_when_subword :polarity? t)
                (("2" (assert) nil nil)) nil)
               ("3" (use member_symbol_when_subword :polarity? t)
                (("3" (assert) nil nil)) nil))
              nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (inst - s!2 "rest(Δ!2)") (("1" (assert) nil nil))
                  nil)
                 ("2" (inst - s!2 Δ!2) (("2" (assert) nil nil)) nil)
                 ("3" (inst - s!2 Δ!2) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skosimp* :preds? t)
      (("4" (assert)
        (("4" (lift-if)
          (("4" (bddsimp 1)
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (use member_symbol_when_subword :polarity? t)
                (("2" (assert) nil nil)) nil)
               ("3" (use member_symbol_when_subword :polarity? t)
                (("3" (assert) nil nil)) nil))
              nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (inst - s!2 "rest(Δ!2)") (("1" (assert) nil nil))
                  nil)
                 ("2" (inst - s!2 Δ!2) (("2" (assert) nil nil)) nil)
                 ("3" (inst - s!2 Δ!2) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skosimp* :preds? t)
      (("5" (assert)
        (("5" (lift-if)
          (("5" (bddsimp 1)
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (use member_symbol_when_subword :polarity? t)
                (("2" (assert) nil nil)) nil)
               ("3" (use member_symbol_when_subword :polarity? t)
                (("3" (assert) nil nil)) nil))
              nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (inst - s!2 "rest(Δ!2)") (("1" (assert) nil nil))
                  nil)
                 ("2" (inst - s!2 Δ!2) (("2" (assert) nil nil)) nil)
                 ("3" (inst - s!2 Δ!2) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skosimp* :preds? t)
      (("6" (assert)
        (("6" (lift-if)
          (("6" (bddsimp -8)
            (("6" (bddsimp -8)
              (("1" (inst - s!1 "rest(Δ!2)") (("1" (assert) nil nil))
                nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skosimp* :preds? t)
      (("7" (assert)
        (("7" (lift-if)
          (("7" (bddsimp 1)
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (use member_symbol_when_subword :polarity? t)
                (("2" (assert) nil nil)) nil)
               ("3" (use member_symbol_when_subword :polarity? t)
                (("3" (assert) nil nil)) nil))
              nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (inst - s!2 "rest(Δ!2)") (("1" (assert) nil nil))
                  nil)
                 ("2" (inst - s!2 Δ!2) (("2" (assert) nil nil)) nil)
                 ("3" (inst - s!2 Δ!2) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skosimp* :preds? t)
      (("8" (assert)
        (("8" (lift-if)
          (("8" (bddsimp 1)
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (use member_symbol_when_subword :polarity? t)
                (("2" (assert) nil nil)) nil)
               ("3" (use member_symbol_when_subword :polarity? t)
                (("3" (assert) nil nil)) nil))
              nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (inst - s!2 "rest(Δ!2)") (("1" (assert) nil nil))
                  nil)
                 ("2" (inst - s!2 Δ!2) (("2" (assert) nil nil)) nil)
                 ("3" (inst - s!2 Δ!2) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("9" (skosimp* :preds? t)
      (("9" (assert)
        (("9" (lift-if)
          (("9" (bddsimp 1)
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (use member_symbol_when_subword :polarity? t)
                (("2" (assert) nil nil)) nil)
               ("3" (use member_symbol_when_subword :polarity? t)
                (("3" (assert) nil nil)) nil))
              nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (inst - s!2 "rest(Δ!2)") (("1" (assert) nil nil))
                  nil)
                 ("2" (inst - s!2 Δ!2) (("2" (assert) nil nil)) nil)
                 ("3" (inst - s!2 Δ!2) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("10" (skosimp* :preds? t)
      (("10" (assert)
        (("10" (lift-if)
          (("10" (bddsimp 1)
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (use member_symbol_when_subword :polarity? t)
                (("2" (assert) nil nil)) nil)
               ("3" (use member_symbol_when_subword :polarity? t)
                (("3" (assert) nil nil)) nil))
              nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (inst - s!2 "rest(Δ!2)") (("1" (assert) nil nil))
                  nil)
                 ("2" (inst - s!2 Δ!2) (("2" (assert) nil nil)) nil)
                 ("3" (inst - s!2 Δ!2) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("11" (skosimp* :preds? t)
      (("11" (use subword_symbol_definition? :polarity? t)
        (("11" (assert) nil nil)) nil))
      nil)
     ("12" (skosimp* :preds? t)
      (("12" (use member_symbol_when_subword :polarity? t)
        (("12" (prop)
          (("12" (use member_nonempty :polarity? t)
            (("12" (assert) nil nil)) nil))
          nil))
        nil))
      nil)
     ("13" (skosimp* :preds? t)
      (("13" (use member_symbol_when_subword :polarity? t)
        (("13" (assert) nil nil)) nil))
      nil)
     ("14" (skosimp* :preds? t)
      (("14" (use member_nonempty :polarity? t)
        (("14" (assert) nil nil)) nil))
      nil)
     ("15" (skosimp* :preds? t)
      (("15" (use member_nonempty :polarity? t)
        (("15" (assert) nil nil)) nil))
      nil))
    nil)
   ((member_nonempty formula-decl nil map nil)
    (subword_symbol_definition? formula-decl nil subword nil)
    (pretheory type-eq-decl nil language nil)
    (preterm type-eq-decl nil language nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pretype type-eq-decl nil language nil)
    (subword_is_reflexive name-judgement
     "(reflexive?[well_formed_context])" subword nil)
    (member_symbol_when_subword formula-decl nil subword nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (context_induction formula-decl nil inductions nil)
    (definition const-decl "{x: semantic |
         (type_kind?(S) IMPLIES pretype?(x)) AND
          (const_kind?(S) IMPLIES preterm?(x)) AND
           (theory_kind?(S) IMPLIES pretheory?(x)) AND
            weight(F)(x) + weight(F)(rest(S)) < weight(F)(S)}" decl
                nil)
    (rest shared-adt-accessor-decl "[{x: semantic |
              ktype_decl?(x) OR ktype_def?(x) OR ktype_ext?(x) OR kvar?(x)
           OR kconst_decl?(x) OR kconst_def?(x) OR kconst_ext?(x)
           OR ktheory?(x) OR itype?(x) OR iconst?(x)} ->
   semantic]" language nil)
    (iconst? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (ktheory? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (kconst_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kvar? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (ktype_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (theory_kind? const-decl "bool" decl nil)
    (preterm? const-decl "[semantic -> bool]" language nil)
    (const_kind? const-decl "bool" decl nil)
    (pretype? const-decl "[semantic -> bool]" language nil)
    (type_kind? const-decl "bool" decl nil)
    (definition type-eq-decl nil decl nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (context formula-decl nil language nil)
    (nonempty type-eq-decl nil language nil)
    (definition? const-decl "bool" decl nil)
    (interp? const-decl "[semantic -> bool]" language nil)
    (pretheory? const-decl "[semantic -> bool]" language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil) (ord type-decl nil language nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (weight def-decl "nat" language nil)
    (ord_nil? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_nil adt-constructor-decl "(ord_nil?)" language nil)
    (ord_symbol? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_symbol adt-constructor-decl "(ord_symbol?)" language nil)
    (ord_dot? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_dot adt-constructor-decl "(ord_dot?)" language nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ord_ktype_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_ktype_def adt-constructor-decl "(ord_ktype_def?)" language
     nil)
    (ord_itype? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_itype adt-constructor-decl "(ord_itype?)" language nil)
    (ord_ktype_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_ktype_decl adt-constructor-decl "(ord_ktype_decl?)" language
     nil)
    (ord_kconst_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_kconst_def adt-constructor-decl "(ord_kconst_def?)" language
     nil)
    (ord_iconst? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_iconst adt-constructor-decl "(ord_iconst?)" language nil)
    (ord_kconst_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_kconst_decl adt-constructor-decl "(ord_kconst_decl?)" language
     nil)
    (F const-decl "(LAMBDA (F: [ord -> nat]):
   (F(ord_nil) <= F(ord_symbol)) AND
    (F(ord_nil) <= F(ord_dot)) AND
     (F(ord_ktype_def) + F(ord_itype) <= F(ord_ktype_decl)) AND
      (F(ord_kconst_def) + F(ord_iconst) <= F(ord_kconst_decl)))"
     language nil)
    (app_symbol def-decl "{T: nonempty |
         (interp?(S) => interp?(T)) AND
          (context?(S) => context?(T)) AND
           (pretheory?(S) => pretheory?(T)) AND
            weight(F)(T) <= weight(F)(S)}" map nil)
    (semantic type-decl nil language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (symbol nonempty-type-decl nil language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (map? const-decl "[semantic -> bool]" language nil)
    (map type-eq-decl nil language nil) (≺ def-decl "bool" subword nil)
    (nonempty? const-decl "[semantic -> bool]" language nil))
   shostak))
 (subword_symbol_type_TCC1 0
  (subword_symbol_type_TCC1-1 nil 3582902491
   ("" (skosimp* :preds? t)
    (("" (use subword_symbol_typed? :polarity? t)
      (("" (assert)
        (("" (invoke (typepred "%1") (~ + "app_symbol(%)(%)"))
          (("" (rewrite nonempty_context_as_context)
            (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((subword_symbol_typed? formula-decl nil subword nil)
    (symbol nonempty-type-decl nil language nil)
    (nonempty? const-decl "[semantic -> bool]" language nil)
    (nonempty type-eq-decl nil language nil)
    (map? const-decl "[semantic -> bool]" language nil)
    (map type-eq-decl nil language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (interp? const-decl "[semantic -> bool]" language nil)
    (pretheory? const-decl "[semantic -> bool]" language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil) (ord type-decl nil language nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (weight def-decl "nat" language nil)
    (ord_nil? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_nil adt-constructor-decl "(ord_nil?)" language nil)
    (ord_symbol? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_symbol adt-constructor-decl "(ord_symbol?)" language nil)
    (ord_dot? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_dot adt-constructor-decl "(ord_dot?)" language nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ord_ktype_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_ktype_def adt-constructor-decl "(ord_ktype_def?)" language
     nil)
    (ord_itype? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_itype adt-constructor-decl "(ord_itype?)" language nil)
    (ord_ktype_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_ktype_decl adt-constructor-decl "(ord_ktype_decl?)" language
     nil)
    (ord_kconst_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_kconst_def adt-constructor-decl "(ord_kconst_def?)" language
     nil)
    (ord_iconst? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_iconst adt-constructor-decl "(ord_iconst?)" language nil)
    (ord_kconst_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_kconst_decl adt-constructor-decl "(ord_kconst_decl?)" language
     nil)
    (F const-decl "(LAMBDA (F: [ord -> nat]):
   (F(ord_nil) <= F(ord_symbol)) AND
    (F(ord_nil) <= F(ord_dot)) AND
     (F(ord_ktype_def) + F(ord_itype) <= F(ord_ktype_decl)) AND
      (F(ord_kconst_def) + F(ord_iconst) <= F(ord_kconst_decl)))"
     language nil)
    (app_symbol def-decl "{T: nonempty |
         (interp?(S) => interp?(T)) AND
          (context?(S) => context?(T)) AND
           (pretheory?(S) => pretheory?(T)) AND
            weight(F)(T) <= weight(F)(S)}" map nil)
    (nonempty formula-decl nil language nil)
    (typed? const-decl "bool" decl nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonempty_context_as_context formula-decl nil subtype nil)
    (subword_is_reflexive name-judgement
     "(reflexive?[well_formed_context])" subword nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil))
   nil))
 (subword_symbol_type 0
  (subword_symbol_type-1 nil 3582987173
   ("" (induct "Γ" :name "context_induction")
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skosimp* :preds? t)
      (("3" (assert)
        (("3" (lift-if)
          (("3" (bddsimp 1)
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (use member_symbol_when_subword :polarity? t)
                (("2" (assert) nil nil)) nil)
               ("3" (use member_symbol_when_subword :polarity? t)
                (("3" (assert) nil nil)) nil))
              nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (inst - s!2 "rest(Δ!2)") (("1" (assert) nil nil))
                  nil)
                 ("2" (inst - s!2 Δ!2) (("2" (assert) nil nil)) nil)
                 ("3" (inst - s!2 Δ!2) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skosimp* :preds? t)
      (("4" (assert)
        (("4" (lift-if)
          (("4" (bddsimp 1)
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (use member_symbol_when_subword :polarity? t)
                (("2" (assert) nil nil)) nil)
               ("3" (use member_symbol_when_subword :polarity? t)
                (("3" (assert) nil nil)) nil))
              nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (inst - s!2 "rest(Δ!2)") (("1" (assert) nil nil))
                  nil)
                 ("2" (inst - s!2 Δ!2) (("2" (assert) nil nil)) nil)
                 ("3" (inst - s!2 Δ!2) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skosimp* :preds? t)
      (("5" (assert)
        (("5" (lift-if)
          (("5" (bddsimp 1)
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (use member_symbol_when_subword :polarity? t)
                (("2" (assert) nil nil)) nil)
               ("3" (use member_symbol_when_subword :polarity? t)
                (("3" (assert) nil nil)) nil))
              nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (inst - s!2 "rest(Δ!2)") (("1" (assert) nil nil))
                  nil)
                 ("2" (inst - s!2 Δ!2) (("2" (assert) nil nil)) nil)
                 ("3" (inst - s!2 Δ!2) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skosimp* :preds? t)
      (("6" (assert)
        (("6" (lift-if)
          (("6" (bddsimp -8)
            (("6" (bddsimp -8)
              (("1" (inst - s!1 "rest(Δ!2)") (("1" (assert) nil nil))
                nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skosimp* :preds? t)
      (("7" (assert)
        (("7" (lift-if)
          (("7" (bddsimp 1)
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (use member_symbol_when_subword :polarity? t)
                (("2" (assert) nil nil)) nil)
               ("3" (use member_symbol_when_subword :polarity? t)
                (("3" (assert) nil nil)) nil))
              nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (inst - s!2 "rest(Δ!2)") (("1" (assert) nil nil))
                  nil)
                 ("2" (inst - s!2 Δ!2) (("2" (assert) nil nil)) nil)
                 ("3" (inst - s!2 Δ!2) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skosimp* :preds? t)
      (("8" (assert)
        (("8" (lift-if)
          (("8" (bddsimp 1)
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (use member_symbol_when_subword :polarity? t)
                (("2" (assert) nil nil)) nil)
               ("3" (use member_symbol_when_subword :polarity? t)
                (("3" (assert) nil nil)) nil))
              nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (inst - s!2 "rest(Δ!2)") (("1" (assert) nil nil))
                  nil)
                 ("2" (inst - s!2 Δ!2) (("2" (assert) nil nil)) nil)
                 ("3" (inst - s!2 Δ!2) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("9" (skosimp* :preds? t)
      (("9" (assert)
        (("9" (lift-if)
          (("9" (bddsimp 1)
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (use member_symbol_when_subword :polarity? t)
                (("2" (assert) nil nil)) nil)
               ("3" (use member_symbol_when_subword :polarity? t)
                (("3" (assert) nil nil)) nil))
              nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (inst - s!2 "rest(Δ!2)") (("1" (assert) nil nil))
                  nil)
                 ("2" (inst - s!2 Δ!2) (("2" (assert) nil nil)) nil)
                 ("3" (inst - s!2 Δ!2) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("10" (skosimp* :preds? t)
      (("10" (assert)
        (("10" (lift-if)
          (("10" (bddsimp 1)
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (use member_symbol_when_subword :polarity? t)
                (("2" (assert) nil nil)) nil)
               ("3" (use member_symbol_when_subword :polarity? t)
                (("3" (assert) nil nil)) nil))
              nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1"
                (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
                (("1" (inst - s!2 "rest(Δ!2)") (("1" (assert) nil nil))
                  nil)
                 ("2" (inst - s!2 Δ!2) (("2" (assert) nil nil)) nil)
                 ("3" (inst - s!2 Δ!2) (("3" (assert) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("11" (skosimp* :preds? t)
      (("11" (split 1)
        (("1" (invoke (typepred "%1") (~ + "app_symbol(%)(%)"))
          (("1" (rewrite nonempty_context_as_context)
            (("1" (grind) nil nil)) nil))
          nil)
         ("2" (use subword_symbol_typed? :polarity? t)
          (("2" (assert) nil nil)) nil))
        nil))
      nil)
     ("12" (skosimp* :preds? t)
      (("12" (use member_symbol_when_subword :polarity? t)
        (("12" (prop)
          (("12" (use member_nonempty :polarity? t)
            (("12" (assert) nil nil)) nil))
          nil))
        nil))
      nil)
     ("13" (skosimp* :preds? t)
      (("13" (use member_symbol_when_subword :polarity? t)
        (("13" (assert) nil nil)) nil))
      nil)
     ("14" (skosimp* :preds? t)
      (("14" (invoke (typepred "%1") (~ + "app_symbol(%)(%)"))
        (("14" (rewrite nonempty_context_as_context)
          (("14" (assert) (("14" (grind) nil nil)) nil)) nil))
        nil))
      nil)
     ("15" (skosimp* :preds? t)
      (("15" (use member_nonempty :polarity? t)
        (("15" (assert) nil nil)) nil))
      nil)
     ("16" (skosimp* :preds? t)
      (("16" (invoke (typepred "%1") (~ + "app_symbol(%)(%)"))
        (("16" (rewrite nonempty_context_as_context)
          (("16" (assert) (("16" (grind) nil nil)) nil)) nil))
        nil))
      nil)
     ("17" (skosimp* :preds? t)
      (("17" (use member_nonempty :polarity? t)
        (("17" (assert) nil nil)) nil))
      nil))
    nil)
   ((pretheory formula-decl nil language nil)
    (interp formula-decl nil language nil)
    (member_nonempty formula-decl nil map nil)
    (subword_symbol_typed? formula-decl nil subword nil)
    (nonempty formula-decl nil language nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonempty_context_as_context formula-decl nil subtype nil)
    (pretheory type-eq-decl nil language nil)
    (preterm type-eq-decl nil language nil)
    (preterm? const-decl "[semantic -> bool]" language nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (subword_is_reflexive name-judgement
     "(reflexive?[well_formed_context])" subword nil)
    (member_symbol_when_subword formula-decl nil subword nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (context_induction formula-decl nil inductions nil)
    (type_ const-decl
     "{T | weight(F)(T) + weight(F)(rest(Γ)) < weight(F)(Γ)}" decl nil)
    (rest shared-adt-accessor-decl "[{x: semantic |
              ktype_decl?(x) OR ktype_def?(x) OR ktype_ext?(x) OR kvar?(x)
           OR kconst_decl?(x) OR kconst_def?(x) OR kconst_ext?(x)
           OR ktheory?(x) OR itype?(x) OR iconst?(x)} ->
   semantic]" language nil)
    (iconst? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (ktheory? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (kconst_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kvar? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (ktype_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (pretype type-eq-decl nil language nil)
    (pretype? const-decl "[semantic -> bool]" language nil)
    (typed type-eq-decl nil decl nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (context formula-decl nil language nil)
    (nonempty_context type-eq-decl nil language nil)
    (typed? const-decl "bool" decl nil)
    (nonempty_context? const-decl "[semantic -> bool]" language nil)
    (nonempty type-eq-decl nil language nil)
    (interp? const-decl "[semantic -> bool]" language nil)
    (pretheory? const-decl "[semantic -> bool]" language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil) (ord type-decl nil language nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (weight def-decl "nat" language nil)
    (ord_nil? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_nil adt-constructor-decl "(ord_nil?)" language nil)
    (ord_symbol? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_symbol adt-constructor-decl "(ord_symbol?)" language nil)
    (ord_dot? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_dot adt-constructor-decl "(ord_dot?)" language nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ord_ktype_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_ktype_def adt-constructor-decl "(ord_ktype_def?)" language
     nil)
    (ord_itype? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_itype adt-constructor-decl "(ord_itype?)" language nil)
    (ord_ktype_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_ktype_decl adt-constructor-decl "(ord_ktype_decl?)" language
     nil)
    (ord_kconst_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_kconst_def adt-constructor-decl "(ord_kconst_def?)" language
     nil)
    (ord_iconst? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_iconst adt-constructor-decl "(ord_iconst?)" language nil)
    (ord_kconst_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_kconst_decl adt-constructor-decl "(ord_kconst_decl?)" language
     nil)
    (F const-decl "(LAMBDA (F: [ord -> nat]):
   (F(ord_nil) <= F(ord_symbol)) AND
    (F(ord_nil) <= F(ord_dot)) AND
     (F(ord_ktype_def) + F(ord_itype) <= F(ord_ktype_decl)) AND
      (F(ord_kconst_def) + F(ord_iconst) <= F(ord_kconst_decl)))"
     language nil)
    (app_symbol def-decl "{T: nonempty |
         (interp?(S) => interp?(T)) AND
          (context?(S) => context?(T)) AND
           (pretheory?(S) => pretheory?(T)) AND
            weight(F)(T) <= weight(F)(S)}" map nil)
    (semantic type-decl nil language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (symbol nonempty-type-decl nil language nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (map? const-decl "[semantic -> bool]" language nil)
    (map type-eq-decl nil language nil) (≺ def-decl "bool" subword nil)
    (nonempty? const-decl "[semantic -> bool]" language nil))
   shostak))
 (subword_var_kind 0
  (subword_var_kind-1 nil 3582987395
   ("" (induct "Γ" :name "context_induction")
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skosimp* :preds? t)
      (("3" (assert)
        (("3" (lift-if)
          (("3" (bddsimp -7)
            (("1" (grind) nil nil)
             ("2" (bddsimp -6)
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil)
             ("3" (assert) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skosimp* :preds? t)
      (("4" (assert)
        (("4" (lift-if)
          (("4" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
            (("1" (grind) nil nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil)
             ("3"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skosimp* :preds? t)
      (("5" (assert)
        (("5" (lift-if)
          (("5" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
            (("1" (grind) nil nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil)
             ("3"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skosimp* :preds? t)
      (("6" (assert)
        (("6" (lift-if)
          (("6" (bddsimp -8)
            (("6" (bddsimp -9)
              (("1" (inst - "x!1 - 1" "rest(Δ!2)")
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skosimp* :preds? t)
      (("7" (assert)
        (("7" (lift-if)
          (("7" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
            (("1" (grind) nil nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil)
             ("3"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skosimp* :preds? t)
      (("8" (assert)
        (("8" (lift-if)
          (("8" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
            (("1" (grind) nil nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil)
             ("3"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("9" (skosimp* :preds? t)
      (("9" (assert)
        (("9" (lift-if)
          (("9" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
            (("1" (assert) nil nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil)
             ("3"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("10" (skosimp* :preds? t)
      (("10" (assert)
        (("10" (lift-if)
          (("10" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
            (("1" (assert) nil nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil)
             ("3"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("11" (skosimp* :preds? t)
      (("11" (use member_var_when_subword :polarity? t)
        (("11" (inst - x!1) (("11" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((member_var_when_subword formula-decl nil subword nil)
    (pretheory type-eq-decl nil language nil)
    (pretheory? const-decl "[semantic -> bool]" language nil)
    (preterm type-eq-decl nil language nil)
    (preterm? const-decl "[semantic -> bool]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ktype_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktheory? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (iconst? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (rest shared-adt-accessor-decl "[{x: semantic |
              ktype_decl?(x) OR ktype_def?(x) OR ktype_ext?(x) OR kvar?(x)
           OR kconst_decl?(x) OR kconst_def?(x) OR kconst_ext?(x)
           OR ktheory?(x) OR itype?(x) OR iconst?(x)} ->
   semantic]" language nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pretype type-eq-decl nil language nil)
    (pretype? const-decl "[semantic -> bool]" language nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (subword_is_reflexive name-judgement
     "(reflexive?[well_formed_context])" subword nil)
    (kind_nonempty application-judgement "kind" decl nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (context_induction formula-decl nil inductions nil)
    (app_var def-decl
     "{Δ | kvar?(Δ) AND nonempty?(Δ) AND weight(F)(Δ) <= weight(F)(Γ)}"
     map nil)
    (F const-decl "(LAMBDA (F: [ord -> nat]):
   (F(ord_nil) <= F(ord_symbol)) AND
    (F(ord_nil) <= F(ord_dot)) AND
     (F(ord_ktype_def) + F(ord_itype) <= F(ord_ktype_decl)) AND
      (F(ord_kconst_def) + F(ord_iconst) <= F(ord_kconst_decl)))"
     language nil)
    (ord_kconst_decl adt-constructor-decl "(ord_kconst_decl?)" language
     nil)
    (ord_kconst_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_iconst adt-constructor-decl "(ord_iconst?)" language nil)
    (ord_iconst? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_kconst_def adt-constructor-decl "(ord_kconst_def?)" language
     nil)
    (ord_kconst_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_ktype_decl adt-constructor-decl "(ord_ktype_decl?)" language
     nil)
    (ord_ktype_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_itype adt-constructor-decl "(ord_itype?)" language nil)
    (ord_itype? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_ktype_def adt-constructor-decl "(ord_ktype_def?)" language
     nil)
    (ord_ktype_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (ord_dot adt-constructor-decl "(ord_dot?)" language nil)
    (ord_dot? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_symbol adt-constructor-decl "(ord_symbol?)" language nil)
    (ord_symbol? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_nil adt-constructor-decl "(ord_nil?)" language nil)
    (ord_nil? adt-recognizer-decl "[ord -> boolean]" language nil)
    (weight def-decl "nat" language nil)
    (ord type-decl nil language nil) (<= const-decl "bool" reals nil)
    (kvar? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (kind const-decl "{r: keyword | nonempty?(S) IFF r ≠ ⊥}" decl nil)
    (⊥ adt-constructor-decl "(undefined?)" language nil)
    (undefined? adt-recognizer-decl "[keyword -> boolean]" language
     nil)
    (≠ const-decl "[T, T -> bool]" notequal nil)
    (nonempty? const-decl "[semantic -> bool]" language nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (map type-eq-decl nil language nil)
    (map? const-decl "[semantic -> bool]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (keyword type-decl nil language nil)
    (context formula-decl nil language nil)
    (semantic type-decl nil language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (≺ def-decl "bool" subword nil))
   shostak))
 (subword_var_type_TCC1 0
  (subword_var_type_TCC1-1 nil 3582902491
   ("" (skosimp* :preds? t)
    (("" (split 1)
      (("1" (invoke (typepred "%1") (~ + "app_var(%)(%)"))
        (("1" (rewrite nonempty_context_as_context)
          (("1" (grind) nil nil)) nil))
        nil)
       ("2" (invoke (typepred "%1") (~ + "app_var(%)(%)"))
        (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((nonempty_context_as_context formula-decl nil subtype nil)
    (app_var def-decl
     "{Δ | kvar?(Δ) AND nonempty?(Δ) AND weight(F)(Δ) <= weight(F)(Γ)}"
     map nil)
    (F const-decl "(LAMBDA (F: [ord -> nat]):
   (F(ord_nil) <= F(ord_symbol)) AND
    (F(ord_nil) <= F(ord_dot)) AND
     (F(ord_ktype_def) + F(ord_itype) <= F(ord_ktype_decl)) AND
      (F(ord_kconst_def) + F(ord_iconst) <= F(ord_kconst_decl)))"
     language nil)
    (ord_kconst_decl adt-constructor-decl "(ord_kconst_decl?)" language
     nil)
    (ord_kconst_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_iconst adt-constructor-decl "(ord_iconst?)" language nil)
    (ord_iconst? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_kconst_def adt-constructor-decl "(ord_kconst_def?)" language
     nil)
    (ord_kconst_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_ktype_decl adt-constructor-decl "(ord_ktype_decl?)" language
     nil)
    (ord_ktype_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_itype adt-constructor-decl "(ord_itype?)" language nil)
    (ord_itype? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_ktype_def adt-constructor-decl "(ord_ktype_def?)" language
     nil)
    (ord_ktype_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (ord_dot adt-constructor-decl "(ord_dot?)" language nil)
    (ord_dot? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_symbol adt-constructor-decl "(ord_symbol?)" language nil)
    (ord_symbol? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_nil adt-constructor-decl "(ord_nil?)" language nil)
    (ord_nil? adt-recognizer-decl "[ord -> boolean]" language nil)
    (weight def-decl "nat" language nil)
    (ord type-decl nil language nil) (<= const-decl "bool" reals nil)
    (nonempty? const-decl "[semantic -> bool]" language nil)
    (kvar? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonempty formula-decl nil language nil)
    (typed? const-decl "bool" decl nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nonempty_rest application-judgement
     "{m: map | weight(F)(m) < weight(F)(x)}" subtype nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (semantic type-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (well_formed_context type-eq-decl nil well_formed nil))
   nil))
 (subword_var_type_TCC2 0
  (subword_var_type_TCC2-1 nil 3582902491
   ("" (induct "Γ" :name "context_induction")
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skosimp* :preds? t)
      (("3" (assert)
        (("3" (lift-if)
          (("3" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
            (("1" (assert) nil nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil)
             ("3"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skosimp* :preds? t)
      (("4" (assert)
        (("4" (lift-if)
          (("4" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
            (("1" (assert) nil nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil)
             ("3"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skosimp* :preds? t)
      (("5" (assert)
        (("5" (lift-if)
          (("5" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
            (("1" (assert) nil nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil)
             ("3"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skosimp* :preds? t)
      (("6" (assert)
        (("6" (lift-if)
          (("6" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
            (("6" (assert) nil nil)) nil))
          nil))
        nil))
      nil)
     ("7" (skosimp* :preds? t)
      (("7" (assert)
        (("7" (lift-if)
          (("7" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
            (("1" (assert) nil nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil)
             ("3"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skosimp* :preds? t)
      (("8" (assert)
        (("8" (lift-if)
          (("8" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
            (("1" (assert) nil nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil)
             ("3"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("9" (skosimp* :preds? t)
      (("9" (assert)
        (("9" (lift-if)
          (("9" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
            (("1" (assert) nil nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil)
             ("3"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("10" (skosimp* :preds? t)
      (("10" (assert)
        (("10" (lift-if)
          (("10" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
            (("1" (assert) nil nil)
             ("2"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil)
             ("3"
              (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
              (("1" (inst - "x!1 - 1" Δ!2)
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("11" (skosimp* :preds? t)
      (("11" (use member_var_when_subword :polarity? t)
        (("11" (grind) nil nil)) nil))
      nil)
     ("12" (skosimp* :preds? t)
      (("12" (use member_var_when_subword :polarity? t)
        (("12" (grind) nil nil)) nil))
      nil))
    nil)
   ((≺ def-decl "bool" subword nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (syntaxic type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (context type-eq-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (semantic type-decl nil language nil)
    (app_var def-decl
     "{Δ | kvar?(Δ) AND nonempty?(Δ) AND weight(F)(Δ) <= weight(F)(Γ)}"
     map nil)
    (F const-decl "(LAMBDA (F: [ord -> nat]):
   (F(ord_nil) <= F(ord_symbol)) AND
    (F(ord_nil) <= F(ord_dot)) AND
     (F(ord_ktype_def) + F(ord_itype) <= F(ord_ktype_decl)) AND
      (F(ord_kconst_def) + F(ord_iconst) <= F(ord_kconst_decl)))"
     language nil)
    (ord_kconst_decl adt-constructor-decl "(ord_kconst_decl?)" language
     nil)
    (ord_kconst_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_iconst adt-constructor-decl "(ord_iconst?)" language nil)
    (ord_iconst? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_kconst_def adt-constructor-decl "(ord_kconst_def?)" language
     nil)
    (ord_kconst_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_ktype_decl adt-constructor-decl "(ord_ktype_decl?)" language
     nil)
    (ord_ktype_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_itype adt-constructor-decl "(ord_itype?)" language nil)
    (ord_itype? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_ktype_def adt-constructor-decl "(ord_ktype_def?)" language
     nil)
    (ord_ktype_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (ord_dot adt-constructor-decl "(ord_dot?)" language nil)
    (ord_dot? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_symbol adt-constructor-decl "(ord_symbol?)" language nil)
    (ord_symbol? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_nil adt-constructor-decl "(ord_nil?)" language nil)
    (ord_nil? adt-recognizer-decl "[ord -> boolean]" language nil)
    (weight def-decl "nat" language nil)
    (ord type-decl nil language nil) (<= const-decl "bool" reals nil)
    (nonempty? const-decl "[semantic -> bool]" language nil)
    (kvar? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (nonempty_context? const-decl "[semantic -> bool]" language nil)
    (context formula-decl nil language nil)
    (nonempty_context type-eq-decl nil language nil)
    (typed? const-decl "bool" decl nil)
    (context_induction formula-decl nil inductions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subword_is_reflexive name-judgement
     "(reflexive?[well_formed_context])" subword nil)
    (nonempty_context formula-decl nil language nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (pretype type-eq-decl nil language nil)
    (pretype? const-decl "[semantic -> bool]" language nil)
    (preterm type-eq-decl nil language nil)
    (preterm? const-decl "[semantic -> bool]" language nil)
    (pretheory type-eq-decl nil language nil)
    (pretheory? const-decl "[semantic -> bool]" language nil)
    (member_var_when_subword formula-decl nil subword nil))
   nil))
 (subword_var_type 0
  (subword_var_type-1 nil 3582988037
   ("" (induct "Γ" :name "context_induction")
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skosimp* :preds? t)
      (("3" (assert)
        (("3" (lift-if)
          (("3" (bddsimp -5)
            (("1" (bddsimp -7)
              (("1" (grind) nil nil)
               ("2" (inst - x!1 Δ!2)
                (("2" (assert) (("2" (grind) nil nil)) nil)) nil)
               ("3" (inst - x!1 Δ!2) (("3" (grind) nil nil)) nil))
              nil)
             ("2" (assert) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skosimp* :preds? t)
      (("4" (assert)
        (("4" (lift-if)
          (("4"
            (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (inst - x!1 Δ!2) (("2" (grind) nil nil)) nil)
               ("3" (inst - x!1 Δ!2) (("3" (grind) nil nil)) nil))
              nil)
             ("2" (assert) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skosimp* :preds? t)
      (("5" (assert)
        (("5" (lift-if)
          (("5"
            (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (inst - x!1 Δ!2) (("2" (grind) nil nil)) nil)
               ("3" (inst - x!1 Δ!2) (("3" (grind) nil nil)) nil))
              nil)
             ("2" (assert) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skosimp* :preds? t)
      (("6" (assert)
        (("6" (lift-if)
          (("6"
            (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)) nil)
             ("2" (assert) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skosimp* :preds? t)
      (("7" (assert)
        (("7" (lift-if)
          (("7"
            (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (inst - x!1 Δ!2) (("2" (grind) nil nil)) nil)
               ("3" (inst - x!1 Δ!2) (("3" (grind) nil nil)) nil))
              nil)
             ("2" (assert) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skosimp* :preds? t)
      (("8" (assert)
        (("8" (lift-if)
          (("8"
            (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (inst - x!1 Δ!2) (("2" (grind) nil nil)) nil)
               ("3" (inst - x!1 Δ!2) (("3" (grind) nil nil)) nil))
              nil)
             ("2" (assert) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("9" (skosimp* :preds? t)
      (("9" (assert)
        (("9" (lift-if)
          (("9"
            (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (inst - x!1 Δ!2) (("2" (grind) nil nil)) nil)
               ("3" (inst - x!1 Δ!2) (("3" (grind) nil nil)) nil))
              nil)
             ("2" (assert) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("10" (skosimp* :preds? t)
      (("10" (assert)
        (("10" (lift-if)
          (("10"
            (invoke (bddsimp $1n) (~ "well_formed?(%)(%) IMPLIES %"))
            (("1" (invoke (bddsimp $1n) (~ "IF % THEN % ELSE % ENDIF"))
              (("1" (grind) nil nil)
               ("2" (inst - x!1 Δ!2) (("2" (grind) nil nil)) nil)
               ("3" (inst - x!1 Δ!2) (("3" (grind) nil nil)) nil))
              nil)
             ("2" (assert) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("11" (skosimp* :preds? t)
      (("11" (assert) (("11" (grind) nil nil)) nil)) nil)
     ("12" (skosimp* :preds? t)
      (("12" (use member_var_when_subword :polarity? t)
        (("12" (grind) nil nil)) nil))
      nil)
     ("13" (skosimp* :preds? t)
      (("13" (split 1)
        (("1" (invoke (typepred "%1") (~ + "app_var(%)(%)"))
          (("1" (rewrite nonempty_context_as_context)
            (("1" (grind) nil nil)) nil))
          nil)
         ("2" (invoke (typepred "%1") (~ + "app_var(%)(%)"))
          (("2" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nonempty_rest application-judgement
     "{m: map | weight(F)(m) < weight(F)(x)}" subtype nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nonempty formula-decl nil language nil)
    (nonempty_context_as_context formula-decl nil subtype nil)
    (member_var_when_subword formula-decl nil subword nil)
    (nonempty_context formula-decl nil language nil)
    (pretheory type-eq-decl nil language nil)
    (pretheory? const-decl "[semantic -> bool]" language nil)
    (preterm type-eq-decl nil language nil)
    (preterm? const-decl "[semantic -> bool]" language nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (subword_is_reflexive name-judgement
     "(reflexive?[well_formed_context])" subword nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (context_induction formula-decl nil inductions nil)
    (type_ const-decl
     "{T | weight(F)(T) + weight(F)(rest(Γ)) < weight(F)(Γ)}" decl nil)
    (rest shared-adt-accessor-decl "[{x: semantic |
              ktype_decl?(x) OR ktype_def?(x) OR ktype_ext?(x) OR kvar?(x)
           OR kconst_decl?(x) OR kconst_def?(x) OR kconst_ext?(x)
           OR ktheory?(x) OR itype?(x) OR iconst?(x)} ->
   semantic]" language nil)
    (iconst? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (ktheory? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (kconst_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (kconst_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_ext? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_def? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (ktype_decl? adt-recognizer-decl "[semantic -> boolean]" language
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (pretype type-eq-decl nil language nil)
    (pretype? const-decl "[semantic -> bool]" language nil)
    (typed type-eq-decl nil decl nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (context formula-decl nil language nil)
    (semantic type-decl nil language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (syntaxic type-eq-decl nil language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (≺ def-decl "bool" subword nil)
    (nonempty_context? const-decl "[semantic -> bool]" language nil)
    (kvar? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (nonempty? const-decl "[semantic -> bool]" language nil)
    (<= const-decl "bool" reals nil) (ord type-decl nil language nil)
    (weight def-decl "nat" language nil)
    (ord_nil? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_nil adt-constructor-decl "(ord_nil?)" language nil)
    (ord_symbol? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_symbol adt-constructor-decl "(ord_symbol?)" language nil)
    (ord_dot? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_dot adt-constructor-decl "(ord_dot?)" language nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ord_ktype_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_ktype_def adt-constructor-decl "(ord_ktype_def?)" language
     nil)
    (ord_itype? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_itype adt-constructor-decl "(ord_itype?)" language nil)
    (ord_ktype_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_ktype_decl adt-constructor-decl "(ord_ktype_decl?)" language
     nil)
    (ord_kconst_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_kconst_def adt-constructor-decl "(ord_kconst_def?)" language
     nil)
    (ord_iconst? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_iconst adt-constructor-decl "(ord_iconst?)" language nil)
    (ord_kconst_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_kconst_decl adt-constructor-decl "(ord_kconst_decl?)" language
     nil)
    (F const-decl "(LAMBDA (F: [ord -> nat]):
   (F(ord_nil) <= F(ord_symbol)) AND
    (F(ord_nil) <= F(ord_dot)) AND
     (F(ord_ktype_def) + F(ord_itype) <= F(ord_ktype_decl)) AND
      (F(ord_kconst_def) + F(ord_iconst) <= F(ord_kconst_decl)))"
     language nil)
    (app_var def-decl
     "{Δ | kvar?(Δ) AND nonempty?(Δ) AND weight(F)(Δ) <= weight(F)(Γ)}"
     map nil)
    (nonempty_context type-eq-decl nil language nil)
    (typed? const-decl "bool" decl nil))
   shostak))
 (well_formed_subword 0
  (well_formed_subword-1 nil 3582989254
   ("" (induct "e" :name "expr_induction")
    (("1" (grind) nil nil)
     ("2" (skosimp* :preds? t)
      (("2" (assert)
        (("2" (prop)
          (("1" (use member_symbol_when_subword :polarity? t)
            (("1" (assert) nil nil)) nil)
           ("2" (use subword_symbol_kind :polarity? t)
            (("2" (assert) (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil)
     ("3" (skosimp* :preds? t)
      (("3" (assert)
        (("3" (prop)
          (("1" (use member_symbol_when_subword :polarity? t)
            (("1" (assert) nil nil)) nil)
           ("2" (use subword_symbol_kind :polarity? t)
            (("2" (grind) nil nil)) nil)
           ("3" (use subword_symbol_definition :polarity? t)
            (("3" (assert) (("3" (grind) nil nil)) nil)) nil)
           ("4" (inst? :polarity? t) (("4" (assert) nil nil)) nil))
          nil))
        nil))
      nil)
     ("4" (skosimp* :preds? t)
      (("4" (assert)
        (("4" (use member_var_when_subword :polarity? t)
          (("4" (grind) nil nil)) nil))
        nil))
      nil)
     ("5" (skosimp* :preds? t)
      (("5" (assert) (("5" (grind) nil nil)) nil)) nil)
     ("6" (grind) nil nil) ("7" (grind) nil nil) ("8" (grind) nil nil)
     ("9" (grind) nil nil)
     ("10" (skosimp* :preds? t)
      (("10" (assert)
        (("10" (inst - Γ!1 Δ!1)
          (("10" (inst - "kvar(A!1, Γ!1)" "kvar(A!1, Δ!1)")
            (("1" (assert) (("1" (grind) nil nil)) nil)
             ("2" (rewrite doubleplus_empty) (("2" (assert) nil nil))
              nil)
             ("3" (rewrite doubleplus_empty) (("3" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("11" (skosimp* :preds? t)
      (("11" (assert)
        (("11" (inst - Γ!1 Δ!1)
          (("11" (inst - "kvar(A!1, Γ!1)" "kvar(A!1, Δ!1)")
            (("1" (assert) (("1" (grind) nil nil)) nil)
             ("2" (rewrite doubleplus_empty) (("2" (assert) nil nil))
              nil)
             ("3" (rewrite doubleplus_empty) (("3" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("12" (skosimp* :preds? t)
      (("12" (assert)
        (("12" (inst - Γ!1 Δ!1)
          (("12" (inst - "kvar(T!1, Γ!1)" "kvar(T!1, Δ!1)")
            (("1" (grind) nil nil)
             ("2" (rewrite doubleplus_empty) (("2" (assert) nil nil))
              nil)
             ("3" (rewrite doubleplus_empty) (("3" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("13" (skosimp* :preds? t) (("13" (grind) nil nil)) nil)
     ("14" (skosimp* :preds? t)
      (("14" (assert) (("14" (grind) nil nil)) nil)) nil)
     ("15" (grind) nil nil))
    nil)
   ((doubleplus_empty formula-decl nil context nil)
    (kvar adt-constructor-decl "[[semantic, semantic] -> (kvar?)]"
     language nil)
    (kvar? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ord type-decl nil language nil)
    (weight def-decl "nat" language nil)
    (<= const-decl "bool" reals nil)
    (ord_nil? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_nil adt-constructor-decl "(ord_nil?)" language nil)
    (ord_symbol? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_symbol adt-constructor-decl "(ord_symbol?)" language nil)
    (ord_dot? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_dot adt-constructor-decl "(ord_dot?)" language nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ord_ktype_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_ktype_def adt-constructor-decl "(ord_ktype_def?)" language
     nil)
    (ord_itype? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_itype adt-constructor-decl "(ord_itype?)" language nil)
    (ord_ktype_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_ktype_decl adt-constructor-decl "(ord_ktype_decl?)" language
     nil)
    (ord_kconst_def? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_kconst_def adt-constructor-decl "(ord_kconst_def?)" language
     nil)
    (ord_iconst? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_iconst adt-constructor-decl "(ord_iconst?)" language nil)
    (ord_kconst_decl? adt-recognizer-decl "[ord -> boolean]" language
     nil)
    (ord_kconst_decl adt-constructor-decl "(ord_kconst_decl?)" language
     nil)
    (F const-decl "(LAMBDA (F: [ord -> nat]):
   (F(ord_nil) <= F(ord_symbol)) AND
    (F(ord_nil) <= F(ord_dot)) AND
     (F(ord_ktype_def) + F(ord_itype) <= F(ord_ktype_decl)) AND
      (F(ord_kconst_def) + F(ord_iconst) <= F(ord_kconst_decl)))"
     language nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ord_empty? adt-recognizer-decl "[ord -> boolean]" language nil)
    (ord_empty adt-constructor-decl "(ord_empty?)" language nil)
    (++ def-decl
     "{Θ | weight(F)(Θ) = weight(F)(Γ) + weight(F)(Δ) - F(ord_empty) - 1}"
     context nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pretype? const-decl "[semantic -> bool]" language nil)
    (pretype type-eq-decl nil language nil)
    (preterm? const-decl "[semantic -> bool]" language nil)
    (preterm type-eq-decl nil language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (member_var_when_subword formula-decl nil subword nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (interp type-eq-decl nil language nil)
    (interp? const-decl "[semantic -> bool]" language nil)
    (definition const-decl "{x: semantic |
         (type_kind?(S) IMPLIES pretype?(x)) AND
          (const_kind?(S) IMPLIES preterm?(x)) AND
           (theory_kind?(S) IMPLIES pretheory?(x)) AND
            weight(F)(x) + weight(F)(rest(S)) < weight(F)(S)}" decl
                nil)
    (definition? const-decl "bool" decl nil)
    (subword_symbol_definition formula-decl nil subword nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (symbol nonempty-type-decl nil language nil)
    (member_symbol_when_subword formula-decl nil subword nil)
    (theory_kind? const-decl "bool" decl nil)
    (kind const-decl "{r: keyword | nonempty?(S) IFF r ≠ ⊥}" decl nil)
    (subword_symbol_kind formula-decl nil subword nil)
    (kind_theory formula-decl nil decl nil)
    (subword_is_reflexive name-judgement
     "(reflexive?[well_formed_context])" subword nil)
    (kind_nonempty application-judgement "kind" decl nil)
    (expr_induction formula-decl nil inductions nil)
    (≺ def-decl "bool" subword nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (well_formed_context type-eq-decl nil well_formed nil)
    (〈〉 adt-constructor-decl "(empty?)" language nil)
    (empty? adt-recognizer-decl "[semantic -> boolean]" language nil)
    (well_formed? def-decl "bool" well_formed nil)
    (syntaxic type-eq-decl nil language nil)
    (syntaxic? const-decl "[semantic -> bool]" language nil)
    (context type-eq-decl nil language nil)
    (context? const-decl "[semantic -> bool]" language nil)
    (expr type-eq-decl nil language nil)
    (expr? const-decl "[semantic -> bool]" language nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (semantic type-decl nil language nil)
    (context formula-decl nil language nil))
   shostak)))

