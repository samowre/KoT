definitions: THEORY
BEGIN
  IMPORTING contexts
  
  e: VAR expr
  Γ, Δ, Θ: VAR context
  A, B, T: VAR pretype
  r, s, m: VAR symbol
  n: VAR name
  x, y: VAR nat
  a, b, f, g: VAR preterm
  σ, τ: VAR interp
  S: VAR syntaxic



  % We would have liked to say that 
  %  Δ ≺ Γ AND s ∈ Δ IMPLIES Δ(s) = Γ(s), 
  % but because of the way we represent Δ(s) (as a context, not just the car)
  % it is false. We instead give these equivalent theorems :
  %  Δ ≺ Γ AND s ∈ Δ IMPLIES Δ(s) and Γ(s) have same
  % kind, definition and type. 

  % NOTE: I wrote ... definition?(Δ(s)) IMPLIES definition(Δ(s)) = definition(Γ(s))
  % The fact that definition?(Δ(s)) IMPLIES definition?(Γ(S)) will be generated
  % as a TCC, and hence won't be easily usable. If we need it at some point, 
  % add it to the theorem (or write the TCC as a lemma).
  subword_symbol_kind: THEOREM 
    well_formed?(〈〉)(Γ) AND Δ ≺ Γ AND
    s ∈ Δ 
    IMPLIES kind(Δ(s)) = kind(Γ(s))
  subword_symbol_definition: THEOREM
    well_formed?(〈〉)(Γ) AND Δ ≺ Γ AND
    s ∈ Δ AND definition?(Δ(s))
    IMPLIES definition(Δ(s)) = definition(Γ(s))
  subword_symbol_type: THEOREM 
    well_formed?(〈〉)(Γ) AND Δ ≺ Γ AND
    s ∈ Δ AND typed?(Δ(s)) 
    IMPLIES type_(Δ(s)) = type_(Γ(s))

  % Same for variables
  subword_var_kind: THEOREM
    Δ ≺ Γ AND x ∈ Δ IMPLIES kind(Δ(x)) = kind(Γ(x))
  subword_var_type: THEOREM
    Δ ≺ Γ AND x ∈ Δ IMPLIES type_(Δ(x)) = type_(Γ(x))
  
  % I don't remember why and where we need it, but we do 
  % (probably for τ's tccs)
  well_formed_subword: THEOREM 
    well_formed?(〈〉)(Γ) AND Δ ≺ Γ AND 
    well_formed?(Δ)(e) IMPLIES well_formed?(Γ)(e)




  % η function, as informally defined just before definition 5.5
  % + some modification for the theory interpretations extension
  η(Γ, m, σ)(e): RECURSIVE semantic =
    CASES e OF
      symbol(s):
        IF s ∈ σ THEN definition(σ(s))
	ELSIF s ∈ Γ THEN  dot(m, σ, s)
	ELSE symbol(s) ENDIF,
      dot(m_, τ, s_): dot(m_, η(Γ, m, σ)(τ), s_),
      fun(A, B): fun(η(Γ, m, σ)(A), η(Γ, m, σ)(B)),
      prod(A, B): prod(η(Γ, m, σ)(A), η(Γ, m, σ)(B)),
      subtype(T, a): subtype(η(Γ, m, σ)(T), η(Γ, m, σ)(a)),
      v(i): v(i),
      app(f, a): app(η(Γ, m, σ)(f), η(Γ, m, σ)(a)),
      lam(T, a): lam(η(Γ, m, σ)(T), η(Γ, m, σ)(a)),
      pair(a, b): pair(η(Γ, m, σ)(a), η(Γ, m, σ)(b)),
      lproj(a): lproj(η(Γ, m, σ)(a)),
      rproj(a): rproj(η(Γ, m, σ)(a)),
      nil: nil,
      itype(s, T, τ): itype(s, η(Γ, m, σ)(T), η(Γ, m, σ)(τ)),
      iconst(s, a, τ): iconst(s, η(Γ, m, σ)(a), η(Γ, m, σ)(τ))
    ENDCASES
  MEASURE w(e)


  %eta_pretype: JUDGEMENT η(Γ, m, σ)(e: pretype?(T)) HAS_TYPE pretype
  %eta_pretype: JUDGEMENT η(Γ, m, σ)(e: preterm?(T)) HAS_TYPE preterm 
  %eta_pretype: JUDGEMENT η(Γ, m, σ)(e: interp?(T)) HAS_TYPE interp



  external?(Γ): bool = ktype_ext?(Γ) OR kconst_ext?(Γ)

  % Expanded Type : 2.16, 3.9, 5.5, 5.16
  % + some modification for the theory interpretations extension
  δ(Γ)(T | well_formed?(Γ)(T)): RECURSIVE semantic =
    CASES T OF
      symbol(s):
        IF definition?(Γ(s)) THEN
          δ(rest(Γ(s)))(definition(Γ(s)))
  	ELSE symbol(s) ENDIF,
      dot(m, σ, s):
        IF s ∈ σ THEN
  	  δ(Γ)(definition(σ(s)))
  	ELSE
  	  LET Δ = definition(Γ(m)) IN
  	  IF definition?(Δ(s)) THEN
  	    δ(Γ)(η(rest(Δ(s)), m, σ)(definition(Δ(s))))
  	  ELSIF external?(Δ(s)) THEN
  	    dot(m, nil, s)
  	  ELSE dot(m, δ(Γ)(σ), s) ENDIF
  	ENDIF,
      fun(A, B): fun(δ(Γ)(A), δ(Γ)(B)),
      prod(A, B): prod(δ(Γ)(A), δ(Γ)(B)),
      subtype(T, a): subtype(δ(Γ)(T), a),
      〈〉: 〈〉,
      ktype_decl(s, Δ): ktype_decl(s, δ(Γ)(Δ)),
      ktype_def(s, T, Δ): ktype_def(s, δ(Γ ++ δ(Γ)(Δ))(T), δ(Γ)(Δ)),
      ktype_ext(s, Δ): ktype_ext(s, δ(Γ)(Δ)),
      kconst_decl(s, T, Δ): kconst_decl(s, δ(Γ ++ δ(Γ)(Δ))(T), δ(Γ)(Δ)),
      kconst_def(s, T, a, Δ):
        kconst_def(s, δ(Γ ++ δ(Γ)(Δ))(T), δ(Γ ++ δ(Γ)(Δ))(a), δ(Γ)(Δ)),
      kconst_ext(s, T, Δ):
        kconst_ext(s, δ(Γ ++ δ(Γ)(Δ))(T), δ(Γ)(Δ)),
      nil: nil,
      itype(s, T, σ): itype(s, δ(Γ)(T), δ(Γ)(σ)),
      iconst(s, a, σ): iconst(s, δ(Γ)(a), δ(Γ)(σ))
    ENDCASES
  MEASURE w(Γ) + w(T)

  %delta_pretype: JUDGEMENT δ(Γ)(T | well_formed?(Γ)(T) AND pretype?(T)) HAS_TYPE pretype
  %delta_pretheory: JUDGEMENT δ(Γ)(T | well_formed?(Γ)(T) AND pretheory?(T)) HAS_TYPE pretheory
  %delta_precontext: JUDGEMENT δ(Γ)(T | well_formed?(Γ)(T) AND context?(T)) HAS_TYPE context
  %delta_interp: JUDGEMENT δ(Γ)(T | well_formed?(Γ)(T) AND interp?(T)) HAS_TYPE interp
        
END definitions
