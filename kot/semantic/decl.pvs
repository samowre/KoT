decl: THEORY
BEGIN
  IMPORTING language, subtype, inductions


  Γ, Δ, Θ: VAR context
  A, B, T: VAR pretype
  r, s: VAR symbol
  n, m: VAR name
  x, y: VAR nat
  a, b, f, g: VAR preterm
  σ, τ: VAR interp
  S: VAR map

  type_kind?(S): bool =
    COND
      ktype_decl?(S) -> TRUE,
      ktype_def?(S) -> TRUE,
      ktype_ext?(S) -> TRUE,
      itype?(S) -> TRUE,
      ELSE -> FALSE
    ENDCOND
  type_kind: TYPE = (type_kind?)

  const_kind?(S): bool =
    COND
      kconst_decl?(S) -> TRUE,
      kconst_def?(S) -> TRUE,
      kconst_ext?(S) -> TRUE,
      iconst?(S) -> TRUE,
      ELSE -> FALSE
    ENDCOND
  const_kind: TYPE = (const_kind?)

  var_kind?(S): bool =
    COND
      kvar?(S) -> TRUE,
      ELSE -> FALSE
    ENDCOND
  var_kind: TYPE = (var_kind?)

  typed_kind?(S): bool =
    COND
      kconst_decl?(S) -> TRUE,
      kconst_def?(S) -> TRUE,
      kconst_ext?(S) -> TRUE,
      iconst?(S) -> TRUE,
      kvar?(S) -> TRUE,
      ELSE -> FALSE
    ENDCOND
  typed_kind: TYPE = (typed_kind?)

  theory_kind?(S): bool =
    COND
      ktheory?(S) -> TRUE,
      ELSE -> FALSE
    ENDCOND
  theory_kind: TYPE = (theory_kind?)

  const_kind_is_typed_kind: JUDGEMENT
    const_kind SUBTYPE_OF typed_kind
  var_kind_is_typed_kind: JUDGEMENT
    var_kind SUBTYPE_OF typed_kind
  var_kind_when_typed_kind: THEOREM
    typed_kind?(S) IMPLIES (var_kind?(S) IFF NOT const_kind?(S))
  const_kind_when_typed_kind: THEOREM
    typed_kind?(S) IMPLIES (const_kind?(S) IFF NOT var_kind?(S))
  theory_kind_when_typed_kind: THEOREM
    typed_kind?(S) IMPLIES NOT theory_kind?(S)
  typed_kind_when_theory_kind: THEOREM
    theory_kind?(S) IMPLIES NOT typed_kind?(S)
  type_kind_when_typed_kind: THEOREM
    typed_kind?(S) IMPLIES NOT type_kind?(S)
  typed_kind_when_type_kind: THEOREM
    type_kind?(S) IMPLIES NOT typed_kind?(S)
  type_kind_when_theory_kind: THEOREM
    theory_kind?(S) IMPLIES NOT type_kind?(S)
  theory_kind_when_type_kind: THEOREM
    type_kind?(S) IMPLIES NOT theory_kind?(S)
  theory_kind_when_interp: THEOREM
    interp?(S) IMPLIES NOT theory_kind?(S)
  interp_when_theory_kind: THEOREM
    theory_kind?(S) IMPLIES NOT interp?(S)

  % Function kind as informally defined at the begining of chapter 2.
  % Meant to be used as kind(Γ(s)), to give the kind of the symbol s
  % among CONSTANT, TYPE, VARIABLE, THEORY
  kind(S): 
    { r: keyword | nonempty?(S) IFF r ≠ ⊥ } =
    CASES S OF
      ktype_decl(s, Δ): KTYPE,
      ktype_def(s, T, Δ): KTYPE,
      ktype_ext(s, Δ): KTYPE,
      kconst_decl(s, T, Δ): KCONST,
      kconst_def(s, T, a, Δ): KCONST,
      kconst_ext(s, T, Δ): KCONST,
      kvar(T, Δ): KVAR,
      ktheory(s, Θ, Δ): KTHEORY,
      itype(s, T, σ): KTYPE,
      iconst(s, a, σ): KCONST
      ELSE ⊥
    ENDCASES
  AUTO_REWRITE+ kind
  kind_nonempty: JUDGEMENT
    kind(S: nonempty) HAS_TYPE kind
  kind_type: THEOREM
    kind(S) = KTYPE IFF type_kind?(S)
  kind_const: THEOREM
    kind(S) = KCONST IFF const_kind?(S)
  kind_var: THEOREM
    kind(S) = KVAR IFF var_kind?(S)
  kind_theory: THEOREM
    kind(S) = KTHEORY IFF theory_kind?(S)
  AUTO_REWRITE+ kind_type, kind_const, kind_var, kind_theory

  % Checks if the first element of S is a definition (not a declaration)
  % Used as definition?(Γ(s)) it checks that s has a definition in Γ
  % (such as s: TYPE = def_type, or s: T = def_term)
  definition?(S: nonempty): bool =
    CASES S OF
      ktype_def(s, T, Δ): TRUE,
      kconst_def(s, T, a, Δ): TRUE,
      ktheory(s, Θ, Δ): TRUE,
      itype(s, T, σ): TRUE,
      iconst(s, a, σ): TRUE
      ELSE FALSE
    ENDCASES
  AUTO_REWRITE+ definition?
  definition: TYPE = (definition?)
  nonempty_interp_is_definition: JUDGEMENT
    nonempty_interp SUBTYPE_OF definition

  
  % Function definition as informally defined at the begining of section 2.5
  % Meant to be used as definition(Γ(s)), to give the definition of the symbol s
  % (if it exists, see definition?), i.e a type, a term or a theory.
  definition(S: definition):
    { x: semantic | (type_kind?(S) IMPLIES pretype?(x)) AND
                    (const_kind?(S) IMPLIES preterm?(x)) AND
		    (theory_kind?(S) IMPLIES pretheory?(x)) AND
		    w(x) + w(rest(S)) < w(S) } =
    CASES S OF
      ktype_def(s, T, Δ): T,
      kconst_def(s, T, a, Δ): a,
      ktheory(s, Θ, Δ): Θ,
      itype(s, T, σ): T,
      iconst(s, a, σ): a
    ENDCASES
  AUTO_REWRITE+ definition

  % Checks if the first element of S has a type (i.e is a preterm).
  % Used as typed?(Γ(s)) it checks that s is a preterm in Γ,
  % i.e appears of the form s: T or s: T = a
  typed?(Γ: nonempty_context): bool =
    COND
      kconst_decl?(Γ) -> TRUE,
      kconst_def?(Γ) -> TRUE,
      kconst_ext?(Γ) -> TRUE,
      kvar?(Γ) -> TRUE,
      ELSE -> FALSE
    ENDCOND
  AUTO_REWRITE+ typed?
  typed: TYPE = (typed?)

  % Function type as informally defined at the begining of chapter 2.
  % Meant to be used as type(Γ(s)), to give the type of s
  % (if it exists, see typed?), i.e type(s: T = def_term, Γ) = T
  type_(Γ: typed): { T | w(T) + w(rest(Γ)) < w(Γ) } =
    CASES Γ OF
      kconst_decl(s, T, Δ): T,
      kconst_def(s, T, a, Δ): T,
      kconst_ext(s, T, Δ): T,
      kvar(T, Δ): T
    ENDCASES
  AUTO_REWRITE+ type_
END decl
