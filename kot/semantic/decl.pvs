decl: THEORY
BEGIN
  IMPORTING language, subtype, inductions
  IMPORTING subst

  Γ, Δ, Θ: VAR context
  A, B, T: VAR pretype
  r, s: VAR symbol
  n, m: VAR name
  x, y: VAR nat
  a, b, f, g: VAR preterm
  σ, τ: VAR interp
  S: VAR syntaxic
  M: VAR map

  % find(Γ, s: ..., Δ)(s) = Γ
  % It is the context in which s is declared
  % (hence in which defintion(s) and type(s) are defined)
  find(Γ)(s: (dsymbols(Γ))): RECURSIVE context =
    COND
      kvar?(Γ) -> find(rest(Γ))(s)
    , ELSE -> IF s = s(Γ) THEN rest(Γ) ELSE find(rest(Γ))(s) ENDIF
    ENDCOND
  MEASURE w(Γ)
  dsymbols_find: THEOREM FORALL (s: (dsymbols(Γ))):
    dsymbols(find(Γ)(s)) ⊂ dsymbols(Γ)
  dvars_find: THEOREM FORALL (s: (dsymbols(Γ))):
    dvars(find(Γ)(s)) <= dvars(Γ)
  symbols_find: THEOREM FORALL (s: (dsymbols(Γ))):
    symbols(find(Γ)(s)) ⊂ symbols(Γ)
  vars_find: THEOREM FORALL (s: (dsymbols(Γ))):
    vars(find(Γ)(s)) ⊂ { x | (x + dvars(Γ) - dvars(find(Γ)(s))) ∈ vars(Γ) }
  find_is_closed: THEOREM FORALL (Δ | closed?(Γ)(Δ)), (s: (dsymbols(Δ))):
    closed?(Γ)(find(Δ)(s))
  find_is_uniques: JUDGEMENT
    find(Γ | uniques?(Γ))(s: (dsymbols(Γ))) HAS_TYPE (uniques?)


  % Checks that s has a definition in Γ
  % (such as s: TYPE = def_type, or s: T = def_term)
  definition?(Γ)(s: (dsymbols(Γ))): RECURSIVE bool =
    COND
      kvar?(Γ) -> definition?(rest(Γ))(s)
    , ELSE -> IF s = s(Γ) THEN (ktype_def?(Γ) OR kconst_def?(Γ) OR ktheory?(Γ))
              ELSE definition?(rest(Γ))(s) ENDIF
    ENDCOND
  MEASURE w(Γ)

  % dtheory?(Γ, s: THEORY ..., Δ)(s) = TRUE
  dtheory?(Γ)(s: (dsymbols(Γ))): RECURSIVE bool =
    COND
      kvar?(Γ) -> dtheory?(rest(Γ))(s)
    , ELSE -> IF s = s(Γ) THEN ktheory?(Γ)
              ELSE dtheory?(rest(Γ))(s) ENDIF
    ENDCOND
  MEASURE w(Γ)
  dtheory_is_definition: THEOREM FORALL (s: (dsymbols(Γ))):
    dtheory?(Γ)(s) IMPLIES definition?(Γ)(s)

  % dtype?(Γ, s: TYPE = ..., Δ)(s) = TRUE
  dtype?(Γ)(s: (dsymbols(Γ))): RECURSIVE bool =
    COND
      kvar?(Γ) -> dtype?(rest(Γ))(s)
    , ELSE -> IF s = s(Γ) THEN ktype_def?(Γ)
              ELSE dtype?(rest(Γ))(s) ENDIF
    ENDCOND
  MEASURE w(Γ)
  dtype_is_definition: THEOREM FORALL (s: (dsymbols(Γ))):
    dtype?(Γ)(s) IMPLIES definition?(Γ)(s)

  % dconst?(Γ, s: T = ..., Δ)(s) = TRUE
  dconst?(Γ)(s: (dsymbols(Γ))): RECURSIVE bool =
    COND
      kvar?(Γ) -> dconst?(rest(Γ))(s)
    , ELSE -> IF s = s(Γ) THEN kconst_def?(Γ)
              ELSE dconst?(rest(Γ))(s) ENDIF
    ENDCOND
  MEASURE w(Γ)
  dconst_is_definition: THEOREM FORALL (s: (dsymbols(Γ))):
    dconst?(Γ)(s) IMPLIES definition?(Γ)(s)

  % Function kind as informally defined at the begining of chapter 2.
  % Meant to be used as kind(Γ(s)), to give the kind of the symbol s
  % among CONSTANT, TYPE, VARIABLE, THEORY
  %kind(Γ)(s: (dsymbols(Γ))): kind =
  %  CASES 


  AUTO_REWRITE definition?, dtheory?, dtype?, dconst?
  AUTO_REWRITE dtheory_is_definition, dtype_is_definition, dconst_is_definition

  % Function definition as informally defined at the begining of section 2.5
  % definition(Γ, s: TYPE = T, Δ)(s) = T
  % definition(Γ, s: T = a, Δ)(s) = a
  % definition(Γ, s: THEORY BEGIN Θ END, Δ)(s) = Θ
  definition(Γ)(s: (definition?(Γ))): RECURSIVE expr =
    CASES Γ OF
      ktype_def(t, T, Δ): IF t = s THEN T ELSE definition(Δ)(s) ENDIF
    , kconst_def(t, T, a, Δ): IF t = s THEN a ELSE definition(Δ)(s) ENDIF
    , ktheory(t, Θ, Δ): IF t = s THEN Θ ELSE definition(Δ)(s) ENDIF
      ELSE definition(rest(Γ))(s)
    ENDCASES
  MEASURE w(Γ)
  AUTO_REWRITE definition
  definition_dtype: RECURSIVE JUDGEMENT
    definition(Γ)(s: (dtype?(Γ))) HAS_TYPE pretype
  definition_dconst: RECURSIVE JUDGEMENT
    definition(Γ)(s: (dconst?(Γ))) HAS_TYPE preterm
  definition_dtheory: RECURSIVE JUDGEMENT
    definition(Γ)(s: (dtheory?(Γ))) HAS_TYPE pretheory

  % If Γ is closed (ie uses only symbols declared in Γ) then
  % definition(Γ)(s) only uses symbols that have been previously
  % declared in Γ
  symbols_definition: THEOREM FORALL (Δ: (closed?(Γ)), s: (definition?(Δ))):
    symbols(definition(Δ)(s)) ⊂ dsymbols(find(Δ)(s)) ∪ dsymbols(Γ)
  % Same for vars
  vars_definition: THEOREM FORALL (Δ: (closed?(Γ)), s: (definition?(Δ))):
    vars(definition(Δ)(s)) ⊂ { x | x < dvars(find(Δ)(s)) + dvars(Γ) }
  % closed_definition = symbols_definition AND vars_definition
  closed_definition: THEOREM FORALL (Δ: (closed?(Γ)), s: (definition?(Δ))):
    closed?(Γ ++ find(Δ)(s))(definition(Δ)(s))
    
  % A theory does not define variables
  dvars_definition: THEOREM FORALL (s: (dtheory?(Γ))):
    dvars(definition(Γ)(s)) = 0
  uniques_definition: THEOREM FORALL (s: (dtheory?(Γ))):
    uniques?(Γ) IMPLIES uniques?(definition(Γ)(s))

  % Checks that s is a preterm in Γ,
  % i.e appears of the form s: T or s: T = a
  typed?(Γ)(s: (dsymbols(Γ))): RECURSIVE bool =
    COND
      kvar?(Γ) -> typed?(rest(Γ))(s)
    , ELSE -> IF s = s(Γ) THEN (kconst_def?(Γ) OR kconst_decl?(Γ) OR kconst_ext?(Γ))
              ELSE typed?(rest(Γ))(s) ENDIF
    ENDCOND
  MEASURE w(Γ)
  AUTO_REWRITE typed?

  % Function type as informally defined at the begining of chapter 2.
  % type(Γ, s: T, Δ) = T
  % type(Γ, s: T = a, Δ) = T
  type_(Γ)(s: (typed?(Γ))): RECURSIVE pretype =
    CASES Γ OF
      kconst_def(t, T, a, Δ): IF t = s THEN T ELSE type_(Δ)(s) ENDIF
    , kconst_decl(t, T, Δ): IF t = s THEN T ELSE type_(Δ)(s) ENDIF
    , kconst_ext(t, T, Δ): IF t = s THEN T ELSE type_(Δ)(s) ENDIF
      ELSE type_(rest(Γ))(s)
    ENDCASES
  MEASURE w(Γ)
  AUTO_REWRITE type_

  % If Γ is closed, then type(Γ)(s) only uses symbols
  % that have been previously declared in Γ
  symbols_type: THEOREM FORALL (Γ: (closed?(〈〉)), s: (typed?(Γ))):
    symbols(type_(Γ)(s)) ⊂ dsymbols(find(Γ)(s))
  % same for vars
  vars_type: THEOREM FORALL (Γ: (closed?(〈〉)), s: (typed?(Γ))):
    vars(type_(Γ)(s)) ⊂ { x | x < dvars(find(Γ)(s)) }
  % closed_type = symbols_type AND vars_type
  closed_type: THEOREM FORALL (Γ: (closed?(〈〉)), s: (typed?(Γ))):
    closed?(find(Γ)(s))(type_(Γ)(s))


  % Length of a context (as a list)
  length(Γ): RECURSIVE nat =
    CASES Γ OF
      〈〉: 0
      ELSE 1 + length(rest(Γ))
    ENDCASES
  MEASURE w(Γ)
  AUTO_REWRITE length

  % pos(Γ)(s) returns the position of s in Γ 
  % where contexts are seen as reversed lists
  % ie pos(Γ, s: ...)(s) = length(Γ)
  % and nth(s: ..., Γ)(s) = 0
  pos(Γ, (s: (dsymbols(Γ)))): RECURSIVE below[length(Γ)] =
    CASES Γ OF
      kvar(T, Δ): pos(Δ, s)
      ELSE IF s = s(Γ) THEN length(rest(Γ)) ELSE pos(rest(Γ), s) ENDIF
    ENDCASES
  MEASURE w(Γ)
  AUTO_REWRITE pos

  % If the symbol t is used in the definition of symbol s
  % then t is defined before s, 
  % hence pos(Γ)(t) < pos(Γ)(s)
  pos_definition: THEOREM FORALL (Γ: (closed?(〈〉)), s: (definition?(Γ))):
    FORALL (t: (symbols(definition(Γ)(s)))):
      t ∈ dsymbols(find(Γ)(s)) IMPLIES pos(find(Γ)(s), t) < pos(Γ, s)  
  % Same in the type of symbol s
  pos_type: THEOREM FORALL (Γ: (uniques?), s: (typed?(Γ))):
    FORALL (t: (symbols(type_(Γ)(s)))):
      t ∈ dsymbols(Γ) IMPLIES pos(Γ, t) < pos(Γ, s)
  % Returns the position of a variable in a context
  pos(Γ, (x | x < dvars(Γ))): RECURSIVE below[length(Γ)] =
    CASES Γ OF
      kvar(T, Δ): IF x = 0 THEN length(Δ) ELSE pos(Δ, x - 1) ENDIF
      ELSE pos(rest(Γ), x)
    ENDCASES
  MEASURE w(Γ)
END decl
