decl: THEORY
BEGIN
  IMPORTING language, subtype, inductions


  Γ, Δ, Θ: VAR context
  A, B, T: VAR pretype
  r, s: VAR symbol
  n, m: VAR name
  x, y: VAR nat
  a, b, f, g: VAR preterm
  σ, τ: VAR interp
  S: VAR syntaxic
  M: VAR map


  % Datatype decl = context of size one
  decl: DATATYPE WITH SUBTYPES ktype_decl, kvar_decl, kconst_decl, ktheory_decl
  BEGIN
    dtype_decl: dtype_decl?: ktype_decl
    dtype_def(definition: pretype): dtype_def?: ktype_decl
    dvar(type_: pretype): dvar?: kvar_decl
    dconst_decl(type_: pretype): dconst_decl?: kconst_decl
    dconst_def(type_: pretype, definition: preterm): dconst_def?: kconst_decl
    dtheory(definition: pretheory): dtheory?: ktheory_decl
    dtype_interp(definition: pretype): dtype_interp?: ktype_decl
    dconst_interp(definition: preterm): dconst_interp?: kconst_decl
  END decl
  AUTO_REWRITE+ ktype_decl, kvar_decl, kconst_decl, ktheory_decl

  kcontext?(d: decl): bool = 
    dtype_decl?(d) OR dtype_def?(d) OR
    dvar?(d) OR
    dconst_decl?(d) OR dconst_def?(d) OR
    dtheory?(d)
  ktheory?(d: decl): bool = 
    dtype_decl?(d) OR dtype_def?(d) OR
    dconst_decl?(d) OR dconst_def?(d)
  kinterp?(d: decl): bool = 
    dtype_interp?(d) OR dconst_interp?(d)

  AUTO_REWRITE+ kcontext?, ktheory?, kinterp?

  % decl(M) = "car(M)"
  decl(M: nonempty): decl =
    CASES M OF
      ktype_decl(s, Γ): dtype_decl,
      ktype_def(s, T, Γ): dtype_def(T),
      ktype_ext(s, Γ): dtype_decl,
      kvar(T, Γ): dvar(T),
      kconst_decl(s, T, Γ): dconst_decl(T),
      kconst_def(s, T, a, Γ): dconst_def(T, a),
      kconst_ext(s, T, Γ): dconst_decl(T),
      ktheory(s, Θ, Γ): dtheory(Θ),
      itype(s, T, σ): dtype_interp(T),
      iconst(s, a, σ): dconst_interp(a)
    ENDCASES
  decl_context: JUDGEMENT decl(Γ | nonempty?(Γ)) HAS_TYPE (kcontext?)
  decl_theory: JUDGEMENT decl(Δ: pretheory | nonempty?(Δ)) HAS_TYPE (ktheory?)
  decl_interp: JUDGEMENT decl(σ | nonempty?(σ)) HAS_TYPE (kinterp?)
  

  % Function kind as informally defined at the begining of chapter 2.
  % Meant to be used as kind(Γ(s)), to give the kind of the symbol s
  % among CONSTANT, TYPE, VARIABLE, THEORY
  kind(d: decl): kind =
    COND
      ktype_decl(d) -> KTYPE,
      kvar_decl(d) -> KVAR,
      kconst_decl(d) -> KCONST,
      ktheory_decl(d) -> KTHEORY
    ENDCOND
  AUTO_REWRITE+ kind

  % Checks if the first element of M is a definition (not a declaration)
  % Used as definition?(Γ(s)) it checks that s has a definition in Γ
  % (such as s: TYPE = def_type, or s: T = def_term)
  definition?(d: decl): bool =
    dtype_def?(d) OR dconst_def?(d) OR dtheory?(d) OR dtype_interp?(d) OR dconst_interp?(d)
  definition: TYPE = (definition?)
  AUTO_REWRITE+ definition?
  
  % Function definition as informally defined at the begining of section 2.5
  % Meant to be used as definition(Γ(s)), to give the definition of the symbol s
  % (if it exists, see definition?), i.e a type, a term or a theory.
  % Built-in decl DATATYPE

  % Checks if the first element of M has a type (i.e is a preterm).
  % Used as typed?(Γ(s)) it checks that s is a preterm in Γ,
  % i.e appears of the form s: T or s: T = a
  typed?(d: decl): bool =
    dvar?(d) OR dconst_def?(d) OR dconst_decl?(d)
  AUTO_REWRITE+ typed?

  % Function type as informally defined at the begining of chapter 2.
  % Meant to be used as type(Γ(s)), to give the type of s
  % (if it exists, see typed?), i.e type(s: T = def_term, Γ) = T
  % Built-in decl DATATYPE
END decl
