decl: THEORY
BEGIN
  IMPORTING language, subtype, inductions
  IMPORTING subst

  Γ, Δ, Θ: VAR context
  A, B, T: VAR pretype
  r, s: VAR symbol
  n, m: VAR name
  x, y: VAR nat
  a, b, f, g: VAR preterm
  σ, τ: VAR interp
  S: VAR syntaxic
  M: VAR map

  definition?(Γ)(s: (dsymbols(Γ))): RECURSIVE bool =
    CASES
      kvar?(Γ) -> definition?(rest(Γ))(s)
    , ELSE -> IF s = s(Γ) THEN (ktype_def?(Γ) OR kconst_def?(Γ) OR ktheory?(Γ))
              ELSE definition?(rest(Γ))(s) ENDIF
    ENDCASES
  MEASURE w(Γ)

  typed?(Γ)(s: (dsymbols(Γ))): RECURSIVE bool =
    CASES
      kvar?(Γ) -> typed?(rest(Γ))(s)
    , ELSE -> IF s = s(Γ) THEN (ktype_def?(Γ) OR ktype_decl?(Γ) OR ktype_ext?(Γ))
              ELSE typed?(rest(Γ))(s) ENDIF
    ENDCASES
  MEASURE w(Γ)

  theory?(Γ)(s: (definition?(Γ))): RECURSIVE bool =
    CASES
      kvar?(Γ) -> theory?(rest(Γ))(s)
    , ELSE -> IF s = s(Γ) THEN ktheory?(Γ)
              ELSE theory?(rest(Γ))(s) ENDIF
    ENDCASES
  MEASURE w(Γ)

  
  find(Γ)(s: (dsymbols(Γ))): RECURSIVE context	 =
    COND
      kvar?(Γ) -> find(rest(Γ))(s)
    , ELSE -> IF s = s(Γ) THEN rest(Γ) ELSE find(rest(Γ))(s) ENDIF
    ENDCOND
  MEASURE w(Γ)
  CONVERSION+ find

  symbols_definition: THEOREM FORALL (s: (definition?(\Gamma))):
      symbols(definition(Γ)(s)) ⊂ (dsymbols(Γ) ∪ symbols(Γ))
  vars_definition: THEOREM FORALL (s: (definition?
    s ∈ Γ AND definition?(Γ)(s) IMPLIES
      vars(definition(Γ)(s)) ⊂ { x | x < dvars(Γ) }
  dvars_definition: THEOREM
    s ∈ Γ AND definition?(Γ)(s) AND kind(Γ)(s) = KTHEORY IMPLIES
      dvars(definition(Γ)(s)) = 0
  uniques_definition: THEOREM
    s ∈ Γ AND definition?(Γ)(s) AND kind(Γ)(s) = KTHEORY IMPLIES
      uniques?(Γ) IMPLIES uniques?(definition(Γ)(s))

  symbols_type: THEOREM FORALL (s: (typed?(Γ))):
    symbols(type_(Γ)(s)) ⊂ (dsymbols(Γ) ∪ symbols(Γ))
  vars_type: THEOREM FORALL (s: (typed?(Γ))):
    vars(type_(Γ)(s)) ⊂ (vars(Γ) ∪ { x | x < dvars(Γ) })

  length(Γ): RECURSIVE nat =
    CASES Γ OF
      〈〉: 0
      ELSE 1 + length(rest(Γ))
    ENDCASES
  MEASURE w(Γ)

  pos(Γ, (s: (dsymbols(Γ)))): RECURSIVE below[length(Γ)] =
    CASES Γ OF
      kvar(T, Δ): pos(Δ, s)
      ELSE IF s = s(Γ) THEN length(rest(Γ)) ELSE pos(rest(Γ), s) ENDIF
    ENDCASES
  MEASURE w(Γ)
  pos_definition: THEOREM FORALL (s: (definition?(Γ))):
    uniques?(Γ) IMPLIES
      FORALL (t: (symbols(definition(Γ)(s)))):
        t ∈ dsymbols(Γ) IMPLIES pos(Γ, t) < pos(Γ, s)
  pos_type: THEOREM FORALL (s: (typed?(Γ))):
    uniques?(Γ) IMPLIES
      FORALL (t: (symbols(type_(Γ)(s)))):
        t ∈ dsymbols(Γ) IMPLIES pos(Γ, t) < pos(Γ, s)

  pos(Γ, (x | x < dvars(Γ))): RECURSIVE below[length(Γ)] =
    CASES Γ OF
      kvar(T, Δ): IF x = 0 THEN length(Δ) ELSE pos(Δ, x - 1) ENDIF
      ELSE pos(rest(Γ), x)
    ENDCASES
  MEASURE w(Γ)

  closed?(Γ)(S): bool =
    vars(S) ⊂ { x | x < dvars(Γ) } AND
    symbols(S) ⊂ dsymbols(Γ)
  

  % Datatype decl = context of size one
  decl: DATATYPE WITH SUBTYPES ktype_decl, kvar_decl, kconst_decl, ktheory_decl
  BEGIN
    dtype_decl: dtype_decl?: ktype_decl
    dtype_def(definition: pretype): dtype_def?: ktype_decl
    dvar(type_: pretype): dvar?: kvar_decl
    dconst_decl(type_: pretype): dconst_decl?: kconst_decl
    dconst_def(type_: pretype, definition: preterm): dconst_def?: kconst_decl
    dtheory(definition: pretheory): dtheory?: ktheory_decl
    dtype_interp(definition: pretype): dtype_interp?: ktype_decl
    dconst_interp(definition: preterm): dconst_interp?: kconst_decl
  END decl
  AUTO_REWRITE+ ktype_decl, kvar_decl, kconst_decl, ktheory_decl

  kcontext?(d: decl): bool = 
    dtype_decl?(d) OR dtype_def?(d) OR
    dvar?(d) OR
    dconst_decl?(d) OR dconst_def?(d) OR
    dtheory?(d)
  ktheory?(d: decl): bool = 
    dtype_decl?(d) OR dtype_def?(d) OR
    dconst_decl?(d) OR dconst_def?(d)
  kinterp?(d: decl): bool = 
    dtype_interp?(d) OR dconst_interp?(d)

  %AUTO_REWRITE+ kcontext?, ktheory?, kinterp?

  % decl(M) = "car(M)"
  decl(M: nonempty): decl =
    CASES M OF
      ktype_decl(s, Γ): dtype_decl,
      ktype_def(s, T, Γ): dtype_def(T),
      ktype_ext(s, Γ): dtype_decl,
      kvar(T, Γ): dvar(T),
      kconst_decl(s, T, Γ): dconst_decl(T),
      kconst_def(s, T, a, Γ): dconst_def(T, a),
      kconst_ext(s, T, Γ): dconst_decl(T),
      ktheory(s, Θ, Γ): dtheory(Θ),
      itype(s, T, σ): dtype_interp(T),
      iconst(s, a, σ): dconst_interp(a)
    ENDCASES
  decl_context: JUDGEMENT decl(Γ | nonempty?(Γ)) HAS_TYPE (kcontext?)
  decl_theory: JUDGEMENT decl(Δ: pretheory | nonempty?(Δ)) HAS_TYPE (ktheory?)
  decl_interp: JUDGEMENT decl(σ | nonempty?(σ)) HAS_TYPE (kinterp?)
  

  % Function kind as informally defined at the begining of chapter 2.
  % Meant to be used as kind(Γ(s)), to give the kind of the symbol s
  % among CONSTANT, TYPE, VARIABLE, THEORY
  kind(d: decl): kind =
    COND
      ktype_decl(d) -> KTYPE,
      kvar_decl(d) -> KVAR,
      kconst_decl(d) -> KCONST,
      ktheory_decl(d) -> KTHEORY
    ENDCOND
  AUTO_REWRITE+ kind

  % Checks if the first element of M is a definition (not a declaration)
  % Used as definition?(Γ(s)) it checks that s has a definition in Γ
  % (such as s: TYPE = def_type, or s: T = def_term)
  definition?(d: decl): bool =
    dtype_def?(d) OR dconst_def?(d) OR dtheory?(d) OR dtype_interp?(d) OR dconst_interp?(d)
  definition: TYPE = (definition?)
  
  % Function definition as informally defined at the begining of section 2.5
  % Meant to be used as definition(Γ(s)), to give the definition of the symbol s
  % (if it exists, see definition?), i.e a type, a term or a theory.
  % Built-in decl DATATYPE

  % Checks if the first element of M has a type (i.e is a preterm).
  % Used as typed?(Γ(s)) it checks that s is a preterm in Γ,
  % i.e appears of the form s: T or s: T = a
  typed?(d: decl): bool =
    dvar?(d) OR dconst_def?(d) OR dconst_decl?(d)
  AUTO_REWRITE+ typed?

  % Function type as informally defined at the begining of chapter 2.
  % Meant to be used as type(Γ(s)), to give the type of s
  % (if it exists, see typed?), i.e type(s: T = def_term, Γ) = T
  % Built-in decl DATATYPE
END decl
