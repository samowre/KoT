preserves_tau: THEORY
BEGIN
  IMPORTING tau

  Γ, Δ, Θ: VAR finseq[(scontext?)]
  U: VAR syntaxic
  x: VAR nat
  m, t: VAR (sexpr?)
  k: VAR keyword
  l: VAR list[pretcc]
  nb: VAR [nat, nat]
  n: VAR nat
  d: VAR (scontext?)


  tau(Γ)(U): MACRO keyword = τ(Γ)(U)`1
  tccs(Γ)(U): MACRO list[pretcc] = τ(Γ)(U)`2



  % Very basic properties of τ
  

  tau_rest: THEOREM x < length(Θ) AND
    KTHEORY?(tau(Γ)(theory_(Θ))) IMPLIES 
    KTHEORY?(tau(Γ)(theory_(rest(Θ, x))))
  tau_decl: THEOREM x < length(Θ) AND
    KTHEORY?(tau(Γ)(theory_(Θ))) IMPLIES 
    KDECL?(tau(Γ ++ rest(Θ, x))(Θ(x)))
  tau_def: THEOREM x < length(Θ) AND definition?(Θ(x)) AND
    KTHEORY?(tau(Γ)(theory_(Θ))) IMPLIES
    NOT UNDEFINED?(tau(Γ ++ rest(Θ, x))(def(Θ(x))))
  tau_type: THEOREM x < length(Θ) AND typed?(Θ(x)) AND
    KTHEORY?(tau(Γ)(theory_(Θ))) IMPLIES
    KTYPE?(tau(Γ ++ rest(Θ, x))(type_(Θ(x))))

  tau_concat: THEOREM
  KTHEORY?(tau(Γ)(theory_(Δ ++ Θ))) IFF 
  KTHEORY?(tau(Γ)(theory_(Δ))) AND KTHEORY?(tau(Γ ++ Δ)(theory_(Θ)))


  % The following functions preserves tau:
  % ↑, subst, μ0, η, δ
  % We first have to define these functions over [keyword, list[tcc]] and keyword
  over_keyword(f: [U: syntaxic -> same(U)], k): keyword = 
    CASES k OF
      KTERM(T): KTERM(f(T))
      ELSE k
    ENDCASES
  %AUTO_REWRITE over_keyword

  ;↑(Δ, nb): MACRO finseq[(scontext?)] = decls(theory_(Δ) ↑ nb)
  ;↑(k, nb): MACRO keyword = over_keyword(LAMBDA (U: syntaxic): U ↑ nb, k)
  ;↑(l, nb): MACRO list[pretcc] = map(LAMBDA U: U ↑ nb)(l)
  subst(Δ, x, t): MACRO finseq[(scontext?)] = decls(subst(theory_(Δ), x, t))
  subst(k, x, t): MACRO keyword = over_keyword(LAMBDA U: subst(U, x, t), k)
  subst(l, x, t): MACRO list[pretcc] = map(LAMBDA U: subst(U, x, t))(l)


  hook: THEOREM FALSE

  strong_shift_preserves: THEOREM
    tau(Γ ++ Δ ++ (Θ ↑ (length(Δ), 0)))(U ↑ (length(Δ), length(Θ))) 
    = tau(Γ ++ Θ)(U) ↑ (length(Δ), length(Θ))
  shift_preserves: THEOREM
    tau(Γ ++ Δ)(U ↑ length(Δ)) = tau(Γ)(U) ↑ (length(Δ), 0)

  strong_shift_tccs: THEOREM
    tccs(Γ ++ Δ ++ (Θ ↑ (length(Δ), 0)))(U ↑ (length(Δ), length(Θ)))
    = tccs(Γ ++ Θ)(U) ↑ (length(Δ), length(Θ))
  shift_tccs: THEOREM
    tccs(Γ ++ Δ)(U ↑ length(Δ)) = tccs(Γ)(U) ↑ (length(Δ), 0)

  strong_subst_preserves: THEOREM
    KTERM?(tau(Γ)(t)) IMPLIES
    LET T = TYPEOF(τ(Γ)(t)`1) IN
    tau(Γ ++ subst(Δ, 0, t))(subst(U, length(Δ), t ↑ length(Δ)))
    = subst(tau(Γ ++ k(const_var(T)) ++ Δ)(U), length(Δ), t)
  subst_preserves: THEOREM
    KTERM?(tau(Γ)(t)) IMPLIES
    LET T = TYPEOF(τ(Γ)(t)`1) IN
    tau(Γ)(subst(U, 0, t)) = subst(tau(Γ ++ k(const_var(T)))(U), 0, t)

  strong_subst_tccs: THEOREM
    KTERM?(tau(Γ)(t)) IMPLIES
    LET T = TYPEOF(τ(Γ)(t)`1) IN
    tccs(Γ ++ subst(Δ, 0, t))(subst(U, length(Δ), t ↑ length(Δ)))
    = subst(tccs(Γ ++ k(const_var(T)) ++ Δ)(U), length(Δ), t)
  subst_tccs: THEOREM
    KTERM?(tau(Γ)(t)) IMPLIES
    LET T = TYPEOF(τ(Γ)(t)`1) IN
    tccs(Γ)(subst(U, 0, t)) = subst(tccs(Γ ++ k(const_var(T)))(U), 0, t)


  mu0_idempotent: THEOREM
    μ0(μ0(U)) = μ0(U)
  delta_idempotent: THEOREM
    δ(Δ)(δ(Δ)(U)) = δ(Δ)(U)

  mu0_preserves: THEOREM
    τ(Γ)(μ0(U)) = τ(Γ)(U)

  eta_preserves: THEOREM
    LET Δ = signature(Γ, m) IN
    theory?(Δ) IMPLIES
    tau(Γ)(η(m, length(decls(Δ)))(U)) = η(m, length(decls(Δ)))(tau(Γ ++ decls(Δ))(U))

  eta_tccs: THEOREM
    LET Δ = signature(Γ, m) IN
    theory?(Δ) IMPLIES
    tccs(Γ)(η(m, length(decls(Δ)))(U)) = η(m, length(decls(Δ)))(tccs(Γ ++ decls(Δ))(U))


  % This one needs eta preservess 
  tau_signature: THEOREM
    KTHEORY?(tau(Γ)(U)) IMPLIES KTHEORY?(tau(Γ)(signature(Γ, U)))


  delta_preserves: THEOREM
    τ(Γ)(δ(Γ)(U)) = τ(Γ)(U)




END preserves_tau

