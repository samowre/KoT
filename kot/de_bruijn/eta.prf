(eta
 (η_TCC1 0
  (η_TCC1-1 nil 3583783735 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length const-decl "nat" language nil)
    (sapply const-decl "signature" language nil))
   nil))
 (η_TCC2 0
  (η_TCC2-1 nil 3583783735 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (length const-decl "nat" language nil)
    (∈ const-decl "bool" language nil))
   nil))
 (η_TCC3 0
  (η_TCC3-1 nil 3583783735 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (length const-decl "nat" language nil)
    (∈ const-decl "bool" language nil))
   nil))
 (η_TCC4 0
  (η_TCC4-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sinterp?" "sdecl?" "scontext?"))
      (("" (propax) nil nil)) nil))
    nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil))
   nil))
 (η_TCC5 0
  (η_TCC5-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (assert) (("" (expand "sexpr?") (("" (propax) nil nil)) nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil))
   nil))
 (η_TCC6 0
  (η_TCC6-1 nil 3583783735
   ("" (subtype-tcc)
    (("" (expand "sexpr?") (("" (propax) nil nil)) nil)) nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (∈ const-decl "bool" language nil)
    (length const-decl "nat" language nil))
   nil))
 (η_TCC7 0
  (η_TCC7-1 nil 3583783735
   ("" (subtype-tcc)
    (("" (expand "sexpr?") (("" (propax) nil nil)) nil)) nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (∈ const-decl "bool" language nil)
    (length const-decl "nat" language nil))
   nil))
 (η_TCC8 0
  (η_TCC8-1 nil 3583783735
   ("" (subtype-tcc)
    (("1" (expand ("sexpr?" "sinterp?" "sdecl?" "scontext?"))
      (("1" (propax) nil nil)) nil)
     ("2" (invoke (rewrite $1n) (~ "% = %"))
      (("2" (expand ("sexpr?" "sinterp?" "sdecl?" "scontext?"))
        (("2" (propax) nil nil)) nil))
      nil)
     ("3" (invoke (rewrite $1n) (~ "% = %"))
      (("3" (expand ("sexpr?" "sinterp?" "sdecl?" "scontext?"))
        (("3" (propax) nil nil)) nil))
      nil))
    nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (sapply const-decl "signature" language nil)
    (∈ const-decl "bool" language nil)
    (length const-decl "nat" language nil))
   nil))
 (η_TCC9 0
  (η_TCC9-1 nil 3583783735
   ("" (subtype-tcc)
    (("" (grind) (("" (all-typepreds) (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((irreflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (strict_order? const-decl "bool" orders nil)
    (trichotomous? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (partial_order? const-decl "bool" orders nil)
    (dichotomous? const-decl "bool" orders nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (even? const-decl "bool" integers nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sig adt-accessor-decl "[(stheory?) -> finseq[signature]]" language
         nil)
    (v? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (v adt-constructor-decl "[nat -> (v?)]" language nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (∈ const-decl "bool" language nil)
    (length const-decl "nat" language nil))
   nil))
 (η_TCC10 0
  (η_TCC10-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sdecl?" "sinterp?" "scontext?") +)
      (("" (assert)
        (("" (rewrite -8)
          (("" (assert)
            (("" (flatten)
              (("" (assert)
                (("" (expand "↑")
                  (("" (all-typepreds)
                    (("" (assert)
                      ((""
                        (typepred
                         "(def(σ!1`seq(i!1 - sig(ρ!1)`length)) ↑ (sig(ρ!1)`length, 0))")
                        (("" (expand "sexpr?") (("" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((scontext? adt-def-decl "boolean" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (↑ macro-decl "syntaxic" subst nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (even? const-decl "bool" integers nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND (scontext?(U) IFF scontext?(V))}"
     subst nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sig adt-accessor-decl "[(stheory?) -> finseq[signature]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (const_def? adt-recognizer-decl "[syntaxic -> boolean]" language
     nil)
    (type_def? adt-recognizer-decl "[syntaxic -> boolean]" language
     nil)
    (def shared-adt-accessor-decl
     "[{x: syntaxic | iterm?(x) OR itype?(x) OR const_def?(x) OR type_def?(x)} ->
   (sexpr?)]" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil))
   nil))
 (η_TCC11 0
  (η_TCC11-1 nil 3583783735 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (length const-decl "nat" language nil)
    (∈ const-decl "bool" language nil)
    (sapply const-decl "signature" language nil))
   nil))
 (η_TCC12 0
  (η_TCC12-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sdecl?" "sinterp?" "scontext?") +)
      (("" (assert) nil nil)) nil))
    nil)
   ((scontext? adt-def-decl "boolean" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil))
   nil))
 (η_TCC13 0
  (η_TCC13-1 nil 3583783735 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "nat" language nil))
   nil))
 (η_TCC14 0
  (η_TCC14-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sdecl?" "sinterp?" "scontext?") +)
      (("" (assert) nil nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (< const-decl "bool" reals nil) (size def-decl "nat" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC15 0
  (η_TCC15-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (assert)
        (("" (rewrite -6 :dont-delete? t)
          (("" (assert) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (size def-decl "nat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC16 0
  (η_TCC16-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (assert)
        (("" (rewrite -7 :dont-delete? t)
          (("" (assert)
            (("" (typepred "sum")
              (("" (inst?)
                (("1" (inst?) (("1" (assert) nil nil)) nil)
                 ("2" (assert) (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (size def-decl "nat" language nil) (<= const-decl "bool" reals nil)
    (sum def-decl "{n: nat | FORALL (x: below[len]): f(x) <= n}"
     language nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (τ!1 skolem-const-decl "finseq[(sinterp?)]" eta nil)
    (U!1 skolem-const-decl "syntaxic" eta nil)
    (map adt-accessor-decl "[(interp?) -> finseq[(sinterp?)]]" language
         nil)
    (interp? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC17 0
  (η_TCC17-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sdecl?" "sinterp?" "scontext?") +)
      (("" (assert) nil nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (< const-decl "bool" reals nil) (size def-decl "nat" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC18 0
  (η_TCC18-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sinterp?" "sdecl?" "scontext?"))
      (("" (invoke (rewrite $1n) (~ "% = %"))
        (("" (assert)
          (("" (assert)
            (("" (rewrite -7)
              (("" (assert) (("" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (size def-decl "nat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC19 0
  (η_TCC19-1 nil 3583783735 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "nat" language nil))
   nil))
 (η_TCC20 0
  (η_TCC20-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sdecl?" "sinterp?" "scontext?") +)
      (("" (assert) nil nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (< const-decl "bool" reals nil) (size def-decl "nat" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC21 0
  (η_TCC21-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sinterp?" "sdecl?" "scontext?"))
      (("" (invoke (rewrite $1n) (~ "% = %"))
        (("" (assert)
          (("" (assert)
            (("" (invoke (rewrite $1n) (~ "% = %"))
              (("" (invoke (rewrite $1n) (~ "% = %"))
                (("" (assert) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (size def-decl "nat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC22 0
  (η_TCC22-1 nil 3583783735 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "nat" language nil))
   nil))
 (η_TCC23 0
  (η_TCC23-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sdecl?" "sinterp?" "scontext?") +)
      (("" (assert) nil nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (< const-decl "bool" reals nil) (size def-decl "nat" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC24 0
  (η_TCC24-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sinterp?" "sdecl?" "scontext?"))
      (("" (invoke (rewrite $1n) (~ "% = %"))
        (("" (assert)
          (("" (assert)
            (("" (invoke (rewrite $1n) (~ "% = %"))
              (("" (invoke (rewrite $1n) (~ "% = %"))
                (("" (assert) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (size def-decl "nat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC25 0
  (η_TCC25-1 nil 3583783735 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "nat" language nil))
   nil))
 (η_TCC26 0
  (η_TCC26-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sdecl?" "sinterp?" "scontext?") +)
      (("" (assert) nil nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (< const-decl "bool" reals nil) (size def-decl "nat" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC27 0
  (η_TCC27-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sinterp?" "sdecl?" "scontext?"))
      (("" (invoke (rewrite $1n) (~ "% = %"))
        (("" (assert)
          (("" (assert)
            (("" (invoke (rewrite $1n) (~ "% = %"))
              (("" (invoke (rewrite $1n) (~ "% = %"))
                (("" (assert) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (size def-decl "nat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC28 0
  (η_TCC28-1 nil 3583783735 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "nat" language nil))
   nil))
 (η_TCC29 0
  (η_TCC29-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sdecl?" "sinterp?" "scontext?") +)
      (("" (assert) nil nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (< const-decl "bool" reals nil) (size def-decl "nat" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC30 0
  (η_TCC30-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sinterp?" "sdecl?" "scontext?"))
      (("" (invoke (rewrite $1n) (~ "% = %"))
        (("" (assert)
          (("" (assert)
            (("" (invoke (rewrite $1n) (~ "% = %"))
              (("" (invoke (rewrite $1n) (~ "% = %"))
                (("" (assert) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (size def-decl "nat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC31 0
  (η_TCC31-1 nil 3583783735 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "nat" language nil))
   nil))
 (η_TCC32 0
  (η_TCC32-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sdecl?" "sinterp?" "scontext?") +)
      (("" (assert) nil nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (< const-decl "bool" reals nil) (size def-decl "nat" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC33 0
  (η_TCC33-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sinterp?" "sdecl?" "scontext?"))
      (("" (invoke (rewrite $1n) (~ "% = %"))
        (("" (assert)
          (("" (assert)
            (("" (invoke (rewrite $1n) (~ "% = %"))
              (("" (invoke (rewrite $1n) (~ "% = %"))
                (("" (assert) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (size def-decl "nat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC34 0
  (η_TCC34-1 nil 3583783735 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "nat" language nil))
   nil))
 (η_TCC35 0
  (η_TCC35-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sdecl?" "sinterp?" "scontext?") +)
      (("" (assert) nil nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (< const-decl "bool" reals nil) (size def-decl "nat" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC36 0
  (η_TCC36-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sinterp?" "sdecl?" "scontext?"))
      (("" (invoke (rewrite $1n) (~ "% = %"))
        (("" (assert)
          (("" (assert)
            (("" (invoke (rewrite $1n) (~ "% = %"))
              (("" (invoke (rewrite $1n) (~ "% = %"))
                (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (size def-decl "nat" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC37 0
  (η_TCC37-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sdecl?" "sinterp?" "scontext?") +)
      (("" (assert) nil nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (< const-decl "bool" reals nil) (size def-decl "nat" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC38 0
  (η_TCC38-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sinterp?" "sdecl?" "scontext?"))
      (("" (invoke (rewrite $1n) (~ "% = %"))
        (("" (assert)
          (("" (assert)
            (("" (invoke (rewrite $1n) (~ "% = %"))
              (("" (invoke (rewrite $1n) (~ "% = %"))
                (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (size def-decl "nat" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC39 0
  (η_TCC39-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sdecl?" "sinterp?" "scontext?") +)
      (("" (assert) nil nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (< const-decl "bool" reals nil) (size def-decl "nat" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC40 0
  (η_TCC40-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sdecl?" "sinterp?" "scontext?") +)
      (("" (assert) nil nil)) nil))
    nil)
   ((scontext? adt-def-decl "boolean" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil))
   nil))
 (η_TCC41 0
  (η_TCC41-1 nil 3583783735 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (η_TCC42 0
  (η_TCC42-1 nil 3583783735 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "nat" language nil))
   nil))
 (η_TCC43 0
  (η_TCC43-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sinterp?" "sdecl?" "scontext?"))
      (("" (invoke (rewrite $1n) (~ "% = %")) (("" (assert) nil nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (< const-decl "bool" reals nil) (size def-decl "nat" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC44 0
  (η_TCC44-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (expand ("sexpr?" "sinterp?" "sdecl?" "scontext?"))
        (("" (invoke (rewrite $1n) (~ "% = %"))
          (("" (assert)
            (("" (invoke (rewrite $1n) (~ "% = %"))
              (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (size def-decl "nat" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC45 0
  (η_TCC45-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sdecl?" "sinterp?" "scontext?") +)
      (("" (assert) nil nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (< const-decl "bool" reals nil) (size def-decl "nat" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC46 0
  (η_TCC46-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sinterp?" "sdecl?" "scontext?"))
      (("" (invoke (rewrite $1n) (~ "% = %"))
        (("" (assert)
          (("" (assert)
            (("" (invoke (rewrite $1n) (~ "% = %"))
              (("" (invoke (rewrite $1n) (~ "% = %"))
                (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (size def-decl "nat" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC47 0
  (η_TCC47-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sdecl?" "sinterp?" "scontext?") +)
      (("" (assert) nil nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (< const-decl "bool" reals nil) (size def-decl "nat" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC48 0
  (η_TCC48-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sinterp?" "sdecl?" "scontext?"))
      (("" (invoke (rewrite $1n) (~ "% = %"))
        (("" (assert)
          (("" (assert)
            (("" (invoke (rewrite $1n) (~ "% = %"))
              (("" (invoke (rewrite $1n) (~ "% = %"))
                (("" (assert) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (size def-decl "nat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC49 0
  (η_TCC49-1 nil 3583783735 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "nat" language nil))
   nil))
 (η_TCC50 0
  (η_TCC50-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sdecl?" "sinterp?" "scontext?") +)
      (("" (assert) nil nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (< const-decl "bool" reals nil) (size def-decl "nat" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC51 0
  (η_TCC51-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sdecl?" "sinterp?" "scontext?") +)
      (("" (assert) nil nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (scontext? adt-def-decl "boolean" language nil)
    (< const-decl "bool" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil))
   nil))
 (η_TCC52 0
  (η_TCC52-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (invoke (rewrite $1n) (~ "% = %"))
      (("" (assert)
        (("" (invoke (rewrite $1n) (~ "% = %"))
          (("" (invoke (rewrite $1n) (~ "% = %"))
            (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (signature def-decl "signature" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (scontext? adt-def-decl "boolean" language nil)
    (< const-decl "bool" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil))
   nil))
 (η_TCC53 0
  (η_TCC53-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (invoke (rewrite $1n) (~ "% = %"))
      (("" (assert) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((length_signature formula-decl nil language nil)
    (length const-decl "nat" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (scontext? adt-def-decl "boolean" language nil)
    (< const-decl "bool" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil))
   nil))
 (η_TCC54 0
  (η_TCC54-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (typepred "sum")
        (("" (inst?)
          (("" (inst?)
            (("1" (assert) (("1" (grind) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (size def-decl "nat" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (def adt-accessor-decl "[(theory_def?) -> finseq[(scontext?)]]"
     language nil)
    (theory_def? adt-recognizer-decl "[syntaxic -> boolean]" language
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (U!1 skolem-const-decl "syntaxic" eta nil)
    (x!1 skolem-const-decl "below[f!1`length]" eta nil)
    (f!1 skolem-const-decl "finseq[(scontext?)]" eta nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (sum def-decl "{n: nat | FORALL (x: below[len]): f(x) <= n}"
     language nil)
    (<= const-decl "bool" reals nil)
    (scontext? adt-def-decl "boolean" language nil)
    (< const-decl "bool" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil))
   nil))
 (η_TCC55 0
  (η_TCC55-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sdecl?" "sinterp?" "scontext?") +)
      (("" (assert) nil nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (< const-decl "bool" reals nil) (size def-decl "nat" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC56 0
  (η_TCC56-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sdecl?" "sinterp?" "scontext?") +)
      (("" (assert) nil nil)) nil))
    nil)
   ((scontext? adt-def-decl "boolean" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil))
   nil))
 (η_TCC57 0
  (η_TCC57-1 nil 3583783735 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "nat" language nil))
   nil))
 (η_TCC58 0
  (η_TCC58-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sdecl?" "sinterp?" "scontext?") +)
      (("" (assert) nil nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (< const-decl "bool" reals nil) (size def-decl "nat" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC59 0
  (η_TCC59-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sinterp?" "sdecl?" "scontext?"))
      (("" (invoke (rewrite $1n) (~ "% = %"))
        (("" (assert)
          (("" (assert)
            (("" (invoke (rewrite $1n) (~ "% = %"))
              (("" (invoke (rewrite $1n) (~ "% = %"))
                (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (size def-decl "nat" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC60 0
  (η_TCC60-1 nil 3583783735
   ("" (skosimp* :preds? t)
    (("" (expand ("sexpr?" "sdecl?" "sinterp?" "scontext?") +)
      (("" (assert) nil nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (∈ const-decl "bool" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (length const-decl "nat" language nil)
    (< const-decl "bool" reals nil) (size def-decl "nat" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (signature_eta_TCC1 0
  (signature_eta_TCC1-1 nil 3584104942 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sapply const-decl "signature" language nil)
    (length const-decl "nat" language nil)
    (∈ const-decl "bool" language nil))
   nil))
 (signature_eta 0
  (signature_eta-1 nil 3584104943
   ("" (induct M)
    (("1" (grind) nil nil)
     ("2" (skosimp* :preds? t) (("2" (grind) nil nil)) nil)
     ("3" (grind) nil nil)
     ("4" (skosimp* :preds? t) (("4" (grind) nil nil)) nil)
     ("5" (grind :exclude eta) nil nil)
     ("6" (grind :exclude eta) nil nil)
     ("7" (grind :exclude eta) nil nil)
     ("8" (grind :exclude eta) nil nil)
     ("9" (grind :exclude eta) nil nil)
     ("10" (grind :exclude eta) nil nil)
     ("11" (grind :exclude eta) nil nil)
     ("12" (grind :exclude eta) nil nil)
     ("13" (grind :exclude eta) nil nil)
     ("14" (grind :exclude eta) nil nil)
     ("15" (grind :exclude eta) nil nil)
     ("16" (grind :exclude eta) nil nil)
     ("17" (grind :exclude eta) nil nil)
     ("18" (grind :exclude eta) nil nil)
     ("19" (skosimp* :preds? t)
      (("19" (assert)
        (("19" (expand η 1)
          (("19" (expand signature +)
            (("19" (stop-rewrite eta)
              (("19" (decompose-equality 1)
                (("19" (grind-with-ext) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("20" (grind :exclude eta) nil nil)
     ("21" (grind :exclude eta) nil nil)
     ("22" (grind :exclude eta) nil nil)
     ("23" (grind :exclude eta) nil nil)
     ("24" (grind :exclude eta) nil nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (theory_def1_var!1 skolem-const-decl "finseq[(scontext?)]" eta nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (ρ!1 skolem-const-decl "(stheory?)" eta nil)
    (TRUE const-decl "bool" booleans nil)
    (epsilon const-decl "T" epsilons nil)
    (pred type-eq-decl nil defined_types nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (x!1 skolem-const-decl "below[theory_def1_var!1`length]" eta nil)
    (signature_stheory_extensionality formula-decl nil language nil)
    (stheory adt-constructor-decl "[finseq[signature] -> (stheory?)]"
     language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (rest const-decl "(stheory?)" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (++ const-decl "(stheory?)" language nil)
    (O const-decl "finseq" finite_sequences nil)
    (k const-decl "(stheory?)" language nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (syntaxic_induction formula-decl nil language nil)
    (signature def-decl "signature" language nil)
    (length const-decl "nat" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (η def-decl "{V: syntaxic |
         (sexpr?(U) => sexpr?(V)) AND
          (sinterp?(U) => sinterp?(V)) AND (scontext?(U) => scontext?(V))}"
     eta nil)
    (syntaxic type-decl nil language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (scontext? adt-def-decl "boolean" language nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (sig adt-accessor-decl "[(stheory?) -> finseq[signature]]" language
         nil)
    (∈ const-decl "bool" language nil)
    (sapply const-decl "signature" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   shostak))
 (pretau_eta_TCC1 0
  (pretau_eta_TCC1-1 nil 3583785539 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (signature type-decl nil language nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (syntaxic type-decl nil language nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (length const-decl "nat" language nil)
    (∈ const-decl "bool" language nil)
    (sapply const-decl "signature" language nil))
   nil))
 (pretau_eta 0
  (pretau_eta-1 nil 3583785654
   ("" (induct U)
    (("1" (skosimp* :preds? t)
      (("1" (decompose-equality 1)
        (("1" (iff)
          (("1" (split 1)
            (("1" (flatten)
              (("1" (expand η -1)
                (("1" (split 1)
                  (("1" (split -1)
                    (("1" (expand ∈)
                      (("1" (flatten) (("1" (assert) nil nil)) nil))
                      nil)
                     ("2" (flatten)
                      (("2" (split -1)
                        (("1" (flatten) (("1" (assert) nil nil)) nil)
                         ("2" (flatten)
                          (("2" (assert)
                            (("2" (flatten) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand sapply)
                    (("2" (split -1)
                      (("1" (expand ++ +)
                        (("1" (expand o)
                          (("1" (assert)
                            (("1" (flatten)
                              (("1"
                                (assert)
                                (("1"
                                  (expand sapply)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (expand ++)
                                      (("1"
                                        (expand o)
                                        (("1" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (split -1)
                          (("1" (flatten)
                            (("1" (expand ++ +)
                              (("1"
                                (expand o)
                                (("1"
                                  (expand ∈)
                                  (("1"
                                    (expand length 1)
                                    (("1"
                                      (lift-if)
                                      (("1"
                                        (split 2)
                                        (("1" (assert) nil nil)
                                         ("2"
                                          (flatten)
                                          (("2"
                                            (rewrite -9)
                                            (("2"
                                              (split 2)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (split -3)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (expand
                                                       pretau
                                                       -2)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (expand
                                                           pretau
                                                           -3)
                                                          (("1"
                                                            (grind
                                                             :exclude
                                                             (η eta))
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (lemma
                                                         shift_pretau)
                                                        (("2"
                                                          (inst
                                                           -
                                                           Sig!1
                                                           ρ!1
                                                           "def(σ!1`seq(v1_var!1 - sig(ρ!1)`length))")
                                                          (("2"
                                                            (expand
                                                             length)
                                                            (("2"
                                                              (rewrite
                                                               -1)
                                                              (("2"
                                                                (inst
                                                                 -
                                                                 "v1_var!1 - sig(ρ!1)`length")
                                                                (("2"
                                                                  (assert)
                                                                  (("2"
                                                                    (invoke
                                                                     (typepred
                                                                      "%1")
                                                                     (~
                                                                      1
                                                                      "ikeep?(%1)"))
                                                                    (("2"
                                                                      (expand
                                                                       sinterp?
                                                                       -1)
                                                                      (("2"
                                                                        (split
                                                                         -1)
                                                                        (("1"
                                                                          (assert)
                                                                          (("1"
                                                                            (flatten)
                                                                            (("1"
                                                                              (use
                                                                               kw_pretau_expr
                                                                               :polarity?
                                                                               t)
                                                                              (("1"
                                                                                (invoke
                                                                                 (inst
                                                                                  -
                                                                                  "%1")
                                                                                 (~
                                                                                  -13
                                                                                  "pretau(%)(%)(%1)"))
                                                                                (("1"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (assert)
                                                                          (("2"
                                                                            (flatten)
                                                                            (("2"
                                                                              (use
                                                                               kw_pretau_expr
                                                                               :polarity?
                                                                               t)
                                                                              (("2"
                                                                                (invoke
                                                                                 (inst
                                                                                  -
                                                                                  "%1")
                                                                                 (~
                                                                                  -13
                                                                                  "pretau(%)(%)(%1)"))
                                                                                (("2"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (expand ++ +)
                              (("2"
                                (expand o)
                                (("2"
                                  (assert)
                                  (("2"
                                    (flatten)
                                    (("2"
                                      (grind :exclude (η eta))
                                      nil
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (assert)
                (("2" (expand η 1)
                  (("2" (split 1)
                    (("1" (flatten)
                      (("1" (expand ∈)
                        (("1" (assert)
                          (("1" (expand sapply)
                            (("1" (expand ++)
                              (("1"
                                (expand o)
                                (("1" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (split 2)
                        (("1" (flatten)
                          (("1" (split 1)
                            (("1" (expand ∈)
                              (("1"
                                (flatten)
                                (("1"
                                  (expand sapply)
                                  (("1"
                                    (expand pretau 1)
                                    (("1"
                                      (split 1)
                                      (("1"
                                        (expand pretau 1)
                                        (("1"
                                          (split 1)
                                          (("1" (propax) nil nil)
                                           ("2"
                                            (assert)
                                            (("2"
                                              (grind :exclude (η eta))
                                              nil
                                              nil))
                                            nil)
                                           ("3"
                                            (grind :exclude (η eta))
                                            nil
                                            nil)
                                           ("4"
                                            (skosimp* :preds? t)
                                            (("4"
                                              (inst - x!2)
                                              (("4"
                                                (use
                                                 shift_pretau
                                                 :polarity?
                                                 t)
                                                (("4"
                                                  (inst
                                                   -
                                                   Sig!1
                                                   ρ!1
                                                   "σ!1`seq(x!2)")
                                                  (("4"
                                                    (grind
                                                     :exclude
                                                     (η eta))
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (assert)
                                        (("2"
                                          (split 1)
                                          (("1" (assert) nil nil)
                                           ("2"
                                            (grind :exclude (η eta))
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (invoke
                                 (typepred "%1")
                                 (~ 1 "ikeep?(%1)"))
                                (("1"
                                  (expand sinterp? -1)
                                  (("1"
                                    (split -1)
                                    (("1" (propax) nil nil)
                                     ("2"
                                      (inst - "v1_var!1 - length(ρ!1)")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (use
                                             shift_pretau
                                             :polarity?
                                             t)
                                            (("1"
                                              (inst
                                               -
                                               Sig!1
                                               ρ!1
                                               "def(σ!1`seq(v1_var!1 - sig(ρ!1)`length))")
                                              (("1"
                                                (expand sapply)
                                                (("1"
                                                  (expand length)
                                                  (("1"
                                                    (rewrite -1)
                                                    (("1"
                                                      (expand ++ -4)
                                                      (("1"
                                                        (expand o)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (use
                                                             kw_pretau_expr
                                                             :polarity?
                                                             t)
                                                            (("1"
                                                              (inst
                                                               -
                                                               x!1)
                                                              (("1"
                                                                (grind
                                                                 :exclude
                                                                 (η
                                                                  eta))
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2" (assert) nil nil))
                                      nil)
                                     ("3"
                                      (inst - "v1_var!1 - length(ρ!1)")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (use
                                             shift_pretau
                                             :polarity?
                                             t)
                                            (("1"
                                              (inst
                                               -
                                               Sig!1
                                               ρ!1
                                               "def(σ!1`seq(v1_var!1 - sig(ρ!1)`length))")
                                              (("1"
                                                (expand length)
                                                (("1"
                                                  (rewrite -1)
                                                  (("1"
                                                    (use
                                                     kw_pretau_expr
                                                     :polarity?
                                                     t)
                                                    (("1"
                                                      (inst - x!1)
                                                      (("1"
                                                        (grind
                                                         :exclude
                                                         (η eta))
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2" (assert)
                            (("2" (expand sapply)
                              (("2"
                                (assert)
                                (("2"
                                  (expand ++ +)
                                  (("2"
                                    (expand ++ -2)
                                    (("2"
                                      (expand o)
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skosimp* :preds? t)
      (("2" (decompose-equality 1)
        (("2" (expand η 1)
          (("2" (assert)
            (("2" (hide -8)
              (("2" (inst - Sig!1 m!1 ρ!1 σ!1)
                (("2" (assert)
                  (("2" (split -7)
                    (("1" (assert) (("1" (grind :exclude eta) nil nil))
                      nil)
                     ("2" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skosimp* :preds? t)
      (("3" (decompose-equality 1)
        (("3" (auto-rewrite η)
          (("3" (expand η 1)
            (("3" (expand pretau 1 1)
              (("3" (inst - Sig!1 m!1 ρ!1 σ!1)
                (("3" (assert)
                  (("3" (split -5)
                    (("1" (lazy-grind :exclude eta) nil nil)
                     ("2" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skosimp* :preds? t)
      (("4" (decompose-equality 1)
        (("4" (expand η 1)
          (("4" (assert)
            (("4" (inst - Sig!1 m!1 ρ!1 σ!1)
              (("4" (inst - Sig!1 m!1 "ρ!1 ++ k(sconst_def)" σ!1)
                (("4" (assert) (("4" (grind :exclude eta) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skosimp* :preds? t)
      (("5" (decompose-equality 1)
        (("5" (expand η 1)
          (("5" (assert)
            (("5" (inst - Sig!1 m!1 ρ!1 σ!1)
              (("5" (inst - Sig!1 m!1 "ρ!1 ++ k(sconst_def)" σ!1)
                (("5" (assert) (("5" (grind :exclude eta) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("6" (skosimp* :preds? t)
      (("6" (decompose-equality 1)
        (("6" (expand η 1)
          (("6" (assert)
            (("6" (inst - Sig!1 m!1 ρ!1 σ!1)
              (("6" (inst - Sig!1 m!1 "ρ!1 ++ k(sconst_def)" σ!1)
                (("6" (assert) (("6" (grind :exclude eta) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("7" (skosimp* :preds? t)
      (("7" (decompose-equality 1)
        (("7" (expand η 1)
          (("7" (assert)
            (("7" (inst - Sig!1 m!1 ρ!1 σ!1)
              (("7" (inst - Sig!1 m!1 ρ!1 σ!1)
                (("7" (assert) (("7" (grind :exclude eta) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("8" (skosimp* :preds? t)
      (("8" (decompose-equality 1)
        (("8" (expand η 1)
          (("8" (assert)
            (("8" (inst - Sig!1 m!1 ρ!1 σ!1)
              (("8" (inst - Sig!1 m!1 "ρ!1 ++ k(sconst_def)" σ!1)
                (("8" (assert) (("8" (grind :exclude eta) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("9" (skosimp* :preds? t)
      (("9" (decompose-equality 1)
        (("9" (expand η 1)
          (("9" (assert)
            (("9" (inst - Sig!1 m!1 ρ!1 σ!1)
              (("9" (inst - Sig!1 m!1 ρ!1 σ!1)
                (("9" (assert) (("9" (grind :exclude eta) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("10" (skosimp* :preds? t)
      (("10" (decompose-equality 1)
        (("10" (expand η 1)
          (("10" (assert)
            (("10" (inst - Sig!1 m!1 ρ!1 σ!1)
              (("10" (assert) (("10" (grind :exclude eta) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("11" (skosimp* :preds? t)
      (("11" (decompose-equality 1)
        (("11" (expand η 1)
          (("11" (assert)
            (("11" (inst - Sig!1 m!1 ρ!1 σ!1)
              (("11" (assert) (("11" (grind :exclude eta) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("12" (skosimp* :preds? t)
      (("12" (decompose-equality 1)
        (("12" (grind :exclude eta) nil nil)) nil))
      nil)
     ("13" (skosimp* :preds? t)
      (("13" (decompose-equality 1)
        (("13" (grind :exclude eta) nil nil)) nil))
      nil)
     ("14" (skosimp* :preds? t)
      (("14" (decompose-equality 1)
        (("14" (expand η 1)
          (("14" (assert)
            (("14" (inst - Sig!1 m!1 ρ!1 σ!1)
              (("14" (assert) (("14" (grind :exclude eta) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("15" (skosimp* :preds? t)
      (("15" (decompose-equality 1)
        (("15" (expand η 1)
          (("15" (assert)
            (("15" (inst - Sig!1 m!1 ρ!1 σ!1)
              (("15" (assert) (("15" (grind :exclude eta) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("16" (skosimp* :preds? t)
      (("16" (decompose-equality 1)
        (("16" (expand η 1)
          (("16" (assert)
            (("16" (inst - Sig!1 m!1 ρ!1 σ!1)
              (("16" (assert) (("16" (grind :exclude eta) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("17" (skosimp* :preds? t)
      (("17" (decompose-equality 1)
        (("17" (expand η 1)
          (("17" (assert)
            (("17" (inst - Sig!1 m!1 ρ!1 σ!1)
              (("17" (inst - Sig!1 m!1 ρ!1 σ!1)
                (("17" (assert) (("17" (grind :exclude eta) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("18" (skosimp* :preds? t)
      (("18" (decompose-equality 1)
        (("18" (expand η 1)
          (("18" (iff)
            (("18" (expand pretau 1 1)
              (("18" (split 1)
                (("1" (flatten)
                  (("1" (split 1)
                    (("1" (propax) nil nil) ("2" (assert) nil nil)
                     ("3" (skosimp* :preds? t)
                      (("3" (inst - x!2)
                        (("3" (inst - x!2)
                          (("3"
                            (inst - Sig!1 m!1
                             "ρ!1 ++ rest(signature(theory_def(theory_def1_var!1)), x!2)"
                             σ!1)
                            (("3" (split -8)
                              (("1"
                                (stop-rewrite sconcat_assoc)
                                (("1"
                                  (stop-rewrite length)
                                  (("1"
                                    (simplify -1)
                                    (("1"
                                      (use signature_eta :polarity? t)
                                      (("1"
                                        (inst
                                         -
                                         "theory_def(theory_def1_var!1)"
                                         "ρ!1"
                                         σ!1)
                                        (("1"
                                          (split -1)
                                          (("1"
                                            (expand η -1)
                                            (("1"
                                              (rewrite -1)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (decompose-equality
                                                   -1)
                                                  (("1"
                                                    (inst
                                                     -
                                                     "sapply(x!1)(x!2)")
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (rewrite*
                                                         sconcat_assoc)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (hide -5)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (rewrite length)
                                                nil
                                                nil))
                                              nil))
                                            nil)
                                           ("3" (propax) nil nil)
                                           ("4"
                                            (hide -5)
                                            (("4"
                                              (assert)
                                              (("4"
                                                (rewrite* length)
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (propax) nil nil)
                               ("3" (propax) nil nil)
                               ("4" (propax) nil nil)
                               ("5" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (split 1)
                    (("1" (propax) nil nil) ("2" (assert) nil nil)
                     ("3" (skosimp* :preds? t)
                      (("3" (inst - x!2)
                        (("3" (inst - x!2)
                          (("3"
                            (inst - Sig!1 m!1
                             "ρ!1 ++ rest(signature(theory_def(theory_def1_var!1)), x!2)"
                             σ!1)
                            (("3" (split -8)
                              (("1"
                                (rewrite* sconcat_assoc)
                                (("1"
                                  (rewrite -1 :dir rl)
                                  (("1"
                                    (use signature_eta :polarity? t)
                                    (("1"
                                      (inst
                                       -
                                       "theory_def(theory_def1_var!1)"
                                       "ρ!1"
                                       σ!1)
                                      (("1"
                                        (split -1)
                                        (("1"
                                          (expand η -1)
                                          (("1" (rewrite -1) nil nil))
                                          nil)
                                         ("2"
                                          (hide 2)
                                          (("2" (assert) nil nil))
                                          nil)
                                         ("3" (propax) nil nil)
                                         ("4"
                                          (hide 2)
                                          (("4" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (propax) nil nil)
                               ("3" (propax) nil nil)
                               ("4" (propax) nil nil)
                               ("5" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("19" (skosimp* :preds? t)
      (("19" (decompose-equality 1)
        (("19" (grind :exclude eta) nil nil)) nil))
      nil)
     ("20" (skosimp* :preds? t)
      (("20" (decompose-equality 1)
        (("20" (grind :exclude eta) nil nil)) nil))
      nil)
     ("21" (skosimp* :preds? t)
      (("21" (decompose-equality 1)
        (("21" (grind :exclude eta) nil nil)) nil))
      nil)
     ("22" (skosimp* :preds? t) (("22" (assert) nil nil)) nil)
     ("23" (skosimp* :preds? t) (("23" (assert) nil nil)) nil))
    nil)
   ((iterm adt-constructor-decl "[(sexpr?) -> (iterm?)]" language nil)
    (itype adt-constructor-decl "[(sexpr?) -> (itype?)]" language nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (ikeep adt-constructor-decl "(ikeep?)" language nil)
    (signature_eta formula-decl nil eta nil)
    (rest const-decl "(stheory?)" language nil)
    (signature def-decl "signature" language nil)
    (theory_def? adt-recognizer-decl "[syntaxic -> boolean]" language
     nil)
    (theory_def adt-constructor-decl
     "[finseq[(scontext?)] -> (theory_def?)]" language nil)
    (const_def adt-constructor-decl
     "[[(sexpr?), (sexpr?)] -> (const_def?)]" language nil)
    (const_var? adt-recognizer-decl "[syntaxic -> boolean]" language
     nil)
    (const_var adt-constructor-decl "[(sexpr?) -> (const_var?)]"
     language nil)
    (const_decl? adt-recognizer-decl "[syntaxic -> boolean]" language
     nil)
    (const_decl adt-constructor-decl "[(sexpr?) -> (const_decl?)]"
     language nil)
    (type_def adt-constructor-decl "[(sexpr?) -> (type_def?)]" language
     nil)
    (type_var? adt-recognizer-decl "[syntaxic -> boolean]" language
     nil)
    (type_var adt-constructor-decl "(type_var?)" language nil)
    (type_decl? adt-recognizer-decl "[syntaxic -> boolean]" language
     nil)
    (type_decl adt-constructor-decl "(type_decl?)" language nil)
    (rproj? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (rproj adt-constructor-decl "[(sexpr?) -> (rproj?)]" language nil)
    (lproj? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (lproj adt-constructor-decl "[(sexpr?) -> (lproj?)]" language nil)
    (pair? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (pair adt-constructor-decl "[[(sexpr?), (sexpr?)] -> (pair?)]"
     language nil)
    (lam? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (lam adt-constructor-decl "[[(sexpr?), (sexpr?)] -> (lam?)]"
         language nil)
    (app? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (app adt-constructor-decl "[[(sexpr?), (sexpr?)] -> (app?)]"
     language nil)
    (subtype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (subtype adt-constructor-decl
             "[[(sexpr?), (sexpr?)] -> (subtype?)]" language nil)
    (prod? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (prod adt-constructor-decl "[[(sexpr?), (sexpr?)] -> (prod?)]"
     language nil)
    (sconcat_assoc formula-decl nil language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (k const-decl "(stheory?)" language nil)
    (sconst_def? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (sconst_def adt-constructor-decl "(sconst_def?)" language nil)
    (fun? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (fun adt-constructor-decl "[[(sexpr?), (sexpr?)] -> (fun?)]"
     language nil)
    (interp? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (interp adt-constructor-decl
            "[[(sexpr?), finseq[(sinterp?)]] -> (interp?)]" language
            nil)
    (dot? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (dot adt-constructor-decl
     "[[(sexpr?), (stheory?), (sexpr?)] -> (dot?)]" language nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (v1_var!1 skolem-const-decl "nat" eta nil)
    (ρ!1 skolem-const-decl "(stheory?)" eta nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (O const-decl "finseq" finite_sequences nil)
    (kw const-decl "prekeyword" language nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (def shared-adt-accessor-decl
     "[{x: syntaxic | iterm?(x) OR itype?(x) OR const_def?(x) OR type_def?(x)} ->
   (sexpr?)]" language nil)
    (type_def? adt-recognizer-decl "[syntaxic -> boolean]" language
     nil)
    (const_def? adt-recognizer-decl "[syntaxic -> boolean]" language
     nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (kw_pretau_expr formula-decl nil language nil)
    (shift_pretau formula-decl nil subst nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (v? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (v adt-constructor-decl "[nat -> (v?)]" language nil)
    (slength_concat formula-decl nil language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (syntaxic_induction formula-decl nil language nil)
    (η def-decl "{V: syntaxic |
         (sexpr?(U) => sexpr?(V)) AND
          (sinterp?(U) => sinterp?(V)) AND (scontext?(U) => scontext?(V))}"
     eta nil)
    (scontext? adt-def-decl "boolean" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (++ const-decl "(stheory?)" language nil)
    (length const-decl "nat" language nil)
    (pretau def-decl "bool" language nil)
    (signature type-decl nil language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (stheory? adt-recognizer-decl "[signature -> boolean]" language
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (sig adt-accessor-decl "[(stheory?) -> finseq[signature]]" language
         nil)
    (∈ const-decl "bool" language nil)
    (sapply const-decl "signature" language nil)
    (< const-decl "bool" reals nil))
   shostak)))

