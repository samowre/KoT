(tau_props
 (context?_TCC1 0
  (context?_TCC1-1 nil 3585608210 ("" (subtype-tcc) nil nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (fcontext?_TCC1 0
  (fcontext?_TCC1-1 nil 3585608210 ("" (subtype-tcc) nil nil)
   ((typecheckable? const-decl "bool" tau nil)) nil))
 (fcontext?_TCC2 0
  (fcontext?_TCC2-1 nil 3585608210 ("" (subtype-tcc) nil nil)
   ((empty_seq const-decl "finseq" finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (type?_TCC1 0
  (type?_TCC1-1 nil 3585608210 ("" (subtype-tcc) nil nil) nil nil))
 (type_correctness_TCC1 0
  (type_correctness_TCC1-1 nil 3585608210 ("" (subtype-tcc) nil nil)
   nil nil))
 (type_correctness 0
  (type_correctness-1 nil 3584447740
   ("" (induct a)
    (("1" (skosimp* :preds? t)
      (("1" (assert)
        (("1" (expand τ -3)
          (("1" (expand τ 1 2)
            (("1" (lift-if)
              (("1" (split -3)
                (("1" (flatten)
                  (("1" (assert)
                    (("1" (split -2)
                      (("1" (propax) nil nil)
                       ("2" (flatten)
                        (("2" (assert)
                          (("2" (split -1)
                            (("1" (assert)
                              (("1"
                                (expand finseq_appl)
                                (("1"
                                  (lemma shift_preserves)
                                  (("1"
                                    (invoke
                                     (inst
                                      -
                                      "%1"
                                      "%2"
                                      "Γ!1 ^^ (0, v1_var!1 + 1)")
                                     (~ "δ(%)(%)")
                                     (~ "δ(%1)(%)"))
                                    (("1"
                                      (case
                                       "rest(Γ!1, v1_var!1) ++ Γ!1 ^^ (0, v1_var!1 + 1) = Γ!1")
                                      (("1"
                                        (rewrite -1)
                                        (("1"
                                          (expand ^^ -1 1)
                                          (("1"
                                            (expand min)
                                            (("1"
                                              (expand over_keyword)
                                              (("1"
                                                (rewrite -1)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (rewrite
                                                     delta_preserves)
                                                    (("1"
                                                      (use tau_type)
                                                      (("1"
                                                        (split -1)
                                                        (("1"
                                                          (expand
                                                           finseq_appl)
                                                          (("1"
                                                            (case
                                                             "empty_seq ++ rest(Γ!1, v1_var!1) = rest(Γ!1, v1_var!1)")
                                                            (("1"
                                                              (rewrite
                                                               -1)
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (hide-all-but
                                                               (1
                                                                -3
                                                                -4))
                                                              (("2"
                                                                (grind-with-ext)
                                                                (("2"
                                                                  (typepred
                                                                   x!1)
                                                                  (("2"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (propax)
                                                          nil
                                                          nil)
                                                         ("3"
                                                          (expand
                                                           kind
                                                           -1)
                                                          (("3"
                                                            (expand
                                                             typed?)
                                                            (("3"
                                                              (expand
                                                               finseq_appl)
                                                              (("3"
                                                                (hide
                                                                 2
                                                                 3)
                                                                (("3"
                                                                  (lift-if)
                                                                  (("3"
                                                                    (bddsimp
                                                                     -1)
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil)
                                                                     ("2"
                                                                      (assert)
                                                                      nil
                                                                      nil)
                                                                     ("3"
                                                                      (assert)
                                                                      nil
                                                                      nil)
                                                                     ("4"
                                                                      (assert)
                                                                      nil
                                                                      nil)
                                                                     ("5"
                                                                      (assert)
                                                                      nil
                                                                      nil)
                                                                     ("6"
                                                                      (assert)
                                                                      nil
                                                                      nil)
                                                                     ("7"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("4"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (hide-all-but (1 -3 -4))
                                        (("2"
                                          (grind-with-ext)
                                          (("2"
                                            (typepred x!1)
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (propax) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skosimp* :preds? t)
      (("2" (expand τ -6)
        (("2" (expand τ 1 2)
          (("2" (lift-if)
            (("2" (assert)
              (("2" (split -6)
                (("1" (flatten)
                  (("1" (assert)
                    (("1" (hide -8)
                      (("1" (lemma eta_preserves)
                        (("1" (inst - dot2_var!1 dot1_var!1 "Γ!1")
                          (("1" (assert)
                            (("1"
                              (inst -
                               "Γ!1 ++ decls(signature(Γ!1, dot1_var!1))")
                              (("1"
                                (split -9)
                                (("1" (postpone) nil nil)
                                 ("2" (postpone) nil nil)
                                 ("3" (postpone) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (propax) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (postpone) nil nil) ("4" (postpone) nil nil)
     ("5" (postpone) nil nil) ("6" (postpone) nil nil)
     ("7" (postpone) nil nil) ("8" (postpone) nil nil)
     ("9" (postpone) nil nil) ("10" (postpone) nil nil)
     ("11" (postpone) nil nil) ("12" (postpone) nil nil)
     ("13" (postpone) nil nil) ("14" (postpone) nil nil)
     ("15" (postpone) nil nil) ("16" (postpone) nil nil)
     ("17" (postpone) nil nil) ("18" (postpone) nil nil)
     ("19" (postpone) nil nil) ("20" (postpone) nil nil)
     ("21" (postpone) nil nil) ("22" (postpone) nil nil))
    nil)
   nil shostak))
 (τ_TCC1 0
  (τ_TCC1-1 nil 3585608210 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (tccs type-decl nil language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (< const-decl "bool" reals nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (τ0 def-decl "{x: [keyword, tccs] |
         LET (k, t) = x IN
                (KTHEORY?(k) IMPLIES
                  sexpr?(U) AND
                   theory?(ρ0(Γ)(U)) AND
                    tccs?(t) AND length(decls(ρ0(Γ)(U))) = length(map(t)))
            AND (KDECL?(k) IMPLIES scontext?(U))
            AND (KINTERP?(k) AND ideep?(U) IMPLIES
                  compatible?(Γ ^^ (0, length(map(U))), map(U)) AND
                   tccs?(t) AND length(map(U)) = length(map(t)))
            AND (KINTERP?(k) AND (ikeep?(U) OR itype?(U) OR iterm?(U))
                  IMPLIES compatible0?(finseq_appl[(scontext?)](Γ)(0), U))
            AND (KTYPE?(k) IMPLIES sexpr?(U) AND tcc?(t))
            AND (KTERM?(k) IMPLIES sexpr?(U) AND tcc?(t))}" tau nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (theory_ adt-constructor-decl "[finseq[(scontext?)] -> (theory?)]"
     language nil)
    (fcontext type-eq-decl nil tau_props nil))
   nil))
 (τ_TCC2 0
  (τ_TCC2-1 nil 3585608210
   ("" (skosimp* :preds? t)
    (("" (expand typecheckable? 1)
      (("" (assert)
        (("" (typepred "f!1`seq(x!1)")
          (("" (expand sexpr? -1) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (tccs type-decl nil language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (< const-decl "bool" reals nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (τ0 def-decl "{x: [keyword, tccs] |
         LET (k, t) = x IN
                (KTHEORY?(k) IMPLIES
                  sexpr?(U) AND
                   theory?(ρ0(Γ)(U)) AND
                    tccs?(t) AND length(decls(ρ0(Γ)(U))) = length(map(t)))
            AND (KDECL?(k) IMPLIES scontext?(U))
            AND (KINTERP?(k) AND ideep?(U) IMPLIES
                  compatible?(Γ ^^ (0, length(map(U))), map(U)) AND
                   tccs?(t) AND length(map(U)) = length(map(t)))
            AND (KINTERP?(k) AND (ikeep?(U) OR itype?(U) OR iterm?(U))
                  IMPLIES compatible0?(finseq_appl[(scontext?)](Γ)(0), U))
            AND (KTYPE?(k) IMPLIES sexpr?(U) AND tcc?(t))
            AND (KTERM?(k) IMPLIES sexpr?(U) AND tcc?(t))}" tau nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (theory_ adt-constructor-decl "[finseq[(scontext?)] -> (theory?)]"
     language nil)
    (fcontext type-eq-decl nil tau_props nil))
   nil))
 (τ_TCC3 0
  (τ_TCC3-1 nil 3585608210
   ("" (skosimp* :preds? t)
    (("" (expand typecheckable? 1)
      (("" (typepred "f!1`seq(x!1)")
        (("" (expand sexpr? -1)
          (("" (assert) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (tccs type-decl nil language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (< const-decl "bool" reals nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (τ0 def-decl "{x: [keyword, tccs] |
         LET (k, t) = x IN
                (KTHEORY?(k) IMPLIES
                  sexpr?(U) AND
                   theory?(ρ0(Γ)(U)) AND
                    tccs?(t) AND length(decls(ρ0(Γ)(U))) = length(map(t)))
            AND (KDECL?(k) IMPLIES scontext?(U))
            AND (KINTERP?(k) AND ideep?(U) IMPLIES
                  compatible?(Γ ^^ (0, length(map(U))), map(U)) AND
                   tccs?(t) AND length(map(U)) = length(map(t)))
            AND (KINTERP?(k) AND (ikeep?(U) OR itype?(U) OR iterm?(U))
                  IMPLIES compatible0?(finseq_appl[(scontext?)](Γ)(0), U))
            AND (KTYPE?(k) IMPLIES sexpr?(U) AND tcc?(t))
            AND (KTERM?(k) IMPLIES sexpr?(U) AND tcc?(t))}" tau nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (theory_ adt-constructor-decl "[finseq[(scontext?)] -> (theory?)]"
     language nil)
    (fcontext type-eq-decl nil tau_props nil))
   nil))
 (τ_TCC4 0
  (τ_TCC4-1 nil 3585608210
   ("" (skosimp* :preds? t) (("" (assert) nil nil)) nil)
   ((int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (tccs type-decl nil language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (< const-decl "bool" reals nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (τ0 def-decl "{x: [keyword, tccs] |
         LET (k, t) = x IN
                (KTHEORY?(k) IMPLIES
                  sexpr?(U) AND
                   theory?(ρ0(Γ)(U)) AND
                    tccs?(t) AND length(decls(ρ0(Γ)(U))) = length(map(t)))
            AND (KDECL?(k) IMPLIES scontext?(U))
            AND (KINTERP?(k) AND ideep?(U) IMPLIES
                  compatible?(Γ ^^ (0, length(map(U))), map(U)) AND
                   tccs?(t) AND length(map(U)) = length(map(t)))
            AND (KINTERP?(k) AND (ikeep?(U) OR itype?(U) OR iterm?(U))
                  IMPLIES compatible0?(finseq_appl[(scontext?)](Γ)(0), U))
            AND (KTYPE?(k) IMPLIES sexpr?(U) AND tcc?(t))
            AND (KTERM?(k) IMPLIES sexpr?(U) AND tcc?(t))}" tau nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (theory_ adt-constructor-decl "[finseq[(scontext?)] -> (theory?)]"
     language nil)
    (fcontext type-eq-decl nil tau_props nil))
   nil))
 (τ_TCC5 0
  (τ_TCC5-1 nil 3585608210 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (tccs type-decl nil language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (< const-decl "bool" reals nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (τ0 def-decl "{x: [keyword, tccs] |
         LET (k, t) = x IN
                (KTHEORY?(k) IMPLIES
                  sexpr?(U) AND
                   theory?(ρ0(Γ)(U)) AND
                    tccs?(t) AND length(decls(ρ0(Γ)(U))) = length(map(t)))
            AND (KDECL?(k) IMPLIES scontext?(U))
            AND (KINTERP?(k) AND ideep?(U) IMPLIES
                  compatible?(Γ ^^ (0, length(map(U))), map(U)) AND
                   tccs?(t) AND length(map(U)) = length(map(t)))
            AND (KINTERP?(k) AND (ikeep?(U) OR itype?(U) OR iterm?(U))
                  IMPLIES compatible0?(finseq_appl[(scontext?)](Γ)(0), U))
            AND (KTYPE?(k) IMPLIES sexpr?(U) AND tcc?(t))
            AND (KTERM?(k) IMPLIES sexpr?(U) AND tcc?(t))}" tau nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (theory_ adt-constructor-decl "[finseq[(scontext?)] -> (theory?)]"
     language nil)
    (fcontext type-eq-decl nil tau_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil))
   nil))
 (τ_TCC6 0
  (τ_TCC6-1 nil 3585608210
   ("" (skosimp* :preds? t) (("" (assert) nil nil)) nil)
   ((int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (tccs type-decl nil language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (< const-decl "bool" reals nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (τ0 def-decl "{x: [keyword, tccs] |
         LET (k, t) = x IN
                (KTHEORY?(k) IMPLIES
                  sexpr?(U) AND
                   theory?(ρ0(Γ)(U)) AND
                    tccs?(t) AND length(decls(ρ0(Γ)(U))) = length(map(t)))
            AND (KDECL?(k) IMPLIES scontext?(U))
            AND (KINTERP?(k) AND ideep?(U) IMPLIES
                  compatible?(Γ ^^ (0, length(map(U))), map(U)) AND
                   tccs?(t) AND length(map(U)) = length(map(t)))
            AND (KINTERP?(k) AND (ikeep?(U) OR itype?(U) OR iterm?(U))
                  IMPLIES compatible0?(finseq_appl[(scontext?)](Γ)(0), U))
            AND (KTYPE?(k) IMPLIES sexpr?(U) AND tcc?(t))
            AND (KTERM?(k) IMPLIES sexpr?(U) AND tcc?(t))}" tau nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (theory_ adt-constructor-decl "[finseq[(scontext?)] -> (theory?)]"
     language nil)
    (fcontext type-eq-decl nil tau_props nil))
   nil))
 (τ_TCC7 0
  (τ_TCC7-1 nil 3585608210 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (tccs type-decl nil language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (< const-decl "bool" reals nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (τ0 def-decl "{x: [keyword, tccs] |
         LET (k, t) = x IN
                (KTHEORY?(k) IMPLIES
                  sexpr?(U) AND
                   theory?(ρ0(Γ)(U)) AND
                    tccs?(t) AND length(decls(ρ0(Γ)(U))) = length(map(t)))
            AND (KDECL?(k) IMPLIES scontext?(U))
            AND (KINTERP?(k) AND ideep?(U) IMPLIES
                  compatible?(Γ ^^ (0, length(map(U))), map(U)) AND
                   tccs?(t) AND length(map(U)) = length(map(t)))
            AND (KINTERP?(k) AND (ikeep?(U) OR itype?(U) OR iterm?(U))
                  IMPLIES compatible0?(finseq_appl[(scontext?)](Γ)(0), U))
            AND (KTYPE?(k) IMPLIES sexpr?(U) AND tcc?(t))
            AND (KTERM?(k) IMPLIES sexpr?(U) AND tcc?(t))}" tau nil)
    (theory_ adt-constructor-decl "[finseq[(scontext?)] -> (theory?)]"
     language nil)
    (fcontext type-eq-decl nil tau_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (sum def-decl "{n: nat | FORALL (x: below[len]): f(x) <= n}"
     language nil)
    (tsize def-decl "posnat" language nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (τ_TCC8 0
  (τ_TCC8-1 nil 3585608210 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (tccs type-decl nil language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (< const-decl "bool" reals nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (τ0 def-decl "{x: [keyword, tccs] |
         LET (k, t) = x IN
                (KTHEORY?(k) IMPLIES
                  sexpr?(U) AND
                   theory?(ρ0(Γ)(U)) AND
                    tccs?(t) AND length(decls(ρ0(Γ)(U))) = length(map(t)))
            AND (KDECL?(k) IMPLIES scontext?(U))
            AND (KINTERP?(k) AND ideep?(U) IMPLIES
                  compatible?(Γ ^^ (0, length(map(U))), map(U)) AND
                   tccs?(t) AND length(map(U)) = length(map(t)))
            AND (KINTERP?(k) AND (ikeep?(U) OR itype?(U) OR iterm?(U))
                  IMPLIES compatible0?(finseq_appl[(scontext?)](Γ)(0), U))
            AND (KTYPE?(k) IMPLIES sexpr?(U) AND tcc?(t))
            AND (KTERM?(k) IMPLIES sexpr?(U) AND tcc?(t))}" tau nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (theory_ adt-constructor-decl "[finseq[(scontext?)] -> (theory?)]"
     language nil)
    (fcontext type-eq-decl nil tau_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (τ_TCC9 0
  (τ_TCC9-1 nil 3585608210
   ("" (skosimp* :preds? t)
    (("" (expand expandable? 2)
      (("" (assert)
        (("" (typepred "Γ!1`seq(pos!1)")
          (("" (expand scontext? -1) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (tccs type-decl nil language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (< const-decl "bool" reals nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (τ0 def-decl "{x: [keyword, tccs] |
         LET (k, t) = x IN
                (KTHEORY?(k) IMPLIES
                  sexpr?(U) AND
                   theory?(ρ0(Γ)(U)) AND
                    tccs?(t) AND length(decls(ρ0(Γ)(U))) = length(map(t)))
            AND (KDECL?(k) IMPLIES scontext?(U))
            AND (KINTERP?(k) AND ideep?(U) IMPLIES
                  compatible?(Γ ^^ (0, length(map(U))), map(U)) AND
                   tccs?(t) AND length(map(U)) = length(map(t)))
            AND (KINTERP?(k) AND (ikeep?(U) OR itype?(U) OR iterm?(U))
                  IMPLIES compatible0?(finseq_appl[(scontext?)](Γ)(0), U))
            AND (KTYPE?(k) IMPLIES sexpr?(U) AND tcc?(t))
            AND (KTERM?(k) IMPLIES sexpr?(U) AND tcc?(t))}" tau nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (theory_ adt-constructor-decl "[finseq[(scontext?)] -> (theory?)]"
     language nil)
    (fcontext type-eq-decl nil tau_props nil))
   nil))
 (τ_TCC10 0
  (τ_TCC10-1 nil 3585608210
   ("" (skosimp* :preds? t) (("" (assert) nil nil)) nil)
   ((int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (tccs type-decl nil language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (< const-decl "bool" reals nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (τ0 def-decl "{x: [keyword, tccs] |
         LET (k, t) = x IN
                (KTHEORY?(k) IMPLIES
                  sexpr?(U) AND
                   theory?(ρ0(Γ)(U)) AND
                    tccs?(t) AND length(decls(ρ0(Γ)(U))) = length(map(t)))
            AND (KDECL?(k) IMPLIES scontext?(U))
            AND (KINTERP?(k) AND ideep?(U) IMPLIES
                  compatible?(Γ ^^ (0, length(map(U))), map(U)) AND
                   tccs?(t) AND length(map(U)) = length(map(t)))
            AND (KINTERP?(k) AND (ikeep?(U) OR itype?(U) OR iterm?(U))
                  IMPLIES compatible0?(finseq_appl[(scontext?)](Γ)(0), U))
            AND (KTYPE?(k) IMPLIES sexpr?(U) AND tcc?(t))
            AND (KTERM?(k) IMPLIES sexpr?(U) AND tcc?(t))}" tau nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (theory_ adt-constructor-decl "[finseq[(scontext?)] -> (theory?)]"
     language nil)
    (fcontext type-eq-decl nil tau_props nil))
   nil))
 (τ_TCC11 0
  (τ_TCC11-1 nil 3585608210
   ("" (skosimp* :preds? t)
    (("" (expand expandable? 2)
      (("" (typepred "Γ!1`seq(pos!1)")
        (("1" (expand scontext? -1)
          (("1" (assert) (("1" (grind) nil nil)) nil)) nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (tsize def-decl "posnat" language nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (expand def-decl "{V |
         (sexpr?(U) IMPLIES sexpr?(V)) AND
          (scontext?(U) IMPLIES scontext?(V)) AND
           (ideep?(U) IMPLIES theory?(V)) AND
            (ikeep?(U) OR itype?(U) OR iterm?(U) IMPLIES scontext?(V))}"
            delta nil)
    (expand_ctx const-decl "{Δ | Δ ≡ Γ}" delta nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (O const-decl "finseq" finite_sequences nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (ρ const-decl "syntaxic" tau nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (tccs type-decl nil language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (< const-decl "bool" reals nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (τ0 def-decl "{x: [keyword, tccs] |
         LET (k, t) = x IN
                (KTHEORY?(k) IMPLIES
                  sexpr?(U) AND
                   theory?(ρ0(Γ)(U)) AND
                    tccs?(t) AND length(decls(ρ0(Γ)(U))) = length(map(t)))
            AND (KDECL?(k) IMPLIES scontext?(U))
            AND (KINTERP?(k) AND ideep?(U) IMPLIES
                  compatible?(Γ ^^ (0, length(map(U))), map(U)) AND
                   tccs?(t) AND length(map(U)) = length(map(t)))
            AND (KINTERP?(k) AND (ikeep?(U) OR itype?(U) OR iterm?(U))
                  IMPLIES compatible0?(finseq_appl[(scontext?)](Γ)(0), U))
            AND (KTYPE?(k) IMPLIES sexpr?(U) AND tcc?(t))
            AND (KTERM?(k) IMPLIES sexpr?(U) AND tcc?(t))}" tau nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (theory_ adt-constructor-decl "[finseq[(scontext?)] -> (theory?)]"
     language nil)
    (fcontext type-eq-decl nil tau_props nil))
   nil))
 (τ_TCC12 0
  (τ_TCC12-1 nil 3585608210 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (tccs type-decl nil language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (< const-decl "bool" reals nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (τ0 def-decl "{x: [keyword, tccs] |
         LET (k, t) = x IN
                (KTHEORY?(k) IMPLIES
                  sexpr?(U) AND
                   theory?(ρ0(Γ)(U)) AND
                    tccs?(t) AND length(decls(ρ0(Γ)(U))) = length(map(t)))
            AND (KDECL?(k) IMPLIES scontext?(U))
            AND (KINTERP?(k) AND ideep?(U) IMPLIES
                  compatible?(Γ ^^ (0, length(map(U))), map(U)) AND
                   tccs?(t) AND length(map(U)) = length(map(t)))
            AND (KINTERP?(k) AND (ikeep?(U) OR itype?(U) OR iterm?(U))
                  IMPLIES compatible0?(finseq_appl[(scontext?)](Γ)(0), U))
            AND (KTYPE?(k) IMPLIES sexpr?(U) AND tcc?(t))
            AND (KTERM?(k) IMPLIES sexpr?(U) AND tcc?(t))}" tau nil)
    (theory_ adt-constructor-decl "[finseq[(scontext?)] -> (theory?)]"
     language nil)
    (fcontext type-eq-decl nil tau_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (expand_ctx const-decl "{Δ | Δ ≡ Γ}" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (ρ const-decl "syntaxic" tau nil)
    (O const-decl "finseq" finite_sequences nil)
    (++ const-decl "finseq[(scontext?)]" language nil))
   nil))
 (τ_TCC13 0
  (τ_TCC13-1 nil 3585608210
   ("" (skosimp* :preds? t)
    (("" (use size_textract)
      (("1" (split -1)
        (("1" (rewrite -5) nil nil) ("2" (assert) nil nil)) nil)
       ("2" (assert) nil nil))
      nil))
    nil)
   ((size_textract formula-decl nil language nil)
    (pos!1 skolem-const-decl "int" tau_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (tccs type-decl nil language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (< const-decl "bool" reals nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (τ0 def-decl "{x: [keyword, tccs] |
         LET (k, t) = x IN
                (KTHEORY?(k) IMPLIES
                  sexpr?(U) AND
                   theory?(ρ0(Γ)(U)) AND
                    tccs?(t) AND length(decls(ρ0(Γ)(U))) = length(map(t)))
            AND (KDECL?(k) IMPLIES scontext?(U))
            AND (KINTERP?(k) AND ideep?(U) IMPLIES
                  compatible?(Γ ^^ (0, length(map(U))), map(U)) AND
                   tccs?(t) AND length(map(U)) = length(map(t)))
            AND (KINTERP?(k) AND (ikeep?(U) OR itype?(U) OR iterm?(U))
                  IMPLIES compatible0?(finseq_appl[(scontext?)](Γ)(0), U))
            AND (KTYPE?(k) IMPLIES sexpr?(U) AND tcc?(t))
            AND (KTERM?(k) IMPLIES sexpr?(U) AND tcc?(t))}" tau nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (theory_ adt-constructor-decl "[finseq[(scontext?)] -> (theory?)]"
     language nil)
    (fcontext type-eq-decl nil tau_props nil))
   nil))
 (tcc_correctness_TCC1 0
  (tcc_correctness_TCC1-1 nil 3585608210 ("" (subtype-tcc) nil nil) nil
   nil))
 (tcc_correctness_TCC2 0
  (tcc_correctness_TCC2-1 nil 3585608210 ("" (subtype-tcc) nil nil) nil
   nil))
 (type_expansion_TCC1 0
  (type_expansion_TCC1-1 nil 3585608210 ("" (subtype-tcc) nil nil) nil
   nil))
 (type_expansion_TCC2 0
  (type_expansion_TCC2-1 nil 3585608210 ("" (subtype-tcc) nil nil) nil
   nil))
 (type_expansion_TCC3 0
  (type_expansion_TCC3-1 nil 3585608210 ("" (subtype-tcc) nil nil) nil
   nil)))

