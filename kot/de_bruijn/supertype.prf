(supertype (type_size_TCC1 0
            (type_size_TCC1-1 nil 3584291454
             ("" (termination-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (<< adt-def-decl "(strict_well_founded?[syntaxic])"
               language nil))
             nil))
           (type_size_TCC2 0
            (type_size_TCC2-1 nil 3584291454
             ("" (termination-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (<< adt-def-decl "(strict_well_founded?[syntaxic])"
               language nil))
             nil))
           (type_size_TCC3 0
            (type_size_TCC3-1 nil 3584291454
             ("" (termination-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (<< adt-def-decl "(strict_well_founded?[syntaxic])"
               language nil))
             nil))
           (type_size_TCC4 0
            (type_size_TCC4-1 nil 3584291454
             ("" (termination-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (<< adt-def-decl "(strict_well_founded?[syntaxic])"
               language nil))
             nil))
           (type_size_TCC5 0
            (type_size_TCC5-1 nil 3584291454
             ("" (termination-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (<< adt-def-decl "(strict_well_founded?[syntaxic])"
               language nil))
             nil))
           (divide_TCC1 0
            (divide_TCC1-1 nil 3584291454 ("" (subtype-tcc) nil nil)
             nil nil))
           (divide_TCC2 0
            (divide_TCC2-1 nil 3584291454
             ("" (termination-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (> const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (above nonempty-type-eq-decl nil integers nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (and_ const-decl "(sexpr?)" init_context nil)
              (∧ const-decl "(sexpr?)" init_context nil)
              (sinterp? adt-def-decl "boolean" language nil)
              (scontext? adt-def-decl "boolean" language nil))
             nil))
           (divide_TCC3 0
            (divide_TCC3-1 nil 3584291454 ("" (subtype-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (real_lt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (nnint_plus_posint_is_posint application-judgement
               "posint" integers nil)
              (nnint_plus_nnint_is_nnint application-judgement
               "nonneg_int" integers nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (type_size def-decl "nat" supertype nil))
             nil))
           (divide_TCC4 0
            (divide_TCC4-1 nil 3584291454
             ("" (subtype-tcc)
              (("1" (grind) nil nil) ("2" (grind) nil nil)
               ("3" (grind)
                (("3" (expand "sexpr?") (("3" (propax) nil nil)) nil))
                nil))
              nil)
             nil nil))
           (divide_TCC5 0
            (divide_TCC5-1 nil 3584291454
             ("" (termination-tcc) nil nil) nil nil))
           (divide_TCC6 0
            (divide_TCC6-1 nil 3584291454 ("" (subtype-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (real_lt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (nnint_plus_posint_is_posint application-judgement
               "posint" integers nil)
              (nnint_plus_nnint_is_nnint application-judgement
               "nonneg_int" integers nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (type_size def-decl "nat" supertype nil))
             nil))
           (divide_TCC7 0
            (divide_TCC7-1 nil 3584291454
             ("" (termination-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (< const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (>= const-decl "bool" reals nil)
              (nat nonempty-type-eq-decl nil naturalnumbers nil)
              (type_size def-decl "nat" supertype nil)
              (> const-decl "bool" reals nil)
              (above nonempty-type-eq-decl nil integers nil)
              (AND const-decl "[bool, bool -> bool]" booleans nil)
              (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (sinterp? adt-def-decl "boolean" language nil)
              (scontext? adt-def-decl "boolean" language nil))
             nil))
           (divide_TCC8 0
            (divide_TCC8-1 nil 3584291454 ("" (subtype-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (real_lt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (nnint_plus_posint_is_posint application-judgement
               "posint" integers nil)
              (nnint_plus_nnint_is_nnint application-judgement
               "nonneg_int" integers nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (type_size def-decl "nat" supertype nil))
             nil))
           (divide_TCC9 0
            (divide_TCC9-1 nil 3584291454 ("" (subtype-tcc) nil nil)
             nil nil))
           (divide_TCC10 0
            (divide_TCC10-1 nil 3584291454
             ("" (termination-tcc) nil nil) nil nil))
           (divide_TCC11 0
            (divide_TCC11-1 nil 3584291454 ("" (subtype-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (real_lt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (nnint_plus_posint_is_posint application-judgement
               "posint" integers nil)
              (nnint_plus_nnint_is_nnint application-judgement
               "nonneg_int" integers nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (type_size def-decl "nat" supertype nil))
             nil))
           (divide_TCC12 0
            (divide_TCC12-1 nil 3584984595 ("" (subtype-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (< const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (>= const-decl "bool" reals nil)
              (nat nonempty-type-eq-decl nil naturalnumbers nil)
              (type_size def-decl "nat" supertype nil)
              (> const-decl "bool" reals nil)
              (above nonempty-type-eq-decl nil integers nil)
              (AND const-decl "[bool, bool -> bool]" booleans nil)
              (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (sinterp? adt-def-decl "boolean" language nil)
              (scontext? adt-def-decl "boolean" language nil))
             nil))
           (divide_TCC13 0
            (divide_TCC13-1 nil 3584984595 ("" (subtype-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (sinterp? adt-def-decl "boolean" language nil)
              (scontext? adt-def-decl "boolean" language nil))
             nil))
           (mubody_TCC1 0
            (mubody_TCC1-1 nil 3584292541 ("" (subtype-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (pred type-eq-decl nil defined_types nil)
              (strict_well_founded? const-decl "bool" orders nil)
              (<< adt-def-decl "(strict_well_founded?[syntaxic])"
               language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (> const-decl "bool" reals nil)
              (above nonempty-type-eq-decl nil integers nil)
              (AND const-decl "[bool, bool -> bool]" booleans nil)
              (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
              (same type-eq-decl nil language nil)
              (lam? adt-recognizer-decl "[syntaxic -> boolean]"
               language nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (sinterp? adt-def-decl "boolean" language nil)
              (scontext? adt-def-decl "boolean" language nil))
             nil))
           (mubody_TCC2 0
            (mubody_TCC2-1 nil 3584292541 ("" (subtype-tcc) nil nil)
             ((↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
               subst nil)
              (sexpr? adt-def-decl "boolean" language nil))
             nil))
           (mubody_TCC3 0
            (mubody_TCC3-1 nil 3584292541 ("" (subtype-tcc) nil nil)
             ((sexpr? adt-def-decl "boolean" language nil)) nil))
           (mubody_TCC4 0
            (mubody_TCC4-1 nil 3584292541 ("" (subtype-tcc) nil nil)
             ((↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
               subst nil)
              (sexpr? adt-def-decl "boolean" language nil))
             nil))
           (mubody_TCC5 0
            (mubody_TCC5-1 nil 3584292541 ("" (subtype-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (pred type-eq-decl nil defined_types nil)
              (strict_well_founded? const-decl "bool" orders nil)
              (<< adt-def-decl "(strict_well_founded?[syntaxic])"
               language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (> const-decl "bool" reals nil)
              (above nonempty-type-eq-decl nil integers nil)
              (AND const-decl "[bool, bool -> bool]" booleans nil)
              (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
              (same type-eq-decl nil language nil)
              (lam? adt-recognizer-decl "[syntaxic -> boolean]"
               language nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (sinterp? adt-def-decl "boolean" language nil)
              (scontext? adt-def-decl "boolean" language nil))
             nil))
           (mubody_TCC6 0
            (mubody_TCC6-1 nil 3584292541
             ("" (termination-tcc) nil nil) nil nil))
           (mubody_TCC7 0
            (mubody_TCC7-1 nil 3584292541 ("" (subtype-tcc) nil nil)
             ((↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
               subst nil)
              (sexpr? adt-def-decl "boolean" language nil))
             nil))
           (mubody_TCC8 0
            (mubody_TCC8-1 nil 3584292541 ("" (subtype-tcc) nil nil)
             ((sexpr? adt-def-decl "boolean" language nil)) nil))
           (mubody_TCC9 0
            (mubody_TCC9-1 nil 3584292541 ("" (subtype-tcc) nil nil)
             ((sexpr? adt-def-decl "boolean" language nil)) nil))
           (mubody_TCC10 0
            (mubody_TCC10-1 nil 3584292541 ("" (subtype-tcc) nil nil)
             ((sexpr? adt-def-decl "boolean" language nil)) nil))
           (mubody_TCC11 0
            (mubody_TCC11-1 nil 3584292541
             ("" (skosimp* :preds? t)
              (("" (assert)
                (("" (rewrite -3)
                  (("" (expand "<<") (("" (propax) nil nil)) nil))
                  nil))
                nil))
              nil)
             ((↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
               subst nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (lam? adt-recognizer-decl "[syntaxic -> boolean]"
               language nil)
              (boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (pred type-eq-decl nil defined_types nil)
              (strict_well_founded? const-decl "bool" orders nil)
              (<< adt-def-decl "(strict_well_founded?[syntaxic])"
               language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (> const-decl "bool" reals nil)
              (above nonempty-type-eq-decl nil integers nil)
              (AND const-decl "[bool, bool -> bool]" booleans nil)
              (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (sinterp? adt-def-decl "boolean" language nil)
              (scontext? adt-def-decl "boolean" language nil)
              (same type-eq-decl nil language nil))
             nil))
           (mubody_TCC12 0
            (mubody_TCC12-1 nil 3584292541
             ("" (skosimp* :preds? t) (("" (assert) nil nil)) nil)
             ((posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (> const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (above nonempty-type-eq-decl nil integers nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil))
             nil))
           (mubody_TCC13 0
            (mubody_TCC13-1 nil 3584292541 ("" (subtype-tcc) nil nil)
             nil nil))
           (mubody_TCC14 0
            (mubody_TCC14-1 nil 3584292541
             ("" (termination-tcc) nil nil)
             ((↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
               subst nil)
              (sexpr? adt-def-decl "boolean" language nil))
             nil))
           (mubody_TCC15 0
            (mubody_TCC15-1 nil 3584292541
             ("" (termination-tcc) nil nil)
             ((sexpr? adt-def-decl "boolean" language nil)) nil))
           (mubody_TCC16 0
            (mubody_TCC16-1 nil 3584292541
             ("" (skosimp* :preds? t) (("" (assert) nil nil)) nil)
             ((↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
               subst nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (lam? adt-recognizer-decl "[syntaxic -> boolean]"
               language nil)
              (boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (pred type-eq-decl nil defined_types nil)
              (strict_well_founded? const-decl "bool" orders nil)
              (<< adt-def-decl "(strict_well_founded?[syntaxic])"
               language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (> const-decl "bool" reals nil)
              (above nonempty-type-eq-decl nil integers nil)
              (AND const-decl "[bool, bool -> bool]" booleans nil)
              (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (sinterp? adt-def-decl "boolean" language nil)
              (scontext? adt-def-decl "boolean" language nil)
              (same type-eq-decl nil language nil))
             nil))
           (mubody_TCC17 0
            (mubody_TCC17-1 nil 3584292541
             ("" (skosimp* :preds? t) (("" (assert) nil nil)) nil)
             ((↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
               subst nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (lam? adt-recognizer-decl "[syntaxic -> boolean]"
               language nil)
              (boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (pred type-eq-decl nil defined_types nil)
              (strict_well_founded? const-decl "bool" orders nil)
              (<< adt-def-decl "(strict_well_founded?[syntaxic])"
               language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (> const-decl "bool" reals nil)
              (above nonempty-type-eq-decl nil integers nil)
              (AND const-decl "[bool, bool -> bool]" booleans nil)
              (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (sinterp? adt-def-decl "boolean" language nil)
              (scontext? adt-def-decl "boolean" language nil)
              (same type-eq-decl nil language nil))
             nil))
           (mubody_TCC18 0
            (mubody_TCC18-1 nil 3584292541
             ("" (skosimp* :preds? t) (("" (assert) nil nil)) nil)
             ((posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (lam? adt-recognizer-decl "[syntaxic -> boolean]"
               language nil)
              (boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (pred type-eq-decl nil defined_types nil)
              (strict_well_founded? const-decl "bool" orders nil)
              (<< adt-def-decl "(strict_well_founded?[syntaxic])"
               language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (> const-decl "bool" reals nil)
              (above nonempty-type-eq-decl nil integers nil)
              (AND const-decl "[bool, bool -> bool]" booleans nil)
              (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (sinterp? adt-def-decl "boolean" language nil)
              (scontext? adt-def-decl "boolean" language nil)
              (same type-eq-decl nil language nil))
             nil))
           (mubody_TCC19 0
            (mubody_TCC19-1 nil 3584292541
             ("" (skosimp* :preds? t) (("" (assert) nil nil)) nil)
             ((↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
               subst nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (lam? adt-recognizer-decl "[syntaxic -> boolean]"
               language nil)
              (boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (pred type-eq-decl nil defined_types nil)
              (strict_well_founded? const-decl "bool" orders nil)
              (<< adt-def-decl "(strict_well_founded?[syntaxic])"
               language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (> const-decl "bool" reals nil)
              (above nonempty-type-eq-decl nil integers nil)
              (AND const-decl "[bool, bool -> bool]" booleans nil)
              (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (sinterp? adt-def-decl "boolean" language nil)
              (scontext? adt-def-decl "boolean" language nil)
              (same type-eq-decl nil language nil))
             nil))
           (mubody_TCC20 0
            (mubody_TCC20-1 nil 3584292541
             ("" (skosimp* :preds? t)
              (("" (expand "sexpr?" +)
                (("" (expand "sinterp?" +)
                  (("" (expand "scontext?" +)
                    (("" (assert) (("" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil)
             ((real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (real_lt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (subst def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
                     subst
                nil)
              (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
               subst nil)
              (lam? adt-recognizer-decl "[syntaxic -> boolean]"
               language nil)
              (boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (pred type-eq-decl nil defined_types nil)
              (strict_well_founded? const-decl "bool" orders nil)
              (<< adt-def-decl "(strict_well_founded?[syntaxic])"
               language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (> const-decl "bool" reals nil)
              (above nonempty-type-eq-decl nil integers nil)
              (AND const-decl "[bool, bool -> bool]" booleans nil)
              (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (sinterp? adt-def-decl "boolean" language nil)
              (scontext? adt-def-decl "boolean" language nil)
              (same type-eq-decl nil language nil))
             nil))
           (mubody_TCC21 0
            (mubody_TCC21-1 nil 3584296737 ("" (subtype-tcc) nil nil)
             ((sexpr? adt-def-decl "boolean" language nil)) nil))
           (mubody_TCC22 0
            (mubody_TCC22-1 nil 3584296737
             ("" (termination-tcc) nil nil)
             ((↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
               subst nil)
              (subst def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
                     subst
                nil)
              (sexpr? adt-def-decl "boolean" language nil))
             nil))
           (mubody_TCC23 0
            (mubody_TCC23-1 nil 3584296737 ("" (subtype-tcc) nil nil)
             ((sexpr? adt-def-decl "boolean" language nil)
              (sinterp? adt-def-decl "boolean" language nil)
              (scontext? adt-def-decl "boolean" language nil))
             nil))
           (π_TCC1 0
            (π_TCC1-1 nil 3584293159
             ("" (subtype-tcc)
              (("1" (grind)
                (("1" (expand "sexpr?") (("1" (propax) nil nil)) nil))
                nil)
               ("2" (expand "sexpr?") (("2" (propax) nil nil)) nil)
               ("3" (expand "sexpr?") (("3" (propax) nil nil)) nil)
               ("4" (expand "sexpr?") (("4" (propax) nil nil)) nil))
              nil)
             ((real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (> const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (above nonempty-type-eq-decl nil integers nil)
              (AND const-decl "[bool, bool -> bool]" booleans nil)
              (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
              (sinterp? adt-def-decl "boolean" language nil)
              (scontext? adt-def-decl "boolean" language nil)
              (same type-eq-decl nil language nil))
             nil))
           (mu_TCC1 0
            (mu_TCC1-1 nil 3584293256
             ("" (subtype-tcc)
              (("" (expand "sexpr?" +) (("" (propax) nil nil)) nil))
              nil)
             nil nil))
           (mu_TCC2 0
            (mu_TCC2-1 nil 3584293256
             ("" (skosimp* :preds? t) (("" (assert) nil nil)) nil)
             ((posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (> const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (above nonempty-type-eq-decl nil integers nil))
             nil))
           (mu_TCC3 0
            (mu_TCC3-1 nil 3584293256
             ("" (skosimp* :preds? t)
              (("" (invoke (typepred "%1") (~ + "sexpr?(%1)")) nil
                nil))
              nil)
             ((>= const-decl "bool" reals nil)
              (nat nonempty-type-eq-decl nil naturalnumbers nil)
              (AND const-decl "[bool, bool -> bool]" booleans nil)
              (IFF const-decl "[bool, bool -> bool]" booleans nil)
              (sinterp? adt-def-decl "boolean" language nil)
              (scontext? adt-def-decl "boolean" language nil)
              (ideep? adt-recognizer-decl "[syntaxic -> boolean]"
               language nil)
              (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
               subst nil)
              (π const-decl "(sexpr?)" supertype nil)
              (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
              (boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (> const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (above nonempty-type-eq-decl nil integers nil))
             nil))
           (mu_TCC4 0
            (mu_TCC4-1 nil 3584984595
             ("" (skosimp* :preds? t)
              (("" (expand sexpr? +) (("" (propax) nil nil)) nil)) nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil))
             nil))
           (mu_TCC5 0
            (mu_TCC5-1 nil 3584984595
             ("" (skosimp* :preds? t)
              (("" (expand sexpr? +) (("" (propax) nil nil)) nil)) nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (> const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (above nonempty-type-eq-decl nil integers nil))
             nil))
           (mu 0
            (mu-1 nil 3584293280
             ("" (skosimp* :preds? t)
              (("" (assert)
                (("" (lift-if)
                  (("" (assert)
                    (("" (bddsimp)
                      (("1" (assert)
                        (("1" (expand "mubody" 1 1)
                          (("1" (propax) nil nil)) nil))
                        nil)
                       ("2" (assert)
                        (("2" (expand "mubody" 1 1)
                          (("2" (assert) nil nil)) nil))
                        nil)
                       ("3" (expand "mubody" 1 1)
                        (("3" (assert) nil nil)) nil)
                       ("4" (assert) (("4" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ((real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (μ const-decl "(sexpr?)" supertype nil)
              (π const-decl "(sexpr?)" supertype nil)
              (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
               subst nil)
              (int_minus_int_is_int application-judgement "int"
               integers nil)
              (TRUE_ const-decl "(sexpr?)" init_context nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (mubody def-decl "[same(U), (sexpr?)]" supertype nil)
              (boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (> const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (above nonempty-type-eq-decl nil integers nil))
             shostak))
           (pi_TCC1 0
            (pi_TCC1-1 nil 3584294172
             ("" (subtype-tcc)
              (("" (expand "sexpr?") (("" (propax) nil nil)) nil)) nil)
             ((real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (> const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (above nonempty-type-eq-decl nil integers nil)
              (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
               subst nil)
              (π const-decl "(sexpr?)" supertype nil))
             nil))
           (pi_TCC2 0
            (pi_TCC2-1 nil 3584294172
             ("" (skosimp* :preds? t)
              (("" (expand "sexpr?") (("" (propax) nil nil)) nil)) nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil))
             nil))
           (pi_TCC3 0
            (pi_TCC3-1 nil 3584294172
             ("" (skosimp* :preds? t)
              (("" (expand "sexpr?") (("" (propax) nil nil)) nil)) nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (> const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (above nonempty-type-eq-decl nil integers nil))
             nil))
           (pi_TCC4 0
            (pi_TCC4-1 nil 3584294172
             ("" (skosimp* :preds? t)
              (("" (expand "sexpr?") (("" (propax) nil nil)) nil)) nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (> const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (above nonempty-type-eq-decl nil integers nil))
             nil))
           (pi_TCC5 0
            (pi_TCC5-1 nil 3584294172
             ("" (skosimp* :preds? t)
              (("" (assert)
                (("" (expand "sexpr?") (("" (propax) nil nil)) nil))
                nil))
              nil)
             ((posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (π const-decl "(sexpr?)" supertype nil)
              (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
               subst nil)
              (boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (> const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (above nonempty-type-eq-decl nil integers nil))
             nil))
           (pi_TCC6 0
            (pi_TCC6-1 nil 3584294172
             ("" (skosimp* :preds? t)
              (("" (expand sexpr? +) (("" (propax) nil nil)) nil)) nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil))
             nil))
           (pi_TCC7 0
            (pi_TCC7-1 nil 3584294172
             ("" (skosimp* :preds? t)
              (("" (assert)
                (("" (expand "sexpr?") (("" (propax) nil nil)) nil))
                nil))
              nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil))
             nil))
           (pi_TCC8 0
            (pi_TCC8-1 nil 3584294172
             ("" (skosimp* :preds? t)
              (("" (expand "sexpr?") (("" (propax) nil nil)) nil)) nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil))
             nil))
           (pi_TCC9 0
            (pi_TCC9-1 nil 3584294172
             ("" (skosimp* :preds? t)
              (("" (expand "sexpr?") (("" (propax) nil nil)) nil)) nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (> const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (above nonempty-type-eq-decl nil integers nil))
             nil))
           (pi_TCC10 0
            (pi_TCC10-1 nil 3584294172
             ("" (skosimp* :preds? t)
              (("" (expand "sexpr?") (("" (propax) nil nil)) nil)) nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (> const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (above nonempty-type-eq-decl nil integers nil))
             nil))
           (pi_TCC11 0
            (pi_TCC11-1 nil 3584294172
             ("" (skosimp* :preds? t)
              (("" (expand "sexpr?") (("" (propax) nil nil)) nil)) nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil))
             nil))
           (pi_TCC12 0
            (pi_TCC12-1 nil 3584294172
             ("" (skosimp* :preds? t)
              (("" (expand "sexpr?") (("" (propax) nil nil)) nil)) nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (> const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (above nonempty-type-eq-decl nil integers nil))
             nil))
           (pi_TCC13 0
            (pi_TCC13-1 nil 3584294172
             ("" (skosimp* :preds? t)
              (("" (assert)
                (("" (expand "sexpr?") (("" (propax) nil nil)) nil))
                nil))
              nil)
             ((real_lt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (π const-decl "(sexpr?)" supertype nil)
              (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
               subst nil)
              (subst def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
                     subst
                nil)
              (boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (> const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (above nonempty-type-eq-decl nil integers nil))
             nil))
           (pi_TCC14 0
            (pi_TCC14-1 nil 3584294172
             ("" (skosimp* :preds? t)
              (("" (expand sexpr? +) (("" (propax) nil nil)) nil)) nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil))
             nil))
           (pi_TCC15 0
            (pi_TCC15-1 nil 3584294172
             ("" (skosimp* :preds? t)
              (("" (assert)
                (("" (expand "sexpr?") (("" (propax) nil nil)) nil))
                nil))
              nil)
             ((real_lt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (π const-decl "(sexpr?)" supertype nil)
              (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
               subst nil)
              (subst def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
                     subst
                nil)
              (boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (> const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (above nonempty-type-eq-decl nil integers nil))
             nil))
           (pi 0
            (pi-1 nil 3584294359
             ("" (skosimp* :preds? t)
              (("" (assert)
                (("" (lift-if)
                  (("" (bddsimp)
                    (("1" (assert)
                      (("1" (decompose-equality +)
                        (("1" (expand "mubody" 1 1)
                          (("1" (propax) nil nil)) nil)
                         ("2" (expand "mubody" 1 1)
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (assert)
                      (("2" (expand "mubody" 1 2)
                        (("2" (expand "mubody" 1 1)
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil)
                     ("3" (assert)
                      (("3" (expand "mubody" 1 2)
                        (("3" (expand "mubody" 1 1)
                          (("3" (assert) nil nil)) nil))
                        nil))
                      nil)
                     ("4" (assert) (("4" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ((real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (π const-decl "(sexpr?)" supertype nil)
              (lam adt-constructor-decl
                   "[[(sexpr?), (sexpr?)] -> (lam?)]" language nil)
              (AND const-decl "[bool, bool -> bool]" booleans nil)
              (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
              (sinterp? adt-def-decl "boolean" language nil)
              (scontext? adt-def-decl "boolean" language nil)
              (same type-eq-decl nil language nil)
              (mubody def-decl "[same(U), (sexpr?)]" supertype nil)
              (subtype? adt-recognizer-decl "[syntaxic -> boolean]"
                        language nil)
              (supertype adt-accessor-decl "[(subtype?) -> (sexpr?)]"
                         language nil)
              (∧ const-decl "(sexpr?)" init_context nil)
              (app? adt-recognizer-decl "[syntaxic -> boolean]"
               language nil)
              (app adt-constructor-decl
               "[[(sexpr?), (sexpr?)] -> (app?)]" language nil)
              (>= const-decl "bool" reals nil)
              (nat nonempty-type-eq-decl nil naturalnumbers nil)
              (IFF const-decl "[bool, bool -> bool]" booleans nil)
              (ideep? adt-recognizer-decl "[syntaxic -> boolean]"
               language nil)
              (v? adt-recognizer-decl "[syntaxic -> boolean]" language
               nil)
              (v adt-constructor-decl "[nat -> (v?)]" language nil)
              (pred adt-accessor-decl "[(subtype?) -> (sexpr?)]"
               language nil)
              (numfield nonempty-type-eq-decl nil number_fields nil)
              (+ const-decl "[numfield, numfield -> numfield]"
                 number_fields nil)
              (syntaxic_lam_extensionality formula-decl nil language
               nil)
              (lam? adt-recognizer-decl "[syntaxic -> boolean]"
               language nil)
              (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
               subst nil)
              (μ const-decl "(sexpr?)" supertype nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (subst def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
                     subst
                nil)
              (real_lt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (TRUE_ const-decl "(sexpr?)" init_context nil)
              (int_minus_int_is_int application-judgement "int"
               integers nil)
              (boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (> const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (above nonempty-type-eq-decl nil integers nil))
             shostak))
           (divide_size 0
            (divide_size-1 nil 3584291729
             ("" (induct "U")
              (("1" (grind) nil nil) ("2" (grind) nil nil)
               ("3" (grind) nil nil) ("4" (grind) nil nil)
               ("5" (grind) nil nil) ("6" (grind) nil nil)
               ("7" (grind) nil nil) ("8" (grind) nil nil)
               ("9" (grind) nil nil) ("10" (grind) nil nil)
               ("11" (grind) nil nil) ("12" (grind) nil nil)
               ("13" (grind) nil nil) ("14" (grind) nil nil)
               ("15" (grind) nil nil) ("16" (grind) nil nil)
               ("17" (grind) nil nil) ("18" (grind) nil nil)
               ("19" (grind) nil nil) ("20" (grind) nil nil)
               ("21" (grind) nil nil) ("22" (grind) nil nil)
               ("23" (grind) nil nil))
              nil)
             ((and_ const-decl "(sexpr?)" init_context nil)
              (∧ const-decl "(sexpr?)" init_context nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (+ const-decl "[numfield, numfield -> numfield]"
                 number_fields nil)
              (numfield nonempty-type-eq-decl nil number_fields nil)
              (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
               subst nil)
              (ideep? adt-recognizer-decl "[syntaxic -> boolean]"
               language nil)
              (IFF const-decl "[bool, bool -> bool]" booleans nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (nnint_plus_nnint_is_nnint application-judgement
               "nonneg_int" integers nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic_induction formula-decl nil language nil)
              (/ def-decl "{V |
         (sexpr?(U) => sexpr?(V)) AND
          (sinterp?(U) => sinterp?(V)) AND (scontext?(U) => scontext?(V))}"
                 supertype nil)
              (scontext? adt-def-decl "boolean" language nil)
              (sinterp? adt-def-decl "boolean" language nil)
              (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
              (AND const-decl "[bool, bool -> bool]" booleans nil)
              (type_size def-decl "nat" supertype nil)
              (nat nonempty-type-eq-decl nil naturalnumbers nil)
              (>= const-decl "bool" reals nil)
              (= const-decl "[T, T -> boolean]" equalities nil)
              (above nonempty-type-eq-decl nil integers nil)
              (> const-decl "bool" reals nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (int nonempty-type-eq-decl nil integers nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (real nonempty-type-from-decl nil reals nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number nonempty-type-decl nil numbers nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (boolean nonempty-type-decl nil booleans nil)
              (syntaxic type-decl nil language nil))
             nil))
           (mubody_size 0
            (mubody_size-1 nil 3584295793
             ("" (induct U)
              (("1" (grind) nil nil) ("2" (grind) nil nil)
               ("3" (grind) nil nil) ("4" (grind) nil nil)
               ("5" (grind) nil nil) ("6" (grind) nil nil)
               ("7" (grind) nil nil) ("8" (grind) nil nil)
               ("9" (grind) nil nil) ("10" (grind) nil nil)
               ("11" (grind) nil nil) ("12" (grind) nil nil)
               ("13" (grind) nil nil) ("14" (grind) nil nil)
               ("15" (grind) nil nil) ("16" (grind) nil nil)
               ("17" (grind) nil nil) ("18" (grind) nil nil)
               ("19" (grind) nil nil) ("20" (grind) nil nil)
               ("21" (grind) nil nil) ("22" (grind) nil nil)
               ("23" (grind) nil nil))
              nil)
             ((subst def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
                     subst
                nil)
              (and_ const-decl "(sexpr?)" init_context nil)
              (∧ const-decl "(sexpr?)" init_context nil)
              (nnint_plus_nnint_is_nnint application-judgement
               "nonneg_int" integers nil)
              (divide_size application-judgement
               "{V | type_size(V) = type_size(U)}" supertype nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
               subst nil)
              (bool_ const-decl "(sexpr?)" init_context nil)
              (length def-decl "nat" list_props nil)
              (list2finseq const-decl "finseq[T]" list2finseq nil)
              (equal const-decl "(sexpr?)" init_context nil)
              (forall_ const-decl "(sexpr?)" init_context nil)
              (numfield nonempty-type-eq-decl nil number_fields nil)
              (+ const-decl "[numfield, numfield -> numfield]"
                 number_fields nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (TRUE_ const-decl "(sexpr?)" init_context nil)
              (syntaxic_induction formula-decl nil language nil)
              (mubody def-decl "[same(U), (sexpr?)]" supertype nil)
              (same type-eq-decl nil language nil)
              (scontext? adt-def-decl "boolean" language nil)
              (sinterp? adt-def-decl "boolean" language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
              (AND const-decl "[bool, bool -> bool]" booleans nil)
              (type_size def-decl "nat" supertype nil)
              (nat nonempty-type-eq-decl nil naturalnumbers nil)
              (>= const-decl "bool" reals nil)
              (= const-decl "[T, T -> boolean]" equalities nil)
              (above nonempty-type-eq-decl nil integers nil)
              (> const-decl "bool" reals nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (int nonempty-type-eq-decl nil integers nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (real nonempty-type-from-decl nil reals nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number nonempty-type-decl nil numbers nil)
              (boolean nonempty-type-decl nil booleans nil)
              (syntaxic type-decl nil language nil))
             nil))
           (mu_size 0
            (mu_size-1 nil 3584295793
             ("" (induct T)
              (("1" (grind) nil nil) ("2" (grind) nil nil)
               ("3" (grind) nil nil) ("4" (grind) nil nil)
               ("5" (grind) nil nil) ("6" (grind) nil nil)
               ("7" (grind) nil nil) ("8" (grind) nil nil)
               ("9" (grind) nil nil) ("10" (grind) nil nil)
               ("11" (grind) nil nil) ("12" (grind) nil nil)
               ("13" (grind) nil nil) ("14" (grind) nil nil)
               ("15" (grind) nil nil) ("16" (grind) nil nil)
               ("17" (grind) nil nil) ("18" (grind) nil nil)
               ("19" (grind) nil nil) ("20" (grind) nil nil)
               ("21" (grind) nil nil) ("22" (grind) nil nil)
               ("23" (grind) nil nil) ("24" (grind) nil nil))
              nil)
             ((divide_size application-judgement
               "{V | type_size(V) = type_size(U)}" supertype nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (numfield nonempty-type-eq-decl nil number_fields nil)
              (+ const-decl "[numfield, numfield -> numfield]"
                 number_fields nil)
              (nnint_plus_posint_is_posint application-judgement
               "posint" integers nil)
              (nnint_plus_nnint_is_nnint application-judgement
               "nonneg_int" integers nil)
              (ideep? adt-recognizer-decl "[syntaxic -> boolean]"
               language nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (real_ge_is_total_order name-judgement
               "(total_order?[real])" real_props nil)
              (mu formula-decl nil supertype nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic_induction formula-decl nil language nil)
              (μ const-decl "(sexpr?)" supertype nil)
              (type_size def-decl "nat" supertype nil)
              (nat nonempty-type-eq-decl nil naturalnumbers nil)
              (>= const-decl "bool" reals nil)
              (= const-decl "[T, T -> boolean]" equalities nil)
              (above nonempty-type-eq-decl nil integers nil)
              (> const-decl "bool" reals nil)
              (int nonempty-type-eq-decl nil integers nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (real nonempty-type-from-decl nil reals nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number nonempty-type-decl nil numbers nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (boolean nonempty-type-decl nil booleans nil)
              (syntaxic type-decl nil language nil))
             nil))
           (shift_size 0
            (shift_size-1 nil 3584296737
             ("" (induct-and-simplify "U") nil nil)
             ((syntaxic type-decl nil language nil)
              (boolean nonempty-type-decl nil booleans nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (>= const-decl "bool" reals nil)
              (nat nonempty-type-eq-decl nil naturalnumbers nil)
              (= const-decl "[T, T -> boolean]" equalities nil)
              (type_size def-decl "nat" supertype nil)
              (AND const-decl "[bool, bool -> bool]" booleans nil)
              (IFF const-decl "[bool, bool -> bool]" booleans nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (sinterp? adt-def-decl "boolean" language nil)
              (scontext? adt-def-decl "boolean" language nil)
              (ideep? adt-recognizer-decl "[syntaxic -> boolean]"
               language nil)
              (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
               subst nil)
              (syntaxic_induction formula-decl nil language nil)
              (real_lt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (finseq_appl const-decl "[below[length(fs)] -> T]"
               finite_sequences nil)
              (nnint_plus_nnint_is_nnint application-judgement
               "nonneg_int" integers nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (nnint_plus_posint_is_posint application-judgement
               "posint" integers nil)
              (numfield nonempty-type-eq-decl nil number_fields nil)
              (+ const-decl "[numfield, numfield -> numfield]"
                 number_fields nil))
             nil))
           (subst_size 0
            (subst_size-1 nil 3584296737
             ("" (induct U)
              (("1" (skosimp* :preds? t)
                (("1" (assert) (("1" (grind) nil nil)) nil)) nil)
               ("2" (skosimp* :preds? t) (("2" (assert) nil nil)) nil)
               ("3" (skosimp* :preds? t) (("3" (assert) nil nil)) nil)
               ("4" (skosimp* :preds? t) (("4" (assert) nil nil)) nil)
               ("5" (skosimp* :preds? t)
                (("5" (assert) (("5" (grind) nil nil)) nil)) nil)
               ("6" (skosimp* :preds? t)
                (("6" (assert) (("6" (grind) nil nil)) nil)) nil)
               ("7" (skosimp* :preds? t)
                (("7" (assert) (("7" (grind) nil nil)) nil)) nil)
               ("8" (skosimp* :preds? t) (("8" (assert) nil nil)) nil)
               ("9" (skosimp* :preds? t) (("9" (assert) nil nil)) nil)
               ("10" (skosimp* :preds? t) (("10" (assert) nil nil))
                nil)
               ("11" (skosimp* :preds? t) (("11" (assert) nil nil))
                nil)
               ("12" (skosimp* :preds? t) (("12" (assert) nil nil))
                nil)
               ("13" (skosimp* :preds? t) (("13" (assert) nil nil))
                nil)
               ("14" (skosimp* :preds? t) (("14" (assert) nil nil))
                nil)
               ("15" (skosimp* :preds? t) (("15" (assert) nil nil))
                nil)
               ("16" (skosimp* :preds? t) (("16" (assert) nil nil))
                nil)
               ("17" (skosimp* :preds? t) (("17" (assert) nil nil))
                nil)
               ("18" (skosimp* :preds? t) (("18" (assert) nil nil))
                nil)
               ("19" (skosimp* :preds? t) (("19" (assert) nil nil))
                nil)
               ("20" (skosimp* :preds? t) (("20" (assert) nil nil))
                nil)
               ("21" (skosimp* :preds? t) (("21" (assert) nil nil))
                nil)
               ("22" (skosimp* :preds? t) (("22" (assert) nil nil))
                nil)
               ("23" (skosimp* :preds? t) (("23" (assert) nil nil))
                nil))
              nil)
             ((↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
               subst nil)
              (numfield nonempty-type-eq-decl nil number_fields nil)
              (+ const-decl "[numfield, numfield -> numfield]"
                 number_fields nil)
              (nnint_plus_posint_is_posint application-judgement
               "posint" integers nil)
              (shift_size application-judgement
               "{V | type_size(V) = type_size(U)}" supertype nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (nnint_plus_nnint_is_nnint application-judgement
               "nonneg_int" integers nil)
              (int_minus_int_is_int application-judgement "int"
               integers nil)
              (finseq_appl const-decl "[below[length(fs)] -> T]"
               finite_sequences nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (real_ge_is_total_order name-judgement
               "(total_order?[real])" real_props nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (syntaxic_induction formula-decl nil language nil)
              (subst def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
                     subst
                nil)
              (ideep? adt-recognizer-decl "[syntaxic -> boolean]"
               language nil)
              (scontext? adt-def-decl "boolean" language nil)
              (sinterp? adt-def-decl "boolean" language nil)
              (IFF const-decl "[bool, bool -> bool]" booleans nil)
              (AND const-decl "[bool, bool -> bool]" booleans nil)
              (type_size def-decl "nat" supertype nil)
              (nat nonempty-type-eq-decl nil naturalnumbers nil)
              (>= const-decl "bool" reals nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (int nonempty-type-eq-decl nil integers nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (real nonempty-type-from-decl nil reals nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (= const-decl "[T, T -> boolean]" equalities nil)
              (number nonempty-type-decl nil numbers nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (boolean nonempty-type-decl nil booleans nil)
              (syntaxic type-decl nil language nil))
             nil))
           (simeq_TCC1 0
            (simeq_TCC1-1 nil 3584295489 ("" (termination-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (> const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (above nonempty-type-eq-decl nil integers nil)
              (type_size def-decl "nat" supertype nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (nnint_plus_nnint_is_nnint application-judgement
               "nonneg_int" integers nil)
              (nnint_plus_posint_is_posint application-judgement
               "posint" integers nil)
              (mu_size application-judgement
               "{A | type_size(A) = type_size(T)}" supertype nil)
              (real_lt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil))
             nil))
           (simeq_TCC2 0
            (simeq_TCC2-1 nil 3584295489
             ("" (subtype-tcc)
              (("" (expand "sexpr?") (("" (propax) nil nil)) nil)) nil)
             ((mu_size application-judgement
               "{A | type_size(A) = type_size(T)}" supertype nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (> const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (above nonempty-type-eq-decl nil integers nil)
              (bool_ const-decl "(sexpr?)" init_context nil))
             nil))
           (simeq_TCC3 0
            (simeq_TCC3-1 nil 3584295489 ("" (termination-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (< const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (>= const-decl "bool" reals nil)
              (nat nonempty-type-eq-decl nil naturalnumbers nil)
              (type_size def-decl "nat" supertype nil)
              (> const-decl "bool" reals nil)
              (above nonempty-type-eq-decl nil integers nil)
              (tccs type-decl nil language nil)
              (tcc? adt-recognizer-decl "[tccs -> boolean]" language
                    nil)
              (mu_size application-judgement
               "{A | type_size(A) = type_size(T)}" supertype nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (μ const-decl "(sexpr?)" supertype nil)
              (bool_ const-decl "(sexpr?)" init_context nil)
              (length def-decl "nat" list_props nil)
              (list2finseq const-decl "finseq[T]" list2finseq nil)
              (equal const-decl "(sexpr?)" init_context nil)
              (≐ const-decl "(sexpr?)" init_context nil)
              (t const-decl "(tcc?)" language nil))
             nil))
           (simeq_TCC4 0
            (simeq_TCC4-1 nil 3584295489 ("" (termination-tcc) nil nil)
             nil nil))
           (simeq_TCC5 0
            (simeq_TCC5-1 nil 3584295489 ("" (termination-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (type_size def-decl "nat" supertype nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (nnint_plus_nnint_is_nnint application-judgement
               "nonneg_int" integers nil)
              (nnint_plus_posint_is_posint application-judgement
               "posint" integers nil)
              (real_lt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil))
             nil))
           (simeq_TCC6 0
            (simeq_TCC6-1 nil 3584296184
             ("" (subtype-tcc)
              (("" (expand "sexpr?") (("" (propax) nil nil)) nil)) nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (< const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (>= const-decl "bool" reals nil)
              (nat nonempty-type-eq-decl nil naturalnumbers nil)
              (type_size def-decl "nat" supertype nil)
              (> const-decl "bool" reals nil)
              (above nonempty-type-eq-decl nil integers nil)
              (tccs type-decl nil language nil)
              (tcc? adt-recognizer-decl "[tccs -> boolean]" language
                    nil)
              (mu_size application-judgement
               "{A | type_size(A) = type_size(T)}" supertype nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (O const-decl "finseq" finite_sequences nil)
              (++ const-decl "same(x)" language nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (μ const-decl "(sexpr?)" supertype nil)
              (bool_ const-decl "(sexpr?)" init_context nil)
              (list2finseq const-decl "finseq[T]" list2finseq nil)
              (equal const-decl "(sexpr?)" init_context nil)
              (≐ const-decl "(sexpr?)" init_context nil)
              (t const-decl "(tcc?)" language nil)
              (finseq_appl const-decl "[below[length(fs)] -> T]"
               finite_sequences nil)
              (TRUE_ const-decl "(sexpr?)" init_context nil)
              (forall_ const-decl "(sexpr?)" init_context nil)
              (forall_ const-decl "(tcc?)" init_context nil))
             nil))
           (simeq_TCC7 0
            (simeq_TCC7-1 nil 3584296184
             ("" (subtype-tcc)
              (("" (expand "sexpr?") (("" (propax) nil nil)) nil)) nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (< const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (>= const-decl "bool" reals nil)
              (nat nonempty-type-eq-decl nil naturalnumbers nil)
              (type_size def-decl "nat" supertype nil)
              (> const-decl "bool" reals nil)
              (above nonempty-type-eq-decl nil integers nil)
              (tccs type-decl nil language nil)
              (tcc? adt-recognizer-decl "[tccs -> boolean]" language
                    nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (mu_size application-judgement
               "{A | type_size(A) = type_size(T)}" supertype nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (O const-decl "finseq" finite_sequences nil)
              (++ const-decl "same(x)" language nil)
              (nnint_plus_posint_is_posint application-judgement
               "posint" integers nil)
              (μ const-decl "(sexpr?)" supertype nil)
              (bool_ const-decl "(sexpr?)" init_context nil)
              (list2finseq const-decl "finseq[T]" list2finseq nil)
              (equal const-decl "(sexpr?)" init_context nil)
              (≐ const-decl "(sexpr?)" init_context nil)
              (t const-decl "(tcc?)" language nil)
              (finseq_appl const-decl "[below[length(fs)] -> T]"
               finite_sequences nil)
              (TRUE_ const-decl "(sexpr?)" init_context nil)
              (forall_ const-decl "(sexpr?)" init_context nil)
              (forall_ const-decl "(tcc?)" init_context nil))
             nil))
           (simeq_TCC8 0
            (simeq_TCC8-1 nil 3585319261 ("" (subtype-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (type_size def-decl "nat" supertype nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (nnint_plus_nnint_is_nnint application-judgement
               "nonneg_int" integers nil)
              (nnint_plus_posint_is_posint application-judgement
               "posint" integers nil)
              (real_lt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil))
             nil))
           (simeq_TCC9 0
            (simeq_TCC9-1 nil 3585319261 ("" (termination-tcc) nil nil)
             nil nil))
           (simeq_TCC10 0
            (simeq_TCC10-1 nil 3585319261 ("" (subtype-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (type_size def-decl "nat" supertype nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (nnint_plus_nnint_is_nnint application-judgement
               "nonneg_int" integers nil)
              (nnint_plus_posint_is_posint application-judgement
               "posint" integers nil)
              (real_lt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil))
             nil))
           (simeq_TCC11 0
            (simeq_TCC11-1 nil 3585319261 ("" (subtype-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (< const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (>= const-decl "bool" reals nil)
              (nat nonempty-type-eq-decl nil naturalnumbers nil)
              (type_size def-decl "nat" supertype nil)
              (> const-decl "bool" reals nil)
              (above nonempty-type-eq-decl nil integers nil)
              (tccs type-decl nil language nil)
              (tcc? adt-recognizer-decl "[tccs -> boolean]" language
                    nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (finseq_appl const-decl "[below[length(fs)] -> T]"
               finite_sequences nil)
              (bool_ const-decl "(sexpr?)" init_context nil)
              (list2finseq const-decl "finseq[T]" list2finseq nil)
              (equal const-decl "(sexpr?)" init_context nil)
              (TRUE_ const-decl "(sexpr?)" init_context nil)
              (forall_ const-decl "(sexpr?)" init_context nil)
              (forall_ const-decl "(tcc?)" init_context nil))
             nil))
           (simeq_TCC12 0
            (simeq_TCC12-1 nil 3585319261
             ("" (termination-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (< const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (>= const-decl "bool" reals nil)
              (nat nonempty-type-eq-decl nil naturalnumbers nil)
              (type_size def-decl "nat" supertype nil)
              (> const-decl "bool" reals nil)
              (above nonempty-type-eq-decl nil integers nil)
              (tccs type-decl nil language nil)
              (tcc? adt-recognizer-decl "[tccs -> boolean]" language
                    nil)
              (O const-decl "finseq" finite_sequences nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (finseq_appl const-decl "[below[length(fs)] -> T]"
               finite_sequences nil)
              (bool_ const-decl "(sexpr?)" init_context nil)
              (length def-decl "nat" list_props nil)
              (list2finseq const-decl "finseq[T]" list2finseq nil)
              (equal const-decl "(sexpr?)" init_context nil)
              (TRUE_ const-decl "(sexpr?)" init_context nil)
              (forall_ const-decl "(sexpr?)" init_context nil)
              (forall_ const-decl "(tcc?)" init_context nil)
              (++ const-decl "same(x)" language nil))
             nil))
           (sim_TCC1 0
            (sim_TCC1-1 nil 3584984595
             ("" (skosimp* :preds? t) (("" (grind) nil nil)) nil)
             ((real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (mu_size application-judgement
               "{A | type_size(A) = type_size(T)}" supertype nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (int_minus_int_is_int application-judgement "int"
               integers nil)
              (nnint_plus_posint_is_posint application-judgement
               "posint" integers nil)
              (t const-decl "(tcc?)" language nil)
              (≐ const-decl "(sexpr?)" init_context nil)
              (equal const-decl "(sexpr?)" init_context nil)
              (list2finseq const-decl "finseq[T]" list2finseq nil)
              (length def-decl "nat" list_props nil)
              (bool_ const-decl "(sexpr?)" init_context nil)
              (boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (> const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (above nonempty-type-eq-decl nil integers nil))
             nil))
           (sim_TCC2 0
            (sim_TCC2-1 nil 3584984595
             ("" (skosimp* :preds? t)
              (("" (expand sexpr? +) (("" (propax) nil nil)) nil)) nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil))
             nil))
           (sim_TCC3 0
            (sim_TCC3-1 nil 3584984595
             ("" (skosimp* :preds? t)
              (("" (expand sexpr? +) (("" (propax) nil nil)) nil)) nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil))
             nil))
           (sim_TCC4 0
            (sim_TCC4-1 nil 3584984595 ("" (termination-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (< const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (>= const-decl "bool" reals nil)
              (nat nonempty-type-eq-decl nil naturalnumbers nil)
              (type_size def-decl "nat" supertype nil)
              (> const-decl "bool" reals nil)
              (above nonempty-type-eq-decl nil integers nil)
              (tccs type-decl nil language nil)
              (tcc? adt-recognizer-decl "[tccs -> boolean]" language
                    nil)
              (O const-decl "finseq" finite_sequences nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (mu_size application-judgement
               "{A | type_size(A) = type_size(T)}" supertype nil)
              (bool_ const-decl "(sexpr?)" init_context nil)
              (length def-decl "nat" list_props nil)
              (list2finseq const-decl "finseq[T]" list2finseq nil)
              (equal const-decl "(sexpr?)" init_context nil)
              (≐ const-decl "(sexpr?)" init_context nil)
              (t const-decl "(tcc?)" language nil)
              (++ const-decl "same(x)" language nil)
              (finseq_appl const-decl "[below[length(fs)] -> T]"
               finite_sequences nil)
              (TRUE_ const-decl "(sexpr?)" init_context nil)
              (forall_ const-decl "(sexpr?)" init_context nil)
              (forall_ const-decl "(tcc?)" init_context nil))
             nil))
           (sim_TCC5 0
            (sim_TCC5-1 nil 3584984595
             ("" (subtype-tcc)
              (("" (expand sexpr? +) (("" (propax) nil nil)) nil)) nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (< const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (>= const-decl "bool" reals nil)
              (nat nonempty-type-eq-decl nil naturalnumbers nil)
              (type_size def-decl "nat" supertype nil)
              (> const-decl "bool" reals nil)
              (above nonempty-type-eq-decl nil integers nil)
              (tccs type-decl nil language nil)
              (tcc? adt-recognizer-decl "[tccs -> boolean]" language
                    nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (mu_size application-judgement
               "{A | type_size(A) = type_size(T)}" supertype nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (O const-decl "finseq" finite_sequences nil)
              (++ const-decl "same(x)" language nil)
              (nnint_plus_posint_is_posint application-judgement
               "posint" integers nil)
              (numfield nonempty-type-eq-decl nil number_fields nil)
              (+ const-decl "[numfield, numfield -> numfield]"
                 number_fields nil)
              (app? adt-recognizer-decl "[syntaxic -> boolean]"
               language nil)
              (app adt-constructor-decl
               "[[(sexpr?), (sexpr?)] -> (app?)]" language nil)
              (v? adt-recognizer-decl "[syntaxic -> boolean]" language
               nil)
              (v adt-constructor-decl "[nat -> (v?)]" language nil)
              (bool_ const-decl "(sexpr?)" init_context nil)
              (list2finseq const-decl "finseq[T]" list2finseq nil)
              (equal const-decl "(sexpr?)" init_context nil)
              (≐ const-decl "(sexpr?)" init_context nil)
              (t const-decl "(tcc?)" language nil)
              (finseq_appl const-decl "[below[length(fs)] -> T]"
               finite_sequences nil)
              (TRUE_ const-decl "(sexpr?)" init_context nil)
              (forall_ const-decl "(sexpr?)" init_context nil)
              (forall_ const-decl "(tcc?)" init_context nil))
             nil))
           (sim_TCC6 0
            (sim_TCC6-1 nil 3584984595
             ("" (grind)
              (("" (expand sexpr? 1) (("" (propax) nil nil)) nil)) nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil))
             nil))
           (sim_TCC7 0
            (sim_TCC7-1 nil 3585319261 ("" (termination-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (type_size def-decl "nat" supertype nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (nnint_plus_nnint_is_nnint application-judgement
               "nonneg_int" integers nil)
              (nnint_plus_posint_is_posint application-judgement
               "posint" integers nil)
              (real_lt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil))
             nil))
           (sim_TCC8 0
            (sim_TCC8-1 nil 3585319261
             ("" (grind)
              (("" (expand sexpr? 1) (("" (propax) nil nil)) nil)) nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil))
             nil))
           (sim_TCC9 0
            (sim_TCC9-1 nil 3585319261
             ("" (grind)
              (("" (rewrite subst_size) (("" (assert) nil nil)) nil))
              nil)
             ((subst_size judgement-tcc nil supertype nil)
              (number nonempty-type-decl nil numbers nil)
              (= const-decl "[T, T -> boolean]" equalities nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (>= const-decl "bool" reals nil)
              (nat nonempty-type-eq-decl nil naturalnumbers nil)
              (lproj? adt-recognizer-decl "[syntaxic -> boolean]"
               language nil)
              (lproj adt-constructor-decl "[(sexpr?) -> (lproj?)]"
               language nil)
              (posint_plus_nnint_is_posint application-judgement
               "posint" integers nil)
              (nnint_plus_nnint_is_nnint application-judgement
               "nonneg_int" integers nil)
              (nnint_plus_posint_is_posint application-judgement
               "posint" integers nil)
              (real_lt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (type_size def-decl "nat" supertype nil)
              (boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil))
             nil))
           (sim_TCC10 0
            (sim_TCC10-1 nil 3585319261 ("" (subtype-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (< const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (>= const-decl "bool" reals nil)
              (nat nonempty-type-eq-decl nil naturalnumbers nil)
              (type_size def-decl "nat" supertype nil)
              (> const-decl "bool" reals nil)
              (above nonempty-type-eq-decl nil integers nil)
              (tccs type-decl nil language nil)
              (tcc? adt-recognizer-decl "[tccs -> boolean]" language
                    nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (AND const-decl "[bool, bool -> bool]" booleans nil)
              (IFF const-decl "[bool, bool -> bool]" booleans nil)
              (sinterp? adt-def-decl "boolean" language nil)
              (scontext? adt-def-decl "boolean" language nil)
              (ideep? adt-recognizer-decl "[syntaxic -> boolean]"
               language nil)
              (subst def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
                     subst
                nil)
              (rproj adt-constructor-decl "[(sexpr?) -> (rproj?)]"
               language nil)
              (rproj? adt-recognizer-decl "[syntaxic -> boolean]"
               language nil)
              (lproj adt-constructor-decl "[(sexpr?) -> (lproj?)]"
               language nil)
              (lproj? adt-recognizer-decl "[syntaxic -> boolean]"
               language nil))
             nil))
           (sim_TCC11 0
            (sim_TCC11-1 nil 3585319261 ("" (subtype-tcc) nil nil)
             ((boolean nonempty-type-decl nil booleans nil)
              (bool nonempty-type-eq-decl nil booleans nil)
              (NOT const-decl "[bool -> bool]" booleans nil)
              (syntaxic type-decl nil language nil)
              (sexpr? adt-def-decl "boolean" language nil)
              (number nonempty-type-decl nil numbers nil)
              (number_field_pred const-decl "[number -> boolean]"
               number_fields nil)
              (number_field nonempty-type-from-decl nil number_fields
               nil)
              (real_pred const-decl "[number_field -> boolean]" reals
                         nil)
              (real nonempty-type-from-decl nil reals nil)
              (< const-decl "bool" reals nil)
              (rational_pred const-decl "[real -> boolean]" rationals
                             nil)
              (rational nonempty-type-from-decl nil rationals nil)
              (integer_pred const-decl "[rational -> boolean]" integers
                            nil)
              (int nonempty-type-eq-decl nil integers nil)
              (>= const-decl "bool" reals nil)
              (nat nonempty-type-eq-decl nil naturalnumbers nil)
              (type_size def-decl "nat" supertype nil)
              (> const-decl "bool" reals nil)
              (above nonempty-type-eq-decl nil integers nil)
              (tccs type-decl nil language nil)
              (tcc? adt-recognizer-decl "[tccs -> boolean]" language
                    nil)
              (real_gt_is_strict_total_order name-judgement
               "(strict_total_order?[real])" real_props nil)
              (O const-decl "finseq" finite_sequences nil)
              (++ const-decl "same(x)" language nil)
              (nnint_plus_nnint_is_nnint application-judgement
               "nonneg_int" integers nil)
              (lproj? adt-recognizer-decl "[syntaxic -> boolean]"
               language nil)
              (lproj adt-constructor-decl "[(sexpr?) -> (lproj?)]"
               language nil))
             nil)))

