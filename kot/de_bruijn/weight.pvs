weight: THEORY
BEGIN
  IMPORTING language

  Γ: VAR precontext
  S: VAR semantic
  x: VAR nat

  weight(Γ, S): RECURSIVE nat =
    CASES S OF
      v(i):
        IF i ∈ Γ
	  THEN 1 + IF (type_def?(Γ(i)) OR const_def?(Γ(i))) THEN weight(rest(Γ(i)), def(Γ(i))) ELSE 0 ENDIF
	  ELSE 0
	ENDIF
    , dot(i, σ, x):
        IF i ∈ Γ AND theory_def?(Γ(i)) AND compatible?(def(Γ(i)), σ) AND i(x) ∈ σ
	  THEN max(weight(Γ, σ), weight(Γ ++ interp(i, σ), x)) + 1
	  ELSE 0 ENDIF

    , fun(A, B): max(weight(Γ, A), weight(Γ ++ k(const_var(A)), B))
    , prod(A, B): max(weight(Γ, A), weight(Γ ++ k(const_var(A)), B))
    , subtype(T, a): max(weight(Γ, T), weight(Γ ++ k(const_var(T)), a))

    , app(f, a): max(weight(Γ, f), weight(Γ, a))
    , lam(T, a): max(weight(Γ, T), weight(Γ ++ k(const_var(T)), a))
    , pair(a, b): max(weight(Γ, a), weight(Γ, b))
    , lproj(a): weight(Γ, a)
    , rproj(a): weight(Γ, a)

    , type_decl: 0
    , type_var: 0
    , type_def(T): weight(Γ, T)
    , const_decl(T): weight(Γ, T)
    , const_var(T): weight(Γ, T)
    , const_def(T, a): max(weight(Γ, T), weight(Γ, a))
    , theory_def(Θ): weight(Γ, Θ)

    , nil: 0
    , ikeep(σ): weight(Γ, σ)
    , itype(σ, T): max(weight(Γ, σ), weight(Γ, T))
    , iconst(σ, a): max(weight(Γ, σ), weight(Γ, a))
    ENDCASES
  MEASURE sizde(S)

  weight_definition: THEOREM x ∈ Γ AND (type_def?(Γ(x)) OR const_def?(Γ(x))) IMPLIES
    weight(rest(Γ(x)), def(Γ(x))) < weight(Γ, v(x))
END weight
