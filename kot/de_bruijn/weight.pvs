weight: THEORY
BEGIN
  IMPORTING language

  Γ: VAR precontext
  x: VAR nat

  max(len: nat, f: [below[len] -> nat]): RECURSIVE
    { x | len = 0 AND x = 0 OR EXISTS (i: below[len]): x = f(i) } =
    IF len = 0 THEN 0
    ELSE max(f(len - 1), max(len - 1, LAMBDA (x: below[len - 1]): f(x))) ENDIF
  MEASURE len

  weight(Γ, (S: semantic(Γ))): RECURSIVE nat =
    CASES S OF
      v(i):
        IF i ∈ Γ
	  THEN 1 + size(Γ(i))
	  ELSE 0
	ENDIF
    , dot(i, σ, x):
        IF i ∈ Γ AND theory_def?(Γ(i)) AND compatible?(def(Γ(i)), σ) AND i(x) ∈ σ
	  THEN max(weight(Γ, σ), weight(Γ ++ interp(def(Γ(i)), σ), x)) + 1
	  ELSE 0 ENDIF

    , fun(A, B): max(weight(Γ, A), weight(Γ ++ k(const_var(A)), B))
    , prod(A, B): max(weight(Γ, A), weight(Γ ++ k(const_var(A)), B))
    , subtype(T, a): max(weight(Γ, T), weight(Γ ++ k(const_var(T)), a))

    , app(f, a): max(weight(Γ, f), weight(Γ, a))
    , lam(T, a): max(weight(Γ, T), weight(Γ ++ k(const_var(T)), a))
    , pair(a, b): max(weight(Γ, a), weight(Γ, b))
    , lproj(a): weight(Γ, a)
    , rproj(a): weight(Γ, a)

    , type_decl: 0
    , type_var: 0
    , type_def(T): weight(Γ, T)
    , const_decl(T): weight(Γ, T)
    , const_var(T): weight(Γ, T)
    , const_def(T, a): max(weight(Γ, T), weight(Γ, a))
    , theory_def(Θ): weight(Γ, Θ)

    , nil: 0
    , itype(σ, i, T): max(weight(Γ, σ), weight(Γ, T))
    , iconst(σ, i, a): max(weight(Γ, σ), weight(Γ, a))

    , map(f): max(f`length, LAMBDA (x: below[f`length]): weight(Γ ++ rest(S, x), f`seq(x)))
    ENDCASES
  MEASURE size(S)

  weight_definition: THEOREM x ∈ Γ AND (type_def?(Γ(x)) OR const_def?(Γ(x))) IMPLIES
    weight(rest(Γ(x)), def(Γ(x))) < weight(Γ, v(x))
END weight
