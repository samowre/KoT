weight: THEORY
BEGIN
  IMPORTING language

  M: VAR (scontext?)
  x: VAR nat

  max(len: nat, f: [below[len] -> nat]): RECURSIVE
    { x | len = 0 AND x = 0 OR EXISTS (i: below[len]): x = f(i) } =
    IF len = 0 THEN 0
    ELSE max(f(len - 1), max(len - 1, LAMBDA (x: below[len - 1]): f(x))) ENDIF
  MEASURE len

  weight(M, (S: semantic(M))): RECURSIVE nat =
    CASES S OF
      v(i):
        IF i ∈ M
	  THEN 1 + size(M(i))
	  ELSE 0
	ENDIF
    , dot(i, σ, x):
        IF i ∈ M AND theory_def?(M(i)) AND compatible?(def(M(i)), σ) AND i(x) ∈ σ
	  THEN max(weight(M, σ), weight(M ++ interp(def(M(i)), σ), x)) + 1
	  ELSE 0 ENDIF

    , fun(A, B): max(weight(M, A), weight(M ++ k(const_var(A)), B))
    , prod(A, B): max(weight(M, A), weight(M ++ k(const_var(A)), B))
    , subtype(T, a): max(weight(M, T), weight(M ++ k(const_var(T)), a))

    , app(f, a): max(weight(M, f), weight(M, a))
    , lam(T, a): max(weight(M, T), weight(M ++ k(const_var(T)), a))
    , pair(a, b): max(weight(M, a), weight(M, b))
    , lproj(a): weight(M, a)
    , rproj(a): weight(M, a)

    , type_decl: 0
    , type_var: 0
    , type_def(T): weight(M, T)
    , const_decl(T): weight(M, T)
    , const_var(T): weight(M, T)
    , const_def(T, a): max(weight(M, T), weight(M, a))
    , theory_def(Θ): weight(M, Θ)

    , nil: 0
    , itype(σ, i, T): max(weight(M, σ), weight(M, T))
    , iconst(σ, i, a): max(weight(M, σ), weight(M, a))

    , map(f): max(f`length, LAMBDA (x: below[f`length]): weight(M ++ rest(S, x), f`seq(x)))
    ENDCASES
  MEASURE size(S)

  weight_definition: THEOREM x ∈ M AND (type_def?(M(x)) OR const_def?(M(x))) IMPLIES
    weight(rest(M, x), def(M(x))) < weight(M, v(x))
END weight
