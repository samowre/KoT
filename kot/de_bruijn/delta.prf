(delta
 (η_TCC1 0
  (η_TCC1-1 nil 3584299169 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (syntaxic type-decl nil language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC2 0
  (η_TCC2-1 nil 3584299169 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (syntaxic type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (η_TCC3 0
  (η_TCC3-1 nil 3584299169 ("" (subtype-tcc) nil nil) nil nil))
 (η_TCC4 0 (η_TCC4-1 nil 3584299169 ("" (grind) nil nil) nil nil))
 (η_TCC5 0
  (η_TCC5-1 nil 3584299169
   ("" (skosimp* :preds? t)
    (("" (assert) (("" (expand "sexpr?") (("" (propax) nil nil)) nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (syntaxic type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   nil))
 (η_TCC6 0
  (η_TCC6-1 nil 3584304729
   ("" (subtype-tcc)
    (("" (expand "sexpr?") (("" (propax) nil nil)) nil)) nil)
   ((sexpr? adt-def-decl "boolean" language nil)) nil))
 (η_TCC7 0
  (η_TCC7-1 nil 3584304729
   ("" (skosimp* :preds? t)
    (("" (name-extract s (~ + "subst(%,%,%)"))
      (("1" (inst?)
        (("1" (typepred s)
          (("1" (assert)
            (("1" (flatten)
              (("1" (hide -2 -4 -6) (("1" (grind) nil nil)) nil)) nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil)
       ("2" (assert)
        (("2" (expand sexpr?) (("2" (propax) nil nil)) nil)) nil)
       ("3" (expand sexpr?) (("3" (propax) nil nil)) nil)
       ("4" (assert) nil nil))
      nil))
    nil)
   ((v adt-constructor-decl "[nat -> (v?)]" language nil)
    (v? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (↑ def-decl
     "{V | (sexpr?(U) IFF sexpr?(V)) AND (sinterp?(U) IFF sinterp?(V)) AND (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
     subst nil)
    (dot adt-constructor-decl "[[(sexpr?), (sexpr?)] -> (dot?)]"
     language nil)
    (dot? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (subst def-decl
           "{V | (sexpr?(U) IFF sexpr?(V)) AND (sinterp?(U) IFF sinterp?(V)) AND (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
           subst
      nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (n!1 skolem-const-decl "nat" delta nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (syntaxic type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (same type-eq-decl nil language nil))
   nil))
 (η_TCC8 0
  (η_TCC8-1 nil 3584304729 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (syntaxic type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (externalize_TCC1 0
  (externalize_TCC1-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (externalize_TCC2 0
  (externalize_TCC2-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (externalize_TCC3 0
  (externalize_TCC3-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (externalize_TCC4 0
  (externalize_TCC4-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (externalize_TCC5 0
  (externalize_TCC5-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (scontext? adt-def-decl "boolean" language nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (externalize_TCC6 0
  (externalize_TCC6-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (externalize_TCC7 0
  (externalize_TCC7-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (externalize_TCC8 0
  (externalize_TCC8-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (externalize_TCC9 0
  (externalize_TCC9-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (externalize_TCC10 0
  (externalize_TCC10-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (scontext? adt-def-decl "boolean" language nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (externalize_TCC11 0
  (externalize_TCC11-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (syntaxic type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (externalize_TCC12 0
  (externalize_TCC12-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (syntaxic type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (expandable?_TCC1 0
  (expandable?_TCC1-1 nil 3584909484 ("" (subtype-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (expandable?_TCC2 0
  (expandable?_TCC2-1 nil 3584909484
   ("" (skosimp* :preds? t)
    (("" (expand sinterp?) (("" (assert) (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((sinterp? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (expand_TCC1 0
  (expand_TCC1-1 nil 3584723429 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (definition? const-decl "bool" language nil))
   nil))
 (expand_TCC2 0
  (expand_TCC2-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (grind :rewrites (sexpr? scontext? sinterp?)) nil nil)) nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (↑ macro-decl "syntaxic" subst nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible0? const-decl "bool" interp nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil)
    (definition? const-decl "bool" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil))
   nil))
 (expand_TCC3 0
  (expand_TCC3-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (split 2)
      (("1" (flatten) nil nil) ("2" (flatten) nil nil)
       ("3" (flatten) (("3" (assert) nil nil)) nil)
       ("4" (flatten) (("4" (rewrite -4) (("4" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil))
   nil))
 (expand_TCC4 0
  (expand_TCC4-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (assert)
        (("" (expand sexpr? -)
          (("" (assert) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC5 0
  (expand_TCC5-1 nil 3584723429 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (expand_TCC6 0
  (expand_TCC6-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (flatten)
        (("" (assert)
          (("" (expand sexpr? -5)
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC7 0
  (expand_TCC7-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -5) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC8 0
  (expand_TCC8-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (grind :rewrites (sexpr? scontext? sinterp?)) nil nil)) nil)
   ((O const-decl "finseq" finite_sequences nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible0? const-decl "bool" interp nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC9 0
  (expand_TCC9-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (grind :rewrites (sexpr? scontext? sinterp?)) nil nil)) nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible0? const-decl "bool" interp nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC10 0
  (expand_TCC10-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2)
        (("" (assert) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC11 0
  (expand_TCC11-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -4) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC12 0
  (expand_TCC12-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand sexpr? +) (("" (propax) nil nil)) nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC13 0
  (expand_TCC13-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (assert)
        (("" (split 1)
          (("1" (expand compatible? -6)
            (("1" (flatten)
              (("1" (expand ++ 1) (("1" (assert) nil nil)) nil)) nil))
            nil)
           ("2" (assert)
            (("2" (case "(Γ!1 ++ Θ!1) ^^ (0, length(map(σ!1))) = Θ!1")
              (("1" (rewrite -1) nil nil)
               ("2" (expand compatible? -6)
                (("2" (flatten)
                  (("2" (rewrite -5 :dir rl)
                    (("2" (hide-all-but 1)
                      (("2" (grind-with-ext) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((O const-decl "finseq" finite_sequences nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (compatible? const-decl "bool" interp nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (TRUE const-decl "bool" booleans nil)
    (Θ!1 skolem-const-decl "finseq[(scontext?)]" delta nil)
    (epsilon const-decl "T" epsilons nil)
    (pred type-eq-decl nil defined_types nil)
    (FALSE const-decl "bool" booleans nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC14 0
  (expand_TCC14-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -5) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC15 0
  (expand_TCC15-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -5 :dont-delete? t)
      (("" (assert)
        (("" (split 1)
          (("1" (flatten)
            (("1" (invoke (typepred "%1") (~ + "externalize(%, %)"))
              (("1" (inst - ths?!1)
                (("1" (inst - "(Γ!1 ++ Θ!1, σ!1)")
                  (("1" (flatten)
                    (("1" (assert)
                      (("1" (expand sexpr? 1) (("1" (propax) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand expandable?)
                    (("2" (expand compatible? -9)
                      (("2" (flatten)
                        (("2" (expand ++ 1)
                          (("2"
                            (case "(Θ!1 o Γ!1) ^^ (0, length(map(σ!1))) = Θ!1")
                            (("1" (rewrite -1) (("1" (assert) nil nil))
                              nil)
                             ("2" (rewrite -8 :dir rl)
                              (("2"
                                (hide-all-but 1)
                                (("2"
                                  (grind-with-ext)
                                  (("2"
                                    (typepred x!1)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand expandable?)
                (("2" (expand ++ 1)
                  (("2" (expand compatible? -7)
                    (("2"
                      (case "(Θ!1 o Γ!1) ^^ (0, length(map(σ!1))) = Θ!1")
                      (("1" (rewrite -1) (("1" (assert) nil nil)) nil)
                       ("2" (flatten)
                        (("2" (rewrite -6 :dir rl)
                          (("2" (hide-all-but 1)
                            (("2" (grind-with-ext)
                              (("2"
                                (typepred x!1)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (hide 2)
                (("3" (hide -3)
                  (("3" (expand expandable?)
                    (("3" (expand sexpr? -3) (("3" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (expand scontext? -1) (("2" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((++ const-decl "finseq[(scontext?)]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (same type-eq-decl nil language nil)
    (externalize const-decl "same(U)" delta nil)
    (interp? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (interp adt-constructor-decl "[[(sexpr?), (ideep?)] -> (interp?)]"
            language nil)
    (FALSE const-decl "bool" booleans nil)
    (Γ!1 skolem-const-decl "finseq[(scontext?)]" delta nil)
    (Θ!1 skolem-const-decl "finseq[(scontext?)]" delta nil)
    (σ!1 skolem-const-decl "(ideep?)" delta nil)
    (compatible? const-decl "bool" interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (epsilon const-decl "T" epsilons nil)
    (TRUE const-decl "bool" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (O const-decl "finseq" finite_sequences nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC16 0
  (expand_TCC16-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (flatten)
        (("" (assert)
          (("" (split 2)
            (("1" (flatten) nil nil) ("2" (flatten) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC17 0
  (expand_TCC17-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -5)
      (("" (assert)
        (("" (expand (sexpr? scontext?) 2) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC18 0
  (expand_TCC18-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -3)
      (("" (assert)
        (("" (expand scontext? 1) (("" (flatten) nil nil)) nil)) nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (expand_TCC19 0
  (expand_TCC19-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?) (("" (propax) nil nil)) nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (expand_TCC20 0
  (expand_TCC20-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -2) (("" (rewrite size_rest) nil nil)) nil)) nil)
   ((size_rest formula-decl nil language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (expand_TCC21 0
  (expand_TCC21-1 nil 3584723429
   ("" (skosimp* :preds? t) (("" (assert) nil nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC22 0
  (expand_TCC22-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (assert)
        (("" (typepred "Θ!1`seq(0)")
          (("" (expand scontext? -1)
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC23 0
  (expand_TCC23-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -3)
      (("" (assert)
        (("" (assert)
          (("" (invoke (typepred "%1") (~ + "sum(%, %)"))
            (("" (inst - 0) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<= const-decl "bool" reals nil)
    (sum def-decl "{n: nat | FORALL (x: below[len]): f(x) <= n}"
     language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC24 0
  (expand_TCC24-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (rewrite -3 :dont-delete? t)
        (("" (assert)
          (("" (split 2)
            (("1" (flatten)
              (("1" (expand sexpr? 1) (("1" (propax) nil nil)) nil))
              nil)
             ("2" (flatten)
              (("2" (expand scontext? -1) (("2" (propax) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC25 0
  (expand_TCC25-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -3)
      (("" (assert)
        (("" (expand scontext? 3) (("" (flatten) nil nil)) nil)) nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC26 0
  (expand_TCC26-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand scontext? 1) (("" (propax) nil nil)) nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC27 0
  (expand_TCC27-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (assert)
        (("" (expand sexpr? -8)
          (("" (assert)
            (("" (split 1)
              (("1" (flatten) (("1" (grind) nil nil)) nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((k const-decl "finseq[(scontext?)]" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC28 0
  (expand_TCC28-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -9) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC29 0
  (expand_TCC29-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -8)
      (("" (assert)
        (("" (split 1)
          (("1" (flatten)
            (("1" (expand sexpr? 1) (("1" (propax) nil nil)) nil)) nil)
           ("2" (flatten)
            (("2" (expand scontext? -1) (("2" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((k const-decl "finseq[(scontext?)]" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC30 0
  (expand_TCC30-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2)
        (("" (assert) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC31 0
  (expand_TCC31-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -4) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC32 0
  (expand_TCC32-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand scontext?) (("" (propax) nil nil)) nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC33 0
  (expand_TCC33-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -8)
        (("" (split -8)
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil) ("4" (grind) nil nil)
           ("5" (grind) nil nil) ("6" (grind) nil nil)
           ("7" (grind) nil nil) ("8" (grind) nil nil)
           ("9" (grind) nil nil) ("10" (grind) nil nil)
           ("11" (grind) nil nil) ("12" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC34 0
  (expand_TCC34-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -9) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC35 0
  (expand_TCC35-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -8)
      (("" (assert)
        (("" (split 1)
          (("1" (flatten)
            (("1" (expand sexpr? 1) (("1" (propax) nil nil)) nil)) nil)
           ("2" (flatten)
            (("2" (expand scontext? -1) (("2" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((k const-decl "finseq[(scontext?)]" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC36 0
  (expand_TCC36-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (rewrite -4)
        (("" (expand sexpr? -2) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC37 0
  (expand_TCC37-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -4) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC38 0
  (expand_TCC38-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand scontext? 1) (("" (propax) nil nil)) nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC39 0
  (expand_TCC39-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -8)
        (("" (split -8)
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil) ("4" (grind) nil nil)
           ("5" (grind) nil nil) ("6" (grind) nil nil)
           ("7" (grind) nil nil) ("8" (grind) nil nil)
           ("9" (grind) nil nil) ("10" (grind) nil nil)
           ("11" (grind) nil nil) ("12" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC40 0
  (expand_TCC40-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -8)
      (("" (assert)
        (("" (rewrite -8) (("" (assert) (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC41 0
  (expand_TCC41-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -8)
      (("" (assert)
        (("" (split 1)
          (("1" (flatten)
            (("1" (expand sexpr? 1) (("1" (propax) nil nil)) nil)) nil)
           ("2" (flatten)
            (("2" (expand scontext? -1) (("2" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((k const-decl "finseq[(scontext?)]" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC42 0
  (expand_TCC42-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC43 0
  (expand_TCC43-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -4) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC44 0
  (expand_TCC44-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC45 0
  (expand_TCC45-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -4) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC46 0
  (expand_TCC46-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -3) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC47 0
  (expand_TCC47-1 nil 3584723429 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (expand_TCC48 0
  (expand_TCC48-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -5)
      (("" (assert)
        (("" (expand scontext? 1)
          (("" (flatten)
            (("" (expand sexpr? 1) (("" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC49 0
  (expand_TCC49-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand scontext? 1) (("" (propax) nil nil)) nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC50 0
  (expand_TCC50-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -8)
        (("" (split -8)
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil) ("4" (grind) nil nil)
           ("5" (grind) nil nil) ("6" (grind) nil nil)
           ("7" (grind) nil nil) ("8" (grind) nil nil)
           ("9" (grind) nil nil) ("10" (grind) nil nil)
           ("11" (grind) nil nil) ("12" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC51 0
  (expand_TCC51-1 nil 3584723429 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible0? const-decl "bool" interp nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (expand_TCC52 0
  (expand_TCC52-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -9)
      (("" (assert)
        (("" (expand scontext? 1)
          (("" (expand sexpr? 1 2) (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((k const-decl "finseq[(scontext?)]" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC53 0
  (expand_TCC53-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2)
        (("" (split -2)
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil) ("4" (grind) nil nil)
           ("5" (grind) nil nil) ("6" (grind) nil nil)
           ("7" (grind) nil nil) ("8" (grind) nil nil)
           ("9" (grind) nil nil) ("10" (grind) nil nil)
           ("11" (grind) nil nil) ("12" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC54 0
  (expand_TCC54-1 nil 3584723429 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (expand_TCC55 0
  (expand_TCC55-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2)
        (("" (split -2)
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil) ("4" (grind) nil nil)
           ("5" (grind) nil nil) ("6" (grind) nil nil)
           ("7" (grind) nil nil) ("8" (grind) nil nil)
           ("9" (grind) nil nil) ("10" (grind) nil nil)
           ("11" (grind) nil nil) ("12" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC56 0
  (expand_TCC56-1 nil 3584723429 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (expand_TCC57 0
  (expand_TCC57-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -3)
        (("" (split -3)
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil) ("4" (grind) nil nil)
           ("5" (grind) nil nil) ("6" (grind) nil nil)
           ("7" (grind) nil nil) ("8" (grind) nil nil)
           ("9" (grind) nil nil) ("10" (grind) nil nil)
           ("11" (grind) nil nil) ("12" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC58 0
  (expand_TCC58-1 nil 3584723429 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (compatible? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (expand_TCC59 0
  (expand_TCC59-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -5)
      (("" (assert)
        (("" (expand scontext? 1)
          (("" (expand sexpr? 1 2) (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC60 0
  (expand_TCC60-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2)
        (("" (split -2)
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil) ("4" (grind) nil nil)
           ("5" (grind) nil nil) ("6" (grind) nil nil)
           ("7" (grind) nil nil) ("8" (grind) nil nil)
           ("9" (grind) nil nil) ("10" (grind) nil nil)
           ("11" (grind) nil nil) ("12" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC61 0
  (expand_TCC61-1 nil 3584723429 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (compatible? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (expand_TCC62 0
  (expand_TCC62-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -4)
      (("" (assert)
        (("" (expand (scontext? sexpr?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC63 0
  (expand_TCC63-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2)
        (("" (split -2)
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil) ("4" (grind) nil nil)
           ("5" (grind) nil nil) ("6" (grind) nil nil)
           ("7" (grind) nil nil) ("8" (grind) nil nil)
           ("9" (grind) nil nil) ("10" (grind) nil nil)
           ("11" (grind) nil nil) ("12" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC64 0
  (expand_TCC64-1 nil 3584723429 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (expand_TCC65 0
  (expand_TCC65-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -4)
      (("" (assert)
        (("" (expand (scontext? sexpr?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC66 0
  (expand_TCC66-1 nil 3584723429 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (expand_TCC67 0
  (expand_TCC67-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -2)
      (("" (assert)
        (("" (expand sexpr? 1) (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (expand_TCC68 0
  (expand_TCC68-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2)
        (("" (split -2)
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil) ("4" (grind) nil nil)
           ("5" (grind) nil nil) ("6" (grind) nil nil)
           ("7" (grind) nil nil) ("8" (grind) nil nil)
           ("9" (grind) nil nil) ("10" (grind) nil nil)
           ("11" (grind) nil nil) ("12" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC69 0
  (expand_TCC69-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -3) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC70 0
  (expand_TCC70-1 nil 3584900727
   ("" (skosimp* :preds? t)
    (("" (rewrite -4)
      (("" (assert)
        (("" (expand (scontext? sexpr?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC71 0
  (expand_TCC71-1 nil 3584900727 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (expand_TCC72 0
  (expand_TCC72-1 nil 3584900727 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (compatible0? const-decl "bool" interp nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (expand_TCC73 0
  (expand_TCC73-1 nil 3584900727
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2)
        (("" (split -2)
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil) ("4" (grind) nil nil)
           ("5" (grind) nil nil) ("6" (grind) nil nil)
           ("7" (grind) nil nil) ("8" (grind) nil nil)
           ("9" (grind) nil nil) ("10" (grind) nil nil)
           ("11" (grind) nil nil) ("12" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC74 0
  (expand_TCC74-1 nil 3584903051 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (compatible? const-decl "bool" interp nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (expand_TCC75 0
  (expand_TCC75-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -4)
      (("" (assert)
        (("" (expand (scontext? sexpr?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC76 0
  (expand_TCC76-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -3)
      (("" (assert)
        (("" (expand (scontext? sexpr?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (expand_TCC77 0
  (expand_TCC77-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (flatten)
        (("" (rewrite -3)
          (("" (assert)
            (("" (flatten)
              (("" (split 2)
                (("1" (expand (rest irest))
                  (("1" (expand ^^ +)
                    (("1" (expand compatible? -3)
                      (("1" (flatten)
                        (("1" (lift-if)
                          (("1" (split 1)
                            (("1" (flatten)
                              (("1"
                                (assert)
                                (("1"
                                  (lift-if)
                                  (("1"
                                    (split 1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (assert)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (expand min)
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (assert)
                                (("2"
                                  (expand min)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (lift-if)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (split 3)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (assert)
                                              (("1" (grind) nil nil))
                                              nil))
                                            nil)
                                           ("2" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand compatible?)
                  (("2" (flatten)
                    (("2" (split 1)
                      (("1" (expand (rest irest) +)
                        (("1" (expand ^^)
                          (("1" (assert) (("1" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (skosimp* :preds? t)
                        (("2" (inst - "x!1 + 1")
                          (("1" (assert)
                            (("1" (expand irest 1 1)
                              (("1"
                                (expand ^^ 1 1)
                                (("1"
                                  (lift-if +)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (split 1)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (expand finseq_appl)
                                          (("1"
                                            (typepred!
                                             x!1
                                             :implicit?
                                             t)
                                            (("1" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (expand finseq_appl)
                                          (("2"
                                            (assert)
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Γ!1 skolem-const-decl "finseq[(scontext?)]" delta nil)
    (σ!1 skolem-const-decl "finseq[(sinterp?)]" delta nil)
    (x!1 skolem-const-decl
     "below(length(rest(Γ!1, 0) ^^ (0, length(irest(σ!1, 0)))))" delta
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (irest const-decl "finseq[(sinterp?)]" language nil)
    (rest const-decl "finseq[(scontext?)]" language nil)
    (compatible? const-decl "bool" interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (expand_TCC78 0
  (expand_TCC78-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -2) (("" (rewrite size_irest) nil nil)) nil)) nil)
   ((size_irest formula-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (expand_TCC79 0
  (expand_TCC79-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (expand expandable?)
        (("" (flatten)
          (("" (expand compatible? -2)
            (("" (flatten) (("" (assert) (("" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (rest const-decl "finseq[(scontext?)]" language nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (irest const-decl "finseq[(sinterp?)]" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (compatible? const-decl "bool" interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC80 0
  (expand_TCC80-1 nil 3584903051
   ("" (skosimp* :preds? t) (("" (assert) nil nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC81 0
  (expand_TCC81-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (flatten)
        (("" (assert)
          (("" (split 2)
            (("1" (flatten)
              (("1" (split 1)
                (("1" (expand (rest ++) 1) (("1" (assert) nil nil))
                  nil)
                 ("2" (expand (rest ++) 1)
                  (("2" (assert)
                    (("2" (expand compatible? -4)
                      (("2" (flatten)
                        (("2" (inst - 0)
                          (("1" (assert)
                            (("1" (rewrite -7 :dont-delete? t)
                              (("1"
                                (assert)
                                (("1"
                                  (expand compatible0? 1)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (expand finseq_appl)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand ^^ 1)
                            (("2" (assert)
                              (("2"
                                (lift-if)
                                (("2"
                                  (split 1)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (rewrite -7)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (expand min)
                                      (("2"
                                        (rewrite -6)
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (flatten) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (concat_assoc formula-decl nil language nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (Γ!1 skolem-const-decl "finseq[(scontext?)]" delta nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (U!1 skolem-const-decl "(expandable?(Γ!1))" delta nil)
    (below type-eq-decl nil naturalnumbers nil)
    (compatible0? const-decl "bool" interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (irest const-decl "finseq[(sinterp?)]" language nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (rest const-decl "finseq[(scontext?)]" language nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (O const-decl "finseq" finite_sequences nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC82 0
  (expand_TCC82-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -3)
      (("" (assert)
        (("" (invoke (typepred "%1") (~ + "sum(%,%)"))
          (("" (inst - 0) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((sum def-decl "{n: nat | FORALL (x: below[len]): f(x) <= n}"
     language nil)
    (<= const-decl "bool" reals nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC83 0
  (expand_TCC83-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (inst - ths?!1)
      (("" (invoke (inst - "(%1, %2)") (~ + "v!1(%)(%1, %2)"))
        (("1" (assert)
          (("1" (flatten)
            (("1" (assert)
              (("1" (typepred "σ!1`seq(0)")
                (("1" (expand sinterp?)
                  (("1" (expand expandable?)
                    (("1" (flatten)
                      (("1" (expand compatible? -3)
                        (("1" (flatten)
                          (("1" (rewrite -7 :dont-delete? t)
                            (("1" (inst - 0)
                              (("1" (assert) nil nil)
                               ("2"
                                (assert)
                                (("2"
                                  (expand ^^ 1)
                                  (("2"
                                    (rewrite -6)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand expandable?)
          (("2" (split 1)
            (("1" (flatten)
              (("1" (split 1)
                (("1" (expand (rest ++) 1) (("1" (assert) nil nil))
                  nil)
                 ("2" (expand compatible0? 1)
                  (("2" (rewrite -4)
                    (("2" (assert)
                      (("2" (flatten)
                        (("2" (expand compatible? -4)
                          (("2" (flatten)
                            (("2" (inst - 0)
                              (("1"
                                (assert)
                                (("1"
                                  (expand finseq_appl)
                                  (("1" (grind) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (expand ^^ 1)
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (rewrite -4)
                (("2" (assert)
                  (("2" (flatten)
                    (("2" (expand compatible? -4)
                      (("2" (flatten)
                        (("2" (inst - 0)
                          (("1" (assert) nil nil)
                           ("2" (expand ^^ 1) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((compatible0? const-decl "bool" interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (irest const-decl "finseq[(sinterp?)]" language nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (O const-decl "finseq" finite_sequences nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (U!1 skolem-const-decl "(expandable?(Γ!1))" delta nil)
    (below type-eq-decl nil naturalnumbers nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (compatible? const-decl "bool" interp nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (rest const-decl "finseq[(scontext?)]" language nil)
    (Γ!1 skolem-const-decl "finseq[(scontext?)]" delta nil)
    (Δ!1 skolem-const-decl "finseq[(scontext?)]" delta nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (σ!1 skolem-const-decl "finseq[(sinterp?)]" delta nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (concat_assoc formula-decl nil language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC84 0
  (expand_TCC84-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -3)
      (("" (assert)
        (("" (expand (scontext? sexpr?) 2) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((concat_assoc formula-decl nil language nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC85 0
  (expand_TCC85-1 nil 3584903051 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (compatible? const-decl "bool" interp nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (rest const-decl "finseq[(scontext?)]" language nil)
    (irest const-decl "finseq[(sinterp?)]" language nil))
   nil))
 (expand_TCC86 0
  (expand_TCC86-1 nil 3584903051 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (compatible? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (expand_TCC87 0
  (expand_TCC87-1 nil 3584903051 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (compatible? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (expand_TCC88 0
  (expand_TCC88-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2)
        (("" (split -2)
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil) ("4" (grind) nil nil)
           ("5" (grind) nil nil) ("6" (grind) nil nil)
           ("7" (grind) nil nil) ("8" (grind) nil nil)
           ("9" (grind) nil nil) ("10" (grind) nil nil)
           ("11" (grind) nil nil) ("12" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC89 0
  (expand_TCC89-1 nil 3584903051 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (compatible? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (expand_TCC90 0
  (expand_TCC90-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -4)
      (("" (assert)
        (("" (expand (scontext? sexpr?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC91 0
  (expand_TCC91-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2)
        (("" (split -2)
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil) ("4" (grind) nil nil)
           ("5" (grind) nil nil) ("6" (grind) nil nil)
           ("7" (grind) nil nil) ("8" (grind) nil nil)
           ("9" (grind) nil nil) ("10" (grind) nil nil)
           ("11" (grind) nil nil) ("12" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC92 0
  (expand_TCC92-1 nil 3584903051 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (compatible? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (expand_TCC93 0
  (expand_TCC93-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -4)
      (("" (assert)
        (("" (expand (scontext? sexpr?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC94 0
  (expand_TCC94-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2)
        (("" (split -2)
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil) ("4" (grind) nil nil)
           ("5" (grind) nil nil) ("6" (grind) nil nil)
           ("7" (grind) nil nil) ("8" (grind) nil nil)
           ("9" (grind) nil nil) ("10" (grind) nil nil)
           ("11" (grind) nil nil) ("12" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC95 0
  (expand_TCC95-1 nil 3584903051 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (compatible? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (expand_TCC96 0
  (expand_TCC96-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -4)
      (("" (assert)
        (("" (expand (scontext? sexpr?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC97 0
  (expand_TCC97-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2)
        (("" (split -2)
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil) ("4" (grind) nil nil)
           ("5" (grind) nil nil) ("6" (grind) nil nil)
           ("7" (grind) nil nil) ("8" (grind) nil nil)
           ("9" (grind) nil nil) ("10" (grind) nil nil)
           ("11" (grind) nil nil) ("12" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC98 0
  (expand_TCC98-1 nil 3584903051 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (compatible? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (expand_TCC99 0
  (expand_TCC99-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -3)
        (("" (split -3)
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil) ("4" (grind) nil nil)
           ("5" (grind) nil nil) ("6" (grind) nil nil)
           ("7" (grind) nil nil) ("8" (grind) nil nil)
           ("9" (grind) nil nil) ("10" (grind) nil nil)
           ("11" (grind) nil nil) ("12" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC100 0
  (expand_TCC100-1 nil 3584903051 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (compatible? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (expand_TCC101 0
  (expand_TCC101-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -5)
      (("" (assert)
        (("" (expand (scontext? sexpr?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC102 0
  (expand_TCC102-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2)
        (("" (split -2)
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil) ("4" (grind) nil nil)
           ("5" (grind) nil nil) ("6" (grind) nil nil)
           ("7" (grind) nil nil) ("8" (grind) nil nil)
           ("9" (grind) nil nil) ("10" (grind) nil nil)
           ("11" (grind) nil nil) ("12" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC103 0
  (expand_TCC103-1 nil 3584903051 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (compatible? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (expand_TCC104 0
  (expand_TCC104-1 nil 3584908005
   ("" (skosimp* :preds? t)
    (("" (rewrite -4)
      (("" (assert)
        (("" (expand (scontext? sexpr?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_size_TCC1 0
  (expand_size_TCC1-1 nil 3584978800 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (expand_size_TCC2 0
  (expand_size_TCC2-1 nil 3584978800
   ("" (skosimp* :preds? t)
    (("" (expand expand)
      (("" (lift-if)
        (("" (split 1)
          (("1" (assert) nil nil)
           ("2" (flatten)
            (("2" (split 2)
              (("1" (flatten) (("1" (assert) nil nil)) nil)
               ("2" (flatten) (("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((expand def-decl
            "{V | (sexpr?(U) IMPLIES sexpr?(V)) AND (scontext?(U) IMPLIES scontext?(V)) AND (ideep?(U) IMPLIES theory?(V)) AND (ikeep?(U) OR itype?(U) OR iterm?(U) IMPLIES scontext?(V))}"
            delta nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (expand_size 0
  (expand_size-1 nil 3584979037
   ("" (measure-induct+ "length(Δ)" "Δ")
    (("1" (skosimp* :preds? t)
      (("1" (expand expand 1)
        (("1" (lift-if)
          (("1" (split 1)
            (("1" (propax) nil nil)
             ("2" (flatten)
              (("2" (split 2)
                (("1" (flatten)
                  (("1" (assert)
                    (("1" (expand (++ rest) 1)
                      (("1" (assert)
                        (("1" (inst - "x!1 ^^ (1, length(x!1))")
                          (("1" (inst - ths?!1 Γ!1)
                            (("1" (split -2)
                              (("1"
                                (rewrite -1)
                                (("1"
                                  (hide -1)
                                  (("1" (grind) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (hide -1)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (use expand_size_TCC2) nil nil)
     ("3" (expand expandable?) (("3" (propax) nil nil)) nil)
     ("4" (use expand_size_TCC2) nil nil)
     ("5" (expand expandable?) (("5" (propax) nil nil)) nil))
    nil)
   ((expand_size_TCC2 subtype-tcc nil delta nil)
    (rest const-decl "finseq[(scontext?)]" language nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (O const-decl "finseq" finite_sequences nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (expand def-decl
            "{V | (sexpr?(U) IMPLIES sexpr?(V)) AND (scontext?(U) IMPLIES scontext?(V)) AND (ideep?(U) IMPLIES theory?(V)) AND (ikeep?(U) OR itype?(U) OR iterm?(U) IMPLIES scontext?(V))}"
            delta nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (theory_ adt-constructor-decl "[finseq[(scontext?)] -> (theory?)]"
     language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (scontext? adt-def-decl "boolean" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (syntaxic type-decl nil language nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (expand_ctx_TCC1 0
  (expand_ctx_TCC1-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((empty_seq const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (expand_ctx_TCC2 0
  (expand_ctx_TCC2-1 nil 3584892495
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (expand expand)
        (("" (lift-if)
          (("" (split 1)
            (("1" (flatten) (("1" (assert) nil nil)) nil)
             ("2" (flatten)
              (("2" (split 2)
                (("1" (flatten) (("1" (assert) nil nil)) nil)
                 ("2" (flatten) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((concat_empty formula-decl nil language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (expand def-decl
            "{V | (sexpr?(U) IMPLIES sexpr?(V)) AND (scontext?(U) IMPLIES scontext?(V)) AND (ideep?(U) IMPLIES theory?(V)) AND (ikeep?(U) OR itype?(U) OR iterm?(U) IMPLIES scontext?(V))}"
            delta nil))
   nil))
 (expand_ctx_TCC3 0
  (expand_ctx_TCC3-1 nil 3584903051
   ("" (measure-induct+ "length(Γ)" "Γ")
    (("1" (expand expand 1)
      (("1" (lift-if)
        (("1" (split 1)
          (("1" (grind) nil nil)
           ("2" (flatten)
            (("2" (split 2)
              (("1" (flatten)
                (("1" (assert)
                  (("1" (inst - "rest(x!1, 0)")
                    (("1" (split -2)
                      (("1" (expand ≡ 1)
                        (("1" (split 1)
                          (("1" (expand ++ 1)
                            (("1" (assert)
                              (("1"
                                (use expand_size)
                                (("1"
                                  (rewrite -1)
                                  (("1" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (skosimp* :preds? t)
                            (("2" (assert)
                              (("2"
                                (expand ++ -1)
                                (("2"
                                  (assert)
                                  (("2"
                                    (rewrite expand_size)
                                    (("2"
                                      (expand rest -1)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (expand ^^ -1)
                                          (("2"
                                            (assert)
                                            (("2"
                                              (lift-if)
                                              (("2"
                                                (split -1)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (case "x!2 = 0")
                                                      (("1"
                                                        (rewrite -1)
                                                        (("1"
                                                          (expand ++ 1)
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (typepred
                                                               "x!1`seq(0)")
                                                              (("1"
                                                                (expand
                                                                 scontext?
                                                                 -1)
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (expand ++ 2)
                                                        (("2"
                                                          (assert)
                                                          (("2"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (flatten)
                                                  (("2"
                                                    (expand min)
                                                    (("2"
                                                      (expand ++ 3)
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (case
                                                           "x!2 = 0")
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (typepred
                                                               "x!1`seq(0)")
                                                              (("1"
                                                                (expand
                                                                 scontext?
                                                                 -1)
                                                                (("1"
                                                                  (rewrite
                                                                   -2)
                                                                  (("1"
                                                                    (hide
                                                                     -3
                                                                     -4)
                                                                    (("1"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (assert)
                                                            (("2"
                                                              (expand
                                                               ≡
                                                               -2)
                                                              (("2"
                                                                (flatten)
                                                                (("2"
                                                                  (inst
                                                                   -
                                                                   "x!2 - 1")
                                                                  (("2"
                                                                    (assert)
                                                                    (("2"
                                                                      (case
                                                                       "rest(x!1, 0)`seq(x!2 - 1) = x!1`seq(x!2)")
                                                                      (("1"
                                                                        (rewrite
                                                                         -1)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (hide
                                                                         5
                                                                         -3)
                                                                        (("2"
                                                                          (grind-with-ext)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten) (("2" (use expand_size_TCC2) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (use expand_size_TCC2) nil nil)
     ("3" (expand expandable?) (("3" (propax) nil nil)) nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (measure_induction formula-decl nil measure_induction nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (expandable? const-decl "bool" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory_ adt-constructor-decl "[finseq[(scontext?)] -> (theory?)]"
     language nil)
    (TRUE const-decl "bool" booleans nil)
    (expand def-decl
            "{V | (sexpr?(U) IMPLIES sexpr?(V)) AND (scontext?(U) IMPLIES scontext?(V)) AND (ideep?(U) IMPLIES theory?(V)) AND (ikeep?(U) OR itype?(U) OR iterm?(U) IMPLIES scontext?(V))}"
            delta nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (≡ const-decl "bool" language nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (expand_size_TCC2 subtype-tcc nil delta nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (expand_size formula-decl nil delta nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (x!1 skolem-const-decl "finseq[(scontext?)]" delta nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (epsilon const-decl "T" epsilons nil)
    (FALSE const-decl "bool" booleans nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (O const-decl "finseq" finite_sequences nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (concat_empty formula-decl nil language nil)
    (rest const-decl "finseq[(scontext?)]" language nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil)))

