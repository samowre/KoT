(delta
 (η_TCC1 0
  (η_TCC1-1 nil 3584299169 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (syntaxic type-decl nil language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (η_TCC2 0
  (η_TCC2-1 nil 3584299169 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (syntaxic type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (η_TCC3 0
  (η_TCC3-1 nil 3584299169 ("" (subtype-tcc) nil nil) nil nil))
 (η_TCC4 0 (η_TCC4-1 nil 3584299169 ("" (grind) nil nil) nil nil))
 (η_TCC5 0
  (η_TCC5-1 nil 3584299169
   ("" (skosimp* :preds? t)
    (("" (assert) (("" (expand "sexpr?") (("" (propax) nil nil)) nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (syntaxic type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   nil))
 (η_TCC6 0
  (η_TCC6-1 nil 3584304729
   ("" (subtype-tcc)
    (("" (expand "sexpr?") (("" (propax) nil nil)) nil)) nil)
   ((sexpr? adt-def-decl "boolean" language nil)) nil))
 (η_TCC7 0
  (η_TCC7-1 nil 3584304729
   ("" (skosimp* :preds? t)
    (("" (name-extract s (~ + "subst(%,%,%)"))
      (("1" (inst?)
        (("1" (typepred s)
          (("1" (assert)
            (("1" (flatten)
              (("1" (hide -2 -4 -6) (("1" (grind) nil nil)) nil)) nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil)
       ("2" (assert)
        (("2" (expand sexpr?) (("2" (propax) nil nil)) nil)) nil)
       ("3" (expand sexpr?) (("3" (propax) nil nil)) nil)
       ("4" (assert) nil nil))
      nil))
    nil)
   ((v adt-constructor-decl "[nat -> (v?)]" language nil)
    (v? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
     subst nil)
    (dot adt-constructor-decl "[[(sexpr?), (sexpr?)] -> (dot?)]"
     language nil)
    (dot? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (subst def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND
           (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
           subst
      nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (n!1 skolem-const-decl "nat" delta nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (syntaxic type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (same type-eq-decl nil language nil))
   nil))
 (η_TCC8 0
  (η_TCC8-1 nil 3584304729 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (syntaxic type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (externalize_TCC1 0
  (externalize_TCC1-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (externalize_TCC2 0
  (externalize_TCC2-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (externalize_TCC3 0
  (externalize_TCC3-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (externalize_TCC4 0
  (externalize_TCC4-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (externalize_TCC5 0
  (externalize_TCC5-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (scontext? adt-def-decl "boolean" language nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (externalize_TCC6 0
  (externalize_TCC6-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (externalize_TCC7 0
  (externalize_TCC7-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (externalize_TCC8 0
  (externalize_TCC8-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (externalize_TCC9 0
  (externalize_TCC9-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (externalize_TCC10 0
  (externalize_TCC10-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (scontext? adt-def-decl "boolean" language nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (externalize_TCC11 0
  (externalize_TCC11-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (syntaxic type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (externalize_TCC12 0
  (externalize_TCC12-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (syntaxic type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (scontext? adt-def-decl "boolean" language nil))
   nil))
 (expandable?_TCC1 0
  (expandable?_TCC1-1 nil 3584909484 ("" (subtype-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (expandable?_TCC2 0
  (expandable?_TCC2-1 nil 3584909484
   ("" (skosimp* :preds? t)
    (("" (expand sinterp?) (("" (assert) (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((sinterp? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (expand_TCC1 0
  (expand_TCC1-1 nil 3584723429 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (definition? const-decl "bool" language nil))
   nil))
 (expand_TCC2 0
  (expand_TCC2-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (grind :rewrites (sexpr? scontext? sinterp?)) nil nil)) nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (↑ macro-decl "syntaxic" subst nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible0? const-decl "bool" interp nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil)
    (definition? const-decl "bool" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil))
   nil))
 (expand_TCC3 0
  (expand_TCC3-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (split 2)
      (("1" (flatten) nil nil) ("2" (flatten) nil nil)
       ("3" (flatten) (("3" (assert) nil nil)) nil)
       ("4" (flatten) (("4" (rewrite -4) (("4" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil))
   nil))
 (expand_TCC4 0
  (expand_TCC4-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (assert)
        (("" (expand sexpr? -)
          (("" (assert) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC5 0
  (expand_TCC5-1 nil 3584723429 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (expand_TCC6 0
  (expand_TCC6-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (flatten)
        (("" (assert)
          (("" (expand sexpr? -5)
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC7 0
  (expand_TCC7-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -5) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC8 0
  (expand_TCC8-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (grind :rewrites (sexpr? scontext? sinterp?)) nil nil)) nil)
   ((O const-decl "finseq" finite_sequences nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible0? const-decl "bool" interp nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC9 0
  (expand_TCC9-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (grind :rewrites (sexpr? scontext? sinterp?)) nil nil)) nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible0? const-decl "bool" interp nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC10 0
  (expand_TCC10-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2)
        (("" (assert) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC11 0
  (expand_TCC11-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -4) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC12 0
  (expand_TCC12-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand sexpr? +) (("" (propax) nil nil)) nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC13 0
  (expand_TCC13-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (assert)
        (("" (split 1)
          (("1" (expand compatible? -6)
            (("1" (flatten)
              (("1" (expand ++ 1) (("1" (assert) nil nil)) nil)) nil))
            nil)
           ("2" (assert)
            (("2" (case "(Γ!1 ++ Θ!1) ^^ (0, length(map(σ!1))) = Θ!1")
              (("1" (rewrite -1) nil nil)
               ("2" (expand compatible? -6)
                (("2" (flatten)
                  (("2" (rewrite -5 :dir rl)
                    (("2" (hide-all-but 1)
                      (("2" (grind-with-ext) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((O const-decl "finseq" finite_sequences nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (compatible? const-decl "bool" interp nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (TRUE const-decl "bool" booleans nil)
    (Θ!1 skolem-const-decl "finseq[(scontext?)]" delta nil)
    (epsilon const-decl "T" epsilons nil)
    (pred type-eq-decl nil defined_types nil)
    (FALSE const-decl "bool" booleans nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC14 0
  (expand_TCC14-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -5) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC15 0
  (expand_TCC15-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -5 :dont-delete? t)
      (("" (assert)
        (("" (split 1)
          (("1" (flatten)
            (("1" (invoke (typepred "%1") (~ + "externalize(%, %)"))
              (("1" (inst - ths?!1)
                (("1" (inst - "(Γ!1 ++ Θ!1, σ!1)")
                  (("1" (flatten)
                    (("1" (assert)
                      (("1" (expand sexpr? 1) (("1" (propax) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand expandable?)
                    (("2" (expand compatible? -9)
                      (("2" (flatten)
                        (("2" (expand ++ 1)
                          (("2"
                            (case "(Θ!1 o Γ!1) ^^ (0, length(map(σ!1))) = Θ!1")
                            (("1" (rewrite -1) (("1" (assert) nil nil))
                              nil)
                             ("2" (rewrite -8 :dir rl)
                              (("2"
                                (hide-all-but 1)
                                (("2"
                                  (grind-with-ext)
                                  (("2"
                                    (typepred x!1)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand expandable?)
                (("2" (expand ++ 1)
                  (("2" (expand compatible? -7)
                    (("2"
                      (case "(Θ!1 o Γ!1) ^^ (0, length(map(σ!1))) = Θ!1")
                      (("1" (rewrite -1) (("1" (assert) nil nil)) nil)
                       ("2" (flatten)
                        (("2" (rewrite -6 :dir rl)
                          (("2" (hide-all-but 1)
                            (("2" (grind-with-ext)
                              (("2"
                                (typepred x!1)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (hide 2)
                (("3" (hide -3)
                  (("3" (expand expandable?)
                    (("3" (expand sexpr? -3) (("3" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (expand scontext? -1) (("2" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((++ const-decl "finseq[(scontext?)]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (same type-eq-decl nil language nil)
    (externalize const-decl "same(U)" delta nil)
    (interp? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (interp adt-constructor-decl "[[(sexpr?), (ideep?)] -> (interp?)]"
            language nil)
    (FALSE const-decl "bool" booleans nil)
    (Γ!1 skolem-const-decl "finseq[(scontext?)]" delta nil)
    (Θ!1 skolem-const-decl "finseq[(scontext?)]" delta nil)
    (σ!1 skolem-const-decl "(ideep?)" delta nil)
    (compatible? const-decl "bool" interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (epsilon const-decl "T" epsilons nil)
    (TRUE const-decl "bool" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (O const-decl "finseq" finite_sequences nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC16 0
  (expand_TCC16-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (flatten)
        (("" (assert)
          (("" (split 2)
            (("1" (flatten) nil nil) ("2" (flatten) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC17 0
  (expand_TCC17-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -5)
      (("" (assert)
        (("" (expand (sexpr? scontext?) 2) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC18 0
  (expand_TCC18-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -3)
      (("" (assert)
        (("" (expand scontext? 1) (("" (flatten) nil nil)) nil)) nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (expand_TCC19 0
  (expand_TCC19-1 nil 3584723429
   ("" (skosimp* :preds? t) (("" (assert) nil nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (expand_TCC20 0
  (expand_TCC20-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (expand expandable?)
        (("" (assert)
          (("" (rewrite -3)
            (("" (assert)
              (("" (typepred "Θ!1`seq(pos!1)")
                (("" (expand scontext? -1) (("" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (expand_TCC21 0
  (expand_TCC21-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -3)
      (("" (assert)
        (("" (typepred sum)
          (("" (inst?) (("" (inst?) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (<= const-decl "bool" reals nil)
    (sum def-decl "{n: nat | FORALL (x: below[len]): f(x) <= n}"
     language nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (expand_TCC22 0
  (expand_TCC22-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (assert)
        (("" (typepred "Θ!1`seq(0)")
          (("" (expand scontext? -1)
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC23 0
  (expand_TCC23-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?) (("" (propax) nil nil)) nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC24 0
  (expand_TCC24-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -4) (("" (rewrite size_extract) nil nil)) nil)) nil)
   ((size_extract formula-decl nil language nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC25 0
  (expand_TCC25-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -4)
      (("" (assert)
        (("" (expand scontext? 2)
          (("" (flatten)
            (("" (expand sexpr? 2) (("" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((k const-decl "finseq[(scontext?)]" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC26 0
  (expand_TCC26-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -4)
      (("" (assert)
        (("" (expand scontext? 3) (("" (flatten) nil nil)) nil)) nil))
      nil))
    nil)
   ((k const-decl "finseq[(scontext?)]" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC27 0
  (expand_TCC27-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand scontext? 1) (("" (propax) nil nil)) nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC28 0
  (expand_TCC28-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (assert)
        (("" (expand sexpr? -8)
          (("" (assert) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((k const-decl "finseq[(scontext?)]" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC29 0
  (expand_TCC29-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -9) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC30 0
  (expand_TCC30-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (expand (sexpr? scontext?) 1) (("" (propax) nil nil)) nil))
      nil))
    nil)
   ((k const-decl "finseq[(scontext?)]" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC31 0
  (expand_TCC31-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2)
        (("" (assert) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC32 0
  (expand_TCC32-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -4) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC33 0
  (expand_TCC33-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand scontext? 1) (("" (propax) nil nil)) nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC34 0
  (expand_TCC34-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -9)
      (("" (assert)
        (("" (expand expandable?)
          (("" (expand sexpr? -8)
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC35 0
  (expand_TCC35-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -9) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC36 0
  (expand_TCC36-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -9)
      (("" (assert)
        (("" (expand (sexpr? scontext?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((k const-decl "finseq[(scontext?)]" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC37 0
  (expand_TCC37-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2)
        (("" (assert) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC38 0
  (expand_TCC38-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -4) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC39 0
  (expand_TCC39-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand scontext? 1) (("" (propax) nil nil)) nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC40 0
  (expand_TCC40-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -8) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC41 0
  (expand_TCC41-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -9) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC42 0
  (expand_TCC42-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -9)
      (("" (assert)
        (("" (expand (sexpr? scontext?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((k const-decl "finseq[(scontext?)]" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC43 0
  (expand_TCC43-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC44 0
  (expand_TCC44-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (below type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (Γ!1 skolem-const-decl "finseq[(scontext?)]" delta nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (U!1 skolem-const-decl "(expandable?(Γ!1))" delta nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC45 0
  (expand_TCC45-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC46 0
  (expand_TCC46-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -3) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (size def-decl "posnat" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (Γ!1 skolem-const-decl "finseq[(scontext?)]" delta nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (U!1 skolem-const-decl "(expandable?(Γ!1))" delta nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC47 0
  (expand_TCC47-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -3) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC48 0
  (expand_TCC48-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -4) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC49 0
  (expand_TCC49-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -5)
      (("" (assert)
        (("" (expand (sexpr? scontext?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC50 0
  (expand_TCC50-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand scontext? 1) (("" (propax) nil nil)) nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC51 0
  (expand_TCC51-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -8) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC52 0
  (expand_TCC52-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -9) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC53 0
  (expand_TCC53-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -9)
      (("" (assert)
        (("" (expand (sexpr? scontext?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((k const-decl "finseq[(scontext?)]" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC54 0
  (expand_TCC54-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC55 0
  (expand_TCC55-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -4) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC56 0
  (expand_TCC56-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC57 0
  (expand_TCC57-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -4) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC58 0
  (expand_TCC58-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -3) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC59 0
  (expand_TCC59-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -4) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC60 0
  (expand_TCC60-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -5)
      (("" (assert)
        (("" (expand (sexpr? scontext?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC61 0
  (expand_TCC61-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC62 0
  (expand_TCC62-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -3) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC63 0
  (expand_TCC63-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -4)
      (("" (assert)
        (("" (expand (sexpr? scontext?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC64 0
  (expand_TCC64-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC65 0
  (expand_TCC65-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -3) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC66 0
  (expand_TCC66-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -4)
      (("" (assert)
        (("" (expand (sexpr? scontext?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC67 0
  (expand_TCC67-1 nil 3584723429
   ("" (skosimp* :preds? t) (("" (grind) nil nil)) nil)
   ((compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (expand_TCC68 0
  (expand_TCC68-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (rewrite -2)
      (("" (assert)
        (("" (expand (sexpr? scontext?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (expand_TCC69 0
  (expand_TCC69-1 nil 3584723429
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC70 0
  (expand_TCC70-1 nil 3584900727
   ("" (skosimp* :preds? t)
    (("" (rewrite -3) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC71 0
  (expand_TCC71-1 nil 3584900727
   ("" (skosimp* :preds? t)
    (("" (rewrite -4)
      (("" (assert)
        (("" (expand (sexpr? scontext?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC72 0
  (expand_TCC72-1 nil 3584900727
   ("" (skosimp* :preds? t) (("" (grind) nil nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible0? const-decl "bool" interp nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC73 0
  (expand_TCC73-1 nil 3584900727
   ("" (skosimp* :preds? t) (("" (grind) nil nil)) nil)
   ((int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible0? const-decl "bool" interp nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC74 0
  (expand_TCC74-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC75 0
  (expand_TCC75-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -3) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC76 0
  (expand_TCC76-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -4)
      (("" (assert)
        (("" (expand (sexpr? scontext?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC77 0
  (expand_TCC77-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -3)
      (("" (assert)
        (("" (expand (sexpr? scontext?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (expand_TCC78 0
  (expand_TCC78-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (assert)
        (("" (flatten)
          (("" (assert)
            (("" (split 2)
              (("1" (expand (rest irest))
                (("1" (assert)
                  (("1" (expand ^^ 1)
                    (("1" (assert)
                      (("1" (lift-if)
                        (("1" (split 1)
                          (("1" (flatten) (("1" (grind) nil nil)) nil)
                           ("2" (flatten)
                            (("2" (expand min)
                              (("2"
                                (assert)
                                (("2"
                                  (lift-if)
                                  (("2"
                                    (split 3)
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (assert)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand compatible?)
                (("2" (split 1)
                  (("1" (flatten)
                    (("1" (expand (rest irest))
                      (("1" (expand ^^ 1)
                        (("1" (lift-if) (("1" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (skosimp* :preds? t)
                    (("2" (lift-if)
                      (("2" (split 1)
                        (("1" (propax) nil nil)
                         ("2" (flatten)
                          (("2" (split 2)
                            (("1" (flatten)
                              (("1"
                                (assert)
                                (("1"
                                  (inst - "x!1 + 1")
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (expand ^^)
                                    (("2"
                                      (expand (rest irest))
                                      (("2"
                                        (expand ^^)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (inst - "x!1 + 1")
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (compatible? const-decl "bool" interp nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (rest const-decl "finseq[(scontext?)]" language nil)
    (irest const-decl "finseq[(sinterp?)]" language nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (U!1 skolem-const-decl "(expandable?(Γ!1))" delta nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (x!1 skolem-const-decl
     "below(length(rest(Γ!1, 0) ^^ (0, length(irest(σ!1, 0)))))" delta
     nil)
    (σ!1 skolem-const-decl "finseq[(sinterp?)]" delta nil)
    (Γ!1 skolem-const-decl "finseq[(scontext?)]" delta nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (below type-eq-decl nil naturalnumbers nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (expand_TCC79 0
  (expand_TCC79-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -2) (("" (rewrite size_irest) nil nil)) nil)) nil)
   ((size_irest formula-decl nil language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (expand_TCC80 0
  (expand_TCC80-1 nil 3584903051
   ("" (skosimp* :preds? t) (("" (assert) (("" (grind) nil nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (irest const-decl "finseq[(sinterp?)]" language nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (rest const-decl "finseq[(scontext?)]" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC81 0
  (expand_TCC81-1 nil 3584903051
   ("" (skosimp* :preds? t) (("" (grind) nil nil)) nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible0? const-decl "bool" interp nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil)
    (rest const-decl "finseq[(scontext?)]" language nil)
    (irest const-decl "finseq[(sinterp?)]" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC82 0
  (expand_TCC82-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (assert)
        (("" (flatten)
          (("" (split 2)
            (("1" (flatten) (("1" (grind) nil nil)) nil)
             ("2" (flatten)
              (("2" (expand compatible? -3)
                (("2" (flatten)
                  (("2" (inst - 0)
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (compatible? const-decl "bool" interp nil)
    (irest const-decl "finseq[(sinterp?)]" language nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (U!1 skolem-const-decl "(expandable?(Γ!1))" delta nil)
    (Γ!1 skolem-const-decl "finseq[(scontext?)]" delta nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (rest const-decl "finseq[(scontext?)]" language nil)
    (O const-decl "finseq" finite_sequences nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (concat_assoc formula-decl nil language nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC83 0
  (expand_TCC83-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -3)
      (("" (assert)
        (("" (invoke (typepred "%1") (~ + "sum(%,%)"))
          (("" (inst?) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((sum def-decl "{n: nat | FORALL (x: below[len]): f(x) <= n}"
     language nil)
    (<= const-decl "bool" reals nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC84 0
  (expand_TCC84-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (inst - ths?!1)
        ((""
          (inst -
           "(rest(Γ!1, length(Δ!1)) ++ (Δ!1 ++ (# length := 1, seq := LAMBDA (x: below[1]): Γ!1`seq(0) #)), σ!1`seq(0))")
          (("1" (assert)
            (("1" (typepred "σ!1`seq(0)")
              (("1" (expand sinterp? -1)
                (("1" (expand sexpr? -3 1)
                  (("1" (flatten)
                    (("1" (assert)
                      (("1" (delete -3)
                        (("1" (expand expandable? -2)
                          (("1" (flatten)
                            (("1" (expand compatible? -3)
                              (("1"
                                (flatten)
                                (("1"
                                  (inst - 0)
                                  (("1" (grind) nil nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil) ("3" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (concat_assoc formula-decl nil language nil)
    (Γ!1 skolem-const-decl "finseq[(scontext?)]" delta nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (rest const-decl "finseq[(scontext?)]" language nil)
    (Δ!1 skolem-const-decl "finseq[(scontext?)]" delta nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (σ!1 skolem-const-decl "finseq[(sinterp?)]" delta nil)
    (compatible? const-decl "bool" interp nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (U!1 skolem-const-decl "(expandable?(Γ!1))" delta nil)
    (below type-eq-decl nil naturalnumbers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (O const-decl "finseq" finite_sequences nil)
    (irest const-decl "finseq[(sinterp?)]" language nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (compatible0? const-decl "bool" interp nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC85 0
  (expand_TCC85-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -3)
      (("" (assert)
        (("" (expand (sexpr? scontext?) 2) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((concat_assoc formula-decl nil language nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC86 0
  (expand_TCC86-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -3) (("" (assert) nil nil)) nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC87 0
  (expand_TCC87-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -2)
      (("" (assert)
        (("" (expand (sexpr? scontext?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (expand_TCC88 0
  (expand_TCC88-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -2)
      (("" (expand (sexpr? scontext?) 1) (("" (propax) nil nil)) nil))
      nil))
    nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (expand_TCC89 0
  (expand_TCC89-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (rewrite -3)
        (("" (assert)
          (("" (expand sexpr? -2) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC90 0
  (expand_TCC90-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -3) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC91 0
  (expand_TCC91-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -4)
      (("" (assert)
        (("" (expand (sexpr? scontext?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC92 0
  (expand_TCC92-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC93 0
  (expand_TCC93-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -3) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC94 0
  (expand_TCC94-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -4)
      (("" (assert)
        (("" (expand (sexpr? scontext?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC95 0
  (expand_TCC95-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC96 0
  (expand_TCC96-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -3) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC97 0
  (expand_TCC97-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (rewrite -4)
        (("" (expand (sexpr? scontext?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC98 0
  (expand_TCC98-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC99 0
  (expand_TCC99-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -4) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC100 0
  (expand_TCC100-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -3) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC101 0
  (expand_TCC101-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -4) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC102 0
  (expand_TCC102-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (rewrite -5)
      (("" (assert)
        (("" (expand (sexpr? scontext?) 1) (("" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_TCC103 0
  (expand_TCC103-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (expand sexpr? -2) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC104 0
  (expand_TCC104-1 nil 3584908005
   ("" (skosimp* :preds? t)
    (("" (rewrite -3) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (expand_TCC105 0
  (expand_TCC105-1 nil 3585402805
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (expand (sexpr? scontext?) 1) (("" (propax) nil nil)) nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil))
   nil))
 (expand_preserves_theory_TCC1 0
  (expand_preserves_theory_TCC1-1 nil 3585401004 ("" (grind) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible0? const-decl "bool" interp nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (expand_preserves_theory 0
  (expand_preserves_theory-1 nil 3585401978
   ("" (measure-induct "length(Δ)" "Δ")
    (("1" (skosimp* :preds? t)
      (("1" (case "length(x!1) = 0")
        (("1" (assert)
          (("1" (expand expand 1) (("1" (propax) nil nil)) nil)) nil)
         ("2" (expand expand 2)
          (("2" (lift-if) (("2" (assert) nil nil)) nil)) nil))
        nil))
      nil)
     ("2" (skosimp* :preds? t)
      (("2" (expand expandable?) (("2" (propax) nil nil)) nil)) nil))
    nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (expand def-decl "{V |
         (sexpr?(U) IMPLIES sexpr?(V)) AND
          (scontext?(U) IMPLIES scontext?(V)) AND
           (ideep?(U) IMPLIES theory?(V)) AND
            (ikeep?(U) OR itype?(U) OR iterm?(U) IMPLIES scontext?(V))}"
            delta nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (theory_ adt-constructor-decl "[finseq[(scontext?)] -> (theory?)]"
     language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (scontext? adt-def-decl "boolean" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (syntaxic type-decl nil language nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (expand_size_TCC1 0
  (expand_size_TCC1-1 nil 3584978800
   ("" (skosimp* :preds? t)
    (("" (use expand_preserves_theory) nil nil)) nil)
   ((finseq type-eq-decl nil finite_sequences nil)
    (scontext? adt-def-decl "boolean" language nil)
    (syntaxic type-decl nil language nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (expand_preserves_theory formula-decl nil delta nil))
   nil))
 (expand_size 0
  (expand_size-1 nil 3584979037
   ("" (measure-induct+ "length(Δ)" "Δ")
    (("1" (skosimp* :preds? t)
      (("1" (expand expand 1)
        (("1" (lift-if)
          (("1" (split 1)
            (("1" (propax) nil nil)
             ("2" (flatten)
              (("2" (split 2)
                (("1" (flatten)
                  (("1" (assert)
                    (("1" (expand (++ rest) 1)
                      (("1" (assert)
                        (("1" (inst?)
                          (("1" (split -2)
                            (("1" (rewrite -1) (("1" (grind) nil nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil)
                           ("2" (grind) nil nil)
                           ("3" (hide 2)
                            (("3" (skosimp* :preds? t)
                              (("3"
                                (expand expandable?)
                                (("3"
                                  (typepred "x!1`seq(length(x!1) - 1)")
                                  (("3"
                                    (assert)
                                    (("3"
                                      (expand scontext? -1)
                                      (("3"
                                        (assert)
                                        (("3" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (use expand_preserves_theory)
                    (("1" (assert) nil nil) ("2" (assert) nil nil)
                     ("3" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (use expand_preserves_theory) nil nil)
     ("3" (expand expandable?) (("3" (propax) nil nil)) nil)
     ("4" (use expand_preserves_theory) nil nil)
     ("5" (expand expandable?) (("5" (propax) nil nil)) nil))
    nil)
   ((expand_preserves_theory formula-decl nil delta nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Γ!1 skolem-const-decl "finseq[(scontext?)]" delta nil)
    (x!1 skolem-const-decl "finseq[(scontext?)]" delta nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (O const-decl "finseq" finite_sequences nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (expand def-decl "{V |
         (sexpr?(U) IMPLIES sexpr?(V)) AND
          (scontext?(U) IMPLIES scontext?(V)) AND
           (ideep?(U) IMPLIES theory?(V)) AND
            (ikeep?(U) OR itype?(U) OR iterm?(U) IMPLIES scontext?(V))}"
            delta nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (theory_ adt-constructor-decl "[finseq[(scontext?)] -> (theory?)]"
     language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (scontext? adt-def-decl "boolean" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (syntaxic type-decl nil language nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (expand_size_ideep 0
  (expand_size_ideep-1 nil 3585405841
   ("" (measure-induct+ "length(σ)" "σ")
    (("" (skosimp* :preds? t)
      (("" (expand expand 1)
        (("" (lift-if)
          (("" (split 1)
            (("1" (grind) nil nil)
             ("2" (flatten)
              (("2" (split 2)
                (("1" (flatten)
                  (("1" (expand ++ 1 1)
                    (("1" (expand o)
                      (("1" (inst?)
                        (("1" (split -2)
                          (("1" (rewrite -1)
                            (("1" (expand k 1) (("1" (grind) nil nil))
                              nil))
                            nil)
                           ("2" (hide 2)
                            (("2" (expand expandable?)
                              (("2"
                                (flatten)
                                (("2"
                                  (split 1)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (expand compatible?)
                                    (("2"
                                      (flatten)
                                      (("2"
                                        (split 1)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (skosimp* :preds? t)
                                          (("2"
                                            (inst - "x!2 + 1")
                                            (("1" (grind) nil nil)
                                             ("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (hide 2) (("3" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (invoke (typepred "%1") (~ + "theory?(%1)"))
                    nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((O const-decl "finseq" finite_sequences nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (Γ!1 skolem-const-decl "finseq[(scontext?)]" delta nil)
    (> const-decl "bool" reals nil)
    (x!1 skolem-const-decl "finseq[(sinterp?)]" delta nil)
    (below type-eq-decl nil naturalnumbers nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (compatible? const-decl "bool" interp nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (x!2 skolem-const-decl
     "below(length(rest(Γ!1, 0) ^^ (0, length(irest(x!1, 0)))))" delta
     nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (rest const-decl "finseq[(scontext?)]" language nil)
    (irest const-decl "finseq[(sinterp?)]" language nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (expand def-decl "{V |
         (sexpr?(U) IMPLIES sexpr?(V)) AND
          (scontext?(U) IMPLIES scontext?(V)) AND
           (ideep?(U) IMPLIES theory?(V)) AND
            (ikeep?(U) OR itype?(U) OR iterm?(U) IMPLIES scontext?(V))}"
            delta nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ideep adt-constructor-decl "[finseq[(sinterp?)] -> (ideep?)]"
     language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (scontext? adt-def-decl "boolean" language nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (syntaxic type-decl nil language nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (expand_equiv 0
  (expand_equiv-2 nil 3585429879
   ("" (measure-induct+ "length(Δ)" "Δ")
    (("1" (skosimp* :preds? t)
      (("1" (expand expand 1)
        (("1" (lift-if)
          (("1" (split 1)
            (("1" (grind) nil nil)
             ("2" (flatten)
              (("2" (split 2)
                (("1" (flatten)
                  (("1" (assert)
                    (("1" (expand ≡)
                      (("1" (split 1)
                        (("1" (expand ++ 1 1)
                          (("1" (expand o)
                            (("1" (lemma expand_size)
                              (("1"
                                (inst
                                 -
                                 ths?!1
                                 "Γ!1 ++ (# length := 1, seq := LAMBDA (x: below[1]): expand(ths?!1)(Γ!1, x!1`seq(length(x!1) - 1)) #)"
                                 "(x!1 ^^ (0, length(x!1) - 1))")
                                (("1"
                                  (rewrite -1)
                                  (("1"
                                    (expand ^^ 1)
                                    (("1"
                                      (lift-if)
                                      (("1"
                                        (split 1)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (flatten)
                                          (("2"
                                            (assert)
                                            (("2"
                                              (expand min)
                                              (("2" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (typepred "x!1`seq(length(x!1) - 1)")
                                  (("2"
                                    (hide-all-but (1 -1))
                                    (("2"
                                      (expand scontext? -1)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skosimp* :preds? t)
                          (("2" (case "x!2 = length(x!1) - 1")
                            (("1" (assert)
                              (("1"
                                (expand ++ 1)
                                (("1"
                                  (expand o 1)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (case
                                       "decls(expand(ths?!1)
                                        ((# length := 1 + Γ!1`length,
                                            seq := LAMBDA (n: below[1 + Γ!1`length]): IF n < 1 THEN expand(ths?!1)(Γ!1, x!1`seq(length(x!1) - 1)) ELSE Γ!1`seq(n - 1) ENDIF #),
                                         theory_(x!1 ^^ (0, length(x!1) - 1))))`length = x!2")
                                      (("1"
                                        (rewrite -1)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (typepred
                                             "x!1`seq(length(x!1) - 1)")
                                            (("1"
                                              (expand scontext? -1)
                                              (("1"
                                                (bddsimp -1)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (expand expand 1)
                                                    (("1"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (assert)
                                                  (("2"
                                                    (expand expand 1)
                                                    (("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("3"
                                                  (assert)
                                                  (("3"
                                                    (expand expand 1)
                                                    (("3"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("4"
                                                  (assert)
                                                  (("4"
                                                    (expand expand 1)
                                                    (("4"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("5"
                                                  (assert)
                                                  (("5"
                                                    (expand expand 1)
                                                    (("5"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("6"
                                                  (assert)
                                                  (("6"
                                                    (expand expand 1)
                                                    (("6"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("7"
                                                  (assert)
                                                  (("7"
                                                    (expand expand 1)
                                                    (("7"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (hide 2)
                                        (("2"
                                          (use
                                           expand_size
                                           :polarity?
                                           t)
                                          (("2"
                                            (inst
                                             -
                                             ths?!1
                                             "(# length := 1 + Γ!1`length, seq := LAMBDA (n: below[1 + Γ!1`length]): IF n < 1 THEN expand(ths?!1)(Γ!1, x!1`seq(length(x!1) - 1)) ELSE Γ!1`seq(n - 1) ENDIF #)"
                                             "x!1 ^^ (0, length(x!1) - 1)")
                                            (("1"
                                              (rewrite -1)
                                              (("1"
                                                (expand ^^ 1)
                                                (("1"
                                                  (lift-if)
                                                  (("1"
                                                    (split 1)
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (flatten)
                                                      (("2"
                                                        (expand min)
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (assert)
                                              (("2"
                                                (skosimp* :preds? t)
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil)
                                             ("3"
                                              (skosimp* :preds? t)
                                              (("3"
                                                (typepred
                                                 "x!1`seq(length(x!1) - 1)")
                                                (("3"
                                                  (expand scontext? -1)
                                                  (("3"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("3"
                                        (hide 2)
                                        (("3"
                                          (use
                                           expand_preserves_theory
                                           :polarity?
                                           t)
                                          (("1"
                                            (skosimp* :preds? t)
                                            (("1" (assert) nil nil))
                                            nil)
                                           ("2"
                                            (skosimp* :preds? t)
                                            (("2"
                                              (typepred
                                               "x!1`seq(length(x!1) - 1)")
                                              (("2"
                                                (expand scontext? -1)
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("4"
                                        (hide 2)
                                        (("4" (grind) nil nil))
                                        nil)
                                       ("5"
                                        (hide 2)
                                        (("5"
                                          (skosimp* :preds? t)
                                          (("5" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("6"
                                        (hide 2)
                                        (("6"
                                          (skosimp* :preds? t)
                                          (("6"
                                            (typepred
                                             "x!1`seq(length(x!1) - 1)")
                                            (("6"
                                              (expand scontext? -1)
                                              (("6" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2"
                              (inst - "x!1 ^^ (0, length(x!1) - 1)")
                              (("2"
                                (inst
                                 -
                                 ths?!1
                                 "Γ!1 ++ (# length := 1, seq := LAMBDA (x: below[1]): expand(ths?!1)(Γ!1, x!1`seq(length(x!1) - 1)) #)")
                                (("1"
                                  (split -3)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (inst - x!2)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (expand ++ 2)
                                            (("1"
                                              (expand o 2)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (case
                                                   "x!2 <
                           decls(expand(ths?!1)
                                       ((# length := 1 + Γ!1`length,
                                           seq := LAMBDA (n: below[1 + Γ!1`length]): IF n < 1 THEN expand(ths?!1)(Γ!1, x!1`seq(length(x!1) - 1)) ELSE Γ!1`seq(n - 1) ENDIF #),
                                        theory_(x!1 ^^ (0, length(x!1) - 1))))`length")
                                                  (("1"
                                                    (rewrite -1)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand ++ -)
                                                        (("1"
                                                          (expand o -)
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (case
                                                               "(x!1 ^^ (0, length(x!1) - 1))`seq(x!2) = x!1`seq(x!2)")
                                                              (("1"
                                                                (rewrite
                                                                 -1)
                                                                (("1"
                                                                  (split
                                                                   2)
                                                                  (("1"
                                                                    (propax)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (propax)
                                                                    nil
                                                                    nil)
                                                                   ("3"
                                                                    (propax)
                                                                    nil
                                                                    nil)
                                                                   ("4"
                                                                    (propax)
                                                                    nil
                                                                    nil)
                                                                   ("5"
                                                                    (propax)
                                                                    nil
                                                                    nil)
                                                                   ("6"
                                                                    (propax)
                                                                    nil
                                                                    nil)
                                                                   ("7"
                                                                    (propax)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("2"
                                                                (hide
                                                                 3)
                                                                (("2"
                                                                  (expand
                                                                   ^^
                                                                   1)
                                                                  (("2"
                                                                    (lift-if)
                                                                    (("2"
                                                                      (split
                                                                       1)
                                                                      (("1"
                                                                        (grind)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (propax)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("3"
                                                                (hide
                                                                 3)
                                                                (("3"
                                                                  (rewrite
                                                                   -1)
                                                                  (("3"
                                                                    (expand
                                                                     ^^
                                                                     -8)
                                                                    (("3"
                                                                      (lift-if)
                                                                      (("3"
                                                                        (split
                                                                         -8)
                                                                        (("1"
                                                                          (grind)
                                                                          nil
                                                                          nil)
                                                                         ("2"
                                                                          (flatten)
                                                                          (("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil)
                                                               ("4"
                                                                (hide
                                                                 3)
                                                                (("4"
                                                                  (rewrite
                                                                   -1)
                                                                  (("4"
                                                                    (assert)
                                                                    (("4"
                                                                      (expand
                                                                       ^^
                                                                       1)
                                                                      (("4"
                                                                        (expand
                                                                         ^^
                                                                         -8)
                                                                        (("4"
                                                                          (assert)
                                                                          (("4"
                                                                            (lift-if)
                                                                            (("4"
                                                                              (split
                                                                               1)
                                                                              (("1"
                                                                                (grind)
                                                                                nil
                                                                                nil)
                                                                               ("2"
                                                                                (flatten)
                                                                                (("2"
                                                                                  (assert)
                                                                                  (("2"
                                                                                    (expand
                                                                                     min)
                                                                                    (("2"
                                                                                      (assert)
                                                                                      (("2"
                                                                                        (hide
                                                                                         -1
                                                                                         -2
                                                                                         -3
                                                                                         -4
                                                                                         -5
                                                                                         -6
                                                                                         -7
                                                                                         -9)
                                                                                        (("2"
                                                                                          (grind)
                                                                                          (("2"
                                                                                            (case
                                                                                             "x!2 >= 0")
                                                                                            (("1"
                                                                                              (grind)
                                                                                              (("1"
                                                                                                (case
                                                                                                 "x!2 <= length(x!1) - 1")
                                                                                                (("1"
                                                                                                  (assert)
                                                                                                  (("1"
                                                                                                    (grind)
                                                                                                    (("1"
                                                                                                      (expand
                                                                                                       <=
                                                                                                       -1)
                                                                                                      (("1"
                                                                                                        (propax)
                                                                                                        nil
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil)
                                                                                                 ("2"
                                                                                                  (grind)
                                                                                                  (("2"
                                                                                                    (case
                                                                                                     "FORALL (a, b: nat): a < b + 1 IMPLIES a <= b")
                                                                                                    (("1"
                                                                                                      (inst
                                                                                                       -
                                                                                                       x!2
                                                                                                       "length(x!1) - 1")
                                                                                                      (("1"
                                                                                                        (split
                                                                                                         -1)
                                                                                                        (("1"
                                                                                                          (propax)
                                                                                                          nil
                                                                                                          nil)
                                                                                                         ("2"
                                                                                                          (assert)
                                                                                                          nil
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil)
                                                                                                     ("2"
                                                                                                      (hide-all-but
                                                                                                       1)
                                                                                                      (("2"
                                                                                                        (skosimp*
                                                                                                         :preds?
                                                                                                         t)
                                                                                                        (("2"
                                                                                                          (assert)
                                                                                                          nil
                                                                                                          nil))
                                                                                                        nil))
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil)
                                                                                             ("2"
                                                                                              (assert)
                                                                                              nil
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (hide 3)
                                                    (("2"
                                                      (lemma
                                                       expand_size)
                                                      (("2"
                                                        (inst
                                                         -
                                                         ths?!1
                                                         "(# length := 1 + Γ!1`length, seq := LAMBDA (n: below[1 + Γ!1`length]): IF n < 1 THEN expand(ths?!1)(Γ!1, x!1`seq(length(x!1) - 1)) ELSE Γ!1`seq(n - 1) ENDIF #)"
                                                         "x!1 ^^ (0, length(x!1) - 1)")
                                                        (("1"
                                                          (expand
                                                           ++
                                                           -10
                                                           1)
                                                          (("1"
                                                            (expand
                                                             o
                                                             -10)
                                                            (("1"
                                                              (expand
                                                               ++
                                                               -10
                                                               1)
                                                              (("1"
                                                                (expand
                                                                 o
                                                                 -10)
                                                                (("1"
                                                                  (rewrite
                                                                   -1)
                                                                  (("1"
                                                                    (expand
                                                                     ^^
                                                                     1)
                                                                    (("1"
                                                                      (expand
                                                                       ^^
                                                                       -9)
                                                                      (("1"
                                                                        (lift-if)
                                                                        (("1"
                                                                          (split
                                                                           1)
                                                                          (("1"
                                                                            (grind)
                                                                            nil
                                                                            nil)
                                                                           ("2"
                                                                            (flatten)
                                                                            (("2"
                                                                              (assert)
                                                                              (("2"
                                                                                (expand
                                                                                 min)
                                                                                (("2"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (skosimp*
                                                           :preds?
                                                           t)
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (skosimp*
                                                           :preds?
                                                           t)
                                                          (("3"
                                                            (typepred
                                                             "x!1`seq(length(x!1) - 1)")
                                                            (("3"
                                                              (expand
                                                               scontext?
                                                               -1)
                                                              (("3"
                                                                (hide
                                                                 2
                                                                 -5
                                                                 -6
                                                                 -7
                                                                 -8
                                                                 -9
                                                                 -10
                                                                 -11)
                                                                (("3"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("3"
                                                    (hide 3)
                                                    (("3"
                                                      (use
                                                       expand_preserves_theory)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (expand
                                                           ++
                                                           -1
                                                           1)
                                                          (("1"
                                                            (expand
                                                             o
                                                             -1)
                                                            (("1"
                                                              (propax)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (skosimp*
                                                         :preds?
                                                         t)
                                                        (("2"
                                                          (typepred
                                                           "x!1`seq(length(x!1) - 1)")
                                                          (("2"
                                                            (hide
                                                             2
                                                             -5
                                                             -6
                                                             -7
                                                             -8
                                                             -9
                                                             -10)
                                                            (("2"
                                                              (expand
                                                               scontext?
                                                               -1)
                                                              (("2"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("4"
                                                    (hide 3)
                                                    (("4"
                                                      (hide
                                                       -2
                                                       -3
                                                       -4
                                                       -5
                                                       -6
                                                       -7
                                                       -8)
                                                      (("4"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("5"
                                                    (hide 3)
                                                    (("5"
                                                      (skosimp*
                                                       :preds?
                                                       t)
                                                      (("5"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("6"
                                                    (hide 3)
                                                    (("6"
                                                      (skosimp*
                                                       :preds?
                                                       t)
                                                      (("6"
                                                        (typepred
                                                         "x!1`seq(length(x!1) - 1)")
                                                        (("6"
                                                          (hide
                                                           -4
                                                           -5
                                                           -6
                                                           -7
                                                           -8
                                                           -9
                                                           -10
                                                           -11)
                                                          (("6"
                                                            (expand
                                                             scontext?
                                                             -1)
                                                            (("6"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (hide 3)
                                          (("2"
                                            (expand ++ -2 1)
                                            (("2"
                                              (expand o -2)
                                              (("2"
                                                (use expand_size)
                                                (("1"
                                                  (rewrite -1)
                                                  (("1"
                                                    (expand ^^ -1)
                                                    (("1"
                                                      (expand ^^ 1)
                                                      (("1"
                                                        (lift-if)
                                                        (("1"
                                                          (split 1)
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (flatten)
                                                            (("2"
                                                              (assert)
                                                              (("2"
                                                                (expand
                                                                 min)
                                                                (("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (skosimp* :preds? t)
                                                  (("2"
                                                    (typepred
                                                     "x!1`seq(length(x!1) - 1)")
                                                    (("2"
                                                      (expand
                                                       scontext?
                                                       -1)
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (hide 3)
                                    (("2"
                                      (expand ^^ 1)
                                      (("2"
                                        (lift-if)
                                        (("2"
                                          (split 1)
                                          (("1" (grind) nil nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (expand min)
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (hide 3)
                                  (("2"
                                    (skosimp* :preds? t)
                                    (("2"
                                      (typepred
                                       "x!1`seq(length(x!1) - 1)")
                                      (("2"
                                        (expand scontext? -1)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (use expand_preserves_theory)
                    (("1" (assert) nil nil) ("2" (assert) nil nil)
                     ("3" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (use expand_preserves_theory) nil nil) ("3" (grind) nil nil)
     ("4" (use expand_preserves_theory) nil nil) ("5" (grind) nil nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<= const-decl "bool" reals nil)
    (x!2 skolem-const-decl "below
    [length
       ((# length := 1,
           seq
             := LAMBDA (x: below[1]):
                  expand(ths?!1)(Γ!1, x!1`seq(length(x!1) - 1)) #)
         ++
         decls(expand(ths?!1)
                     (Γ!1 ++
                       (# length := 1,
                          seq
                            := LAMBDA (x: below[1]):
                                 expand(ths?!1)
                                       (Γ!1, x!1`seq(length(x!1) - 1)) #),
                      theory_(x!1 ^^ (0, length(x!1) - 1)))))]" delta
     nil)
    (ths?!1 skolem-const-decl "bool" delta nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (expand_preserves_theory formula-decl nil delta nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (expand_size formula-decl nil delta nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (compatible0? const-decl "bool" interp nil)
    (compatible? const-decl "bool" interp nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (x!1 skolem-const-decl "finseq[(scontext?)]" delta nil)
    (Γ!1 skolem-const-decl "finseq[(scontext?)]" delta nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (O const-decl "finseq" finite_sequences nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (≡ const-decl "bool" language nil)
    (expand def-decl "{V |
         (sexpr?(U) IMPLIES sexpr?(V)) AND
          (scontext?(U) IMPLIES scontext?(V)) AND
           (ideep?(U) IMPLIES theory?(V)) AND
            (ikeep?(U) OR itype?(U) OR iterm?(U) IMPLIES scontext?(V))}"
            delta nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (theory_ adt-constructor-decl "[finseq[(scontext?)] -> (theory?)]"
     language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (scontext? adt-def-decl "boolean" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (syntaxic type-decl nil language nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   nil)
  (expand_equiv-1 nil 3585429654 ("" (postpone) nil nil) nil shostak))
 (expand_ctx_TCC1 0
  (expand_ctx_TCC1-1 nil 3584892495 ("" (subtype-tcc) nil nil)
   ((empty_seq const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (expand_ctx_TCC2 0
  (expand_ctx_TCC2-1 nil 3584892495
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (expand expand)
        (("" (lift-if)
          (("" (split 1)
            (("1" (flatten) (("1" (assert) nil nil)) nil)
             ("2" (flatten)
              (("2" (split 2)
                (("1" (flatten) (("1" (assert) nil nil)) nil)
                 ("2" (flatten) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (concat_empty formula-decl nil language nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (expand def-decl "{V |
         (sexpr?(U) IMPLIES sexpr?(V)) AND
          (scontext?(U) IMPLIES scontext?(V)) AND
           (ideep?(U) IMPLIES theory?(V)) AND
            (ikeep?(U) OR itype?(U) OR iterm?(U) IMPLIES scontext?(V))}"
            delta nil))
   nil))
 (expand_ctx_TCC3 0
  (expand_ctx_TCC3-1 nil 3584903051
   ("" (skosimp* :preds? t)
    (("" (lemma expand_equiv) (("" (inst?) nil nil)) nil)) nil)
   ((expand_equiv formula-decl nil delta nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (empty_seq const-decl "finseq" finite_sequences nil))
   nil)))

