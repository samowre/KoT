language: THEORY
BEGIN
  symbol: TYPE = nat
  syntaxic: DATATYPE WITH SUBTYPES name, pretype, preterm, precontext, precontext, preinterp
  BEGIN
    v(i: nat): v?: name
    dot(map: preinterp, i: nat, rest: name): dot?: name
  
    base(path: name): base?: pretype
    fun(dom: pretype, range: pretype): fun?: pretype
    prod(left: pretype, right: pretype): prod?: pretype
    subtype(supertype: pretype, pred: preterm): subtype?: pretype

    symbol(path: name): symbol?: preterm
    app(op: preterm, arg: preterm): preterm
    lam(type_: pretype, body: preterm): lam?: preterm
    pair(left: preterm, right: preterm): pair: preterm
    lproj(arg: preterm): lproj?: preterm
    rproj(arg: preterm): rproj?: preterm

    empty: empty?: precontext
    type_decl(rest: precontext): type_decl?: precontext
    type_var(rest: precontext): type_var?: precontext
    type_def(rest: precontext, def: pretype): type_def?: precontext
    const_decl(rest: precontext, type_: pretype): const_decl?: precontext
    const_var(rest: precontext, type_: pretype): const_var?: precontext
    const_def(rest: precontext, type_: pretype, def: preterm): const_def?: precontext
    theory_def(rest: precontext, def: precontext): theory_def?: precontext

    nil: nil?: preinterp
    ikeep(rest: preinterp): ikeep?: preinterp
    ideep(rest: preinterp, map: preinterp): ideep?: preinterp
    itype(rest: preinterp, def: pretype): itype?: preinterp
    iconst(rest: preinterp, def: preterm): iconst?: preinterp
    itheory(rest: preinterp, def: preinterp): itheory?: preinterp
  END syntaxic

  U, V: VAR syntaxic
  i: VAR nat

  length(U): RECURSIVE nat =
    CASES U OF
    , type_decl(Γ): 1 + length(Γ)
    , type_var(Γ): 1 + length(Γ)
    , type_def(Γ, T): 1 + length(Γ)
    , const_decl(Γ, T): 1 + length(Γ)
    , const_var(Γ, T): 1 + length(Γ)
    , const_def(Γ, T, a): 1 + length(Γ)
    , theory_def(Γ, Θ): 1 + length(Γ) + length(Θ)

    , ikeep(σ): 1 + length(σ)
    , ideep(σ, τ): 1 + length(σ) + length(τ)
    , itype(σ, T): 1 + length(σ)
    , iconst(σ, a): 1 + length(σ)
    , itheory(σ, Θ): 1 + length(σ) + length(Θ)

    ELSE 0
    ENDCASES
  MEASURE U BY <<

  nth(U, (i | i < length(U))): RECURSIVE syntaxic =
    IF i = 0 THEN U ELSE
    CASES U OF
      theory_def(Γ, Θ):
        IF i < length(Θ) THEN nth(Θ, i)
	ELSE nth(Γ, i - length(Θ)) ENDIF
    , ideep(σ, τ):
        IF i < length(τ) THEN nth(τ, i)
	ELSE nth(σ, i - length(τ)) ENDIF
    , itheory(σ, Θ):
        IF i < length(Θ) THEN nth(Θ, i)
	ELSE nth(σ, i - length(Θ)) ENDIF
    ELSE nth(rest(U), i - 1) ENDIF
  MEASURE i

  ;++(U, V): RECURSIVE syntaxic =
    CASES V OF
      type_decl(Γ): type_decl(U ++ Γ)
    , type_var(Γ): type_var(U ++ Γ)
    , type_def(Γ, T): type_def(U ++ Γ, T)
    , const_decl(Γ, T): const_decl(U ++ Γ, T)
    , const_var(Γ, T): const_var(U ++ Γ, T)
    , const_def(Γ, T, a): const_def(U ++ Γ, T, a)
    , theory_def(Γ, Θ): theory_def(U ++ Γ, Θ)

    , ikeep(σ): ikeep(U ++ σ)
    , ideep(σ, τ): ideep(U ++ σ, τ)
    , itype(σ, T): itype(U ++ σ, T)
    , iconst(σ, a): iconst(U ++ σ, a)
    , itheory(σ, Θ): itheory(U ++ σ, Θ)

    ELSE U
    ENDCASES
  MEASURE length(V)
  length_concat: THEOREM
    length(U ++ V) = length(U) + length(V)
  nth_concat: THEOREM i < length(U ++ V) IMPLIES
    nth(U ++ V, i) =
      IF i < length(V) THEN nth(V, i) ELSE nth(U, i - length(V)) ENDIF

  prekeyword: TYPE =
    { PRETYPE, PRETERM, PRECONTEXT, PREINTERP }
  k: VAR prekeyword

  semantic?(U, V, k): RECURSIVE bool =
    CASES V OF
      v(i): i < length(U) AND kind(U, i) = k
    , dot(σ, i, x):
        semantic?(U, σ, PREINTERP) AND i < length(U) AND
	semantic?(apply(U, i), x, k)
	
      base(x): k = PRETYPE AND semantic?(U, x, PRETYPE)
    , fun(A, B):
        k = PRETYPE AND semantic?(U, A, PRETYPE) AND
	semantic?(const_var(U, A), B, PRETYPE)
    , prod(A, B):
        k = PRETYPE AND semantic?(U, A, PRETYPE) AND
	semantic?(const_var(U, A), B, PRETYPE)
    , subtype(T, a):
        k = PRETYPE AND semantic?(U, T, PRETYPE) AND
	semantic?(const_var(U, T), a, PRETERM)

    , symbol(x): k = PRETERM AND semantic?(U, x, PRETERM)
    , app(f, a):
        k = PRETERM AND semantic?(U, f, PRETERM) AND semantic?(U, x, PRETERM)
    , lam(T, a):
        k = PRETERM AND semantic?(U, T, PRETYPE) AND
	semantic?(const_var(U, T), a, PRETERM)
    , lproj(a): k = PRETERM AND semantic?(U, a, PRETERM)
    , rproj(a): k = PRETERM AND semantic?(U, a, PRETERM)

    , empty: k = PRECONTEXT
    , type_decl(Γ): k = PRECONTEXT AND semantic?(U, Γ, PRECONTEXT)
    , type_ext(Γ): k = PRECONTEXT AND semantic?(U, Γ, PRECONTEXT)
    , type_def(Γ, T):
        k = PRECONTEXT AND semantic?(U, Γ, PRECONTEXT) AND
	semantic?(U ++ Γ, T, PRETYPE)
    , const_decl(Γ, T):
        k = PRECONTEXT AND semantic?(U, Γ, PRECONTEXT) AND
	semantic?(U ++ Γ, T, PRETYPE)
    , const_ext(Γ, T):
        k = PRECONTEXT AND semantic?(U, Γ, PRECONTEXT) AND
	semantic?(U ++ Γ, T, PRETYPE)
    , const_def(Γ, T, a):
        k = PRECONTEXT AND semantic?(U, Γ, PRECONTEXT) AND
	semantic?(U ++ Γ, T, PRETYPE) AND semantic?(U ++ Γ, T, PRETERM)
    , const_var(Γ, T):
        k = PRECONTEXT AND semantic?(U, Γ, PRECONTEXT) AND
	semantic?(U ++ Γ, T, PRETYPE)
    , theory_def(Γ, Θ):
        k = PRECONTEXT AND semantic?(U, Γ, PRECONTEXT) AND
	semantic?(U ++ Γ, Θ, PRECONTEXT)

    , nil: k = PREINTERP AND empty?(U)
    , ikeep(σ):
        k = PREINTERP AND NOT empty?(U) AND precontext(U) AND
	semantic?(rest(u), σ, PREINTERP)
    , ideep(σ, τ):
        k = PREINTERP AND theory_def?(U) AND
	semantic?(rest(U) ++ def(U), σ ++ τ, PREINTERP)
    , itype(σ, T):
        k = PREINTERP AND type_decl?(U) AND
	semantic?(rest(U), σ, PREINTERP) AND semantic?(rest(U), T, PRETYPE)
    , iconst(σ, a):
        k = PREINTERP AND const_decl?(U) AND
	semantic?(rest(U), σ, PREINTERP) AND semantic?(rest(U), a, PRETERM)
    , itheory(σ, Θ):
        k = PREINTERP AND theory_def?(U) AND
	semantic?(rest(U), σ, PREINTERP) AND
	semantic?(rest(U), Θ, PRECONTEXT)
    ENDCASES
  MEASURE length(U) + length(V)
  
END language
