language: THEORY
BEGIN
  % TODO: Paste intro from datatype + modify
  syntaxic: DATATYPE WITH SUBTYPES sexpr?, scontext?, sinterp?
  BEGIN
    v(i: nat): v?: sexpr?
    % Update this with finseq for nested theories:
    % finseq[ (sinterp?) ], nat
    dot(m: (sexpr?), x: (sexpr?)): dot?: sexpr?
    interp(m: (sexpr?), map: finseq[(sinterp?)]): interp?: sexpr?
    theory_(decls: finseq[(scontext?)]): theory?: sexpr?

    fun(dom: (sexpr?), range: (sexpr?)): fun?: sexpr?
    prod(left: (sexpr?), right: (sexpr?)): prod?: sexpr?
    subtype(supertype: (sexpr?), pred: (sexpr?)): subtype?: sexpr?

    app(op: (sexpr?), arg: (sexpr?)): app?: sexpr?
    lam(type_: (sexpr?), body: (sexpr?)): lam?: sexpr?
    pair(left: (sexpr?), right: (sexpr?)): pair?: sexpr?
    lproj(arg: (sexpr?)): lproj?: sexpr?
    rproj(arg: (sexpr?)): rproj?: sexpr?

    type_decl: type_decl?: scontext?
    type_var: type_var?: scontext?
    type_def(def: (sexpr?)): type_def?: scontext?
    const_decl(type_: (sexpr?)): const_decl?: scontext?
    const_var(type_: (sexpr?)): const_var?: scontext?
    const_def(type_: (sexpr?), def: (sexpr?)): const_def?: scontext?
    theory_def(def: (sexpr?)): theory_def?: scontext?

    ikeep: ikeep?: sinterp?
    itype(def: (sexpr?)): itype?: sinterp?
    iterm(def: (sexpr?)): iterm?: sinterp?
%    itheory(def: syntaxic): itheory?
  END syntaxic



%%%%% LATER %%%%%%


  % Γ: VAR finseq[(scontext?)]

  % % Pretau is a weaker tau function.
  % % It checks that: 
  % %    - variables and symbols are indeed declared in the current context
  % %    - terms and types are well_formed (eg fun takes two types as arguments)
  % % The function creating a term of type syntaxic from a real PVS expression
  % % should always return a term verifying pretau. Indeed, if the given expression
  % % does not verify pretau, we can't build the associated De Bruijn representation
  % pretau(Γ)(U): RECURSIVE bool =
  %   CASES U OF
  %     v(x): x ∈ Γ AND k = kw(Γ(x))
  %   , dot(m, x):
  %       pretau(Γ)(m)
  %       pretau(Sig)(m)(S) AND
  % 	pretau(S)(x)(s) AND
  % 	% Additional stuff to remove with nested & first-class theories
  % 	interp?(m) AND v?(x)
  %   , interp(m, σ):
  % 	% Additional stuff to remove with nested & first-class theories
  %       v?(m) AND
  %       etheory?(s) AND
  % 	σ`length = length(sig(s)) AND
  %       pretau(Sig)(m)(etheory(sig(s) - σ)) AND
  % 	FORALL (x: below[σ`length]): pretau(Sig ++ rest(stheory(sig(s)), x))(σ`seq(x))(sig(s)(x))

  %   , fun(A, B):
  %       s = etype AND pretau(Sig)(A)(s) AND pretau(Sig ++ k(sconst_def))(B)(s)
  %   , prod(A, B):
  %       s = etype AND pretau(Sig)(A)(s) AND pretau(Sig ++ k(sconst_def))(B)(s)
  %   , subtype(T, a):
  %       s = etype AND pretau(Sig)(T)(s) AND pretau(Sig ++ k(sconst_def))(a)(eterm)

  %   , app(f, a):
  %       s = etype AND pretau(Sig)(f)(s) AND pretau(Sig)(a)(s)
  %   , lam(T, a):
  %       s = etype AND pretau(Sig)(T)(etype) AND pretau(Sig ++ k(sconst_def))(a)(s)
  %   , pair(a, b):
  %       s = etype AND pretau(Sig)(a)(s) AND pretau(Sig)(b)(s)
  %   , lproj(a):
  %       s = etype AND pretau(Sig)(a)(etype)
  %   , rproj(a):
  %       s = etype AND pretau(Sig)(a)(etype)

  %   , ikeep: stype_def?(s) OR sconst_def?(s) OR stype_decl?(s) OR sconst_decl?(s)
  %   , itype(T): stype_def?(s) AND pretau(Sig)(T)(etype)
  %   , iterm(a): sconst_def?(s) AND pretau(Sig)(a)(eterm)

  %   , type_decl: stype_decl?(s)
  %   , type_var: stype_def?(s)
  %   , type_def(T): stype_def?(s) AND pretau(Sig)(T)(etype)
  %   , const_decl(T): sconst_decl?(s) AND pretau(Sig)(T)(etype)
  %   , const_var(T): sconst_def?(s) AND pretau(Sig)(T)(etype)
  %   , const_def(T, a) :
  %       sconst_def?(s) AND pretau(Sig)(T)(etype) AND pretau(Sig)(a)(eterm)
  %   , theory_def(f):
  % 	stheory?(s) AND length(s) = f`length AND % s = signature(U) AND
  % 	FORALL (x: below[f`length]): pretau(Sig ++ rest(s, x))(f`seq(x))(s(x))
  %   ENDCASES
  % MEASURE U BY <<
  % AUTO_REWRITE pretau










  % U, V, S: VAR syntaxic
  % x, y: VAR nat
  % i, j, n: VAR nat
  % M, N, P: VAR (theory_def?)

  % % TODO: move
  % sum(len: nat, f: [below[len] -> nat]):
  %   RECURSIVE { n: nat | FORALL (x: below[len]): f(x) <= n } =
  %   IF len = 0 THEN 0
  %   ELSE f(len - 1) + sum(len - 1, LAMBDA (x: below[len - 1]): f(x)) ENDIF
  % MEASURE len

  % % Size function, useful for termination
  % size(U): RECURSIVE nat =
  %   CASES U OF
  %     v(x): 2
  %   , dot(m, S, x): size(m) + size(x) + 2
  %   , interp(m, σ): size(m) + sum(σ`length, LAMBDA (x: below[σ`length]): size(σ`seq(x))) + 2

  %   , fun(A, B): size(A) + size(B) + 2
  %   , prod(A, B): size(A) + size(B) + 2
  %   , subtype(T, a): size(T) + size(a) + 2

  %   , app(f, a): size(f) + size(a) + 2
  %   , lam(T, a): size(T) + size(a) + 2
  %   , pair(a, b): size(a) + size(b) + 2
  %   , lproj(a): size(a) + 2
  %   , rproj(a): size(a) + 2

  %   , type_decl: 1
  %   , type_var: 1
  %   , type_def(T): size(T) + 1
  %   , const_decl(T): size(T) + 1
  %   , const_var(T): size(T) + 1
  %   , const_def(T, a): size(T) + size(a) + 1

  %   , ikeep: 1
  %   , itype(T): size(T) + 4
  %   , iterm(a): size(a) + 4

  %   , theory_def(f): sum(f`length, LAMBDA (x: below[f`length]): 1 + size(f(x)))
  %   ENDCASES
  % MEASURE U BY <<
  % AUTO_REWRITE+ size

  % % TODO: should it be a conversion ?
  % % Creates a context/signature of length one from a decl  
  % k(d: (scontext?)): (theory_def?) =
  %   theory_def((# length := 1, seq := LAMBDA (x: below[1]): d #))
  % k(d: (decl?)): (stheory?) = 
  %   stheory((# length := 1, seq := LAMBDA (x: below[1]): d #))
  % % empty context/signature
  % empty: MACRO (scontext?) = theory_def(empty_seq)
  % sempty: MACRO (stheory?) = stheory(empty_seq)

  % % Basic functions on contexts/signatures
  % length(M): nat =
  %   def(M)`length
  % length(Sig): nat = 
  %   sig(Sig)`length
  % AUTO_REWRITE+ length
  % ;∈(x, M): bool =
  %   x < length(M)
  % ;∈(x, Sig): bool = 
  %   x < length(Sig)
  % AUTO_REWRITE+ ∈
  % apply(M)(x | x ∈ M): (scontext?) =
  %   def(M)`seq(x)
  % sapply(Sig)(x | x ∈ Sig): signature = 
  %   sig(Sig)`seq(x)
  % CONVERSION+ apply, sapply
  % rest(M, (x | x ∈ M)): (theory_def?) =
  %   theory_def(def(M) ^^ (x + 1, length(M)))
  % rest(Sig, (x | x ∈ Sig)): (stheory?) = 
  %   stheory(sig(Sig) ^^ (x + 1, length(Sig)))
  % ;++(M, N): (theory_def?) =
  %   theory_def(def(N) o def(M))
  % ;++(S1, S2: (stheory?)): (stheory?) = 
  %   stheory(sig(S2) o sig(S1))
  % % Basic theorems about these functions
  % concat_empty: THEOREM
  %   empty ++ M = M
  % concat__empty: THEOREM
  %   M ++ empty = M
  % concat_assoc: THEOREM
  %   M ++ (N ++ P) = (M ++ N) ++ P
  % rest_concat: THEOREM x < length(M) + length(N) IMPLIES
  %   rest(M ++ N, x) =
  %     IF x < length(N)
  %       THEN M ++ rest(N, x)
  % 	ELSE rest(M, x - length(N))
  %     ENDIF
  % AUTO_REWRITE+ concat_empty, concat__empty, concat_assoc, rest_concat

  % sconcat_sempty: THEOREM
  %   sempty ++ Sig = Sig
  % sconcat__sempty: THEOREM
  %   Sig ++ sempty = Sig
  % sconcat_assoc: THEOREM FORALL (Sig, S1, S2: (stheory?)):
  %   Sig ++ (S1 ++ S2) = (Sig ++ S1) ++ S2
  % srest_sconcat: THEOREM FORALL (S1, S2: (stheory?)):
  %   x < length(S1) + length(S2) IMPLIES
  %   rest(S1 ++ S2, x) = 
  %     IF x < length(S2)
  %       THEN S1 ++ rest(S2, x)
  % 	ELSE rest(S1, x - length(S2))
  %     ENDIF
  % AUTO_REWRITE+ sconcat_sempty, sconcat__sempty, sconcat_assoc, srest_sconcat

  % length_concat: THEOREM
  %   length(M ++ N) = length(M) + length(N)
  % length_k: THEOREM FORALL (d: (scontext?)):
  %   length(k(d)) = 1
  % AUTO_REWRITE length_concat, length_k

  % slength_concat: THEOREM FORALL (S1, S2: (stheory?)):
  %   length(S1 ++ S2) = length(S1) + length(S2)
  % slength_k: THEOREM FORALL (s: (decl?)):
  %   length(k(s)) = 1
  % AUTO_REWRITE slength_concat, slength_k
   
  % % Not used anymore 
  % prefix_size: THEOREM FORALL (f, g: finseq[syntaxic]):
  %   f`length < g`length AND (FORALL (x: below[f`length]): f`seq(x) = g`seq(g`length - f`length + x)) IMPLIES
  %     sum(f`length, LAMBDA (x: below[f`length]): 1 + size(f(x))) < sum(g`length, LAMBDA (x: below[g`length]): 1 + size(g(x)))

  % ;-(Sig: finseq[(decl?)], (σ: finseq[(sinterp?)] | length(σ) = length(Sig))): finseq[(decl?)] =
  %   Sig WITH [ `seq := LAMBDA (x: below[length(Sig)]): IF σ(x) = ikeep THEN Sig(x) ELSE undefine(Sig(x)) ENDIF ]

  % Γ, Δ: VAR (scontext?)
  % S1, S2: VAR signature
  % e: VAR (sexpr?)

  % % This theorem is false because of the case ikeep
  % %kw_pretau: THEOREM
  % %  pretau(Sig)(U)(S1) AND pretau(Sig)(U)(S2) IMPLIES kw(S1) = kw(S2)

  % % Determinism of pretau
  % pretau_unique: THEOREM
  %   U /= ikeep AND pretau(Sig)(U)(S1) AND pretau(Sig)(U)(S2) IMPLIES S1 = S2
  
  % % pretau_concat: THEOREM stheory?(S1) AND stheory?(S2) AND theory_def?(Γ) AND theory_def?(Δ) AND length(S1) = length(Γ) AND length(S2) = length(Δ) IMPLIES
  % %   (pretau(Sig)(Γ ++ Δ)(S1 ++ S2) IFF
  % %      pretau(Sig)(Γ)(S1) AND pretau(Sig ++ S1)(Δ)(S2))

  % % pretau_apply: THEOREM theory_def?(Γ) AND stheory?(S1) IMPLIES
  % %   pretau(Sig)(Γ)(S1) AND i ∈ Γ IMPLIES
  % %     pretau(Sig ++ rest(S1, i))(Γ(i))(S1(i))
END language
