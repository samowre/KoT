language: THEORY
BEGIN
  syntaxic: DATATYPE
  BEGIN
    v(i: nat): v?
    dot(m: nat, map: syntaxic, s: syntaxic): dot?
  
    fun(dom: syntaxic, range: syntaxic): fun?
    prod(left: syntaxic, right: syntaxic): prod?
    subtype(supertype: syntaxic, pred: syntaxic): subtype?

    app(op: syntaxic, arg: syntaxic): app?
    lam(type_: syntaxic, body: syntaxic): lam?
    pair(left: syntaxic, right: syntaxic): pair?
    lproj(arg: syntaxic): lproj?
    rproj(arg: syntaxic): rproj?

    empty: empty?
    type_decl(rest: syntaxic): type_decl?
    type_var(rest: syntaxic): type_var?
    type_def(rest: syntaxic, def: syntaxic): type_def?
    const_decl(rest: syntaxic, type_: syntaxic): const_decl?
    const_var(rest: syntaxic, type_: syntaxic): const_var?
    const_def(rest: syntaxic, type_: syntaxic, def: syntaxic): const_def?
    theory_def(rest: syntaxic, def: syntaxic): theory_def?

    nil: nil?
    itype(rest: syntaxic, i: nat, def: syntaxic): itype?
    iconst(rest: syntaxic, i: nat, def: syntaxic): iconst?
%    itheory(def: syntaxic): itheory?
  END syntaxic

  size(U: syntaxic): RECURSIVE nat =
    CASES U OF
      v(i): 2
    , dot(i, σ, x): size(σ) + 2

    , fun(A, B): size(A) + size(B) + 2
    , prod(A, B): size(A) + size(B) + 2
    , subtype(T, a): size(T) + size(a) + 2

    , app(f, a): size(f) + size(a) + 2
    , lam(T, a): size(T) + size(a) + 2
    , pair(a, b): size(a) + size(b) + 2
    , lproj(a): size(a) + 2
    , rproj(a): size(a) + 2

    , empty: 0
    , type_decl(Γ): size(Γ) + 1
    , type_var(Γ): size(Γ) + 1
    , type_def(Γ, T): size(Γ) + size(T) + 1
    , const_decl(Γ, T): size(Γ) + size(T) + 1
    , const_var(Γ, T): size(Γ) + size(T) + 1
    , const_def(Γ, T, a): size(Γ) + size(T) + size(a) + 1
    , theory_def(Γ, Θ): size(Γ) + size(Θ) + 1

    , nil: 1
    , itype(σ, i, T): size(σ) + size(T) + 4
    , iconst(σ, i, a): size(σ) + size(a) + 4
    ENDCASES
  MEASURE U BY <<
  AUTO_REWRITE size

  prekeyword: TYPE =
    { PRETYPE, PRETERM, PRECONTEXT, PREINTERP }

  U, V, W: VAR syntaxic
  x, y: VAR nat
  k: VAR prekeyword  

  parsed?(U)(k): RECURSIVE bool =
    CASES U OF
      v(i): k = PRETYPE OR k = PRETERM
    , dot(i, σ, x): (k = PRETYPE OR k = PRETERM) AND
        parsed?(σ)(PREINTERP) AND v?(x)

    , fun(A, B): k = PRETYPE AND parsed?(A)(PRETYPE) AND parsed?(B)(PRETYPE)
    , prod(A, B): k = PRETYPE AND parsed?(A)(PRETYPE) AND parsed?(B)(PRETYPE)
    , subtype(T, a): k = PRETYPE AND parsed?(T)(PRETYPE) AND parsed?(a)(PRETERM)

    , app(f, a): k = PRETERM AND parsed?(f)(PRETERM) AND parsed?(a)(PRETERM)
    , lam(T, a): k = PRETERM AND parsed?(T)(PRETYPE) AND parsed?(a)(PRETERM)
    , pair(a, b): k = PRETERM AND parsed?(a)(PRETERM) AND parsed?(b)(PRETERM)
    , lproj(a): k = PRETERM AND parsed?(a)(k)
    , rproj(a): k = PRETERM AND parsed?(a)(k)

    , empty: k = PRECONTEXT
    , type_decl(Γ): k = PRECONTEXT AND parsed?(Γ)(PRECONTEXT)
    , type_var(Γ): k = PRECONTEXT AND parsed?(Γ)(PRECONTEXT)
    , type_def(Γ, T): k = PRECONTEXT AND parsed?(Γ)(PRECONTEXT) AND parsed?(T)(PRETYPE)
    , const_decl(Γ, T): k = PRECONTEXT AND parsed?(Γ)(PRECONTEXT) AND parsed?(T)(PRETYPE)
    , const_var(Γ,T): k = PRECONTEXT AND parsed?(Γ)(PRECONTEXT) AND parsed?(T)(PRETYPE)
    , const_def(Γ, T, a) : k = PRECONTEXT AND parsed?(Γ)(PRECONTEXT) AND parsed?(T)(PRETYPE) AND parsed?(a)(PRETERM)
    , theory_def(Γ, Θ): k = PRECONTEXT AND parsed?(Θ)(PRECONTEXT) AND parsed?(Γ)(PRECONTEXT)

    , nil: k = PREINTERP
    , itype(σ, i, T): k = PREINTERP AND parsed?(σ)(PREINTERP) AND parsed?(T)(PRETYPE)
    , iconst(σ, i, a): k = PREINTERP AND parsed?(σ)(PREINTERP) AND parsed?(a)(PRETERM)
    ENDCASES
  MEASURE size(U)
  AUTO_REWRITE parsed?

  precontext?(U): MACRO bool = parsed?(U)(PRECONTEXT)
  pretype?(U): MACRO bool = parsed?(U)(PRETYPE)
  preterm?(U): MACRO bool = parsed?(U)(PRETERM)
  preinterp?(U): MACRO bool = parsed?(U)(PREINTERP)
  premap?(U): MACRO bool = parsed?(U)(PRECONTEXT) OR parsed?(U)(PREINTERP)
  semantic?(U): MACRO bool = parsed?(U)(PRECONTEXT) OR parsed?(U)(PREINTERP) OR parsed?(U)(PRETYPE) OR parsed?(U)(PRETERM)

  precontext: TYPE = (precontext?)
  pretype: TYPE = (pretype?)
  preterm: TYPE = (preterm?)
  preinterp: TYPE = (preinterp?)
  premap: TYPE = (premap?)
  semantic: TYPE = (semantic?)

  Γ, Δ, Θ: VAR precontext
  T, A, B: VAR pretype
  a, b, f: VAR preterm
  σ, τ: VAR preinterp
  S: VAR semantic
  M: VAR premap

  type_decl: MACRO precontext = type_decl(empty)
  type_var: MACRO precontext = type_var(empty)
  type_def(U): MACRO syntaxic = type_def(empty, U)
  const_decl(U): MACRO syntaxic = const_decl(empty, U)
  const_var(U): MACRO syntaxic = const_var(empty, U)
  const_def(U, V): MACRO syntaxic = const_def(empty, U, V)
  theory_def(U): MACRO syntaxic = theory_def(empty, U)
  type_def_is_precontext: JUDGEMENT type_def(T) HAS_TYPE precontext
  const_decl_is_precontext: JUDGEMENT const_decl(T) HAS_TYPE precontext
  const_var_is_precontext: JUDGEMENT const_var(T) HAS_TYPE precontext
  const_def_is_precontext: JUDGEMENT const_def(T, a) HAS_TYPE precontext
  theory_def_is_precontext: JUDGEMENT theory_def(Θ) HAS_TYPE precontext
END language
