language: THEORY
BEGIN
  syntaxic: DATATYPE
  BEGIN
    v(i: nat): v?
    dot(m: nat, map: syntaxic, s: syntaxic): dot?
  
    fun(dom: syntaxic, range: syntaxic): fun?
    prod(left: syntaxic, right: syntaxic): prod?
    subtype(supertype: syntaxic, pred: syntaxic): subtype?

    app(op: syntaxic, arg: syntaxic): app?
    lam(type_: syntaxic, body: syntaxic): lam?
    pair(left: syntaxic, right: syntaxic): pair?
    lproj(arg: syntaxic): lproj?
    rproj(arg: syntaxic): rproj?

    type_decl: type_decl?
    type_var: type_var?
    type_def(def: syntaxic): type_def?
    const_decl(type_: syntaxic): const_decl?
    const_var(type_: syntaxic): const_var?
    const_def(type_: syntaxic, def: syntaxic): const_def?
    theory_def(def: syntaxic): theory_def?

    itype(i: nat, def: syntaxic): itype?
    iconst(i: nat, def: syntaxic): iconst?
%    itheory(def: syntaxic): itheory?

    map(run_map: finseq[syntaxic]): map?
  END syntaxic

  sum(len: nat, f: [below[len] -> nat]): RECURSIVE nat =
    IF len = 0 THEN 0
    ELSE f(len - 1) + sum(len - 1, LAMBDA (x: below[len - 1]): f(x)) ENDIF
  MEASURE len

  size(U: syntaxic): RECURSIVE nat =
    CASES U OF
      v(i): 2
    , dot(i, σ, x): size(σ) + 2

    , fun(A, B): size(A) + size(B) + 2
    , prod(A, B): size(A) + size(B) + 2
    , subtype(T, a): size(T) + size(a) + 2

    , app(f, a): size(f) + size(a) + 2
    , lam(T, a): size(T) + size(a) + 2
    , pair(a, b): size(a) + size(b) + 2
    , lproj(a): size(a) + 2
    , rproj(a): size(a) + 2

    , type_decl: 1
    , type_var: 1
    , type_def(T): size(T) + 1
    , const_decl(T): size(T) + 1
    , const_var(T): size(T) + 1
    , const_def(T, a): size(T) + size(a) + 1
    , theory_def(Θ): size(Θ) + 1

    , itype(i, T): size(T) + 4
    , iconst(i, a): size(a) + 4

    , map(f): sum(f`length, LAMBDA (x: below[f`length]): 1 + size(f(x)))
    ENDCASES
  MEASURE U BY <<
  AUTO_REWRITE size
  prefix_size: THEOREM FORALL (f, g: finseq[syntaxic]):
    f`length < g`length AND (FORALL (x: below[f`length]): f`seq(x) = g`seq(g`length - f`length + x)) IMPLIES
      sum(f`length, LAMBDA (x: below[f`length]): 1 + size(f(x))) < sum(g`length, LAMBDA (x: below[g`length]): 1 + size(g(x)))

  prekeyword: TYPE =
    { PRETYPE, PRETERM, PRECONTEXT, PREINTERP }

  U, V, W: VAR syntaxic
  x, y: VAR nat
  k: VAR prekeyword
  M: VAR (map?)

  length(M): MACRO nat = run_map(M)`length
  apply(M)(x | x < length(M)): MACRO syntaxic = run_map(M)`seq(x)
  CONVERSION+ apply

  kind?(U, k): bool = 
    CASES U OF
      type_decl: k = PRETYPE
    , type_var: k = PRETYPE
    , type_def(T): k = PRETYPE
    , const_decl(T): k = PRETERM
    , const_var(T): k = PRETERM
    , const_def(T, a): k = PRETERM
    , theory_def(Θ): k = PRECONTEXT
    ELSE FALSE
    ENDCASES
  AUTO_REWRITE kind?

  sinterp?(U): bool = itype?(U) OR iconst?(U)

  compatible?(M, U): RECURSIVE bool =
    CASES U OF
      itype(i, T):
        i < length(M) AND type_decl?(M(i))
    , iconst(i, a):
        i < length(M) AND const_decl?(M(i))

    , map(f):
        FORALL (x: below[f`length]): compatible?(M, f`seq(x))
	AND FORALL (x, y: below[f`length]):
	  sinterp?(f`seq(x)) AND sinterp?(f`seq(y)) AND
	    (i(f`seq(x)) = i(f`seq(y)) IFF x = y)
    ENDCASES
  MEASURE U BY <<
  AUTO_REWRITE compatible?

  rest(M, (x | x < length(M))): (map?) =
    map(run_map(M) ^^ (0, length(M) - x))

  ;++(M, N: (map?)): (map?) = map(run_map(N) o run_map(M))

  prekind?(M: (map?))(V)(k): RECURSIVE bool =
    CASES V OF
      v(i): (k = PRETYPE OR k = PRETERM) AND i < length(M) AND kind?(M(i), k)
    , dot(i, σ, x): (k = PRETYPE OR k = PRETERM) AND
        i < length(M) AND prekind?(M)(σ)(PREINTERP) AND v?(x) AND
  	compatible?(def(M(i)), σ) AND
  	kind?(M(i), PRECONTEXT) AND prekind?(def(M(i)))(x)(k)

    , fun(A, B): k = PRETYPE AND prekind?(M)(A)(PRETYPE) AND prekind?(M)(B)(PRETYPE)
    , prod(A, B): k = PRETYPE AND prekind?(M)(A)(PRETYPE) AND prekind?(M)(B)(PRETYPE)
    , subtype(T, a): k = PRETYPE AND prekind?(M)(T)(PRETYPE) AND prekind?(M)(a)(PRETERM)

    , app(f, a): k = PRETERM AND prekind?(M)(f)(PRETERM) AND prekind?(M)(a)(PRETERM)
    , lam(T, a): k = PRETERM AND prekind?(M)(T)(PRETYPE) AND prekind?(M)(a)(PRETERM)
    , pair(a, b): k = PRETERM AND prekind?(M)(a)(PRETERM) AND prekind?(M)(b)(PRETERM)
    , lproj(a): k = PRETERM AND prekind?(M)(a)(k)
    , rproj(a): k = PRETERM AND prekind?(M)(a)(k)

    , type_decl: k = PRECONTEXT
    , type_var: k = PRECONTEXT
    , type_def(T): k = PRECONTEXT AND prekind?(M)(T)(PRETYPE)
    , const_decl(T): k = PRECONTEXT AND prekind?(M)(T)(PRETYPE)
    , const_var(T): k = PRECONTEXT AND prekind?(M)(T)(PRETYPE)
    , const_def(T, a) :
        k = PRECONTEXT AND prekind?(M)(T)(PRETYPE) AND prekind?(M)(a)(PRETERM)
    , theory_def(Θ):
        k = PRECONTEXT AND prekind?(M)(Θ)(PRECONTEXT)

    , itype(i, T): k = PREINTERP AND prekind?(M)(T)(PRETYPE)
    , iconst(i, a): k = PREINTERP AND prekind?(M)(a)(PRETERM)

    , map(f):
        (k = PRECONTEXT OR k = PREINTERP) AND FORALL (x: below[f`length]): prekind?(M ++ rest(V, x))(f`seq(x))(k)
    ENDCASES
  MEASURE V BY <<
  AUTO_REWRITE prekind?

  % precontext?(U): MACRO bool = parsed?(U)(PRECONTEXT)
  % pretype?(U): MACRO bool = parsed?(U)(PRETYPE)
  % preterm?(U): MACRO bool = parsed?(U)(PRETERM)
  % preinterp?(U): MACRO bool = parsed?(U)(PREINTERP)
  % premap?(U): MACRO bool = parsed?(U)(PRECONTEXT) OR parsed?(U)(PREINTERP)
  % semantic?(U): MACRO bool = parsed?(U)(PRECONTEXT) OR parsed?(U)(PREINTERP) OR parsed?(U)(PRETYPE) OR parsed?(U)(PRETERM)

  % precontext: TYPE = (precontext?)
  % pretype: TYPE = (pretype?)
  % preterm: TYPE = (preterm?)
  % preinterp: TYPE = (preinterp?)
  % premap: TYPE = (premap?)
  % semantic: TYPE = (semantic?)

  % Γ, Δ, Θ: VAR precontext
  % T, A, B: VAR pretype
  % a, b, f: VAR preterm
  % σ, τ: VAR preinterp
  % S: VAR semantic
  % M: VAR premap

  % type_decl: MACRO precontext = type_decl(empty)
  % type_var: MACRO precontext = type_var(empty)
  % type_def(U): MACRO syntaxic = type_def(empty, U)
  % const_decl(U): MACRO syntaxic = const_decl(empty, U)
  % const_var(U): MACRO syntaxic = const_var(empty, U)
  % const_def(U, V): MACRO syntaxic = const_def(empty, U, V)
  % theory_def(U): MACRO syntaxic = theory_def(empty, U)
  % type_def_is_precontext: JUDGEMENT type_def(T) HAS_TYPE precontext
  % const_decl_is_precontext: JUDGEMENT const_decl(T) HAS_TYPE precontext
  % const_var_is_precontext: JUDGEMENT const_var(T) HAS_TYPE precontext
  % const_def_is_precontext: JUDGEMENT const_def(T, a) HAS_TYPE precontext
  % theory_def_is_precontext: JUDGEMENT theory_def(Θ) HAS_TYPE precontext
END language
