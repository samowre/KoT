language: THEORY
BEGIN

  signature: DATATYPE
  BEGIN
    stype_decl: stype_decl?
    stype_def: stype_def?
    sconst_decl: sconst_decl?
    sconst_def: sconst_def?
    stheory(sig: finseq[signature]): stheory?
  END signature

  s: VAR signature
  Sig: VAR (stheory?)
  

  prekeyword: DATATYPE
  BEGIN
    PRETYPE: PRETYPE?
    PRETERM: PRETERM?
    PRECONTEXT(SIG: finseq[signature]): PRECONTEXT?
  END prekeyword

  k: VAR prekeyword

  kw(s): prekeyword =
    CASES s OF
      stype_decl: PRETYPE
    , stype_def: PRETYPE
    , sconst_decl: PRETERM
    , sconst_def: PRETERM
    , stheory(Sig): PRECONTEXT(Sig)
    ENDCASES

  syntaxic: DATATYPE WITH SUBTYPES sexpr?, scontext?, sinterp?
  BEGIN
    v(i: nat): v?: sexpr?
    % Update this with finseq for nested theories:
    % finseq[ (sinterp?) ], nat
    dot(m: (sexpr?), sig: finseq[signature], x: (sexpr?)): dot?: sexpr?
    interp(m: (sexpr?), map: finseq[(sinterp?)]): interp?: sexpr?
  
    fun(dom: (sexpr?), range: (sexpr?)): fun?: sexpr?
    prod(left: (sexpr?), right: (sexpr?)): prod?: sexpr?
    subtype(supertype: (sexpr?), pred: (sexpr?)): subtype?: sexpr?

    app(op: (sexpr?), arg: (sexpr?)): app?: sexpr?
    lam(type_: (sexpr?), body: (sexpr?)): lam?: sexpr?
    pair(left: (sexpr?), right: (sexpr?)): pair?: sexpr?
    lproj(arg: (sexpr?)): lproj?: sexpr?
    rproj(arg: (sexpr?)): rproj?: sexpr?

    type_decl: type_decl?: scontext?
    type_var: type_var?: scontext?
    type_def(def: (sexpr?)): type_def?: scontext?
    const_decl(type_: (sexpr?)): const_decl?: scontext?
    const_var(type_: (sexpr?)): const_var?: scontext?
    const_def(type_: (sexpr?), def: (sexpr?)): const_def?: scontext?
    theory_def(def: finseq[(scontext?)]): theory_def?: scontext?

%    map(run_map: finseq[(scontext?)]): map?: scontext?

    ikeep: ikeep?: sinterp?
    itype(def: (sexpr?)): itype?: sinterp?
    iterm(def: (sexpr?)): iterm?: sinterp?
%    itheory(def: syntaxic): itheory?

  END syntaxic
  AUTO_REWRITE- sexpr?
  AUTO_REWRITE+ scontext?

  U, V, S: VAR syntaxic
  x, y: VAR nat
  i, j, n: VAR nat
  M, N, P: VAR (scontext?)


  signature(ctx: (scontext?)): RECURSIVE signature =
    CASES ctx OF
      type_decl: stype_decl
    , type_var: stype_def
    , type_def(T): stype_def
    , const_decl(T): sconst_decl
    , const_var(T): sconst_def
    , const_def(T, a): sconst_def
    , theory_def(f):
        stheory((# length := f`length
	         , seq := LAMBDA (x: below[f`length]): signature(f(x))
	        #))
    ENDCASES
  MEASURE ctx BY <<

  k(d: (scontext?)): (theory_def?) =
    theory_def((# length := 1, seq := LAMBDA (x: below[1]): d #))
  k(s): (stheory?) = 
    stheory((# length := 1, seq := LAMBDA (x: below[1]): s #))


  empty: MACRO (scontext?) = theory_def(empty_seq)
  sempty: MACRO (stheory?) = stheory(empty_seq)

  length(M): nat =
    def(M)`length
  length(Sig): nat = 
    sig(Sig)`length
  AUTO_REWRITE+ length
  ;∈(x, M): MACRO bool =
    x < length(M)
  ;∈(x, Sig): MACRO bool = 
    x < length(Sig)
  apply(M)(x | x ∈ M): (scontext?) =
    def(M)`seq(x)
  apply(Sig)(x | x ∈ Sig): (stheory?) = 
    sig(Sig)`seq(x)
  CONVERSION+ apply
  rest(M, (x | x ∈ M)): (theory_def?) =
    theory_def(def(M) ^^ (x + 1, length(M)))
  rest(Sig, (x | x ∈ Sig)): (stheory?) = 
    stheory(sig(Sig) ^^ (x + 1, length(Sig)))
  ;++(M, N): (theory_def?) =
    theory_def(def(N) o def(M))
  ;++(S1, S2: (stheory?)): (stheory?) = 
    stheory(sig(S2) o sig(S1))
  concat_empty: THEOREM
    empty ++ M = M
  concat__empty: THEOREM
    M ++ empty = M
  concat_assoc: THEOREM
    M ++ (N ++ P) = (M ++ N) ++ P
  rest_concat: THEOREM x < length(M) + length(N) IMPLIES
    rest(M ++ N, x) =
      IF x < length(N)
        THEN M ++ rest(N, x)
	ELSE rest(M, x - length(N))
      ENDIF
  AUTO_REWRITE+ concat_empty, concat__empty, concat_assoc, rest_concat

  sconcat_sempty: THEOREM
    empty ++ Sig = Sig
  sconcat__sempty: THEOREM
    Sig ++ sempty = Sig
  sconcat_assoc: THEOREM FORALL (Sig, S1, S2: (stheory?)):
    Sig ++ (S1 ++ S2) = (Sig ++ S1) ++ S2
  srest_concat: THEOREM FORALL (S1, S2: (stheory?)):
    x < length(S1) + length(S2) IMPLIES
    rest(S1 ++ S2, x) = 
      IF x < length(S2)
        THEN S1 ++ rest(S2, x)
	ELSE rest(S1, x - length(N))
  AUTO_REWRITE+ sconcat_sempty, sconcat__sempty, sconcat_assoc, srest_concat


  length_concat: THEOREM
    length(M ++ N) = length(M) + length(N)
  length_k: THEOREM FORALL (d: (scontext?)):
    length(k(d)) = 1
  AUTO_REWRITE length_concat, length_k

  slength_concat: THEOREM FORALL (S1, S2: (stheory?)):
    length(S1 ++ S2) = length(S1) + length(S2)
  slength_k: THEOREM
    length(k(s)) = 1
  AUTO_REWRITE slength_concat, slength_k
    

  % TODO: move
  sum(len: nat, f: [below[len] -> nat]):
    RECURSIVE { n: nat | FORALL (x: below[len]): f(x) <= n } =
    IF len = 0 THEN 0
    ELSE f(len - 1) + sum(len - 1, LAMBDA (x: below[len - 1]): f(x)) ENDIF
  MEASURE len

  size(U): RECURSIVE nat =
    CASES U OF
      v(x): 2
    , dot(m, S, x): size(m) + size(x) + 2
    , interp(m, σ): size(m) + sum(σ`length, LAMBDA (x: below[σ`length]): size(σ)) + 2

    , fun(A, B): size(A) + size(B) + 2
    , prod(A, B): size(A) + size(B) + 2
    , subtype(T, a): size(T) + size(a) + 2

    , app(f, a): size(f) + size(a) + 2
    , lam(T, a): size(T) + size(a) + 2
    , pair(a, b): size(a) + size(b) + 2
    , lproj(a): size(a) + 2
    , rproj(a): size(a) + 2

    , type_decl: 1
    , type_var: 1
    , type_def(T): size(T) + 1
    , const_decl(T): size(T) + 1
    , const_var(T): size(T) + 1
    , const_def(T, a): size(T) + size(a) + 1

    , ikeep: 1
    , itype(T): size(T) + 4
    , iterm(a): size(a) + 4

    , theory_def(f): sum(f`length, LAMBDA (x: below[f`length]): 1 + size(f(x)))
    ENDCASES
  MEASURE U BY <<
  AUTO_REWRITE size
  prefix_size: THEOREM FORALL (f, g: finseq[syntaxic]):
    f`length < g`length AND (FORALL (x: below[f`length]): f`seq(x) = g`seq(g`length - f`length + x)) IMPLIES
      sum(f`length, LAMBDA (x: below[f`length]): 1 + size(f(x))) < sum(g`length, LAMBDA (x: below[g`length]): 1 + size(g(x)))

  seq1(s): finseq[signature] =
    (# length := 1, seq := LAMBDA (x: below[1]): s #)

  pretau(Sig: finseq[signature])(U)(s): RECURSIVE bool =
    CASES U OF
      v(x): x < Sig`length AND kw(s) = kw(Sig`seq(x))
    , dot(m, S, x):
        pretau(Sig)(m)(stheory(S)) AND
	pretau(S)(x)(s)
    , interp(m, σ):
        stheory?(s) AND
        pretau(Sig)(m)(s) AND
	σ`length = sig(s)`length AND
	FORALL (x: below[σ`length]): pretau(Sig)(σ`seq(x))(sig(s)`seq(x))

    , fun(A, B):
        kw(s) = PRETYPE AND pretau(Sig)(A)(s) AND pretau(seq1(stype_def) o Sig)(B)(s)
        
    , prod(A, B):
        kw(s) = PRETYPE AND pretau(Sig)(A)(s) AND pretau(seq1(stype_def) o Sig)(B)(s)
    , subtype(T, a):
        kw(s) = PRETYPE AND pretau(Sig)(T)(s) AND pretau(seq1(stype_def) o Sig)(a)(sconst_def)

    , app(f, a):
        kw(s) = PRETERM AND pretau(Sig)(f)(s) AND pretau(Sig)(a)(s)
    , lam(T, a):
        kw(s) = PRETERM AND pretau(Sig)(T)(stype_def) AND pretau(seq1(stype_def) o Sig)(a)(s)
    , pair(a, b):
        kw(s) = PRETERM AND pretau(Sig)(a)(s) AND pretau(Sig)(b)(s)
    , lproj(a):
        kw(s) = PRETERM AND pretau(Sig)(a)(s)
    , rproj(a):
        kw(s) = PRETERM AND pretau(Sig)(a)(s)

    , ikeep: TRUE
    , itype(T): stype_decl?(s) AND pretau(Sig)(T)(s)
    , iterm(a): sconst_decl?(s) AND pretau(Sig)(a)(s)

    , type_decl: stype_decl?(s)
    , type_var: stype_def?(s)
    , type_def(T): stype_def?(s) AND pretau(Sig)(T)(s)
    , const_decl(T): sconst_decl?(s) AND pretau(Sig)(T)(stype_def)
    , const_var(T): sconst_def?(s) AND pretau(Sig)(T)(stype_def)
    , const_def(T, a) :
        sconst_def?(s) AND pretau(Sig)(T)(stype_def) AND pretau(Sig)(a)(s)
    , theory_def(f):
        LET fsig = (# length := f`length, seq := LAMBDA (x: below[f`length]): signature(f`seq(x)) #) IN
        FORALL (x: below[f`length]): pretau(fsig ^^ (x + 1, f`length) o Sig)(f`seq(x))(fsig`seq(x))
    ENDCASES
  MEASURE U BY <<
  AUTO_REWRITE pretau

  Γ: VAR precontext

  prekind_concat: THEOREM
    prekind?(M)(N ++ P)(PRECONTEXT) IFF 
    prekind?(M)(N)(PRECONTEXT) AND prekind?(M ++ N)(P)(PRECONTEXT)

  pretheory_as_precontext: THEOREM
    pretheory?(Γ)(M) IMPLIES precontext?(Γ ++ M)
  precontext_as_pretheory: THEOREM
    precontext?(Γ ++ M) IMPLIES pretheory?(Γ)(M)

  semantic_pretheory: THEOREM
    pretheory?(M)(N) AND i ∈ N IMPLIES
      semantic?(M ++ rest(N, i))(N(i))

  kind_equiv: THEOREM
    U ≡ V IMPLIES kind?(U, k) = kind?(V, k)
  length_equiv: THEOREM
    M ≡ N IMPLIES length(M) = length(N)
  apply_equiv: THEOREM
    M ≡ N AND i ∈ M IMPLIES M(i) ≡ N(i)
  prekind_equiv: THEOREM
    M ≡ N IMPLIES prekind?(M)(U) = prekind?(N)(U)
END language
