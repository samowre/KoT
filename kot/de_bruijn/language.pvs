language: THEORY
BEGIN
  syntaxic: DATATYPE WITH SUBTYPES sexpr?, sdecl?, scontext?, sinterp?
  BEGIN
    v(i: nat): v?: sexpr?
    dot(m: nat, map: (sinterp?), s: (sexpr?)): dot?: sexpr?
  
    fun(dom: (sexpr?), range: (sexpr?)): fun?: sexpr?
    prod(left: (sexpr?), right: (sexpr?)): prod?: sexpr?
    subtype(supertype: (sexpr?), pred: (sexpr?)): subtype?: sexpr?

    app(op: (sexpr?), arg: (sexpr?)): app?: sexpr?
    lam(type_: (sexpr?), body: (sexpr?)): lam?: sexpr?
    pair(left: (sexpr?), right: (sexpr?)): pair?: sexpr?
    lproj(arg: (sexpr?)): lproj?: sexpr?
    rproj(arg: (sexpr?)): rproj?: sexpr?

    type_decl: type_decl?: sdecl?
    type_var: type_var?: sdecl?
    type_def(def: (sexpr?)): type_def?: sdecl?
    const_decl(type_: (sexpr?)): const_decl?: sdecl?
    const_var(type_: (sexpr?)): const_var?: sdecl?
    const_def(type_: (sexpr?), def: (sexpr?)): const_def?: sdecl?
    theory_def(def: (scontext?)): theory_def?: sdecl?

    nil: nil?: sinterp?
    itype(rest: (sinterp?), i: nat, def: (sexpr?)): itype?: sinterp?
    iconst(rest: (sinterp?), i: nat, def: (sexpr?)): iconst?: sinterp?
%    itheory(def: syntaxic): itheory?

    map(run_map: finseq[(sdecl?)]): map?: scontext?
  END syntaxic

  prekeyword: TYPE =
    { PRETYPE, PRETERM, PRECONTEXT, PREINTERP, PREDECL }

  U, V: VAR syntaxic
  x, y: VAR nat
  i, j, n: VAR nat
  k: VAR prekeyword

  k(d: sdecl?): scontext? =
    map((# length := 1, seq := LAMBDA (x: below[1]): d #))

  M, N, P: VAR scontext?
  empty: MACRO scontext? = map(empty_seq)

  length(M): MACRO nat =
    run_map(M)`length
  ;∈(x, M): MACRO bool =
    x < length(M)
  apply(M)(x | x ∈ M): sdecl? =
    run_map(M)`seq(x)
  CONVERSION+ apply
  rest(M, (x | x < length(M))): scontext? =
    map(run_map(M) ^^ (x + 1, length(M)))
  ;++(M, N): scontext? =
    map(run_map(N) o run_map(M))
  concat_empty: THEOREM
    empty ++ M = M
  concat__empty: THEOREM
    M ++ empty = M
  concat_assoc: THEOREM
    M ++ (N ++ P) = (M ++ N) ++ P
  rest_concat: THEOREM x < length(M) + length(N) IMPLIES
    rest(M ++ N, x) =
      IF x < length(N)
        THEN M ++ rest(N, x)
	ELSE rest(M, x - length(N))
      ENDIF
  AUTO_REWRITE+ concat_empty, concat__empty, concat_assoc, rest_concat

  length_concat: THEOREM
    length(M ++ N) = length(M) + length(N)
  length_k: THEOREM FORALL (d: sdecl?):
    length(k(d)) = 1
  AUTO_REWRITE length_concat, length_k

  % TODO: move
  sum(len: nat, f: [below[len] -> nat]):
    RECURSIVE { n: nat | FORALL (x: below[len]): f(x) <= n } =
    IF len = 0 THEN 0
    ELSE f(len - 1) + sum(len - 1, LAMBDA (x: below[len - 1]): f(x)) ENDIF
  MEASURE len

  size(U): RECURSIVE nat =
    CASES U OF
      v(i): 2
    , dot(i, σ, x): size(σ) + 2

    , fun(A, B): size(A) + size(B) + 2
    , prod(A, B): size(A) + size(B) + 2
    , subtype(T, a): size(T) + size(a) + 2

    , app(f, a): size(f) + size(a) + 2
    , lam(T, a): size(T) + size(a) + 2
    , pair(a, b): size(a) + size(b) + 2
    , lproj(a): size(a) + 2
    , rproj(a): size(a) + 2

    , type_decl: 1
    , type_var: 1
    , type_def(T): size(T) + 1
    , const_decl(T): size(T) + 1
    , const_var(T): size(T) + 1
    , const_def(T, a): size(T) + size(a) + 1
    , theory_def(Θ): size(Θ) + 1

    , nil: 0
    , itype(τ, i, T): size(τ) + size(T) + 4
    , iconst(τ, i, a): size(τ) + size(a) + 4

    , map(f): sum(f`length, LAMBDA (x: below[f`length]): 1 + size(f(x)))
    ENDCASES
  MEASURE U BY <<
  AUTO_REWRITE size
  prefix_size: THEOREM FORALL (f, g: finseq[syntaxic]):
    f`length < g`length AND (FORALL (x: below[f`length]): f`seq(x) = g`seq(g`length - f`length + x)) IMPLIES
      sum(f`length, LAMBDA (x: below[f`length]): 1 + size(f(x))) < sum(g`length, LAMBDA (x: below[g`length]): 1 + size(g(x)))

  kind?(U, k): bool = 
    CASES U OF
      type_decl: k = PRETYPE
    , type_var: k = PRETYPE
    , type_def(T): k = PRETYPE
    , const_decl(T): k = PRETERM
    , const_var(T): k = PRETERM
    , const_def(T, a): k = PRETERM
    , theory_def(Θ): k = PRECONTEXT
    ELSE FALSE
    ENDCASES
  AUTO_REWRITE kind?

  interpret?(U, i): RECURSIVE bool =
    CASES U OF
      itype(τ, j, T): i = j OR interpret?(τ, i)
    , iconst(τ, j, a): i = j OR interpret?(τ, i)
    ELSE FALSE
    ENDCASES
  MEASURE U BY <<

  interpret(U, (i | interpret?(U, i))): RECURSIVE syntaxic =
    CASES U OF
      itype(τ, j, T): IF i = j THEN T ELSE interpret(τ, i) ENDIF
    , iconst(τ, j, a): IF i = j THEN a ELSE interpret(τ, i) ENDIF
    ENDCASES
  MEASURE U BY <<

  compatible?(M, U): RECURSIVE bool =
    CASES U OF
      nil: TRUE
    , itype(τ, i, T):
        i < length(M) AND type_decl?(M(i)) AND NOT interpret?(τ, i) AND compatible?(M, τ)
    , iconst(τ, i, a):
        i < length(M) AND const_decl?(M(i)) AND NOT interpret?(τ, i) AND compatible?(M, τ)
    ELSE FALSE
    ENDCASES
  MEASURE U BY <<
  AUTO_REWRITE compatible?
  compatible_interp: THEOREM
    length(M) = length(N) AND sinterp?(U) AND sexpr?(V) AND
    (FORALL (x: below[length(M)]): x /= i => M(x) = N(x)) AND
    (compatible?(M, itype(U, i, V)) OR compatible?(M, iconst(U, i, V)))
      IMPLIES compatible?(N, U)

  interp(M, (U | compatible?(M, U))): RECURSIVE scontext? =
    CASES U OF
      nil: M
    , itype(τ, i, T): interp(map(run_map(M) WITH [ `seq(i) := type_def(T) ]), τ)
    , iconst(τ, i, a): interp(map(run_map(M) WITH [ `seq(i) := const_def(type_(M(i)), a) ]), τ)
    ENDCASES
  MEASURE U BY <<

  prekind?(M: scontext?)(U)(k): RECURSIVE bool =
    CASES U OF
      v(i): (k = PRETYPE OR k = PRETERM) AND i < length(M) AND kind?(M(i), k)
    , dot(i, σ, x): (k = PRETYPE OR k = PRETERM) AND
        i < length(M) AND prekind?(M)(σ)(PREINTERP) AND v?(x) AND
	kind?(M(i), PRECONTEXT) AND theory_def?(M(i)) AND
	compatible?(def(M(i)), σ) AND prekind?(def(M(i)))(x)(k)

    , fun(A, B):
        k = PRETYPE AND prekind?(M)(A)(PRETYPE) AND prekind?(M ++ k(const_var(A)))(B)(PRETYPE)
    , prod(A, B):
        k = PRETYPE AND prekind?(M)(A)(PRETYPE) AND prekind?(M ++ k(const_var(A)))(B)(PRETYPE)
    , subtype(T, a):
        k = PRETYPE AND prekind?(M)(T)(PRETYPE) AND prekind?(M ++ k(const_var(T)))(a)(PRETERM)

    , app(f, a): k = PRETERM AND prekind?(M)(f)(PRETERM) AND prekind?(M)(a)(PRETERM)
    , lam(T, a): k = PRETERM AND prekind?(M)(T)(PRETYPE) AND prekind?(M ++ k(const_var(T)))(a)(PRETERM)
    , pair(a, b): k = PRETERM AND prekind?(M)(a)(PRETERM) AND prekind?(M)(b)(PRETERM)
    , lproj(a): k = PRETERM AND prekind?(M)(a)(k)
    , rproj(a): k = PRETERM AND prekind?(M)(a)(k)

    , type_decl: k = PREDECL
    , type_var: k = PREDECL
    , type_def(T): k = PREDECL AND prekind?(M)(T)(PRETYPE)
    , const_decl(T): k = PREDECL AND prekind?(M)(T)(PRETYPE)
    , const_var(T): k = PREDECL AND prekind?(M)(T)(PRETYPE)
    , const_def(T, a) :
        k = PREDECL AND prekind?(M)(T)(PRETYPE) AND prekind?(M)(a)(PRETERM)
    , theory_def(Θ):
        k = PREDECL AND prekind?(M)(Θ)(PRECONTEXT)

    , nil: k = PREINTERP
    , itype(σ, i, T): k = PREINTERP AND prekind?(M)(T)(PRETYPE) AND prekind?(M)(σ)(PREINTERP)
    , iconst(σ, i, a): k = PREINTERP AND prekind?(M)(a)(PRETERM) AND prekind?(M)(σ)(PREINTERP)

    , map(f):
        k = PRECONTEXT AND scontext?(U) AND
	FORALL (x: below[f`length]): prekind?(M ++ rest(U, x))(f`seq(x))(PREDECL)
    ENDCASES
  MEASURE U BY <<
  AUTO_REWRITE prekind?

  precontext?(U): MACRO bool = prekind?(empty)(U)(PRECONTEXT)
  precontext: TYPE = (precontext?)

  pretheory?(M)(U): MACRO bool = prekind?(M)(U)(PRECONTEXT)
  pretype?(M)(U): MACRO bool = prekind?(M)(U)(PRETYPE)
  preterm?(M)(U): MACRO bool = prekind?(M)(U)(PRETERM)
  preinterp?(M)(U): MACRO bool = prekind?(M)(U)(PREINTERP)
  predecl?(M)(U): MACRO bool = prekind?(M)(U)(PREDECL)
  semantic?(M)(U): bool =
    pretheory?(M)(U) OR pretype?(M)(U) OR preterm?(M)(U) OR preinterp?(M)(U) OR predecl?(M)(U)

  pretheory(M): TYPE = (pretheory?(M))
  pretype(M): TYPE = (pretype?(M))
  preterm(M): TYPE = (preterm?(M))
  preinterp(M): TYPE = (preinterp?(M))
  predecl(M): TYPE = (predecl?(M))
  semantic(M): TYPE = (semantic?(M))

  precontext_is_map: JUDGEMENT precontext SUBTYPE_OF (map?)
  pretheory_is_map: JUDGEMENT pretheory(M) SUBTYPE_OF (map?)
  precontext_is_scontext: JUDGEMENT precontext SUBTYPE_OF scontext?
  pretheory_is_scontext: JUDGEMENT pretheory(M) SUBTYPE_OF scontext?

  Γ: VAR precontext

  prekind_concat: THEOREM
    prekind?(M)(N ++ P)(PRECONTEXT) IFF 
    prekind?(M)(N)(PRECONTEXT) AND prekind?(M ++ N)(P)(PRECONTEXT)

  pretheory_as_precontext: THEOREM
    pretheory?(Γ)(U) IMPLIES precontext?(Γ ++ U)
  precontext_as_pretheory: THEOREM
    precontext?(Γ ++ M) IMPLIES pretheory?(Γ)(M)

  semantic_pretheory: THEOREM
    pretheory?(M)(N) AND i ∈ N IMPLIES
      semantic?(M ++ rest(N, i))(N(i))
END language
