language: THEORY
BEGIN
  syntaxic: DATATYPE
  BEGIN
    v(i: nat): v?
    dot(m: nat, map: syntaxic, s: syntaxic): dot?
  
    fun(dom: syntaxic, range: syntaxic): fun?
    prod(left: syntaxic, right: syntaxic): prod?
    subtype(supertype: syntaxic, pred: syntaxic): subtype?

    app(op: syntaxic, arg: syntaxic): app?
    lam(type_: syntaxic, body: syntaxic): lam?
    pair(left: syntaxic, right: syntaxic): pair?
    lproj(arg: syntaxic): lproj?
    rproj(arg: syntaxic): rproj?

    empty: empty?
    type_decl(rest: syntaxic): type_decl?
    type_var(rest: syntaxic): type_var?
    type_def(rest: syntaxic, def: syntaxic): type_def?
    const_decl(rest: syntaxic, type_: syntaxic): const_decl?
    const_var(rest: syntaxic, type_: syntaxic): const_var?
    const_def(rest: syntaxic, type_: syntaxic, def: syntaxic): const_def?
    theory_def(rest: syntaxic, def: syntaxic): theory_def?

    nil: nil?
    ikeep(rest: syntaxic): ikeep?
    itype(rest: syntaxic, def: syntaxic): itype?
    iconst(rest: syntaxic, def: syntaxic): iconst?
%    itheory(def: syntaxic): itheory?
  END syntaxic

  prekeyword: TYPE =
    { PRETYPE, PRETERM, PRECONTEXT, PREINTERP }

  U, V, W: VAR syntaxic
  x: VAR nat
  k: VAR prekeyword  

  parsed?(U)(k): RECURSIVE bool =
    CASES U OF
      v(i): k = PRETYPE OR k = PRETERM
    , dot(i, σ, x):
        parsed?(σ)(PREINTERP) AND v?(x)

    , fun(A, B): k = PRETYPE AND parsed?(A)(PRETYPE) AND parsed?(B)(PRETYPE)
    , prod(A, B): k = PRETYPE AND parsed?(A)(PRETYPE) AND parsed?(B)(PRETYPE)
    , subtype(T, a): k = PRETYPE AND parsed?(T)(PRETYPE) AND parsed?(a)(PRETERM)

    , app(f, a): k = PRETERM AND parsed?(f)(PRETERM) AND parsed?(a)(PRETERM)
    , lam(T, a): k = PRETERM AND parsed?(T)(PRETYPE) AND parsed?(a)(PRETERM)
    , pair(a, b): k = PRETERM AND parsed?(a)(PRETERM) AND parsed?(a)(PRETERM)
    , lproj(a): k = PRETERM AND parsed?(a)(k)
    , rproj(a): k = PRETERM AND parsed?(a)(k)

    , empty: k = PRECONTEXT
    , type_decl(Γ): k = PRECONTEXT AND parsed?(Γ)(PRECONTEXT)
    , type_var(Γ): k = PRECONTEXT AND parsed?(Γ)(PRECONTEXT)
    , type_def(Γ, T): k = PRECONTEXT AND parsed?(Γ)(PRECONTEXT) AND parsed?(T)(PRETYPE)
    , const_decl(Γ, T): k = PRECONTEXT AND parsed?(Γ)(PRECONTEXT) AND parsed?(T)(PRETYPE)
    , const_var(Γ,T): k = PRECONTEXT AND parsed?(Γ)(PRECONTEXT) AND parsed?(T)(PRETYPE)
    , const_def(Γ, T, a) : k = PRECONTEXT AND parsed?(Γ)(PRECONTEXT) AND parsed?(T)(PRETYPE) AND parsed?(a)(PRETERM)
    , theory_def(Γ, Θ): k = PRECONTEXT AND parsed?(Θ)(PRECONTEXT) AND parsed?(Γ)(PRECONTEXT)

    , nil: k = PREINTERP
    , ikeep(σ): k = PREINTERP AND parsed?(σ)(PREINTERP)
    , itype(σ, T): k = PREINTERP AND parsed?(σ)(PREINTERP) AND parsed?(T)(PRETYPE)
    , iconst(σ, a): k = PREINTERP AND parsed?(σ)(PREINTERP) AND parsed?(a)(PRETERM)
    ENDCASES
  MEASURE U BY <<
  AUTO_REWRITE parsed?

  precontext?(U): MACRO bool = parsed?(U)(PRECONTEXT)
  pretype?(U): MACRO bool = parsed?(U)(PRETYPE)
  preterm?(U): MACRO bool = parsed?(U)(PRETERM)
  preinterp?(U): MACRO bool = parsed?(U)(PREINTERP)
  premap?(U): MACRO bool = parsed?(U)(PRECONTEXT) OR parsed?(U)(PREINTERP)

  precontext: TYPE = (precontext?)
  pretype: TYPE = (pretype?)
  preterm: TYPE = (preterm?)
  preinterp: TYPE = (preinterp?)
  premap: TYPE = (premap?)

  Γ, Δ, Θ: VAR precontext
  T, A, B: VAR pretype
  a, b, f: VAR preterm
  σ, τ: VAR preinterp
  M: VAR premap

  type_decl: precontext = type_decl(empty)
  type_var: precontext = type_var(empty)
  type_def(T): precontext = type_def(empty, T)
  const_decl(T): precontext = const_decl(empty, T)
  const_var(T): precontext = const_var(empty, T)
  const_def(T, a): precontext = const_def(empty, T, a)
  theory_def(Θ): precontext = theory_def(empty, Θ)

  length(U): RECURSIVE nat =
    CASES U OF
      type_decl(Δ): 1 + length(Δ) 
    , type_var(Δ): 1 + length(Δ)
    , type_def(Δ, T): 1 + length(Δ)
    , const_decl(Δ, T): 1 + length(Δ)
    , const_var(Δ, T): 1 + length(Δ)
    , const_def(Δ, T, a): 1 + length(Δ)
    , theory_def(Δ, Θ): 1 + length(Δ)

    , ikeep(σ): 1 + length(σ)
    , itype(σ, T): 1 + length(σ)
    , iconst(σ, a): 1 + length(σ)
    ELSE 0
    ENDCASES
  MEASURE U BY <<
  AUTO_REWRITE length

  ;∈(x, M): MACRO bool =
    x < length(M)

  apply(Γ)(x | x ∈ Γ): RECURSIVE precontext =
    IF x = 0 THEN Γ ELSE apply(rest(Γ))(x - 1) ENDIF
  MEASURE length(Γ)
  CONVERSION apply
  AUTO_REWRITE+ apply
  length_apply: THEOREM x ∈ Γ IMPLIES
    length(apply(Γ)(x)) = length(Γ) - x
  length_rest: THEOREM length(Γ) > 0 IMPLIES
    length(rest(Γ)) = length(Γ) - 1

  ;++(Γ, Δ): RECURSIVE precontext =
    CASES Δ OF
      empty: Γ
    , type_decl(Δ): type_decl(Γ ++ Δ)
    , type_var(Δ): type_var(Γ ++ Δ)
    , type_def(Δ, T): type_def(Γ ++ Δ, T)
    , const_decl(Δ, T): const_decl(Γ ++ Δ, T)
    , const_var(Δ, T): const_var(Γ ++ Δ, T)
    , const_def(Δ, T, a): const_def(Γ ++ Δ, T, a)
    , theory_def(Δ, Θ): theory_def(Γ ++ Δ, Θ)
    ENDCASES
  MEASURE length(Δ)

  concat_assoc: THEOREM
    Γ ++ (Δ ++ Θ) = (Γ ++ Δ) ++ Θ
  length_concat: THEOREM
    length(Γ ++ Δ) = length(Γ) + length(Δ)
  concat_empty: THEOREM
    empty ++ Γ = Γ
  apply_concat: THEOREM x ∈ Γ ++ Δ IMPLIES
    (Γ ++ Δ)(x) = IF x ∈ Δ THEN Γ ++ Δ(x) ELSE Γ(x) ENDIF
  AUTO_REWRITE+ ++, concat_assoc, length_concat, concat_empty, apply_concat

  kind(Γ | 0 ∈ Γ): prekeyword = 
    CASES Γ OF
      type_decl(Δ): PRETYPE
    , type_var(Δ): PRETYPE
    , type_def(Δ, T): PRETYPE
    , const_decl(Δ, T): PRETERM
    , const_var(Δ, T): PRETERM
    , const_def(Δ, T, a): PRETERM
    , theory_def(Δ, Θ): PRECONTEXT
    ENDCASES
  AUTO_REWRITE kind

  compatible?(Γ, σ): RECURSIVE bool =
    CASES σ OF
      nil: empty?(Γ)
    , ikeep(τ): NOT empty?(Γ) AND compatible?(rest(Γ), τ)
    , itype(τ, T): type_decl?(Γ) AND compatible?(rest(Γ), τ)
    , iconst(τ, a): const_decl?(Γ) AND compatible?(rest(Γ), τ)
    ENDCASES
  MEASURE length(σ)
  AUTO_REWRITE compatible?
  compatible_length: THEOREM
    compatible?(Γ, σ) IMPLIES length(Γ) = length(σ)

  interp(Γ, (σ | compatible?(Γ, σ))): RECURSIVE precontext =
    CASES σ OF
      nil: empty
    , ikeep(τ): Γ WITH [ rest := interp(rest(Γ), τ) ]
    , itype(τ, T): type_def(interp(rest(Γ), τ), T)
    , iconst(τ, a): const_def(interp(rest(Γ), τ), type_(Γ), a)
    ENDCASES
  MEASURE length(σ)
  length_interp: THEOREM compatible?(Γ, σ) IMPLIES
    length(interp(Γ, σ)) = length(σ)
  AUTO_REWRITE length_interp

  weight(n: nat, Γ, U): RECURSIVE nat =
    CASES U OF
      v(i): IF i < n OR i >= length(Γ) THEN  0 ELSE length(Γ) - i ENDIF
    , dot(i, σ, x):
        IF i < n OR i >= length(Γ) OR i(x) >= length(σ) THEN 0
	ELSE length(Γ) - i + length(σ) - i(x) ENDIF

    , fun(A, B): max(weight(n, Γ, A), weight(n + 1, Γ ++ const_var(A), B))
    , prod(A, B): max(weight(n, Γ, A), weight(n + 1, Γ ++ const_var(A), B))
    , subtype(T, a): max(weight(n, Γ, T), weight(n + 1, Γ ++ const_var(T), a))

    , app(f, a): max(weight(n, Γ, f), weight(n, Γ, a))
    , lam(T, a): max(weight(n, Γ, T), weight(n + 1, Γ ++ const_var(T), a))
    , pair(a, b): max(weight(n, Γ, a), weight(n, Γ, b))
    , lproj(a): weight(n, Γ, a)
    , rproj(a): weight(n, Γ, a)

    , empty: 0
    , type_decl(Δ): weight(n, Γ, Δ)
    , type_var(Δ): weight(n, Γ, Δ)
    , type_def(Δ, T): max(weight(n, Γ, Δ), weight(n, Γ ++ Δ, T))
    , const_decl(Δ, T): max(weight(n, Γ, Δ), weight(n, Γ ++ Δ, T))
    , const_var(Δ, T): max(weight(n, Γ, Δ), weight(n, Γ ++ Δ, T))
    , const_def(Δ, T, a): max(weight(n, Γ, Δ), max(weight(n, Γ ++ Δ, T), weight(n, Γ ++ Δ, a)))
    , theory_def(Δ, Θ): max(weight(n, Γ, Δ), weight(n, Γ ++ Δ, Θ))

    , nil: 0
    , ikeep(σ): weight(n, Γ, σ)
    , itype(σ, T): max(weight(n, Γ, σ), weight(n, Γ, T))
    , iconst(σ, a): max(weight(n, Γ, σ), weight(n, Γ, a))
    ENDCASES
  MEASURE U BY <<
  n: VAR nat
  weight_definition: THEOREM x ∈ Γ AND x >= n IMPLIES
      weight(n + length(Δ), rest(Γ(x)) ++ Δ, U) < weight(n, Γ, v(x))

  % n: VAR nat

  % size(U): RECURSIVE nat =
  %   CASES U OF
  %     v(i): 1
  %   , dot(i, σ, x): 1

  %   , fun(A, B): size(A) + size(B) + 1
  %   , prod(A, B): size(A) + size(B) + 1
  %   , subtype(T, a): size(T) + size(a) + 1

  %   , app(f, a): size(f) + size(a) + 1
  %   , lam(T, a): size(T) + size(a) + 1
  %   , pair(a, b): size(a) + size(b) + 1
  %   , lproj(a): size(a) + 1
  %   , rproj(a): size(a) + 1

  %   , type_decl: 1
  %   , type_var: 1
  %   , type_def(T): size(T) + 1
  %   , const_decl(T): size(T) + 1
  %   , const_var(T): size(T) + 1
  %   , const_def(T, a): size(T) + size(a) + 1
  %   , theory_def(Θ): size(Θ) + 1

  %   , ikeep: 1
  %   , itype(T): size(T) + 1
  %   , iconst(a): size(a) + 1

  %   , map(f):
  %       fold(f`length, 0, 0,
  % 	     LAMBDA (res: nat, (x | x ∈ U)):
  % 	       res + size(first(U(x))))
  %   ENDCASES
  % MEASURE U BY <<

  % Δ: VAR syntaxic
END language
