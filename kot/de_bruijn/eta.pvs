eta: THEORY
BEGIN
  IMPORTING subst

  Γ, Δ: VAR (scontext?)
  σ: VAR (sinterp?)
  m: VAR nat
  S: VAR syntaxic



%  η(Γ)(Δ: pretheory(Γ), (m | m ∈ Γ AND theory_def?(Γ(m))), (σ: preinterp(Γ) | compatible?(def(Γ(m)), σ)))
%   (S: semantic(Γ ++ def(Γ(m)) ++ Δ) | NOT map?(S)): RECURSIVE
  η(Γ)(Δ, (m | m ∈ Γ AND kind?(Γ(m), PRECONTEXT)), σ)(S):
    RECURSIVE { U: syntaxic | (sexpr?(S) => sexpr?(U)) AND
                              (sdecl?(S) => sdecl?(U)) AND
			      (sinterp?(S) => sinterp?(U)) AND
			      (scontext?(S) => scontext?(U)) } =
%    { U: syntaxic | prekind?(Γ ++ Δ)(U) = prekind?(Γ ++ def(Γ(m)) ++ Δ)(S) } =
    CASES S OF
      v(i):
        IF i ∈ Δ THEN v(i)
	ELSIF (i - length(Δ)) ∈ def(Γ(m)) THEN
	  IF interpret?(σ, i - length(Δ))
	    THEN interpret(σ, i - length(Δ)) ↑ length(Δ)
	    ELSE dot(v(m + length(Δ)), σ ↑ length(Δ), i - length(Δ))
	  ENDIF
	ELSE v(i - length(def(Γ(m)))) ENDIF
    , dot(p, τ, x):
        dot(η(Γ)(Δ, m, σ)(p), η(Γ)(Δ, m, σ)(τ), x)

    , fun(A, B):
        fun(η(Γ)(Δ, m, σ)(A), η(Γ)(Δ ++ k(const_var(A)), m, σ)(B))
    , prod(A, B): prod(η(Γ)(Δ, m, σ)(A), η(Γ)(Δ ++ k(const_var(A)), m, σ)(B))
    , subtype(T, a):
        subtype(η(Γ)(Δ, m, σ)(T), η(Γ)(Δ ++ k(const_var(T)), m, σ)(a))

    , app(f, a): app(η(Γ)(Δ, m, σ)(f), η(Γ)(Δ, m, σ)(a))
    , lam(T, a): lam(η(Γ)(Δ, m, σ)(T), η(Γ)(Δ ++ k(const_var(T)), m, σ)(a))
    , pair(a, b): pair(η(Γ)(Δ, m, σ)(a), η(Γ)(Δ, m, σ)(b))
    , lproj(a): lproj(η(Γ)(Δ, m, σ)(a))
    , rproj(a): rproj(η(Γ)(Δ, m, σ)(a))

    , type_decl: type_decl
    , type_var: type_var
    , type_def(T): type_def(η(Γ)(Δ, m, σ)(T))
    , const_decl(T): const_decl(η(Γ)(Δ, m, σ)(T))
    , const_var(T): const_var(η(Γ)(Δ, m, σ)(T))
    , const_def(T, a): const_def(η(Γ)(Δ, m, σ)(T), η(Γ)(Δ, m, σ)(a))
    , theory_def(Θ): theory_def(η(Γ)(Δ, m, σ)(Θ))

    , nil: nil
    , itype(τ, i, T): itype(η(Γ)(Δ, m, σ)(τ), i, η(Γ)(Δ, m, σ)(T))
    , iconst(τ, i, a): iconst(η(Γ)(Δ, m, σ)(τ), i, η(Γ)(Δ, m, σ)(a))

    , map(f):
        map(f WITH [ `seq := LAMBDA (x: below[f`length]): η(Γ)(Δ ++ rest(S, x), m, σ)(f(x)) ])
    ENDCASES
  MEASURE size(S)

  prekind_eta: THEOREM m ∈ Γ AND kind?(Γ(m), PRECONTEXT) AND compatible?(def(Γ(m)), σ) AND prekind?(Γ)(σ)(PREINTERP) IMPLIES
    prekind?(Γ ++ Δ)(η(Γ)(Δ, m, σ)(S)) = prekind?(Γ ++ def(Γ(m)) ++ Δ)(S)
END eta
