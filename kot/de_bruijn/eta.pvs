eta: THEORY
BEGIN
  IMPORTING subst

  σ: VAR finseq[(sinterp?)]
  m: VAR nat
  S: VAR syntaxic
  Sig, ρ: VAR (stheory?)
  U, V: VAR syntaxic

%  η(Γ)(ρ: pretheory(Γ), (m | m ∈ Γ AND theory_def?(Γ(m))), (σ: preinterp(Γ) | compatible?(def(Γ(m)), σ)))
%   (S: semantic(Γ ++ def(Γ(m)) ++ ρ) | NOT map?(S)): RECURSIVE
  η(Sig)(ρ, (m | m ∈ Sig AND stheory?(Sig(m))), (σ | σ`length = length(Sig(m))))(U):
    RECURSIVE { V: syntaxic | (sexpr?(U) => sexpr?(V)) AND
			      (sinterp?(U) => sinterp?(V)) AND
			      (scontext?(U) => scontext?(V)) } =
%    { U: syntaxic | prekind?(Γ ++ ρ)(U) = prekind?(Γ ++ def(Γ(m)) ++ ρ)(S) } =
    CASES U OF
      v(i):
        IF i ∈ ρ THEN v(i)
	ELSIF (i - length(ρ)) ∈ Sig(m) THEN
	  IF ikeep?(σ`seq(i - length(ρ)))
	    THEN dot(interp(v(m + length(ρ)),
	                    σ WITH [ `seq := LAMBDA (x: below[σ`length]): σ`seq(i) ↑ length(ρ) ]),
		     Sig(m),
		     v(i - length(ρ)))
	    ELSE σ`seq(i - length(ρ)) ↑ length(ρ)
	  ENDIF
	ELSE v(i - length(Sig(m))) ENDIF
    , dot(p, Sp, x):
        dot(η(Sig)(ρ, m, σ)(p), Sp, η(Sig)(ρ, m, σ)(x))
    , interp(p, τ):
        interp(η(Sig)(ρ, m, σ)(p), τ WITH [ `seq := LAMBDA (x: below[τ`length]): η(Sig)(ρ, m, σ)(τ`seq(x)) ])

    , fun(A, B):
        fun(η(Sig)(ρ, m, σ)(A), η(Sig)(ρ ++ k(sconst_def), m, σ)(B))
    , prod(A, B): prod(η(Sig)(ρ, m, σ)(A), η(Sig)(ρ ++ k(sconst_def), m, σ)(B))
    , subtype(T, a):
        subtype(η(Sig)(ρ, m, σ)(T), η(Sig)(ρ ++ k(sconst_def), m, σ)(a))

    , app(f, a): app(η(Sig)(ρ, m, σ)(f), η(Sig)(ρ, m, σ)(a))
    , lam(T, a): lam(η(Sig)(ρ, m, σ)(T), η(Sig)(ρ ++ k(sconst_def), m, σ)(a))
    , pair(a, b): pair(η(Sig)(ρ, m, σ)(a), η(Sig)(ρ, m, σ)(b))
    , lproj(a): lproj(η(Sig)(ρ, m, σ)(a))
    , rproj(a): rproj(η(Sig)(ρ, m, σ)(a))

    , type_decl: type_decl
    , type_var: type_var
    , type_def(T): type_def(η(Sig)(ρ, m, σ)(T))
    , const_decl(T): const_decl(η(Sig)(ρ, m, σ)(T))
    , const_var(T): const_var(η(Sig)(ρ, m, σ)(T))
    , const_def(T, a): const_def(η(Sig)(ρ, m, σ)(T), η(Sig)(ρ, m, σ)(a))
    , theory_def(f):
        theory_def(f WITH [ `seq := LAMBDA (x: below[f`length]): η(Sig)(ρ ++ rest(signature(U), x), m, σ)(f`seq(x)) ])

    , ikeep: ikeep
    , itype(T): itype(η(Sig)(ρ, m, σ)(T))
    , iterm(a): iterm(η(Sig)(ρ, m, σ)(a))
    ENDCASES
  MEASURE size(U)

  % prekind_eta: THEOREM m ∈ Sig AND kind?(Sig(m), PRECONTEXT) AND compatible?(def(Sig(m)), σ) AND prekind?(Sig)(σ)(PREINTERP) IMPLIES
  %   prekind?(Sig ++ ρ)(η(Sig)(ρ, m, σ)(S)) = prekind?(Sig ++ def(Sig(m)) ++ ρ)(S)
END eta
