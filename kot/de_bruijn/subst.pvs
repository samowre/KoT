subst: THEORY
BEGIN
  IMPORTING language

  Γ, Δ, Θ: VAR precontext
  i, j, n, x: VAR nat
  U, t: VAR syntaxic
  nb: VAR [nat, nat]

  
  % Special size function defined for termination
  % of functions defined in supertype
  size(U): RECURSIVE nat =
    CASES U OF
      fun(A, B): size(A) + size(B) + 1,
      prod(A, B): size(A) + size(B) + 1,
      subtype(T, a): size(T),
      v(s): 1, 
      dot(m, σ, s): 1
      ELSE 0
    ENDCASES
  MEASURE U BY <<
  AUTO_REWRITE+ size



  



  
  % Shift: classical shift operator for De Bruijn indices
  ;↑(U, nb): RECURSIVE syntaxic = 
    CASES U OF
      % Names
      v(i): IF i < nb`2 THEN v(i) ELSE v(i + nb`1) ENDIF
    , dot(m, σ, s): IF m < nb`2 THEN dot(m, σ ↑ nb, s) ELSE dot(m + nb`1, σ ↑ nb, s) ENDIF

      % Types
    , subtype(T, a): subtype(T ↑ nb, a ↑ (nb`1, nb`2 + 1))
    , fun(A, B): fun(A ↑ nb, B ↑ (nb`1, nb`2 + 1))
    , prod(A, B): prod(A ↑ nb, B ↑ (nb`1, nb`2 + 1))

      % Terms

    , app(f, a): app(f ↑ nb, a ↑ nb)
    , lam(T, a): lam(T ↑ nb, a ↑ (nb`1, nb`2 + 1))
    , pair(a, b): pair(a ↑ nb, b ↑ nb)
    , lproj(a): lproj(a ↑ nb)
    , rproj(a): rproj(a ↑ nb)

      % Contexts
    , type_decl: type_decl
    , type_var: type_var
    , type_def(T): type_def(T ↑ nb)
    , const_decl(T): const_decl(T ↑ nb)
    , const_var(T): const_var(T ↑ nb)
    , const_def(T, a): const_def(T ↑ nb, a ↑ nb)
    , theory_def(Θ): theory_def(Θ ↑ nb)

      % Map
    , map(f): map( f WITH [`seq := LAMBDA (x: below[f`length]): 
      	      	     f(x) ↑ (nb`1, nb`2 + f`length - 1 - x)])

      % Interpretations
    , nil: nil
    , itype(σ, i, T): itype(σ ↑ nb, i, T ↑ nb)
    , iconst(σ, i, a): iconst(σ ↑ nb, i, a ↑ nb)
    ENDCASES
  MEASURE U BY <<
  AUTO_REWRITE+ ↑

  % Subtype judgements
  shift_pretype: THEOREM FORALL (Θ, Δ: pretheory(Γ)):
    pretype?(Γ ++ Θ)(U) IFF pretype?(Γ ++ Δ ++ Θ)(U ↑ (length(Δ), length(Θ)))
  shift_preterm: THEOREM FORALL (Θ, Δ: pretheory(Γ)):
    preterm?(Γ ++ Θ)(U) IFF preterm?(Γ ++ Δ ++ Θ)(U ↑ (length(Δ), length(Θ)))
  shift_printerp: THEOREM FORALL (Θ, Δ: pretheory(Γ)):
    preinterp?(Γ ++ Θ)(U) IFF preinterp?(Γ ++ Δ ++ Θ)(U ↑ (length(Δ), length(Θ)))
  shift_pretheory: THEOREM FORALL (Θ, Δ: pretheory(Γ)):
    pretheory?(Γ ++ Θ)(U) IFF pretheory?(Γ ++ Δ ++ Θ)(U ↑ (length(Δ), length(Θ)))
  shift_semantic: THEOREM FORALL (Θ, Δ: pretheory(Γ)):
    semantic?(Γ ++ Θ)(U) IFF semantic?(Γ ++ Δ ++ Θ)(U ↑ (length(Δ), length(Θ)))
  % Shift preserves size
  shift_size: THEOREM size(U ↑ nb) = size(U)
  
  % Handy rewrite
  shift_zero: THEOREM
    U ↑ (0, n) = U
  AUTO_REWRITE+ shift_zero

  ;↑(U, (n: nat)): MACRO syntaxic =
    (U ↑ (n, 0))
  length_shift: THEOREM
    length(Γ ↑ nb) = length(Γ)
  shift_plus: THEOREM
    (U ↑ (i, n)) ↑ (j, n) = U ↑ (i + j, n)
  AUTO_REWRITE+ shift_plus


  % This is a "true" substitution - this really removes the bound variable.
  % Outer variables see their index decreased.
  % Definition 2.15, 4.3, modified for the De Bruijn index
  subst(U, x, t): RECURSIVE syntaxic =
    CASES U OF
      % n ↦ t
      % x ↦ x where the λ-binder for n has been removed
      v(i): IF i > x THEN v(i - 1) ELSIF i = x THEN t ELSE v(i) ENDIF
      % /!\ Case x = m not handled
    , dot(m, σ, s): dot(m, subst(σ, x, t), s)

      % { y:  T | a } ↦      { y:   T[ x ← t]    |   a[   x  ←   t ] }
      %                        λ——————————————————————\___________/
    , subtype(T,  a): subtype(subst(T, x,  t), subst(a, x + 1, t ↑ 1))
      % [i: A → B] ↦ [ i:   A[ x ← t] →      B[   x  ←   t  ]]
      %                λ——————————————————————\_____________/
    , fun(  A,  B):  fun(subst(A, x,  t), subst(B, x + 1, t ↑ 1))
      % [i: A, B] ↦ [i:    A[ x ← t],       B[   x  ←   t  ]]
      %              λ———————————————————————\_____________/
    , prod( A, B):  prod(subst(A, x,  t), subst(B, x + 1, t ↑ 1))

      %   f  a ↦           f[ x ← t]        a[ x ← t]
    , app(f, a): app(subst(f, x,  t), subst(a, x,  t))
      % λ(y: T): a ↦ λ(y:      T[ x ← t]):      a[   x  ←   t  ]
      %                λ————————————————————————–\_____________/
    , lam(   T,  a): lam(subst(T, x,  t), subst(a, x + 1, t ↑ 1))
      %   (a, b) ↦ (       a[ x ← t],       b[ x ← t] )
    , pair(a, b):  pair(subst(a, x,  t), subst(b, x,  t))
      %  p₁ a ↦ p₁          a[ x ← t]
    , lproj(a): lproj(subst(a, x,  t))
      %  p₂ a ↦ p₂          a[ x ← t]
    , rproj(a): rproj(subst(a, x,  t))

      % Decls
    , type_decl: type_decl
    , type_var: type_var
    , type_def(T): type_def(subst(T, x, t))
    , const_decl(T): const_decl(subst(T, x, t))
    , const_var(T): const_var(subst(T, x, t))
    , const_def(T, a): const_def(subst(T, x, t), subst(a, x, t))
    , theory_def(Θ): theory_def(subst(Θ, x, t))

      % Map
    , map(f): map(f WITH [`seq := LAMBDA (y: below[f`length]): subst(f(y), x + f`length - 1 - y, t ↑ (f`length - 1 - y))]) 

      % Interpretations
    , nil: nil
    , itype(σ, i, T): itype(subst(σ, x, t), i, subst(T, x, t))
    , iconst(σ, i, a): iconst(subst(σ, x, t), i, subst(a, x, t))
    ENDCASES
  MEASURE U BY <<
  AUTO_REWRITE subst

  % Judgements
  subst_pretype: THEOREM FORALL (Δ: pretheory(Γ), Tx: pretype(Γ)):
    pretype?(Γ ++ k(const_var(Tx)) ++ Δ)(U) AND
    preterm?(Γ ++ Δ)(t) IMPLIES 
    pretype?(Γ ++ subst(Δ, length(Δ), t))(subst(U, length(Δ), t))
  subst_preterm: THEOREM FORALL (Δ: pretheory(Γ), Tx: pretype(Γ)):
    preterm?(Γ ++ k(const_var(Tx)) ++ Δ)(U) AND
    preterm?(Γ ++ Δ)(t) IMPLIES 
    preterm?(Γ ++ subst(Δ, x, t))(subst(U, length(Δ), t))
  subst_preinterp: THEOREM FORALL (Δ: pretheory(Γ), Tx: pretype(Γ)):
    preinterp?(Γ ++ k(const_var(Tx)) ++ Δ)(U) AND
    preterm?(Γ ++ Δ)(t) IMPLIES 
    preinterp?(Γ ++ subst(Δ, x, t))(subst(U, length(Δ), t))
  subst_pretheory: THEOREM FORALL (Δ: pretheory(Γ), Tx: pretype(Γ)):
    preinterp?(Γ ++ k(const_var(Tx)) ++ Δ)(U) AND
    preterm?(Γ ++ Δ)(t) IMPLIES 
    pretheory?(Γ ++ subst(Δ, x, t))(subst(U, length(Δ), t))
  subst_semantic: THEOREM FORALL (Δ: pretheory(Γ), Tx: pretype(Γ)):
    preinterp?(Γ ++ k(const_var(Tx)) ++ Δ)(U) AND
    preterm?(Γ ++ Δ)(t) IMPLIES 
    semantic?(Γ ++ subst(Δ, x, t))(subst(U, length(Δ), t))

  subst_size: THEOREM
    size(subst(U, x, t)) = size(U)
  AUTO_REWRITE subst_size

END subst
