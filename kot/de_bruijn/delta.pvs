delta: THEORY
BEGIN
  IMPORTING subst, interp

  Γ, Δ: VAR finseq[(scontext?)]
  Θ: VAR finseq[(scontext?)]
  U, V: VAR syntaxic
  x: VAR nat
  σ, τ: VAR finseq[(sinterp?)]
  n: VAR nat
  m: VAR (sexpr?)
  a: VAR (sexpr?)
  S: VAR finseq[(scontext?)]
  
%  w: [finseq[(scontext?)], syntaxic -> ordinal]

  ;≡(Γ, Δ): bool =
    length(Γ) = length(Δ) AND
    FORALL (x: below[length(Γ)]):
      (type_decl?(Γ(x)) => type_decl?(Δ(x))) AND
      (type_var?(Γ(x)) => type_var?(Δ(x))) AND
      (type_def?(Γ(x)) => type_def?(Δ(x))) AND
      (const_decl?(Γ(x)) => const_decl?(Δ(x))) AND
      (const_var?(Γ(x)) => const_var?(Δ(x))) AND
      (const_def?(Γ(x)) => const_def?(Δ(x))) AND
      (theory_def?(Γ(x)) => theory_def?(Δ(x)))
      
  η(m, n)(U): RECURSIVE same(U) =
    IF n = 0 THEN U
    ELSE η(m, n - 1)(subst(U, n - 1, dot(m ↑ (n - 1), v(n - 1))))
    ENDIF
  MEASURE n
  AUTO_REWRITE+ sexpr?, scontext?, sinterp?
  η(m, n)(l: list[(sexpr?)]): RECURSIVE list[(sexpr?)] =
    CASES l OF
      null: null
    , cons(h, t): cons(η(m, n)(h), η(m, n)(t))
    ENDCASES
  MEASURE length(l)

  % wdef: AXIOM x < length(Γ) AND definition?(Γ(x)) IMPLIES
  %   w(rest(Γ, x), def(Γ(x))) < w(Γ, v(x))
  % wdot: AXIOM
  %   w(Γ, m) < w(Γ, dot(m, a))
  % winterp: AXIOM
  %   w(Γ, m) < w(Γ, interp(m, σ))
  % wrest: AXIOM
  %   w(Γ, U ↑ x) <= w(rest(Γ, x), U)
  % wtheory: AXIOM
  %   w(Θ, m) < w(Γ, theory_(Θ))
  % winterpret: AXIOM compatible?(Θ, σ) IMPLIES
  %   w(Γ, theory_(interpret(Θ, σ))) < w(Γ, interp(theory_(Θ), σ))

  % max(len: nat, f: [below[len] -> nat]):
  %   RECURSIVE { n: nat | FORALL (x: below[len]): f(x) <= n } =
  %   IF len = 0 THEN 0
  %   ELSE max(f(len - 1), max(len - 1, LAMBDA (x: below[len - 1]): f(x))) ENDIF
  % MEASURE len

  % w(Γ, U): RECURSIVE nat =
  %   CASES U OF
  %     v(x):
  %       IF x < length(Γ)
  % 	  THEN IF definition?(Γ(x))
  % 	    THEN w(rest(Γ, x), def(Γ(x))) + 1
  % 	    ELSE 1
  % 	  ENDIF
  % 	  ELSE 0
  % 	ENDIF
  %   , dot(m, x):
  %       w(Γ, m) + w(Γ, x) + 1 % TODO !!!
  %   , interp(m, σ): w(Γ, m) + 1
  %   , theory_(Θ): 0

  %   , fun(A, B): max(w(Γ, A),  w(Γ ++ k(const_var(A)), B)) + 1
  %   , prod(A, B): max(w(Γ, A),  w(Γ ++ k(const_var(A)), B)) + 1
  %   , subtype(T, a): max(w(Γ, T),  w(Γ ++ k(const_var(T)), a)) + 1

  %   , app(f, a): max(w(Γ, f), w(Γ, a))
  %   , lam(T, a): max(w(Γ, T), w(Γ ++ k(const_var(T)), a)) + 1
  %   , pair(a, b): max(w(Γ, a), w(Γ, b)) + 1
  %   , lproj(a): w(Γ, a) + 1
  %   , rproj(a): w(Γ, a) + 1

  %   , type_decl: 1
  %   , type_var: 1
  %   , type_def(T): w(Γ, T) + 1
  %   , const_decl(T): w(Γ, T) + 1
  %   , const_var(T): w(Γ, T) + 1
  %   , const_def(T, a): max(w(Γ, T), w(Γ, a)) + 1
  %   , theory_def(Th): w(Γ, Th) + 1

  %   , ikeep: 1
  %   , itype(T): w(Γ, T) + 1
  %   , iterm(a): w(Γ, a) + 1
  %   ENDCASES
  % MEASURE sum(length(Γ), LAMBDA (x: below[length(Γ)]): size(Γ(x))) + size(U)

  constrs_at_end(τ, (σ | length(σ) >= length(τ))): bool =
    FORALL (x: below[length(τ)]):
      LET pos = length(σ) - length(τ) + x IN
      (ikeep?(τ(x)) AND ikeep?(σ(pos))) OR
      (itype?(τ(x)) AND itype?(σ(pos))) OR
      (iterm?(τ(x)) AND iterm?(σ(pos)))

  on_interp(σ, (n: nat | n <= length(σ)),
            f: [ x: { τ | length(τ) < length(σ) AND constrs_at_end(τ, σ) } ->
                 { τ | length(τ) = length(x) + 1 AND constrs_at_end(τ, σ) }]):
    RECURSIVE { τ | length(τ) = n AND constrs_at_end(τ, σ) } =
    IF n = 0
      THEN empty_seq
      ELSE f(on_interp(σ, n - 1, f))
    ENDIF
  MEASURE n

  same_interp(U): TYPE = { V | (sexpr?(U) => sexpr?(V)) AND
                               (ikeep?(U) => ikeep?(V)) AND
			       (itype?(U) => itype?(V)) AND
			       (iterm?(U) => iterm?(V)) AND
			       (scontext?(U) => scontext?(V)) }

  expand(ths?: bool)(Γ, U): RECURSIVE same_interp(U) = % todo: ikeep, itype, iterm preserved
    CASES U OF
      v(x):
        IF x < length(Γ) AND definition?(Γ(x)) AND (ths? OR NOT theory_def?(Γ(x)))
  	  THEN def(Γ(x)) ↑ (x + 1)
  	  ELSE U
  	ENDIF
    , dot(m, x):
        CASES expand(TRUE)(Γ, m) OF
  	  theory_(Θ): η(m, length(Θ))(expand(ths?)(Γ ++ Θ, x))
  	  ELSE U
  	ENDCASES
    , interp(m, σ):
        CASES expand(ths?)(Γ, m) OF
  	  theory_(Θ):
  	    IF compatible?(Θ, σ)
  	      THEN
	        theory_(interpret(Θ, on_interp(σ, length(σ),
		  LAMBDA (τ | length(τ) < length(σ) AND constrs_at_end(τ, σ)):
		    LET pos = length(σ) - length(τ) - 1 IN
		    (: expand(ths?)(Γ ++ interpret(rest(Θ, pos), τ), σ(pos)) :) o τ)))
  	      ELSE U
  	    ENDIF
  	  ELSE U
  	ENDCASES
    , theory_(Θ):
        IF length(Θ) = 0
	  THEN U
	  ELSE
	    CASES expand(ths?)(Γ, theory_(rest(Θ, 0))) OF
	      theory_(Δ): theory_(Δ ++ k(expand(ths?)(Γ ++ Δ, Θ(0))))
	      ELSE U
	    ENDCASES
	ENDIF

    , fun(A, B):
        LET eA = expand(ths?)(Γ, A) IN
	fun(eA, expand(ths?)(Γ ++ k(const_decl(eA)), B))
    , prod(A, B):
        LET eA = expand(ths?)(Γ, A) IN
	prod(eA, expand(ths?)(Γ ++ k(const_decl(eA)), B))
    , subtype(T, a):
        LET eT = expand(ths?)(Γ, T) IN
	subtype(eT, expand(ths?)(Γ ++ k(const_decl(eT)), a))

    , app(f, a): app(expand(ths?)(Γ, f), expand(ths?)(Γ, a))
    , lam(T, a):
        LET eT = expand(ths?)(Γ, T) IN
	lam(eT, expand(ths?)(Γ ++ k(const_decl(eT)), a))
    , pair(a, b): pair(expand(ths?)(Γ, a), expand(ths?)(Γ, b))
    , lproj(a): lproj(expand(ths?)(Γ, a))
    , rproj(a): lproj(expand(ths?)(Γ, a))

    , ikeep: ikeep
    , itype(T): itype(expand(ths?)(Γ, T))
    , iterm(a): iterm(expand(ths?)(Γ, a))

    , type_decl: type_decl
    , type_var: type_var
    , type_def(T): type_def(expand(ths?)(Γ, T))
    , const_decl(T): const_decl(expand(ths?)(Γ, T))
    , const_var(T): const_var(expand(ths?)(Γ, T))
    , const_def(T, a): const_def(expand(ths?)(Γ, T), expand(ths?)(Γ, a))
    , theory_def(Th): theory_def(expand(ths?)(Γ, Th))
    ENDCASES
  MEASURE size(U)

  % expand_theory: THEOREM FORALL (ths?: bool):
  %   expand(ths?)(Γ, theory_(Θ)) =
  %     theory_(Θ WITH [ `seq := LAMBDA (x: below[length(Θ)]):
  %       expand(ths?)(Γ ++ decls(expand(ths?)(Γ, theory_(rest(Θ, x)))), Θ(x)) ])

  % expand_interp: THEOREM F
  %   expand(ths?)(Γ, interp(m, σ)) =
  %     CASES expand(ths?)(Γ, m) OF
  %       theory_(Θ):
  % 	  IF compatible?(Θ, σ)
  % 	    THEN expand(ths?)(Γ, theory_(interpret(Θ, σ)))
  % 	    ELSE U
  % 	  ENDIF
  % 	ELSE U
  %     ENDCASES

  expansions(Γ, U):
    RECURSIVE nat =
    CASES U OF
      v(x):
        IF x < length(Γ) AND definition?(Γ(x))
	  THEN 1
	  ELSE 0
	ENDIF
    , dot(m, x):
        expansions(Γ, m) +
        CASES expand(TRUE)(Γ, m) OF
    	  theory_(Θ): expansions(Γ ++ Θ, x)
    	  ELSE 0
    	ENDCASES
    , interp(m, σ):
        expansions(Γ, m) +
        CASES expand(TRUE)(Γ, m) OF
    	  theory_(Θ):
    	    IF compatible?(Θ, σ)
    	      THEN
	        sum(length(σ), LAMBDA (x: below[length(σ)]):
		  expansions(Γ ++ decls(expand(TRUE)(Γ, theory_(interpret(rest(Θ, x), rest(σ, x))))), σ(x)))
    	      ELSE 0
    	    ENDIF
    	  ELSE 0
    	ENDCASES
    , theory_(Θ):
        IF length(Θ) = 0
    	  THEN 0
    	  ELSE
    	    expansions(Γ, theory_(rest(Θ, 0))) +
    	    CASES expand(TRUE)(Γ, theory_(rest(Θ, 0))) OF
    	      theory_(Δ): expansions(Γ ++ Δ, Θ(0))
    	      ELSE 0
    	    ENDCASES
    	ENDIF

    , fun(A, B):
    	expansions(Γ, A) + expansions(Γ ++ k(const_decl(expand(TRUE)(Γ, A))), B)
    , prod(A, B):
    	expansions(Γ, A) + expansions(Γ ++ k(const_decl(expand(TRUE)(Γ, A))), B)
    , subtype(T, a):
    	expansions(Γ, T) + expansions(Γ ++ k(const_decl(expand(TRUE)(Γ, T))), a)

    , app(f, a): expansions(Γ, f) + expansions(Γ, a)
    , lam(T, a):
    	expansions(Γ, T) + expansions(Γ ++ k(const_decl(expand(TRUE)(Γ, T))), a)
    , pair(a, b): expansions(Γ, a) + expansions(Γ, b)
    , lproj(a): expansions(Γ, a)
    , rproj(a): expansions(Γ, a)

    , ikeep: 0
    , itype(T): expansions(Γ, T)
    , iterm(a): expansions(Γ, a)

    , type_decl: 0
    , type_var: 0
    , type_def(T): expansions(Γ, T)
    , const_decl(T): expansions(Γ, T)
    , const_var(T): expansions(Γ, T)
    , const_def(T, a): expansions(Γ, T) + expansions(Γ, a)
    , theory_def(Th): expansions(Γ, Th)
    ENDCASES
  MEASURE size(U)

  expand(Γ): { Δ | Δ ≡ Γ } =
    decls(expand(TRUE)(empty_seq, theory_(Γ)))

  % expand(Γ): finseq[(scontext?)] =
  %   decls(expand(TRUE)(empty_seq, theory_(Γ)))

  % expand_length: THEOREM
  %   length(expand(Γ)) = length(Γ)

  % expand_equiv: THEOREM
  %   FORALL x: expand(Γ)(x) AND Γ(x) have the same constructors

  % expansions((p: pred[syntaxic] | FORALL U: p(U) => definition?(U)), Γ): nat =
  %   expansions(empty_seq, theory_(Γ))

  % real_exp(p, Γ, U) =
  %   expansions(Γ) + expansions(expand(Γ), U)

  % expansions_concat: THEOREM
  %   expansions(Γ ++ Δ) = expansions(Γ) + expansions(expand(Γ), Δ)

  % real_exp_def: THEOREM
  %   real_exp(p, Γ, v(x)) <= 1 + real_exp(p, rest(Γ, x), def(Γ(x)))

  % expand_rest: THEOREM
  %   expand(rest(Γ, x)) = rest(expand(Γ), x)

  % expansions_shift: THEOREM
  %   expansions(Γ, U ↑ (x + 1)) = expansions(rest(Γ, x), U)

  % ρ(Γ)(U): RECURSIVE
  %   { V: same(U) | expansions(theory_def?, expand(Γ), V) <= expansions(theory_def?, expand(Γ), U) } =
  %   CASES U OF
  %     v(x):
  %       IF x < length(Γ) AND theory_def?(Γ(x))
  % 	  THEN ρ(rest(Γ, x))(def(Γ(x))) ↑ (x + 1)
  % 	  ELSE U
  % 	ENDIF
  %   , dot(m, x):
  %       CASES ρ(Γ)(m) OF
  % 	  theory_(Θ): η(m, length(Θ))(ρ(Γ ++ Θ)(x))
  % 	  ELSE U
  % 	ENDCASES
  %   , interp(m, σ):
  %       CASES ρ(Γ)(m) OF
  % 	  theory_(Θ): theory_(interpret(Θ, σ))
  % 	  ELSE U
  % 	ENDCASES

  %     ELSE U
  %   ENDCASES
  % MEASURE expansions(theory_def?, Γ) + expansions(theory_def?, expand(Γ), U)

  % δ(Γ)(U): RECURSIVE same(U) =
  %   CASES U OF
  %     v(x):
  %       IF x < length(Γ) AND definition?(Γ(x)) AND NOT theory_def?(Γ(x))
  % 	  THEN δ(rest(Γ, x), def(Γ(x))) ↑ (x + 1)
  % 	  ELSE U
  % 	ENDIF
  %   , dot(m, x):
  %       CASES signature(Γ, m) OF
  % 	  theory_(Θ): η(m, length(Θ))(δ(Γ ++ Θ, x))
  % 	  ELSE U
  % 	ENDCASES
  %   , interp(m, σ):

  signature(Γ, U): same(U) =
    expand(TRUE)(decls(expand(TRUE)(empty_seq, theory_(Γ))), U)

  δ0(Γ)(U): same(U) =
    expand(FALSE)(Γ, U)

  δ(Γ)(U): same(U) =
    expand(FALSE)(decls(expand(FALSE)(empty_seq, theory_(Γ))), U)

  % signature(Γ, U): RECURSIVE same(U) =
  %   CASES U OF
  %     v(x):
  %       IF x < length(Γ) AND theory_def?(Γ(x))
  % 	  THEN signature(rest(Γ, x), def(Γ(x))) ↑ (x + 1)
  % 	  ELSE U
  % 	ENDIF
  %   , dot(m, x):
  %       CASES signature(Γ, m) OF
  % 	  theory_(Θ): η(theory_(Θ), length(Θ))(signature(Γ ++ Θ, x))
  % 	  ELSE U
  % 	ENDCASES
  %   , interp(m, σ):
  %       CASES signature(Γ, m) OF
  % 	  theory_(Θ):
  % 	    IF compatible?(Θ, σ)
  % 	      THEN theory_(interpret(Θ, σ))
  % 	      ELSE interp(signature(Γ, m), σ)
  % 	    ENDIF
  % 	  ELSE interp(signature(Γ, m), σ)
  % 	ENDCASES
  %   ELSE U
  %   ENDCASES
  % MEASURE sum(length(Γ), LAMBDA (x: below[length(Γ)]): size(Γ(x))) + size(U)

  % δ(Γ)(U): RECURSIVE
  %   { V: same(U) | w(Γ, V) <= w(Γ, U) } =
  %   CASES U OF
  %     v(x):
  %       IF x < length(Γ) AND definition?(Γ(x))
  % 	  THEN δ(rest(Γ, x))(def(Γ(x))) ↑ (x + 1)
  % 	  ELSE U
  % 	ENDIF
  %   , dot(m, x):
  %       CASES signature(Γ, m) OF
  % 	  theory_(Θ): η(m, length(Θ))(δ(Γ ++ Θ)(x))
  % 	  ELSE U
  % 	ENDCASES

  %   , fun(A, B): fun(δ(Γ)(A), δ(Γ ++ k(const_var(δ(Γ)(A))))(B))
  %   , prod(A, B): prod(δ(Γ)(A), δ(Γ ++ k(const_var(δ(Γ)(A))))(B))
  %   , subtype(T, a): subtype(δ(Γ)(T), a)

  %     ELSE U
  %   ENDCASES
  % MEASURE sum(length(Γ), LAMBDA (x: below[length(Γ)]): size(Γ(x))) + size(U)
  % AUTO_REWRITE- sexpr?, scontext?, sinterp?
END delta
