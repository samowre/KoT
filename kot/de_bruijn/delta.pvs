delta: THEORY
BEGIN
  IMPORTING subst, interp

  Γ: VAR finseq[(scontext?)]
  Θ: VAR finseq[(scontext?)]
  U, V: VAR syntaxic
  x: VAR nat
  σ: VAR finseq[(sinterp?)]
  n: VAR nat
  m: VAR (sexpr?)
  a: VAR (sexpr?)
  S: VAR finseq[(scontext?)]
  
%  w: [finseq[(scontext?)], syntaxic -> ordinal]


  η(m, S, n)(U): RECURSIVE same(U) =
    IF n = 0 THEN U
    ELSE
      LET S2 = S WITH [ `seq := LAMBDA (x: below[length(S)]): S(x) ↑ (length(S) + n - 1 - x) ] IN
      η(m, S, n - 1)(subst(U, n - 1, dot(m ↑ (n - 1), S2, v(n - 1))))
    ENDIF
  MEASURE n
  AUTO_REWRITE+ sexpr?, scontext?, sinterp?
  η(m, S, n)(l: list[(sexpr?)]): RECURSIVE list[(sexpr?)] =
    CASES l OF
      null: null
    , cons(h, t): cons(η(m, S, n)(h), η(m, S, n)(t))
    ENDCASES
  MEASURE length(l)

  % wdef: AXIOM x < length(Γ) AND definition?(Γ(x)) IMPLIES
  %   w(rest(Γ, x), def(Γ(x))) < w(Γ, v(x))
  % wdot: AXIOM
  %   w(Γ, m) < w(Γ, dot(m, a))
  % winterp: AXIOM
  %   w(Γ, m) < w(Γ, interp(m, σ))
  % wrest: AXIOM
  %   w(Γ, U ↑ x) <= w(rest(Γ, x), U)
  % wtheory: AXIOM
  %   w(Θ, m) < w(Γ, theory_(Θ))
  % winterpret: AXIOM compatible?(Θ, σ) IMPLIES
  %   w(Γ, theory_(interpret(Θ, σ))) < w(Γ, interp(theory_(Θ), σ))

  max(len: nat, f: [below[len] -> nat]):
    RECURSIVE { n: nat | FORALL (x: below[len]): f(x) <= n } =
    IF len = 0 THEN 0
    ELSE max(f(len - 1), max(len - 1, LAMBDA (x: below[len - 1]): f(x))) ENDIF
  MEASURE len

  w(Γ, U): RECURSIVE nat =
    CASES U OF
      v(x):
        IF x < length(Γ)
	  THEN IF definition?(Γ(x))
	    THEN w(rest(Γ, x), def(Γ(x))) + 1
	    ELSE 1
	  ENDIF
	  ELSE 0
	ENDIF
    , dot(m, S, x):
        w(Γ, m) + w(Γ ++ S, x) + 1
    , interp(m, σ): w(Γ, m) + 1
    , theory_(Θ): 0

    , fun(A, B): max(w(Γ, A),  w(Γ ++ k(const_var(A)), B)) + 1
    , prod(A, B): max(w(Γ, A),  w(Γ ++ k(const_var(A)), B)) + 1
    , subtype(T, a): max(w(Γ, T),  w(Γ ++ k(const_var(T)), a)) + 1

    , app(f, a): max(w(Γ, f), w(Γ, a))
    , lam(T, a): max(w(Γ, T), w(Γ ++ k(const_var(T)), a)) + 1
    , pair(a, b): max(w(Γ, a), w(Γ, b)) + 1
    , lproj(a): w(Γ, a) + 1
    , rproj(a): w(Γ, a) + 1

    , type_decl: 1
    , type_var: 1
    , type_def(T): w(Γ, T) + 1
    , const_decl(T): w(Γ, T) + 1
    , const_var(T): w(Γ, T) + 1
    , const_def(T, a): max(w(Γ, T), w(Γ, a)) + 1
    , theory_def(Th): w(Γ, Th) + 1

    , ikeep: 1
    , itype(T): w(Γ, T) + 1
    , iterm(a): w(Γ, a) + 1
    ENDCASES
  MEASURE sum(length(Γ), LAMBDA (x: below[length(Γ)]): size(Γ(x))) + size(U)

  δ(Γ)(U): RECURSIVE
    { V: same(U) | w(Γ, V) <= w(Γ, U) } =
    CASES U OF
      v(x):
        IF x < length(Γ) AND type_def?(Γ(x)) OR const_def?(Γ(x))
	  THEN δ(rest(Γ, x))(def(Γ(x))) ↑ (x + 1)
	  ELSE U
	ENDIF
    , dot(m, S, x):
        IF δ(Γ ++ S)(x) = x
	  THEN dot(δ(Γ)(m), S, x)
	  ELSE δ(Γ)(η(δ(Γ)(m), S, length(S))(δ(Γ ++ S)(x)))
	ENDIF
    , interp(m, σ): interp(δ(Γ)(m), σ)
        % CASES δ(Γ)(m) OF
	%   theory_(Θ):
	%     IF compatible?(Θ, σ)
	%       THEN δ(Γ)(theory_(interpret(Θ, σ)))
	%       ELSE interp(m, σ) % Shouldn't happen, but hard to prove it
	%     ENDIF
	%   ELSE interp(δ(Γ)(m), σ)
	% ENDCASES
%     , theory_(Θ): theory_(Θ)
% %        theory_(Θ WITH [ `seq := LAMBDA (x: below[length(Θ)]): δ(Γ ++ rest(Θ, x))(Θ(x)) ])

%     , fun(A, B): fun(δ(Γ)(A), δ(Γ ++ k(const_var(δ(Γ)(A))))(B))
%     , prod(A, B): prod(δ(Γ)(A), δ(Γ ++ k(const_var(δ(Γ)(A))))(B))
%     , subtype(T, a): subtype(δ(Γ)(T), a)

%     , type_decl: type_decl
%     , type_var: type_var
%     , type_def(T): type_def(δ(Γ)(T))
%     , const_decl(T): const_decl(δ(Γ)(T))
%     , const_var(T): const_var(δ(Γ)(T))
%     , const_def(T, a): const_def(δ(Γ)(T), a)
%     , theory_def(Th): theory_def(δ(Γ)(Th))

      ELSE U
    ENDCASES
  MEASURE w(Γ, U)
  AUTO_REWRITE- sexpr?, scontext?, sinterp?
END delta
