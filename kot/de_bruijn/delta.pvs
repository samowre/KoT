delta: THEORY
BEGIN
  IMPORTING subst, interp

  Γ: VAR finseq[(scontext?)]
  Θ: VAR finseq[(scontext?)]
  U, V: VAR syntaxic
  x: VAR nat
  σ: VAR finseq[(sinterp?)]
  n: VAR nat
  m: VAR (sexpr?)
  a: VAR (sexpr?)
  S: VAR finseq[(scontext?)]
  
%  w: [finseq[(scontext?)], syntaxic -> ordinal]


  η(m, n)(U): RECURSIVE same(U) =
    IF n = 0 THEN U
    ELSE η(m, n - 1)(subst(U, n - 1, dot(m ↑ (n - 1), v(n - 1))))
    ENDIF
  MEASURE n
  AUTO_REWRITE+ sexpr?, scontext?, sinterp?
  η(m, n)(l: list[(sexpr?)]): RECURSIVE list[(sexpr?)] =
    CASES l OF
      null: null
    , cons(h, t): cons(η(m, n)(h), η(m, n)(t))
    ENDCASES
  MEASURE length(l)

  % wdef: AXIOM x < length(Γ) AND definition?(Γ(x)) IMPLIES
  %   w(rest(Γ, x), def(Γ(x))) < w(Γ, v(x))
  % wdot: AXIOM
  %   w(Γ, m) < w(Γ, dot(m, a))
  % winterp: AXIOM
  %   w(Γ, m) < w(Γ, interp(m, σ))
  % wrest: AXIOM
  %   w(Γ, U ↑ x) <= w(rest(Γ, x), U)
  % wtheory: AXIOM
  %   w(Θ, m) < w(Γ, theory_(Θ))
  % winterpret: AXIOM compatible?(Θ, σ) IMPLIES
  %   w(Γ, theory_(interpret(Θ, σ))) < w(Γ, interp(theory_(Θ), σ))

  max(len: nat, f: [below[len] -> nat]):
    RECURSIVE { n: nat | FORALL (x: below[len]): f(x) <= n } =
    IF len = 0 THEN 0
    ELSE max(f(len - 1), max(len - 1, LAMBDA (x: below[len - 1]): f(x))) ENDIF
  MEASURE len

  w(Γ, U): RECURSIVE nat =
    CASES U OF
      v(x):
        IF x < length(Γ)
	  THEN IF definition?(Γ(x))
	    THEN w(rest(Γ, x), def(Γ(x))) + 1
	    ELSE 1
	  ENDIF
	  ELSE 0
	ENDIF
    , dot(m, x):
        w(Γ, m) + w(Γ, x) + 1 % TODO !!!
    , interp(m, σ): w(Γ, m) + 1
    , theory_(Θ): 0

    , fun(A, B): max(w(Γ, A),  w(Γ ++ k(const_var(A)), B)) + 1
    , prod(A, B): max(w(Γ, A),  w(Γ ++ k(const_var(A)), B)) + 1
    , subtype(T, a): max(w(Γ, T),  w(Γ ++ k(const_var(T)), a)) + 1

    , app(f, a): max(w(Γ, f), w(Γ, a))
    , lam(T, a): max(w(Γ, T), w(Γ ++ k(const_var(T)), a)) + 1
    , pair(a, b): max(w(Γ, a), w(Γ, b)) + 1
    , lproj(a): w(Γ, a) + 1
    , rproj(a): w(Γ, a) + 1

    , type_decl: 1
    , type_var: 1
    , type_def(T): w(Γ, T) + 1
    , const_decl(T): w(Γ, T) + 1
    , const_var(T): w(Γ, T) + 1
    , const_def(T, a): max(w(Γ, T), w(Γ, a)) + 1
    , theory_def(Th): w(Γ, Th) + 1

    , ikeep: 1
    , itype(T): w(Γ, T) + 1
    , iterm(a): w(Γ, a) + 1
    ENDCASES
  MEASURE sum(length(Γ), LAMBDA (x: below[length(Γ)]): size(Γ(x))) + size(U)

  signature(Γ, U): RECURSIVE same(U) =
    CASES U OF
      v(x):
        IF x < length(Γ) AND theory_def?(Γ(x))
	  THEN signature(rest(Γ, x), def(Γ(x))) ↑ (x + 1)
	  ELSE U
	ENDIF
    , dot(m, x):
        CASES signature(Γ, m) OF
	  theory_(Θ): η(theory_(Θ), length(Θ))(signature(Γ ++ Θ, x))
	  ELSE U
	ENDCASES
    , interp(m, σ):
        CASES signature(Γ, m) OF
	  theory_(Θ):
	    IF compatible?(Θ, σ)
	      THEN theory_(interpret(Θ, σ))
	      ELSE interp(signature(Γ, m), σ)
	    ENDIF
	  ELSE interp(signature(Γ, m), σ)
	ENDCASES
    ELSE U
    ENDCASES
  MEASURE sum(length(Γ), LAMBDA (x: below[length(Γ)]): size(Γ(x))) + size(U)

  δ(Γ)(U): RECURSIVE
    { V: same(U) | w(Γ, V) <= w(Γ, U) } =
    CASES U OF
      v(x):
        IF x < length(Γ) AND definition?(Γ(x))
	  THEN δ(rest(Γ, x))(def(Γ(x))) ↑ (x + 1)
	  ELSE U
	ENDIF
    , dot(m, x):
        CASES signature(Γ, m) OF
	  theory_(Θ): η(m, length(Θ))(δ(Γ ++ Θ)(x))
	  ELSE U
	ENDCASES

    , fun(A, B): fun(δ(Γ)(A), δ(Γ ++ k(const_var(δ(Γ)(A))))(B))
    , prod(A, B): prod(δ(Γ)(A), δ(Γ ++ k(const_var(δ(Γ)(A))))(B))
    , subtype(T, a): subtype(δ(Γ)(T), a)

      ELSE U
    ENDCASES
  MEASURE sum(length(Γ), LAMBDA (x: below[length(Γ)]): size(Γ(x))) + size(U)
  AUTO_REWRITE- sexpr?, scontext?, sinterp?
END delta
