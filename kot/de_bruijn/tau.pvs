tau: THEORY
BEGIN
  IMPORTING subst, interp, supertype, delta, init_context

  % TODO:
  % note: the function tau is defined only on what can	
  % be a PVS expression on its own, not on subterms of such.
  % Therefore tau is not defined on the following constructors
  %  - interp, that should only occur on a dot left hand side
  %    (until we handle first-class theory)
  %  - all constructors of subtype (scontext?) except stheory
  %    since they can only occur in a stheory itself (i.e a context)
  %  - all constructors of subtype (sinterp?) since they must occur
  %    only in the right hand side of a interp constructor.
  AUTO_REWRITE+ sexpr?

  % Variable declaration
  Γ, Δ, Θ: VAR (admissible?)
  M, N: VAR (scontext?)
  U, V: VAR syntaxic
  A, B, T: VAR (sexpr?)
  %n, m: VAR name
  x, y, z: VAR nat
  a, b, f, g: VAR (sexpr?)
  %S: VAR semantic
  S: VAR finseq[(scontext?)]
  n: VAR nat
  m: VAR (sexpr?)

  %% Type TCCS 
  pretcc: TYPE = (sexpr?)

  %%% Type keyword
  keyword: DATATYPE
  BEGIN
    ⊥: UNDEFINED?
    KTHEORY: KTHEORY?
    KDECL: KDECL?
    KTYPE: KTYPE?
    KTERM(TYPEOF: (sexpr?)): KTERM?
  END keyword

  ;++(l1, l2: list[pretcc]): list[pretcc] = append(l1, l2)
  CONVERSION- finseq2list, extract1
  π(A)(a)(n): list[(sexpr?)] =
    cons( app(π(A)(n), a), null)
  fail: [keyword, list[pretcc]] = (⊥, null)
  k: VAR keyword
    
  η(m, n)(k): keyword = 
    CASES k OF
      ⊥: ⊥,
      KTHEORY: KTHEORY,
      KDECL: KDECL,
      KTYPE: KTYPE,
      KTERM(T): KTERM(η(m, n)(T))
    ENDCASES
      
  
  % ax1: AXIOM x ∈ Γ IMPLIES x < length(Γ)
  % ax2: AXIOM x ∈ Γ AND kind(Γ(x)) = PRETERM IMPLIES (const_def?(Γ(s)) OR const_var?(Γ(s)) OR const_decl?(Γ(s)))
  % ax3: AXIOM sexpr?(U) IMPLIES sexpr?(δ(Γ)(U))
  % ax4: AXIOM sexpr?(U) IMPLIES sexpr?(U ↑ (n, b))
  % ax5: AXIOM x ∈ Γ AND kind(Γ(x)) = PRETHEORY IMPLIES theory_def?(Γ(x))
  % ax6: AXIOM w(Γ ++ SIG(i), x) < w(Γ, dot(i, x))
  % ax7: AXIOM U << V IMPLIES w(Γ, U) < w(Γ, V)
  % ax8: AXIOM w(Γ, theory_(interpret(SIG(m), σ))) < w(Γ, interp(m, σ))
  % ax9: AXIOM w(Γ ++ rest(Θ, 1), Θ(0)) < w(Γ, Θ)
  % ax10: AXIOM w(Γ, theory_(rest(Θ, 1))) < w(Γ, Θ)
  % ax11: AXIOM w(Γ ++ k(const_var(A)), B) < w(Γ, fun(A, B))
  % ax12: AXIOM w(Γ, A) < w(Γ, fun(A, B))
  % ax13: AXIOM w(Γ ++ k(const_var(A)), B) < w(Γ, prod(A, B))
  %%%%%%%%%%%%%% LIMIT %%%%%%%%%%%%%%
  % axw: << ⊂ w



  % type rules : 2.4, 2.17, 3.10, 4.9, 5.1, 5.3, 5.7, 5.12, 5.14, 5.15, + some modifications
  τ(Γ)(U): RECURSIVE 
    { x: [keyword, list[pretcc]] | TRUE } =
  CASES U OF

  %% Names
    % τ(Γ)(s) = TYPE if kind(Γ(s)) = TYPE
    % τ(Γ)(s) = δ(Γ)(type(Γ(s))) if kind(Γ(s)) = CONSTANT
    % τ(Γ)(s) = δ(Γ)(type(Γ(s))) if kind(Γ(s)) = VARIABLE
    v(s):
      IF s ∈ Γ THEN CASES kind(Γ(s)) OF
	PRETYPE: (KTYPE, null)
      , PRETERM: (KTERM( δ(rest(Γ, s))(type_(Γ(s))) ↑ (s + 1) ), null)
      , PRETHEORY: (KTHEORY, null)
      ENDCASES ELSE fail ENDIF
    % τ(Γ)(m{{ σ }}.s) = TYPE if kind(Γ(m)) = THEORY
    % 	       	       	      and σ is a valid interpretation for definition(Γ(m))
    % 	       	       	      and kind( definition(Γ(m))(s) ) = TYPE
    % τ(Γ)(m{{ σ }}.s) = δ(Γ)( η(Γ, m{{ σ }})(type( definition(Γ(m))(s) )))
    %  	       	       	      if kind(Γ(m)) = THEORY
    % 	       	       	      and σ is a valid interpretation for definition(Γ(m))
    %			      and kind( definition(Γ(m))(s) ) = CONSTANT
    % Note: there is no need to have a τ(Θ)(σ) = INTERP since we already
    % check τ(Θ)(interp(Δ, σ)). Hence we don't have to define τ over the
    % interpretations.
  , dot(i, x):
      LET (kwi, tccsi) = τ(Γ)(i)
        , S = signature(Γ, i)
      IN IF KTHEORY?(kwi) AND v?(x) AND theory?(S) AND i(x) < length(decls(S)) THEN
        LET (kwx, tccsx) = τ(Γ ++ decls(S))(x)
	IN (η(i, length(decls(S)))(kwx), tccsi ++ η(i, length(decls(S)))(tccsx))
      ELSE fail ENDIF
  , interp(m, σ):
      LET (kwm, tccsm) = τ(Γ)(m)
        , sigM = signature(Γ, m)
      IN IF KTHEORY?(kwm) AND theory?(sigM) AND compatible?(decls(sigM), σ) THEN
        LET (kwi, tccsi) = τ(Γ)(theory_(interpret(decls(sigM), σ)))
	IN (kwi, tccsm ++ tccsi)
      ELSE fail ENDIF
  , theory_(Θ):
      IF length(Θ) = 0 THEN (KTHEORY, null) ELSE
      LET (kwΘ, tccsΘ) = τ(Γ)(theory_(rest(Θ, 0))) IN
      IF KTHEORY?(kwΘ) THEN
        LET (kwD, tccsD) = τ(Γ ++ rest(Θ, 0))(Θ(0))
	IN IF KDECL?(kwD) THEN
	  (KTHEORY, tccsΘ ++ η(theory_(rest(Θ, 0)), length(Θ) - 1)(tccsD))
	ELSE fail ENDIF
      ELSE fail ENDIF ENDIF
		       
  %% Types
    % τ(Γ)([x: A -> B]) = TYPE if τ(Γ)(A) = TYPE 
    % 	       	    	       and τ(Γ, x: VAR A) = TYPE
  , fun(A, B):
      LET (kwA, tccsA) = τ(Γ)(A)
      IN IF KTYPE?(kwA) THEN
        LET (kwB, tccsB) = τ(Γ ++ k(const_var(A)))(B)
	IN IF KTYPE?(kwB) THEN
	  (KTYPE, tccsA ++ forall_(A, tccsB)(length(Γ)))
	ELSE fail ENDIF
      ELSE fail ENDIF
    % τ(Γ)([x: A, B]) = TYPE if τ(Γ)(A) = TYPE 
    % 	       	    	       and τ(Γ, x: VAR A) = TYPE
  , prod(A, B):
      LET (kwA, tccsA) = τ(Γ)(A)
      IN IF KTYPE?(kwA) THEN
        LET (kwB, tccsB) = τ(Γ ++ k(const_var(A)))(B)
	IN IF KTYPE?(kwB) THEN
	  (KTYPE, tccsA ++ forall_(A, tccsB)(length(Γ)))
	ELSE fail ENDIF
      ELSE fail ENDIF
    % τ(Γ)({x:T | a}) = TYPE if τ(Γ)(T) = TYPE
    % 		      	     and τ(Γ, x: VAR T)(a) = bool
  , subtype(T, a):
      LET (kwT, tccsT) = τ(Γ)(T)
      IN IF KTYPE?(kwT) THEN
        LET (kwa, tccsa) = τ(Γ ++ k(const_var(T)))(a)
	IN IF KTERM?(kwa) AND TYPEOF(kwa) = bool_(length(Γ)) THEN
	  (KTYPE, tccsT ++ forall_(T, tccsa)(length(Γ)))
	ELSE fail ENDIF
      ELSE fail ENDIF

  %% Terms
    % τ(Γ)(f a) = B' where μ0(τ(Γ)(f)) = [x: A -> B]
    % 	     	     and   τ(Γ)(a) = A'
    %		     and   (A ∼a A')_Γ
    %		     and   B' = B[a/x]
%%%%%		     and   Γ ⊢ π(A)(a)
  , app(f, a):
      LET (kwf, tccsf) = τ(Γ)(f)
      IN IF KTERM?(kwf) THEN
        CASES μ0(TYPEOF(kwf)) OF
	  fun(A, B):
	    LET (kwa, tccsa) = τ(Γ)(a)
	    IN IF KTERM?(kwa) THEN
	      (KTERM(subst(B, 0, a)), tccsf ++ tccsa ++ (A ≃ TYPEOF(kwa))(a)(length(Γ)) ++ π(A)(a)(length(Γ)))
	    ELSE fail ENDIF
	  ELSE fail
	ENDCASES
      ELSE fail ENDIF
    % τ(Γ)(λ(x: A): a) = [x: A -> B] where
    % 		       	 B = τ(Γ, x: VAR A)(a)
    %			 τ(Γ)(A) = TYPE
  , lam(A, a):
      LET (kwA, tccsA) = τ(Γ)(A)
      IN IF KTYPE?(kwA) THEN
        LET (kwa, tccsa) = τ(Γ ++ k(const_var(A)))(a)
	IN IF KTERM?(kwa) THEN
	  (KTERM(fun(A, TYPEOF(kwa))), tccsA ++ forall_(A, tccsa)(length(Γ)))
	ELSE fail ENDIF
      ELSE fail ENDIF
    % τ(Γ)((a1, a2)) = [x: τ(Γ)(a1), τ(Γ)(a2)]
    % 		x doesn't appear in τ(Γ)(a2)
  , pair(a1, a2):
      LET (kwa1, tccsa1) = τ(Γ)(a1)
        , (kwa2, tccsa2) = τ(Γ)(a2)
      IN IF KTERM?(kwa1) AND KTERM?(kwa2) THEN
        (KTERM(prod(TYPEOF(kwa1), TYPEOF(kwa2) ↑ 1)), tccsa1 ++ tccsa2)
      ELSE fail ENDIF
    % τ(Γ)(p1 a) = A1, where μ0(τ(Γ)(a)) = [x: A1, A2]
  , lproj(a):
      LET (kwa, tccsa) = τ(Γ)(a)
      IN IF KTERM?(kwa) THEN
        CASES μ0(TYPEOF(kwa)) OF
	  prod(A1, A2): (KTERM(A1), tccsa)
	  ELSE fail
	ENDCASES
      ELSE fail ENDIF
    % τ(Γ)(p2 a) = A2[(p1 a)/x], where μ0(τ(Γ)(a)) = [x: A1, A2]
  , rproj(a): 
      LET (kwa, tccsa) = τ(Γ)(a)
      IN IF KTERM?(kwa) THEN
        CASES μ0(TYPEOF(kwa)) OF
	  prod(A1, A2): (KTERM(subst(A2, 0, lproj(a))), tccsa)
	  ELSE fail
	ENDCASES
      ELSE fail ENDIF    
	   
  %% Contexts: thanks to De Bruijn representation, we never have to check
   % that s is not already defined before.
     
    % τ(Θ)(s: TYPE) = CONTEXT
  , type_decl: (KDECL, null)
    % For τ : var <-> decl
  , type_var: (KDECL, null)
    % τ(Θ)(s: TYPE = T) = CONTEXT if τ(Θ)(T) = TYPE
  , type_def(T):
      LET (kwT, tccsT) = τ(Γ)(T) IN
      IF KTYPE?(kwT) THEN (KDECL, tccsT) ELSE fail ENDIF
    % τ(Θ)(c: T) = CONTEXT if τ(Θ)(T) = TYPE
  , const_decl(T):
      LET (kwT, tccsT) = τ(Γ)(T) IN
      IF KTYPE?(kwT) THEN (KDECL, tccsT) ELSE fail ENDIF
    % For τ : var <-> decl
  , const_var(T):
      LET (kwT, tccsT) = τ(Γ)(T) IN
      IF KTYPE?(kwT) THEN (KDECL, tccsT) ELSE fail ENDIF
    % τ(Θ)(c: T = a) = CONTEXT if τ(Θ, Γ)(T) = TYPE
    %		       	      and τ(Θ, Γ)(a) = T'
    %			      and (T ∼ T')_Γ
%%%%%			      and Γ ⊢ π(T)(a)    
  , const_def(T, a):
      LET (kwT, tccsT) = τ(Γ)(T)
        , (kwa, tccsa) = τ(Γ)(a)
      IN IF KTYPE?(kwT) AND KTERM?(kwa) THEN
        (KDECL, tccsT ++ tccsa ++ (T ≃ TYPEOF(kwa))(length(Γ)) ++ π(T)(a)(length(Γ)))
      ELSE fail ENDIF
    % τ(θ)(rest(Δ), decl(Δ)) = CONTEXT  τ(Θ)(rest(Δ)) = CONTEXT
    %				    and τ(Θ, rest(Δ))(decl(Δ)) = THEORY 
    %	(THEORY = context without theory declarations)
  , theory_def(Th):
      LET (kwTh, tccsTh) = τ(Γ)(Th)
      IN IF KTHEORY?(kwTh) THEN (KDECL, tccsTh) ELSE fail ENDIF
  , ikeep: fail
  , itype(T): fail
  , iterm(a): fail
  ENDCASES
  MEASURE w(Γ, U)

  % Important invariants of τ to prove :
  %  - τ(Θ)(_) occurs in the definition of τ only if τ(〈〉)(Θ) = CONTEXT
  %    -> done implicitely with type context in every theorems of tau_props.pvs
  %  - KTERM(T) is written only if τ(Θ)(T) = TYPE
  %    -> see thm 2.11
  %  - KTERM(T) is written only if μ0(T) = T (T is not a subtype)
  %  - KTERM(T) is written only if δ(Γ)(T) = T (T is fully expanded)
  %    -> both checked in tau_props (type expansion)
  %  - τ(Γ)(_) generates tccs that are correct (typecheckable) in the context Γ
  %    i.e τ(Γ)(tcc) = KTERM for each tcc generated.
  %    -> see tcc_correctness in tau_props
END tau
