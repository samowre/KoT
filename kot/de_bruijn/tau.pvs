tau: THEORY
BEGIN
  IMPORTING interp
  IMPORTING compare
  IMPORTING definitions


  % TODO:
  % note: the function tau is defined only on what can	
  % be a PVS expression on its own, not on subterms of such.
  % Therefore tau is not defined on the following constructors
  %  - interp, that should only occur on a dot left hand side
  %    (until we handle first-class theory)
  %  - all constructors of subtype (scontext?) except stheory
  %    since they can only occur in a stheory itself (i.e a context)
  %  - all constructors of subtype (sinterp?) since they must occur
  %    only in the right hand side of a interp constructor.


  % Variable declaration
  Γ, Δ, Θ: VAR (theory_def?)
  M, N: VAR (scontext?)
  U, V: VAR syntaxic
  s: VAR signature
  Sig: VAR (stheory?)
  %A, B, T: VAR pretype
  %n, m: VAR name
  x, y, z: VAR nat
  %a, b, f, g: VAR preterm
  %S: VAR semantic


  %% Type TCCS 
  pretcc: TYPE = preterm

  ;++(l1, l2: list[pretcc]): list[pretcc] = append(l1, l2)
  π(A)(a): list[pretcc] = cons( app(π(A), a), null)
  fail: [keyword, list[pretcc]] = (⊥, null)
  
  %%% Type keyword
  keyword: DATATYPE
  BEGIN
    ⊥: undefined?
    KCONTEXT: KCONTEXT?
    KTHEORY: KTHEORY?
    KTYPE: KTYPE?
    KTERM(type_: (expr?)): KTERM?
  END keyword
  k: VAR keyword

  pretau(Sig)(U)(k): bool = 
    pretau(Sig)(U)(s) IMPLIES kw(s) = k

  % type rules : 2.4, 2.17, 3.10, 4.9, 5.1, 5.3, 5.7, 5.12, 5.14, 5.15, + some modifications
  τ(Θ)(U): RECURSIVE 
    { x: [keyword, list[pretcc]] | 
        LET (k, l) = x, Sig = signature(Θ)  IN
	(KCONTEXT?(k) IMPLIES pretau(Sig)(U)(PRECONTEXT(signature(U)))) AND
	(KTHEORY?(k) IMPLIES pretau(Sig)(U)(PRECONTEXT)) AND
	(KTYPE?(k) IMPLIES pretau(Sig)(U)(PRETYPE)) AND
	(KTERM?(k) IMPLIES pretau(Sig)(U)(PRETERM)) } = % AND
	%(k /= ⊥ IMPLIES well_formed?(Θ)(S)) } = 
  CASES S OF

  %% Names
    % τ(Γ)(s) = TYPE if kind(Γ(s)) = TYPE
    % τ(Γ)(s) = δ(Γ)(type(Γ(s))) if kind(Γ(s)) = CONSTANT
    % τ(Γ)(s) = δ(Γ)(type(Γ(s))) if kind(Γ(s)) = VARIABLE
    v(s):
      IF s ∈ Θ
        THEN IF kind(Θ)(s) = PRETYPE
	  THEN (KTYPE, null)
	ELSIF kind(Θ)(s) = PRETERM
	  THEN (KTERM( δ(find(Θ)(s) )( type_(Θ)(s) ) ↑ s), null)
	  ELSE fail
	ENDIF
	ELSE fail
      ENDIF,
    % τ(Γ)(m{{ σ }}.s) = TYPE if kind(Γ(m)) = THEORY
    % 	       	       	      and σ is a valid interpretation for definition(Γ(m))
    % 	       	       	      and kind( definition(Γ(m))(s) ) = TYPE
    % τ(Γ)(m{{ σ }}.s) = δ(Γ)( η(Γ, m{{ σ }})(type( definition(Γ(m))(s) )))
    %  	       	       	      if kind(Γ(m)) = THEORY
    % 	       	       	      and σ is a valid interpretation for definition(Γ(m))
    %			      and kind( definition(Γ(m))(s) ) = CONSTANT
    % Note: there is no need to have a τ(Θ)(σ) = INTERP since we already
    % check τ(Θ)(interp(Δ, σ)). Hence we don't have to define τ over the
    % interpretations.
    dot(i, s, x): 
      IF interp?(i) AND v?(x)
        THEN LET (kwi, tccsi) = τ(Θ)(interp(Θ)(s, i)) IN
	  IF KTHEORY?(kwi) 
	    THEN τ(Θ ++ rest(Δ, y))(y)
	    ELSE fail
	  ENDIF
	ELSE fail
      ENDIF,
    % interp(m, σ):

    % dot(m, σ, v): 
    %   LET s = i(v) IN
    %   IF m ∈ Θ AND kind(Θ)(m) = KTHEORY
    % 	THEN LET Δ = definition(Θ)(m) IN
    % 	  IF interp?(σ) AND interp_for?(Δ)(σ) 
    % 	    THEN LET (kwi, tccsi) = τ(Θ)(interp(Δ, σ)) IN
    % 	     IF KTHEORY?(kwi) AND s ∈ Δ 
    % 	        THEN IF kind(Δ)(s) = KTYPE
    % 		  THEN (KTYPE, null)
    % 		ELSIF kind(Δ)(s) = KCONST
    % 		  THEN ( KTERM( δ(Θ ++ find(Δ)(s))( η(Θ, m, σ)( type_(Δ)(s) )) 
    % 		                ↑ (length(after(Θ, s)))),
    % 		         tccsi )
    % 		  ELSE fail
    % 		ENDIF
    % 		ELSE fail
    % 	      ENDIF
    % 	    ELSE fail
    % 	  ENDIF
    % 	ELSE fail
    %   ENDIF,
			        
		       
  %% Types
    % τ(Γ)([x: A -> B]) = TYPE if τ(Γ)(A) = TYPE 
    % 	       	    	       and τ(Γ, x: VAR A) = TYPE
    fun(A, B): 
      LET (kwA, tccsA) = τ(Θ)(A) IN
     	IF KTYPE?(kwA)
	  THEN LET (kwB, tccsB) = τ(Θ ++ k(const_var(A)))(B) IN
	    IF KTYPE?(kwB) 
	      THEN (KTYPE, tccsA ++ tccsB)
	      ELSE fail
	    ENDIF
	  ELSE fail
	ENDIF, 
    % τ(Γ)([x: A, B]) = TYPE if τ(Γ)(A) = TYPE 
    % 	       	    	       and τ(Γ, x: VAR A) = TYPE
    prod(A, B): 
      LET (kwA, tccsA) = τ(Θ)(A) IN
     	IF KTYPE?(kwA)
	  THEN LET (kwB, tccsB) = τ(Θ ++ k(const_var(A)))(B) IN
	    IF KTYPE?(kwB) 
	      THEN (KTYPE, tccsA ++ tccsB)
	      ELSE fail
	    ENDIF
	  ELSE fail
	ENDIF, 
    % τ(Γ)({x:T | a}) = TYPE if τ(Γ)(T) = TYPE
    % 		      	     and τ(Γ, x: VAR T)(a) = bool
    subtype(T, a): 
      LET (kwT, tccsT) = τ(Θ)(T) IN
    	IF KTYPE?(kwT)
	  THEN LET (kwa, tccsa) = τ(Θ ++ k(const_var(T)))(a) IN
	    CASES kwa OF
	      KTERM(A): 
	        IF A = bool_
		  THEN (KTYPE, tccsT ++ tccsa)
		  ELSE fail
		ENDIF
	      ELSE fail
	    ENDCASES
	  ELSE fail
	ENDIF,  
		 

  %% Terms
    % τ(Γ)(f a) = B' where μ0(τ(Γ)(f)) = [x: A -> B]
    % 	     	     and   τ(Γ)(a) = A'
    %		     and   (A ∼a A')_Γ
    %		     and   B' = B[a/x]
%%%%%		     and   Γ ⊢ π(A)(a)
    app(f, a): 
      LET (kwf, tccsf) = τ(Θ)(f) IN
    	CASES kwf OF
	  KTERM(Tf):
	    CASES μ0(Tf) OF
	      fun(A, B): 
		LET (kwa, tccsa) = τ(Θ)(a) IN
		CASES kwa OF
		  KTERM(Ap):
		    (KTERM(subst(B, 0, a)), 
		     tccsf ++ tccsa ++ (A ≃ Ap)(a) ++ (π(A)(a)) )
		  ELSE fail
		ENDCASES
	      ELSE fail
	    ENDCASES
	  ELSE fail
	ENDCASES, 
    % τ(Γ)(λ(x: A): a) = [x: A -> B] where
    % 		       	 B = τ(Γ, x: VAR A)(a)
    %			 τ(Γ)(A) = TYPE
    lam(A, a): 
      LET (kwA, tccsA) = τ(Θ)(A) IN
    	IF KTYPE?(kwA)
	  THEN LET (kwa, tccsa) = τ(Θ ++ k(const_var(A)))(a) IN
    	    CASES kwa OF
	      KTERM(B): (KTERM(fun(A, B)), tccsA ++ tccsa) 
	      ELSE fail
	    ENDCASES
	  ELSE fail
	ENDIF,
    % τ(Γ)((a1, a2)) = [x: τ(Γ)(a1), τ(Γ)(a2)]
    % 		x doesn't appear in τ(Γ)(a2)
    pair(a1, a2): 
      LET (kwa1, tccsa1) = τ(Θ)(a1) IN
      CASES kwa1 OF
        KTERM(A1): 
	  LET (kwa2, tccsa2) = τ(Θ)(a2) IN
	  CASES kwa2 OF
	    KTERM(A2): (KTERM(prod(A1, A2 ↑ 1)),
		        tccsa1 ++ tccsa2 )
	    ELSE fail
	  ENDCASES
	ELSE fail
      ENDCASES, 
    % τ(Γ)(p1 a) = A1, where μ0(τ(Γ)(a)) = [x: A1, A2]
    lproj(a): 
      LET (kwa, tccsa) = τ(Θ)(a) IN
    	CASES kwa OF
	  KTERM(A): 
	  CASES μ0(A) OF
	    prod(A1, A2): (KTERM(A1), tccsa)
	    ELSE fail
	  ENDCASES
	ELSE fail
      ENDCASES,
    % τ(Γ)(p2 a) = A2[(p1 a)/x], where μ0(τ(Γ)(a)) = [x: A1, A2]
    rproj(a): 
      LET (kwa, tccsa) = τ(Θ)(a) IN
    	CASES kwa OF
	  KTERM(A): 
	  CASES μ0(A) OF
	    prod(A1, A2): (KTERM(subst(A2, 0, lproj(a))), tccsa)
	    ELSE fail
	  ENDCASES
	ELSE fail
      ENDCASES,		  
    
	   
  %% Contexts: thanks to De Bruijn represntation, we never have to check
   % that s is not already defined before.
     
    % τ(Θ)(s: TYPE) = CONTEXT
    type_decl: (KTHEORY, null),
    % For τ : var <-> decl
    type_var: (KTHEORY, null),
    % τ(Θ)(s: TYPE = T) = CONTEXT if τ(Θ)(T) = TYPE
    type_def(T): 
      LET (kwT, tccsT) = τ(Θ)(T) IN
      IF KTYPE?(kwT) THEN (KTHEORY, tccsT) ELSE fail ENDIF, 
    % τ(Θ)(c: T) = CONTEXT if τ(Θ)(T) = TYPE
    const_decl(T):
      LET (kwT, tccsT) = τ(Θ)(T) IN
      IF KTYPE?(kwT) THEN (KTHEORY, tccsT) ELSE fail ENDIF, 
    % For τ : var <-> decl
    const_var(T):
      LET (kwT, tccsT) = τ(Θ)(T) IN
      IF KTYPE?(kwT) THEN (KTHEORY, tccsT) ELSE fail ENDIF, 
    % τ(Θ)(c: T = a) = CONTEXT if τ(Θ, Γ)(T) = TYPE
    %		       	      and τ(Θ, Γ)(a) = T'
    %			      and (T ∼ T')_Γ
%%%%%			      and Γ ⊢ π(T)(a)    
    const_def(T, a): 
      LET (kwT, tccsT) = τ(Θ)(T) IN
      IF kwT = KTYPE
        THEN LET (kwa, tccsa) = τ(Θ)(a) IN
 	  CASES kwa OF
	    KTERM(Tp):
	      (KTHEORY, tccsT ++ tccsa ++ (T ≃ Tp) ++ (π(T)(a)))
	    ELSE fail
	  ENDCASES
	ELSE fail
      ENDIF,
    % τ(θ)(rest(Δ), decl(Δ)) = CONTEXT  τ(Θ)(rest(Δ)) = CONTEXT
    %				    and τ(Θ, rest(Δ))(decl(Δ)) = THEORY 
    %	(THEORY = context without theory declarations)
    theory_def(̣Δ): 
    % τ(Θ)(〈〉) = CONTEXT
      IF length(Δ) = 0 
        THEN (KTHEORY, null) 
	ELSE
          LET (kwΔ, tccsΔ) = τ(Θ)(rest(Δ, 1)) IN
          IF KTHEORY?(kwΔ)
	    THEN LET (kwD, tccsD) = τ(Θ ++ rest(Δ, 1))(Δ(0)) IN
	      IF KCONTEXT?(kwD) 
	        THEN (KCONTEXT, tccsΔ ++ tccsD)
		ELSE fail
	      ENDIF
	    ELSE fail
	  ENDIF
      ENDIF
    ELSE fail
  ENDCASES
  MEASURE extend[semantic, syntaxic, ordinal, zero](LAMBDA (s: syntaxic): w(Θ, s))(S)


  % Important invariants of τ to prove :
  %  - τ(Θ)(_) occurs in the definition of τ only if τ(〈〉)(Θ) = CONTEXT
  %    -> done implicitely with type wf_context in every theorems of tau_props.pvs
  %  - KTERM(T) is written only if τ(Θ)(T) = TYPE
  %    -> see thm 2.11
  %  - KTERM(T) is written only if μ0(T) = T (T is not a subtype)
  %    
  %  - KTERM(T) is written only if δ(Γ(T)) = T (T is fully expanded)
  %  - τ(Γ)(_) generates tccs that are correct (typecheckable) in the context Γ
  %    i.e τ(Γ)(tcc) = KTERM for each tcc generated.
  %    -> done in tau_props.pvs


  tau_is_syntaxic: THEOREM 
    τ(Γ)(S) /= fail IMPLIES syntaxic?(S)
  


END tau
