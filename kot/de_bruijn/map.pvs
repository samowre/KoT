map: THEORY
BEGIN
  IMPORTING language

  U, V, W: VAR syntaxic
  x, y: VAR nat
  k: VAR prekeyword  
  Γ, Δ, Θ: VAR precontext
  T, A, B: VAR pretype
  a, b, f: VAR preterm
  σ, τ: VAR preinterp
  S: VAR semantic
  M: VAR (map?)
  i, j: VAR nat

  ;∈(x, Γ): MACRO bool =
    x < length(Γ)

  apply(Γ)(x | x ∈ Γ): RECURSIVE precontext =
    IF x = 0 THEN Γ ELSE apply(rest(Γ))(x - 1) ENDIF
  MEASURE length(Γ)
  CONVERSION apply
  AUTO_REWRITE+ apply
  length_apply: THEOREM x ∈ Γ IMPLIES
    length(apply(Γ)(x)) = length(Γ) - x
  rest_apply: THEOREM i + 1 ∈ Γ IMPLIES
    rest(Γ)(i) = Γ(i + 1)
  apply_apply: THEOREM i + j ∈ Γ IMPLIES
    Γ(i)(j) = Γ(i + j)
  size_apply: THEOREM x ∈ Γ IMPLIES
    size(apply(Γ)(x)) <= size(Γ)

  ;++(Γ, Δ): RECURSIVE precontext =
    CASES Δ OF
      empty: Γ
    , type_decl(Δ): type_decl(Γ ++ Δ)
    , type_var(Δ): type_var(Γ ++ Δ)
    , type_def(Δ, T): type_def(Γ ++ Δ, T)
    , const_decl(Δ, T): const_decl(Γ ++ Δ, T)
    , const_var(Δ, T): const_var(Γ ++ Δ, T)
    , const_def(Δ, T, a): const_def(Γ ++ Δ, T, a)
    , theory_def(Δ, Θ): theory_def(Γ ++ Δ, Θ)
    ENDCASES
  MEASURE length(Δ)

  concat_assoc: THEOREM
    Γ ++ (Δ ++ Θ) = (Γ ++ Δ) ++ Θ
  length_concat: THEOREM
    length(Γ ++ Δ) = length(Γ) + length(Δ)
  size_concat: THEOREM
    size(Γ ++ Δ) = size(Γ) + size(Δ)
  concat_empty: THEOREM
    empty ++ Γ = Γ
  AUTO_REWRITE+ ++, concat_assoc, length_concat, concat_empty, size_concat

  interp_type(Γ, (i | i ∈ Γ AND type_decl?(Γ(i))), T): RECURSIVE precontext =
    CASES Γ OF
      type_decl(Δ): IF i = 0 THEN type_def(Δ, T) ELSE type_decl(interp_type(Δ, i - 1, T)) ENDIF
    , type_var(Δ): type_var(interp_type(Δ, i - 1, T))
    , type_def(Δ, A): type_def(interp_type(Δ, i - 1, T), A)
    , const_decl(Δ, A): const_decl(interp_type(Δ, i - 1, T), A)
    , const_var(Δ, A): const_var(interp_type(Δ, i - 1, T), A)
    , const_def(Δ, A, a): const_def(interp_type(Δ, i - 1, T), A, a)
    , theory_def(Δ, Θ): theory_def(interp_type(Δ, i - 1, T), Θ)
    ENDCASES
  MEASURE length(Γ)
  length_interp_type: THEOREM i ∈ Γ AND type_decl?(Γ(i)) IMPLIES
    length(interp_type(Γ, i, T)) = length(Γ)
  apply_interp_type: THEOREM i ∈ Γ AND j ∈ Γ AND type_decl?(Γ(i)) IMPLIES
    interp_type(Γ, i, T)(j) = IF i < j THEN Γ(j) ELSE interp_type(Γ(j), i - j, T) ENDIF
  compatible_interp_type: THEOREM
    i ∈ Γ AND type_decl?(Γ(i)) AND compatible?(Γ, τ) AND NOT interpret?(τ, i) IMPLIES
      compatible?(interp_type(Γ, i, T), τ)

  interp_const(Γ, (i | i ∈ Γ AND const_decl?(Γ(i))), a): RECURSIVE precontext =
    CASES Γ OF
      type_decl(Δ): type_decl(interp_const(Δ, i - 1, a))
    , type_var(Δ): type_var(interp_const(Δ, i - 1, a))
    , type_def(Δ, T): type_def(interp_const(Δ, i - 1, a), T)
    , const_decl(Δ, T): IF i = 0 THEN const_def(Δ, T, a) ELSE const_decl(interp_const(Δ, i - 1, a), T) ENDIF
    , const_var(Δ, T): const_var(interp_const(Δ, i - 1, a), T)
    , const_def(Δ, T, b): const_def(interp_const(Δ, i - 1, a), T, b)
    , theory_def(Δ, Θ): theory_def(interp_const(Δ, i - 1, a), Θ)
    ENDCASES
  MEASURE length(Γ)

  interp(Γ, (σ | compatible?(Γ, σ))): RECURSIVE precontext =
    CASES σ OF
      nil: empty
    , itype(τ, i, T): interp(interp_type(Γ, i, T), τ)
    , iconst(τ, i, a): interp(interp_const(Γ, i, a), τ)
    ENDCASES
  MEASURE size(σ)
  length_interp: THEOREM compatible?(Γ, σ) IMPLIES
    length(interp(Γ, σ)) = length(Γ)
  size_interp: THEOREM compatible?(Γ, σ) IMPLIES
    size(interp(Γ, σ)) < size(Γ) + size(σ)
  AUTO_REWRITE length_interp
END map
