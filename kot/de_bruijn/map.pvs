map: THEORY
BEGIN
  IMPORTING language

  U, V, W: VAR syntaxic
  x, y: VAR nat
  k: VAR prekeyword  
  Γ, Δ, Θ: VAR precontext
  T, A, B: VAR pretype
  a, b, f: VAR preterm
  σ, τ: VAR preinterp
  S: VAR semantic
  M: VAR premap

  length(M): RECURSIVE nat =
    CASES M OF
      type_decl(Δ): 1 + length(Δ) 
    , type_var(Δ): 1 + length(Δ)
    , type_def(Δ, T): 1 + length(Δ)
    , const_decl(Δ, T): 1 + length(Δ)
    , const_var(Δ, T): 1 + length(Δ)
    , const_def(Δ, T, a): 1 + length(Δ)
    , theory_def(Δ, Θ): 1 + length(Δ)

    , ikeep(σ): 1 + length(σ)
    , itype(σ, T): 1 + length(σ)
    , iconst(σ, a): 1 + length(σ)
    ELSE 0
    ENDCASES
  MEASURE size(M)
  AUTO_REWRITE length

  ;∈(x, M): MACRO bool =
    x < length(M)

  apply(Γ)(x | length(Γ) >= x): RECURSIVE precontext =
    IF x = 0 THEN Γ ELSE apply(rest(Γ))(x - 1) ENDIF
  MEASURE length(Γ)
  CONVERSION apply
  AUTO_REWRITE+ apply
  length_apply: THEOREM x ∈ Γ IMPLIES
    length(apply(Γ)(x)) = length(Γ) - x
  size_apply: THEOREM x <= length(Γ) IMPLIES
    size(apply(Γ)(x)) <= size(Γ)

  ;++(Γ, Δ): RECURSIVE precontext =
    CASES Δ OF
      empty: Γ
    , type_decl(Δ): type_decl(Γ ++ Δ)
    , type_var(Δ): type_var(Γ ++ Δ)
    , type_def(Δ, T): type_def(Γ ++ Δ, T)
    , const_decl(Δ, T): const_decl(Γ ++ Δ, T)
    , const_var(Δ, T): const_var(Γ ++ Δ, T)
    , const_def(Δ, T, a): const_def(Γ ++ Δ, T, a)
    , theory_def(Δ, Θ): theory_def(Γ ++ Δ, Θ)
    ENDCASES
  MEASURE length(Δ)

  concat_assoc: THEOREM
    Γ ++ (Δ ++ Θ) = (Γ ++ Δ) ++ Θ
  length_concat: THEOREM
    length(Γ ++ Δ) = length(Γ) + length(Δ)
  size_concat: THEOREM
    size(Γ ++ Δ) = size(Γ) + size(Δ)
  concat_empty: THEOREM
    empty ++ Γ = Γ
  apply_concat: THEOREM x ∈ Γ ++ Δ IMPLIES
    (Γ ++ Δ)(x) = IF x ∈ Δ THEN Γ ++ Δ(x) ELSE Γ(x - length(Δ)) ENDIF
  AUTO_REWRITE+ ++, concat_assoc, length_concat, concat_empty, apply_concat, size_concat


  compatible?(Γ, σ): RECURSIVE bool =
    CASES σ OF
      nil: empty?(Γ)
    , ikeep(τ): NOT empty?(Γ) AND compatible?(rest(Γ), τ)
    , itype(τ, T): type_decl?(Γ) AND compatible?(rest(Γ), τ)
    , iconst(τ, a): const_decl?(Γ) AND compatible?(rest(Γ), τ)
    ENDCASES
  MEASURE length(σ)
  AUTO_REWRITE compatible?
  compatible_length: THEOREM
    compatible?(Γ, σ) IMPLIES length(Γ) = length(σ)

  interp(Γ, (σ | compatible?(Γ, σ))): RECURSIVE precontext =
    CASES σ OF
      nil: empty
    , ikeep(τ):
        CASES Γ OF
	  type_decl(Δ): type_decl(interp(Δ, τ))
	, type_def(Δ, T): type_def(interp(Δ, τ), T)
	, type_var(Δ): type_var(interp(Δ, τ))
	, const_decl(Δ, T): const_decl(interp(Δ, τ), T)
	, const_def(Δ, T, a): const_def(interp(Δ, τ), T, a)
	, const_var(Δ, T): const_var(interp(Δ, τ), T)
	, theory_def(Δ, Θ): theory_def(interp(Δ, τ), Θ)
	ENDCASES
    , itype(τ, T): type_def(interp(rest(Γ), τ), T)
    , iconst(τ, a): const_def(interp(rest(Γ), τ), type_(Γ), a)
    ENDCASES
  MEASURE length(σ)
  length_interp: THEOREM compatible?(Γ, σ) IMPLIES
    length(interp(Γ, σ)) = length(σ)
  size_interp: THEOREM compatible?(Γ, σ) IMPLIES
    size(interp(Γ, σ)) < size(Γ) + size(σ)
  AUTO_REWRITE length_interp
END map
