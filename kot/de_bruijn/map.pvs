map: THEORY
BEGIN
  IMPORTING language

  U, V, W: VAR syntaxic
  x, y: VAR nat
  k: VAR prekeyword  
  Γ, Δ, Θ: VAR precontext
  T, A, B: VAR pretype
  a, b, f: VAR preterm
  σ, τ: VAR preinterp
  S: VAR semantic
  M: VAR premap
  i: VAR nat

  length(Γ): RECURSIVE nat =
    CASES Γ OF
      type_decl(Δ): 1 + length(Δ) 
    , type_var(Δ): 1 + length(Δ)
    , type_def(Δ, T): 1 + length(Δ)
    , const_decl(Δ, T): 1 + length(Δ)
    , const_var(Δ, T): 1 + length(Δ)
    , const_def(Δ, T, a): 1 + length(Δ)
    , theory_def(Δ, Θ): 1 + length(Δ) + length(Θ)
    ELSE 0
    ENDCASES
  MEASURE size(Γ)
  AUTO_REWRITE length

  ;∈(x, Γ): MACRO bool =
    x < length(Γ)

  apply(Γ)(x | x ∈ Γ): RECURSIVE precontext =
    COND
      theory_def?(Γ) ->
        IF x < length(def(Γ))
	  THEN apply(def(Γ))(x)
	  ELSIF x = length(def(Γ)) THEN Γ
	  ELSE apply(rest(Γ))(x - length(def(Γ)) - 1)
	ENDIF
    , x = 0 -> Γ
    , ELSE -> apply(rest(Γ))(x - 1)
    ENDCOND
  MEASURE length(Γ)
  CONVERSION apply
  AUTO_REWRITE+ apply
  length_apply: THEOREM x ∈ Γ IMPLIES
    length(apply(Γ)(x)) <= length(Γ)
  size_apply: THEOREM x ∈ Γ IMPLIES
    size(apply(Γ)(x)) <= size(Γ)

  ;++(Γ, Δ): RECURSIVE precontext =
    CASES Δ OF
      empty: Γ
    , type_decl(Δ): type_decl(Γ ++ Δ)
    , type_var(Δ): type_var(Γ ++ Δ)
    , type_def(Δ, T): type_def(Γ ++ Δ, T)
    , const_decl(Δ, T): const_decl(Γ ++ Δ, T)
    , const_var(Δ, T): const_var(Γ ++ Δ, T)
    , const_def(Δ, T, a): const_def(Γ ++ Δ, T, a)
    , theory_def(Δ, Θ): theory_def(Γ ++ Δ, Θ)
    ENDCASES
  MEASURE length(Δ)

  concat_assoc: THEOREM
    Γ ++ (Δ ++ Θ) = (Γ ++ Δ) ++ Θ
  length_concat: THEOREM
    length(Γ ++ Δ) = length(Γ) + length(Δ)
  size_concat: THEOREM
    size(Γ ++ Δ) = size(Γ) + size(Δ)
  concat_empty: THEOREM
    empty ++ Γ = Γ
  apply_concat: THEOREM x ∈ Γ ++ Δ IMPLIES
    (Γ ++ Δ)(x) = IF x ∈ Δ THEN Γ ++ Δ(x) ELSE Γ(x - length(Δ)) ENDIF
  AUTO_REWRITE+ ++, concat_assoc, length_concat, concat_empty, apply_concat, size_concat

  interpret?(σ, i): RECURSIVE bool =
    CASES σ OF
      nil: FALSE
    , itype(τ, j, T): i = j OR interpret?(τ, i)
    , iconst(τ, j, a): i = j OR interpret?(τ, j)
    ENDCASES
  MEASURE size(σ)

  compatible?(Γ, σ): RECURSIVE bool =
    CASES σ OF
      nil: TRUE
    , itype(τ, i, T):
        i ∈ Γ AND type_decl?(Γ(i)) AND compatible?(Γ, τ) AND NOT interpret?(τ, i)
    , iconst(τ, i, a):
        i ∈ Γ AND const_decl?(Γ(i)) AND compatible?(Γ, τ) AND NOT interpret?(τ, i)
    ENDCASES
  MEASURE size(σ)
  AUTO_REWRITE compatible?
  compatible_length: THEOREM
    compatible?(Γ, σ) IMPLIES length(σ) <= length(Γ)

  interp(Γ, (σ | compatible?(Γ, σ))): RECURSIVE precontext =
    CASES σ OF
      nil: empty
    , itype(τ, i, T): type_def(interp(rest(Γ), τ), T)
    , iconst(τ, i, a): const_def(interp(rest(Γ), τ), type_(Γ), a)
    ENDCASES
  MEASURE length(σ)
  length_interp: THEOREM compatible?(Γ, σ) IMPLIES
    length(interp(Γ, σ)) = length(Γ)
  size_interp: THEOREM compatible?(Γ, σ) IMPLIES
    size(interp(Γ, σ)) < size(Γ) + size(σ)
  AUTO_REWRITE length_interp
END map
