(tau
 (π_TCC1 0
  (π_TCC1-1 nil 3584367711
   ("" (grind) (("" (grind :rewrites (sexpr?)) nil nil)) nil)
   ((sexpr? adt-def-decl "boolean" language nil)) nil))
 (π_TCC2 0 (π_TCC2-1 nil 3584367711 ("" (grind) nil nil) (nil) nil))
 (τ_TCC1 0
  (τ_TCC1-1 nil 3584286639 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (admissible? const-decl "bool" init_context nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (bool_theory const-decl "(theory?)" init_context nil)
    (bool_ const-decl "(sexpr?)" init_context nil)
    (equalities const-decl "(theory?)" init_context nil)
    (FALSE_ const-decl "(sexpr?)" init_context nil)
    (length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (equal const-decl "(sexpr?)" init_context nil)
    (≐ const-decl "(sexpr?)" init_context nil) nil
    (not_ const-decl "(sexpr?)" init_context nil)
    (¬ const-decl "(sexpr?)" init_context nil) nil nil
    (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND (scontext?(U) IFF scontext?(V))}"
       subst nil)
    nil (TRUE_ const-decl "(sexpr?)" init_context nil)
    (init_context const-decl "(theory?)" init_context nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (kind const-decl "prekeyword" language nil))
   nil))
 (τ_TCC2 0
  (τ_TCC2-1 nil 3584286639 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (shift_size application-judgement
     "{V | type_size(V) = type_size(U)}" supertype nil))
   nil))
 (τ_TCC3 0
  (τ_TCC3-1 nil 3584286639 ("" (subtype-tcc) nil nil)
   ((TRUE const-decl "bool" booleans nil)
    (pretcc type-eq-decl nil tau nil) (keyword type-decl nil tau nil)
    (sexpr? adt-def-decl "boolean" language nil) nil
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil) nil
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (< def-decl "bool" ordinals nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (scontext? adt-def-decl "boolean" language nil)
    (syntaxic type-decl nil language nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (same type-eq-decl nil subst nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (O const-decl "finseq" finite_sequences nil) nil
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (bool_theory const-decl "(theory?)" init_context nil)
    (bool_ const-decl "(sexpr?)" init_context nil)
    (equalities const-decl "(theory?)" init_context nil)
    (FALSE_ const-decl "(sexpr?)" init_context nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (equal const-decl "(sexpr?)" init_context nil)
    (≐ const-decl "(sexpr?)" init_context nil) nil
    (not_ const-decl "(sexpr?)" init_context nil)
    (¬ const-decl "(sexpr?)" init_context nil) nil nil
    (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND (scontext?(U) IFF scontext?(V))}"
       subst nil)
    nil (TRUE_ const-decl "(sexpr?)" init_context nil)
    (init_context const-decl "(theory?)" init_context nil)
    (admissible? const-decl "bool" init_context nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (τ_TCC4 0
  (τ_TCC4-1 nil 3584286639 ("" (subtype-tcc) nil nil) nil nil))
 (τ_TCC5 0
  (τ_TCC5-1 nil 3584286639 ("" (subtype-tcc) nil nil) nil nil))
 (τ_TCC6 0
  (τ_TCC6-1 nil 3584286639 ("" (subtype-tcc) nil nil) nil nil))
 (τ_TCC7 0
  (τ_TCC7-1 nil 3584286639 ("" (termination-tcc) nil nil) nil nil))
 (τ_TCC8 0
  (τ_TCC8-1 nil 3584286639 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (admissible? const-decl "bool" init_context nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) nil
    (sexpr? adt-def-decl "boolean" language nil)
    (keyword type-decl nil tau nil) (pretcc type-eq-decl nil tau nil)
    (TRUE const-decl "bool" booleans nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (bool_theory const-decl "(theory?)" init_context nil)
    (bool_ const-decl "(sexpr?)" init_context nil)
    (equalities const-decl "(theory?)" init_context nil)
    (FALSE_ const-decl "(sexpr?)" init_context nil)
    (length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (equal const-decl "(sexpr?)" init_context nil)
    (≐ const-decl "(sexpr?)" init_context nil) nil
    (not_ const-decl "(sexpr?)" init_context nil)
    (¬ const-decl "(sexpr?)" init_context nil) nil nil
    (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND (scontext?(U) IFF scontext?(V))}"
       subst nil)
    nil (TRUE_ const-decl "(sexpr?)" init_context nil)
    (init_context const-decl "(theory?)" init_context nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (τ_TCC9 0
  (τ_TCC9-1 nil 3584286639 ("" (subtype-tcc) nil nil)
   ((TRUE const-decl "bool" booleans nil)
    (pretcc type-eq-decl nil tau nil) (keyword type-decl nil tau nil)
    (sexpr? adt-def-decl "boolean" language nil) nil
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil) nil
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (< def-decl "bool" ordinals nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (scontext? adt-def-decl "boolean" language nil)
    (syntaxic type-decl nil language nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (theory_ adt-constructor-decl "[finseq[(scontext?)] -> (theory?)]"
     language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (O const-decl "finseq" finite_sequences nil) nil
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (bool_theory const-decl "(theory?)" init_context nil)
    (bool_ const-decl "(sexpr?)" init_context nil)
    (equalities const-decl "(theory?)" init_context nil)
    (FALSE_ const-decl "(sexpr?)" init_context nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (equal const-decl "(sexpr?)" init_context nil)
    (≐ const-decl "(sexpr?)" init_context nil) nil
    (not_ const-decl "(sexpr?)" init_context nil)
    (¬ const-decl "(sexpr?)" init_context nil) nil nil
    (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND (scontext?(U) IFF scontext?(V))}"
       subst nil)
    nil (TRUE_ const-decl "(sexpr?)" init_context nil)
    (init_context const-decl "(theory?)" init_context nil)
    (admissible? const-decl "bool" init_context nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (τ_TCC10 0
  (τ_TCC10-1 nil 3584286639
   ("" (grind) (("" (expand "sexpr?") (("" (propax) nil nil)) nil))
    nil)
   ((sexpr? adt-def-decl "boolean" language nil)) nil))
 (τ_TCC11 0
  (τ_TCC11-1 nil 3584286639 ("" (grind) nil nil)
   ((O const-decl "finseq" finite_sequences nil) nil
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (τ_TCC12 0
  (τ_TCC12-1 nil 3584286639 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (admissible? const-decl "bool" init_context nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) nil
    (sexpr? adt-def-decl "boolean" language nil)
    (keyword type-decl nil tau nil) (pretcc type-eq-decl nil tau nil)
    (TRUE const-decl "bool" booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (init_context const-decl "(theory?)" init_context nil)
    (TRUE_ const-decl "(sexpr?)" init_context nil) nil
    (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND (scontext?(U) IFF scontext?(V))}"
       subst nil)
    nil nil (¬ const-decl "(sexpr?)" init_context nil)
    (not_ const-decl "(sexpr?)" init_context nil) nil
    (≐ const-decl "(sexpr?)" init_context nil)
    (equal const-decl "(sexpr?)" init_context nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (FALSE_ const-decl "(sexpr?)" init_context nil)
    (equalities const-decl "(theory?)" init_context nil)
    (bool_ const-decl "(sexpr?)" init_context nil)
    (bool_theory const-decl "(theory?)" init_context nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (O const-decl "finseq" finite_sequences nil) nil
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil))
   nil))
 (τ_TCC13 0
  (τ_TCC13-1 nil 3584286639
   ("" (skosimp* :preds? t)
    (("" (expand "sexpr?") (("" (propax) nil nil)) nil)) nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (τ_TCC14 0
  (τ_TCC14-1 nil 3584286639
   ("" (skosimp* :preds? t)
    (("" (expand scontext?) (("" (propax) nil nil)) nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (admissible? const-decl "bool" init_context nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) nil
    (sexpr? adt-def-decl "boolean" language nil)
    (keyword type-decl nil tau nil) (pretcc type-eq-decl nil tau nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (τ_TCC15 0
  (τ_TCC15-1 nil 3584286639 ("" (grind) nil nil)
   ((TRUE const-decl "bool" booleans nil)
    (pretcc type-eq-decl nil tau nil) (keyword type-decl nil tau nil)
    (sexpr? adt-def-decl "boolean" language nil) nil
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil) nil
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (< def-decl "bool" ordinals nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (scontext? adt-def-decl "boolean" language nil)
    (syntaxic type-decl nil language nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (O const-decl "finseq" finite_sequences nil) nil
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (bool_theory const-decl "(theory?)" init_context nil)
    (bool_ const-decl "(sexpr?)" init_context nil)
    (equalities const-decl "(theory?)" init_context nil)
    (FALSE_ const-decl "(sexpr?)" init_context nil)
    (length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (equal const-decl "(sexpr?)" init_context nil)
    (≐ const-decl "(sexpr?)" init_context nil) nil
    (not_ const-decl "(sexpr?)" init_context nil)
    (¬ const-decl "(sexpr?)" init_context nil) nil nil
    (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND (scontext?(U) IFF scontext?(V))}"
       subst nil)
    nil (TRUE_ const-decl "(sexpr?)" init_context nil)
    (init_context const-decl "(theory?)" init_context nil)
    (admissible? const-decl "bool" init_context nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil))
 (τ_TCC16 0
  (τ_TCC16-1 nil 3584286639 ("" (subtype-tcc) nil nil) nil nil))
 (τ_TCC17 0
  (τ_TCC17-1 nil 3584286639 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (admissible? const-decl "bool" init_context nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) nil
    (sexpr? adt-def-decl "boolean" language nil)
    (keyword type-decl nil tau nil) (pretcc type-eq-decl nil tau nil)
    (TRUE const-decl "bool" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) nil nil
    (const_var adt-constructor-decl "[(sexpr?) -> (const_var?)]"
     language nil)
    (const_var? adt-recognizer-decl "[syntaxic -> boolean]" language
     nil)
    nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (init_context const-decl "(theory?)" init_context nil)
    (TRUE_ const-decl "(sexpr?)" init_context nil) nil
    (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND (scontext?(U) IFF scontext?(V))}"
       subst nil)
    nil nil (¬ const-decl "(sexpr?)" init_context nil)
    (not_ const-decl "(sexpr?)" init_context nil) nil
    (≐ const-decl "(sexpr?)" init_context nil)
    (equal const-decl "(sexpr?)" init_context nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (length def-decl "nat" list_props nil)
    (FALSE_ const-decl "(sexpr?)" init_context nil)
    (equalities const-decl "(theory?)" init_context nil)
    (bool_ const-decl "(sexpr?)" init_context nil)
    (bool_theory const-decl "(theory?)" init_context nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (O const-decl "finseq" finite_sequences nil) nil)
   nil))
 (τ_TCC18 0
  (τ_TCC18-1 nil 3584286639 ("" (grind) nil nil)
   ((scontext? adt-def-decl "boolean" language nil)) nil))
 (τ_TCC19 0
  (τ_TCC19-1 nil 3584286639 ("" (grind :rewrites scontext?) nil nil)
   ((scontext? adt-def-decl "boolean" language nil)) nil))
 (τ_TCC20 0
  (τ_TCC20-1 nil 3584286639
   ("" (skosimp* :preds? t)
    (("" (expand admissible?)
      (("" (expand (++ ^^))
        (("" (expand o) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((O const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (bool_theory const-decl "(theory?)" init_context nil)
    (bool_ const-decl "(sexpr?)" init_context nil)
    (equalities const-decl "(theory?)" init_context nil)
    (FALSE_ const-decl "(sexpr?)" init_context nil)
    (length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (equal const-decl "(sexpr?)" init_context nil)
    (≐ const-decl "(sexpr?)" init_context nil) nil
    (not_ const-decl "(sexpr?)" init_context nil)
    (¬ const-decl "(sexpr?)" init_context nil) nil nil
    (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND (scontext?(U) IFF scontext?(V))}"
       subst nil)
    nil (TRUE_ const-decl "(sexpr?)" init_context nil)
    (init_context const-decl "(theory?)" init_context nil)
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (^^ const-decl "finseq" finite_sequences nil) nil
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (admissible? const-decl "bool" init_context nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) nil
    (sexpr? adt-def-decl "boolean" language nil)
    (keyword type-decl nil tau nil) (pretcc type-eq-decl nil tau nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (τ_TCC21 0
  (τ_TCC21-1 nil 3584286639 ("" (grind) nil nil)
   ((scontext? adt-def-decl "boolean" language nil)) nil))
 (τ_TCC22 0
  (τ_TCC22-1 nil 3584286639
   ("" (skosimp* :preds? t) (("" (grind) nil nil)) nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (bool_theory const-decl "(theory?)" init_context nil)
    (bool_ const-decl "(sexpr?)" init_context nil)
    (equalities const-decl "(theory?)" init_context nil)
    (FALSE_ const-decl "(sexpr?)" init_context nil)
    (length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (equal const-decl "(sexpr?)" init_context nil)
    (≐ const-decl "(sexpr?)" init_context nil) nil
    (not_ const-decl "(sexpr?)" init_context nil)
    (¬ const-decl "(sexpr?)" init_context nil) nil nil
    (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND (scontext?(U) IFF scontext?(V))}"
       subst nil)
    nil (TRUE_ const-decl "(sexpr?)" init_context nil)
    (init_context const-decl "(theory?)" init_context nil)
    (O const-decl "finseq" finite_sequences nil) nil
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (admissible? const-decl "bool" init_context nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) nil
    (sexpr? adt-def-decl "boolean" language nil)
    (keyword type-decl nil tau nil) (pretcc type-eq-decl nil tau nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (τ_TCC23 0
  (τ_TCC23-1 nil 3584286639 ("" (subtype-tcc) nil nil) nil nil))
 (τ_TCC24 0
  (τ_TCC24-1 nil 3584286639 ("" (grind :rewrites scontext?) nil nil)
   ((scontext? adt-def-decl "boolean" language nil)) nil))
 (τ_TCC25 0
  (τ_TCC25-1 nil 3584286639
   ("" (skosimp* :preds? t)
    (("" (expand (admissible? ++)) (("" (grind) nil nil)) nil)) nil)
   (nil (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (bool_theory const-decl "(theory?)" init_context nil)
    (bool_ const-decl "(sexpr?)" init_context nil)
    (equalities const-decl "(theory?)" init_context nil)
    (FALSE_ const-decl "(sexpr?)" init_context nil)
    (length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (equal const-decl "(sexpr?)" init_context nil)
    (≐ const-decl "(sexpr?)" init_context nil) nil
    (not_ const-decl "(sexpr?)" init_context nil)
    (¬ const-decl "(sexpr?)" init_context nil) nil nil
    (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND (scontext?(U) IFF scontext?(V))}"
       subst nil)
    nil (TRUE_ const-decl "(sexpr?)" init_context nil)
    (init_context const-decl "(theory?)" init_context nil)
    (O const-decl "finseq" finite_sequences nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (admissible? const-decl "bool" init_context nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) nil
    (sexpr? adt-def-decl "boolean" language nil)
    (keyword type-decl nil tau nil) (pretcc type-eq-decl nil tau nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (τ_TCC26 0
  (τ_TCC26-1 nil 3584286639 ("" (subtype-tcc) nil nil) nil nil))
 (τ_TCC27 0
  (τ_TCC27-1 nil 3584286639
   ("" (skosimp* :preds? t) (("" (grind) nil nil)) nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (bool_theory const-decl "(theory?)" init_context nil)
    (bool_ const-decl "(sexpr?)" init_context nil)
    (equalities const-decl "(theory?)" init_context nil)
    (FALSE_ const-decl "(sexpr?)" init_context nil)
    (length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (equal const-decl "(sexpr?)" init_context nil)
    (≐ const-decl "(sexpr?)" init_context nil) nil
    (not_ const-decl "(sexpr?)" init_context nil)
    (¬ const-decl "(sexpr?)" init_context nil) nil nil
    (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND (scontext?(U) IFF scontext?(V))}"
       subst nil)
    nil (TRUE_ const-decl "(sexpr?)" init_context nil)
    (init_context const-decl "(theory?)" init_context nil)
    (O const-decl "finseq" finite_sequences nil) nil
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (admissible? const-decl "bool" init_context nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) nil
    (sexpr? adt-def-decl "boolean" language nil)
    (keyword type-decl nil tau nil) (pretcc type-eq-decl nil tau nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (τ_TCC28 0
  (τ_TCC28-1 nil 3584286639
   ("" (skosimp* :preds? t) (("" (grind) nil nil)) nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (bool_theory const-decl "(theory?)" init_context nil)
    (bool_ const-decl "(sexpr?)" init_context nil)
    (equalities const-decl "(theory?)" init_context nil)
    (FALSE_ const-decl "(sexpr?)" init_context nil)
    (length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (equal const-decl "(sexpr?)" init_context nil)
    (≐ const-decl "(sexpr?)" init_context nil) nil
    (not_ const-decl "(sexpr?)" init_context nil)
    (¬ const-decl "(sexpr?)" init_context nil) nil nil
    (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND (scontext?(U) IFF scontext?(V))}"
       subst nil)
    nil (TRUE_ const-decl "(sexpr?)" init_context nil)
    (init_context const-decl "(theory?)" init_context nil)
    (O const-decl "finseq" finite_sequences nil) nil
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (admissible? const-decl "bool" init_context nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) nil
    (sexpr? adt-def-decl "boolean" language nil)
    (keyword type-decl nil tau nil) (pretcc type-eq-decl nil tau nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (τ_TCC29 0
  (τ_TCC29-1 nil 3584286639 ("" (termination-tcc) nil nil)
   ((scontext? adt-def-decl "boolean" language nil)) nil))
 (τ_TCC30 0
  (τ_TCC30-1 nil 3584286639 ("" (termination-tcc) nil nil) nil nil))
 (τ_TCC31 0
  (τ_TCC31-1 nil 3584286639 ("" (grind :rewrites sexpr?) nil nil) nil
   nil))
 (τ_TCC32 0
  (τ_TCC32-1 nil 3584286639 ("" (grind :rewrites scontext?) nil nil)
   ((scontext? adt-def-decl "boolean" language nil)) nil))
 (τ_TCC33 0
  (τ_TCC33-1 nil 3584286639
   ("" (skosimp* :preds? t)
    (("" (expand (admissible? ++)) (("" (grind) nil nil)) nil)) nil)
   (nil (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (bool_theory const-decl "(theory?)" init_context nil)
    (bool_ const-decl "(sexpr?)" init_context nil)
    (equalities const-decl "(theory?)" init_context nil)
    (FALSE_ const-decl "(sexpr?)" init_context nil)
    (length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (equal const-decl "(sexpr?)" init_context nil)
    (≐ const-decl "(sexpr?)" init_context nil) nil
    (not_ const-decl "(sexpr?)" init_context nil)
    (¬ const-decl "(sexpr?)" init_context nil) nil nil
    (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND (scontext?(U) IFF scontext?(V))}"
       subst nil)
    nil (TRUE_ const-decl "(sexpr?)" init_context nil)
    (init_context const-decl "(theory?)" init_context nil)
    (O const-decl "finseq" finite_sequences nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (admissible? const-decl "bool" init_context nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) nil
    (sexpr? adt-def-decl "boolean" language nil)
    (keyword type-decl nil tau nil) (pretcc type-eq-decl nil tau nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (τ_TCC34 0
  (τ_TCC34-1 nil 3584286639 ("" (termination-tcc) nil nil) nil nil))
 (τ_TCC35 0
  (τ_TCC35-1 nil 3584286639 ("" (grind) nil nil)
   ((O const-decl "finseq" finite_sequences nil) nil
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (τ_TCC36 0
  (τ_TCC36-1 nil 3584286639
   ("" (skosimp* :preds? t) (("" (grind) nil nil)) nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (bool_theory const-decl "(theory?)" init_context nil)
    (bool_ const-decl "(sexpr?)" init_context nil)
    (equalities const-decl "(theory?)" init_context nil)
    (FALSE_ const-decl "(sexpr?)" init_context nil)
    (length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (equal const-decl "(sexpr?)" init_context nil)
    (≐ const-decl "(sexpr?)" init_context nil) nil
    (not_ const-decl "(sexpr?)" init_context nil)
    (¬ const-decl "(sexpr?)" init_context nil) nil nil
    (↑ def-decl "{V |
         (sexpr?(U) IFF sexpr?(V)) AND
          (sinterp?(U) IFF sinterp?(V)) AND (scontext?(U) IFF scontext?(V))}"
       subst nil)
    nil (TRUE_ const-decl "(sexpr?)" init_context nil)
    (init_context const-decl "(theory?)" init_context nil)
    (O const-decl "finseq" finite_sequences nil) nil
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (admissible? const-decl "bool" init_context nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) nil
    (sexpr? adt-def-decl "boolean" language nil)
    (keyword type-decl nil tau nil) (pretcc type-eq-decl nil tau nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (τ_TCC37 0
  (τ_TCC37-1 nil 3584286639 ("" (termination-tcc) nil nil) nil nil))
 (τ_TCC38 0
  (τ_TCC38-1 nil 3584286639
   ("" (skosimp* :preds? t) (("" (grind :rewrites sexpr?) nil nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (ordstruct type-decl nil ordstruct_adt nil)
    (< def-decl "bool" ordinals nil)
    (ordinal? def-decl "bool" ordinals nil)
    (ordinal nonempty-type-eq-decl nil ordinals nil)
    (TRUE const-decl "bool" booleans nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (τ_TCC39 0
  (τ_TCC39-1 nil 3584286639 ("" (grind) nil nil)
   ((shift_size application-judgement
     "{V | type_size(V) = type_size(U)}" supertype nil))
   nil))
 (τ_TCC40 0
  (τ_TCC40-1 nil 3584286639 ("" (grind) nil nil)
   ((sexpr? adt-def-decl "boolean" language nil)) nil))
 (τ_TCC41 0
  (τ_TCC41-1 nil 3584286639 ("" (termination-tcc) nil nil) nil nil))
 (τ_TCC42 0
  (τ_TCC42-1 nil 3584286639 ("" (subtype-tcc) nil nil) nil nil))
 (τ_TCC43 0
  (τ_TCC43-1 nil 3584367711 ("" (grind) nil nil)
   ((sexpr? adt-def-decl "boolean" language nil)) nil))
 (τ_TCC44 0
  (τ_TCC44-1 nil 3584367711 ("" (termination-tcc) nil nil) nil nil))
 (τ_TCC45 0
  (τ_TCC45-1 nil 3584367711 ("" (termination-tcc) nil nil) nil nil))
 (τ_TCC46 0
  (τ_TCC46-1 nil 3584367711 ("" (termination-tcc) nil nil) nil nil))
 (τ_TCC47 0
  (τ_TCC47-1 nil 3584367711 ("" (termination-tcc) nil nil) nil nil))
 (τ_TCC48 0
  (τ_TCC48-1 nil 3584367711 ("" (termination-tcc) nil nil) nil nil))
 (τ_TCC49 0
  (τ_TCC49-1 nil 3584367711 ("" (termination-tcc) nil nil) nil nil))
 (τ_TCC50 0
  (τ_TCC50-1 nil 3584367711 ("" (termination-tcc) nil nil) nil nil))
 (test_TCC1 0
  (test_TCC1-1 nil 3584456707 ("" (subtype-tcc) nil nil) nil nil))
 (test 0
       (test-1 nil 3584456707
        ("" (assert)
         (("" (expand τ)
           (("" (lift-if)
             (("" (split 1)
               (("1" (propax) nil nil)
                ("2" (flatten)
                 (("2" (split 2)
                   (("1" (flatten)
                     (("1" (split 1)
                       (("1" (flatten)
                         (("1" (decompose-equality 1)
                           (("1" (expand ++ 1)
                             (("1" (postpone) nil nil)) nil)
                            ("2" (grind) nil nil))
                           nil))
                         nil)
                        ("2" (flatten)
                         (("2" (expand finseq_appl)
                           (("2" (expand rest -1)
                             (("2" (expand ^^)
                               (("2"
                                 (lift-if)
                                 (("2"
                                   (assert)
                                   (("2"
                                     (expand init_context -1 1)
                                     (("2"
                                       (expand init_context -1 1)
                                       (("2"
                                         (expand min -1)
                                         (("2"
                                           (expand τ -1)
                                           (("2"
                                             (assert)
                                             (("2"
                                               (lift-if)
                                               (("2"
                                                 (assert)
                                                 (("2"
                                                   (split -1)
                                                   (("1"
                                                     (grind)
                                                     nil
                                                     nil)
                                                    ("2"
                                                     (flatten)
                                                     (("2"
                                                       (split -1)
                                                       (("1"
                                                         (flatten)
                                                         (("1"
                                                           (split -2)
                                                           (("1"
                                                             (postpone)
                                                             nil
                                                             nil)
                                                            ("2"
                                                             (postpone)
                                                             nil
                                                             nil))
                                                           nil))
                                                         nil)
                                                        ("2"
                                                         (postpone)
                                                         nil
                                                         nil))
                                                       nil))
                                                     nil))
                                                   nil))
                                                 nil))
                                               nil))
                                             nil))
                                           nil))
                                         nil))
                                       nil))
                                     nil))
                                   nil))
                                 nil))
                               nil))
                             nil))
                           nil))
                         nil))
                       nil))
                     nil)
                    ("2" (postpone) nil nil))
                   nil))
                 nil))
               nil))
             nil))
           nil))
         nil)
        nil shostak)))

