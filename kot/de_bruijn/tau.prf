(tau
 (π_TCC1 0
  (π_TCC1-1 nil 3584367711
   ("" (grind) (("" (grind :rewrites (sexpr?)) nil nil)) nil)
   ((sexpr? adt-def-decl "boolean" language nil)) nil))
 (uparrow_TCC1 0
  (uparrow_TCC1-1 nil 3584986495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (↑ def-decl
     "{V | (sexpr?(U) IFF sexpr?(V)) AND (sinterp?(U) IFF sinterp?(V)) AND (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
     subst nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (subst_TCC1 0
  (subst_TCC1-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (invoke (typepred "%1") (~ + "theory?(%1)"))
      (("" (assert) nil nil)) nil))
    nil)
   ((IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (theory_ adt-constructor-decl "[finseq[(scontext?)] -> (theory?)]"
     language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (subst def-decl
           "{V | (sexpr?(U) IFF sexpr?(V)) AND (sinterp?(U) IFF sinterp?(V)) AND (scontext?(U) IFF scontext?(V)) AND (ideep?(U) IFF ideep?(V))}"
           subst
      nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (syntaxic type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (τ0_TCC1 0
  (τ0_TCC1-1 nil 3584986495
   ("" (skosimp* :preds? t) (("" (assert) (("" (grind) nil nil)) nil))
    nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible0? const-decl "bool" interp nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil)
    (expandable? const-decl "bool" delta nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC2 0
  (τ0_TCC2-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (expand typecheckable? -1)
      (("" (assert) (("" (flatten) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC3 0
  (τ0_TCC3-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (assert) (("" (expand sinterp? 1) (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC4 0
  (τ0_TCC4-1 nil 3584986495 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (kind const-decl "prekeyword" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil)
    (compatible0? const-decl "bool" interp nil))
   nil))
 (τ0_TCC5 0
  (τ0_TCC5-1 nil 3584986495 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (kind const-decl "prekeyword" language nil))
   nil))
 (τ0_TCC6 0
  (τ0_TCC6-1 nil 3584986495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (shift_size application-judgement
     "{V | type_size(V) = type_size(U)}" supertype nil))
   nil))
 (τ0_TCC7 0
  (τ0_TCC7-1 nil 3584986495 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (kind const-decl "prekeyword" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil)
    (compatible0? const-decl "bool" interp nil))
   nil))
 (τ0_TCC8 0
  (τ0_TCC8-1 nil 3584986495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (τ0_TCC9 0
  (τ0_TCC9-1 nil 3584986495 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC10 0
  (τ0_TCC10-1 nil 3584986495 ("" (subtype-tcc) nil nil)
   ((ρ0 const-decl "syntaxic" delta nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC11 0
  (τ0_TCC11-1 nil 3584986495 ("" (termination-tcc) nil nil)
   ((empty_seq const-decl "finseq" finite_sequences nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil)
    (compatible0? const-decl "bool" interp nil))
   nil))
 (τ0_TCC12 0
  (τ0_TCC12-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (expand expandable? 1) (("" (assert) nil nil)) nil)) nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC13 0
  (τ0_TCC13-1 nil 3584986495 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (shift_size application-judgement
     "{V | type_size(V) = type_size(U)}" supertype nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (expand def-decl
            "{V | (sexpr?(U) IMPLIES sexpr?(V)) AND (scontext?(U) IMPLIES scontext?(V)) AND (ideep?(U) IMPLIES theory?(V)) AND (ikeep?(U) OR itype?(U) OR iterm?(U) IMPLIES scontext?(V))}"
            delta nil)
    (definition? const-decl "bool" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ρ0 const-decl "syntaxic" delta nil))
   nil))
 (τ0_TCC14 0
  (τ0_TCC14-1 nil 3584986495 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (O const-decl "finseq" finite_sequences nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC15 0
  (τ0_TCC15-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (rewrite -4) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC16 0
  (τ0_TCC16-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (split 1)
        (("1" (flatten)
          (("1" (inst - "Γ!1 ++ decls(S!1)")
            (("1" (inst - x!1)
              (("1" (flatten)
                (("1" (expand η -1)
                  (("1" (assert)
                    (("1" (lift-if)
                      (("1" (split -1)
                        (("1" (flatten) (("1" (assert) nil nil)) nil)
                         ("2" (flatten)
                          (("2" (assert)
                            (("2" (split 2)
                              (("1"
                                (expand ρ0 1)
                                (("1"
                                  (rewrite -12 :dont-delete? t)
                                  (("1"
                                    (expand expand 1)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (reveal -2)
                                        (("1"
                                          (inst - Γ!1)
                                          (("1"
                                            (inst - i!1)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (expand ρ0)
                                                    (("1"
                                                      (lift-if)
                                                      (("1"
                                                        (split 1)
                                                        (("1"
                                                          (flatten)
                                                          (("1"
                                                            (rewrite
                                                             -29
                                                             :dont-delete?
                                                             t)
                                                            (("1"
                                                              (postpone)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (flatten)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2" (assert) nil nil))
                                nil)
                               ("3"
                                (assert)
                                (("3"
                                  (flatten)
                                  (("3"
                                    (assert)
                                    (("3"
                                      (expand ρ0)
                                      (("3"
                                        (rewrite -14 :dont-delete? t)
                                        (("3"
                                          (assert)
                                          (("3"
                                            (expand expand 1)
                                            (("3"
                                              (assert)
                                              (("3"
                                                (lift-if)
                                                (("3"
                                                  (split 1)
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (rewrite
                                                       -22
                                                       :dir
                                                       rl
                                                       :dont-delete?
                                                       t)
                                                      (("1"
                                                        (rewrite
                                                         -6
                                                         :dir
                                                         rl)
                                                        (("1"
                                                          (postpone)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (reveal -2)
                                                        (("2"
                                                          (inst - Γ!1)
                                                          (("2"
                                                            (inst
                                                             -
                                                             i!1)
                                                            (("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (inst - "Γ!1 ++ decls(S!1)")
            (("2" (inst - x!1)
              (("2" (flatten)
                (("2" (expand η -1)
                  (("2" (lift-if)
                    (("2" (split -1)
                      (("1" (assert) nil nil)
                       ("2" (flatten)
                        (("2" (assert)
                          (("2" (expand scontext? -4)
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (flatten)
          (("3" (inst - "Γ!1 ++ decls(S!1)")
            (("3" (inst - x!1)
              (("3" (flatten)
                (("3" (assert)
                  (("3" (expand η -1) (("3" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("4" (flatten)
          (("4" (inst - "Γ!1 ++ decls(S!1)")
            (("4" (inst - x!1)
              (("4" (expand η -1)
                (("4" (assert)
                  (("4" (lift-if)
                    (("4" (assert)
                      (("4" (split -1)
                        (("1" (assert) nil nil) ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC17 0
  (τ0_TCC17-1 nil 3584986495 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (expand def-decl
            "{V | (sexpr?(U) IMPLIES sexpr?(V)) AND (scontext?(U) IMPLIES scontext?(V)) AND (ideep?(U) IMPLIES theory?(V)) AND (ikeep?(U) OR itype?(U) OR iterm?(U) IMPLIES scontext?(V))}"
            delta nil)
    (definition? const-decl "bool" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (O const-decl "finseq" finite_sequences nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil)
    (compatible0? const-decl "bool" interp nil))
   nil))
 (τ0_TCC18 0
  (τ0_TCC18-1 nil 3584986495
   ("" (skosimp* :preds? t) (("" (grind) nil nil)) nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (O const-decl "finseq" finite_sequences nil)
    (expand def-decl
            "{V | (sexpr?(U) IMPLIES sexpr?(V)) AND (scontext?(U) IMPLIES scontext?(V)) AND (ideep?(U) IMPLIES theory?(V)) AND (ikeep?(U) OR itype?(U) OR iterm?(U) IMPLIES scontext?(V))}"
            delta nil)
    (definition? const-decl "bool" language nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC19 0
  (τ0_TCC19-1 nil 3584986495 ("" (subtype-tcc) nil nil)
   ((ρ0 const-decl "syntaxic" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC20 0
  (τ0_TCC20-1 nil 3584986495
   ("" (skosimp* :preds? t) (("" (grind) nil nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (τ0_TCC21 0
  (τ0_TCC21-1 nil 3584986495
   ("" (skosimp* :preds? t) (("" (grind) nil nil)) nil)
   ((size def-decl "posnat" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (τ0_TCC22 0
  (τ0_TCC22-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (inst - Γ!1)
      (("" (inst - m!1) (("" (flatten) (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (τ0_TCC23 0
  (τ0_TCC23-1 nil 3584986495 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible0? const-decl "bool" interp nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (τ0_TCC24 0
  (τ0_TCC24-1 nil 3584986495 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ρ0 const-decl "syntaxic" delta nil))
   nil))
 (τ0_TCC25 0
  (τ0_TCC25-1 nil 3584986495 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (ρ0 const-decl "syntaxic" delta nil))
   nil))
 (τ0_TCC26 0
  (τ0_TCC26-1 nil 3584986495
   ("" (skosimp* :preds? t) (("" (grind) nil nil)) nil)
   ((O const-decl "finseq" finite_sequences nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC27 0
  (τ0_TCC27-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (rewrite -5) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC28 0
  (τ0_TCC28-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (copy -3)
      (("" (inst?)
        (("" (inst - "Γ!1 ++ decls(sigM!1)")
          (("" (inst - σ!1)
            (("" (flatten)
              (("" (assert)
                (("" (rewrite -18 :dir rl)
                  (("" (rewrite -13 :dir rl)
                    (("" (assert)
                      (("" (flatten) (("" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((++ const-decl "finseq[(scontext?)]" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC29 0
  (τ0_TCC29-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (inst?) (("" (flatten) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC30 0
  (τ0_TCC30-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (copy -3)
      (("" (inst?)
        (("" (inst - "Γ!1 ++ decls(sigM!1)")
          (("" (inst - σ!1)
            (("" (flatten)
              (("" (assert)
                (("" (flatten) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((++ const-decl "finseq[(scontext?)]" language nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC31 0
  (τ0_TCC31-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (inst - "Γ!1 ++ decls(sigM!1)")
      (("" (inst - σ!1) (("" (flatten) (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((++ const-decl "finseq[(scontext?)]" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC32 0
  (τ0_TCC32-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (inst -11 z!1)
        (("" (inst -14 z!1)
          (("1" (assert) nil nil)
           ("2" (copy -3)
            (("2" (inst - Γ!1)
              (("2" (inst - m!1)
                (("2" (inst - "Γ!1 ++ decls(sigM!1)")
                  (("2" (inst - σ!1)
                    (("2" (flatten)
                      (("2" (assert)
                        (("2" (flatten) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (tccsm!1 skolem-const-decl "tccs" tau nil)
    (z!1 skolem-const-decl "below(length(map(tccsm!1)))" tau nil)
    (tccsi!1 skolem-const-decl "tccs" tau nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC33 0
  (τ0_TCC33-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (expand ρ0)
        (("" (split 1)
          (("1" (rewrite -5)
            (("1" (expand expand 1)
              (("1" (lift-if)
                (("1" (inst?)
                  (("1" (flatten)
                    (("1" (assert)
                      (("1" (flatten)
                        (("1" (assert)
                          (("1" (split 1)
                            (("1" (flatten)
                              (("1"
                                (typepred
                                 "expand(TRUE)(Γ!1 ++ decls(sigM!1), σ!1)")
                                (("1"
                                  (assert)
                                  (("1"
                                    (rewrite -23)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand externalize 1)
                                        (("1" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (expand expandable? 1)
                                  (("2"
                                    (split 1)
                                    (("1"
                                      (expand ++ 1)
                                      (("1" (assert) nil nil))
                                      nil)
                                     ("2"
                                      (lemma extract_concat)
                                      (("2"
                                        (inst - Γ!1 "decls(sigM!1)")
                                        (("2"
                                          (rewrite -18)
                                          (("2"
                                            (rewrite -1)
                                            (("2"
                                              (rewrite -13)
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (reveal -2)
                              (("2"
                                (inst - "Γ!1 ++ decls(sigM!1)")
                                (("2"
                                  (inst - σ!1)
                                  (("2"
                                    (flatten)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (flatten)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (case
                                             "(Γ!1 ++ decls(sigM!1)) ^^ (0, length(map(σ!1))) = decls(sigM!1)")
                                            (("1"
                                              (rewrite -1)
                                              (("1"
                                                (rewrite -16)
                                                nil
                                                nil))
                                              nil)
                                             ("2"
                                              (decompose-equality 1)
                                              (("1"
                                                (expand ^^ 1)
                                                (("1"
                                                  (lift-if)
                                                  (("1"
                                                    (split 1)
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (flatten)
                                                      (("2"
                                                        (expand min 3)
                                                        (("2"
                                                          (assert)
                                                          (("2"
                                                            (lift-if)
                                                            (("2"
                                                              (assert)
                                                              (("2"
                                                                (split
                                                                 3)
                                                                (("1"
                                                                  (assert)
                                                                  (("1"
                                                                    (grind)
                                                                    nil
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (propax)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (decompose-equality 1)
                                                (("2"
                                                  (expand ^^ 1)
                                                  (("2"
                                                    (lift-if)
                                                    (("2"
                                                      (split 1)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (typepred
                                                           x!1)
                                                          (("1"
                                                            (expand
                                                             ^^
                                                             -1)
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (lift-if)
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (flatten)
                                                        (("2"
                                                          (expand ++ 3)
                                                          (("2"
                                                            (assert)
                                                            (("2"
                                                              (lift-if)
                                                              (("2"
                                                                (assert)
                                                                (("2"
                                                                  (typepred
                                                                   x!1)
                                                                  (("2"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (rewrite -5)
            (("2" (expand expand 1)
              (("2" (inst?)
                (("2" (flatten)
                  (("2" (assert)
                    (("2" (lift-if)
                      (("2" (flatten)
                        (("2" (assert)
                          (("2" (reveal -2)
                            (("2" (inst - "Γ!1 ++ decls(sigM!1)")
                              (("2"
                                (inst - σ!1)
                                (("2"
                                  (flatten)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (flatten)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (split 1)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (rewrite -22 :dir rl)
                                                (("1"
                                                  (rewrite -19 :dir rl)
                                                  (("1"
                                                    (rewrite
                                                     -16
                                                     :dir
                                                     rl
                                                     :dont-delete?
                                                     t)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (rewrite
                                                         -9
                                                         :dir
                                                         rl)
                                                        (("1"
                                                          (rewrite -13)
                                                          (("1"
                                                            (typepred
                                                             "expand(TRUE)(Γ!1 ++ decls(sigM!1), σ!1)")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (expand
                                                                 externalize
                                                                 1)
                                                                (("1"
                                                                  (lemma
                                                                   expand_size_ideep)
                                                                  (("1"
                                                                    (inst
                                                                     -
                                                                     TRUE
                                                                     "Γ!1 ++ decls(expand(TRUE)(Γ!1, m!1))"
                                                                     "map(σ!1)")
                                                                    (("1"
                                                                      (split
                                                                       -1)
                                                                      (("1"
                                                                        (rewrite
                                                                         -19)
                                                                        (("1"
                                                                          (assert)
                                                                          (("1"
                                                                            (case
                                                                             "ideep(map(σ!1)) = σ!1")
                                                                            (("1"
                                                                              (rewrite
                                                                               -1)
                                                                              nil
                                                                              nil)
                                                                             ("2"
                                                                              (decompose-equality
                                                                               1)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (typepred!
                                                                         "σ!1"
                                                                         :implicit?
                                                                         t)
                                                                        (("2"
                                                                          (case
                                                                           "ideep(map(σ!1)) = σ!1")
                                                                          (("1"
                                                                            (rewrite
                                                                             -22)
                                                                            (("1"
                                                                              (rewrite
                                                                               -1)
                                                                              nil
                                                                              nil))
                                                                            nil)
                                                                           ("2"
                                                                            (decompose-equality
                                                                             1)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (lemma extract_concat)
                                                (("2"
                                                  (inst
                                                   -
                                                   Γ!1
                                                   "decls(sigM!1)")
                                                  (("2"
                                                    (rewrite -25)
                                                    (("2"
                                                      (rewrite -16)
                                                      (("2"
                                                        (rewrite -1)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((expand def-decl
            "{V | (sexpr?(U) IMPLIES sexpr?(V)) AND (scontext?(U) IMPLIES scontext?(V)) AND (ideep?(U) IMPLIES theory?(V)) AND (ikeep?(U) OR itype?(U) OR iterm?(U) IMPLIES scontext?(V))}"
            delta nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (extract_concat formula-decl nil language nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (O const-decl "finseq" finite_sequences nil)
    (externalize const-decl "same(U)" delta nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (TRUE const-decl "bool" booleans nil)
    (expand_size_ideep formula-decl nil delta nil)
    (syntaxic_ideep_extensionality formula-decl nil language nil)
    (ideep adt-constructor-decl "[finseq[(sinterp?)] -> (ideep?)]"
     language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC34 0
  (τ0_TCC34-1 nil 3584986495
   ("" (skosimp* :preds? t) (("" (assert) nil nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC35 0
  (τ0_TCC35-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (use size_extract :polarity? t)
      (("" (rewrite -7) (("" (rewrite -6) (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((size_extract formula-decl nil language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC36 0
  (τ0_TCC36-1 nil 3584986495 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC37 0
  (τ0_TCC37-1 nil 3584986495 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil))
   nil))
 (τ0_TCC38 0
  (τ0_TCC38-1 nil 3584986495 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (expand def-decl
            "{V | (sexpr?(U) IMPLIES sexpr?(V)) AND (scontext?(U) IMPLIES scontext?(V)) AND (ideep?(U) IMPLIES theory?(V)) AND (ikeep?(U) OR itype?(U) OR iterm?(U) IMPLIES scontext?(V))}"
            delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil)
    (compatible0? const-decl "bool" interp nil))
   nil))
 (τ0_TCC39 0
  (τ0_TCC39-1 nil 3584986495 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (τ0_TCC40 0
  (τ0_TCC40-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (rewrite -3)
        (("" (assert)
          (("" (expand typecheckable?)
            (("" (assert)
              (("" (typepred "Θ!1`seq(pos!1)")
                (("" (expand scontext? -1) (("" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC41 0
  (τ0_TCC41-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (rewrite -3)
      (("" (assert)
        (("" (typepred sum)
          (("" (inst?) (("" (inst?) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (<= const-decl "bool" reals nil)
    (sum def-decl "{n: nat | FORALL (x: below[len]): f(x) <= n}"
     language nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC42 0
  (τ0_TCC42-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (expand expandable? 2)
        (("" (assert)
          (("" (typepred "Θ!1`seq(pos!1)")
            (("" (expand scontext? -1)
              (("" (assert) (("" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC43 0
  (τ0_TCC43-1 nil 3584986495 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (ρ0 const-decl "syntaxic" delta nil))
   nil))
 (τ0_TCC44 0
  (τ0_TCC44-1 nil 3584986495 ("" (termination-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (O const-decl "finseq" finite_sequences nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC45 0
  (τ0_TCC45-1 nil 3584986495 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (ρ0 const-decl "syntaxic" delta nil))
   nil))
 (τ0_TCC46 0
  (τ0_TCC46-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (rewrite -4) (("" (rewrite size_extract) nil nil)) nil)) nil)
   ((size_extract formula-decl nil language nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC47 0
  (τ0_TCC47-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (typepred "k(tccsD!1)")
        (("" (assert)
          ((""
            (inst -
             "Γ!1 ++ (# length := 1, seq := LAMBDA (x: below[1]): epos!1 #)")
            (("1" (inst - "theory_(Θ!1 ^^ (0, pos!1))")
              (("1" (flatten)
                (("1" (assert) (("1" (grind) nil nil)) nil)) nil)
               ("2" (grind) nil nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (Γ!1 skolem-const-decl "finseq[(scontext?)]" tau nil)
    (theory_ adt-constructor-decl "[finseq[(scontext?)] -> (theory?)]"
     language nil)
    (Θ!1 skolem-const-decl "finseq[(scontext?)]" tau nil)
    (pos!1 skolem-const-decl "int" tau nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (O const-decl "finseq" finite_sequences nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (expand def-decl
            "{V | (sexpr?(U) IMPLIES sexpr?(V)) AND (scontext?(U) IMPLIES scontext?(V)) AND (ideep?(U) IMPLIES theory?(V)) AND (ikeep?(U) OR itype?(U) OR iterm?(U) IMPLIES scontext?(V))}"
            delta nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (epos!1 skolem-const-decl "syntaxic" tau nil)
    (k const-decl "(tccs?)" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC48 0
  (τ0_TCC48-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (split 2)
        (("1" (expand ρ0)
          (("1" (use expand_preserves_theory)
            (("1" (rewrite -5) nil nil)) nil))
          nil)
         ("2" (invoke (typepred "%1") (~ + "tccs?(%1)"))
          (("2" (assert) nil nil)) nil)
         ("3" (inst - "Γ!1 ++ k(epos!1)")
          (("1" (inst - "theory_(Θ!1 ^^ (0, pos!1))")
            (("1" (flatten)
              (("1" (assert)
                (("1" (flatten)
                  (("1" (assert)
                    (("1" (expand ρ0)
                      (("1" (rewrite -11)
                        (("1" (expand expand 1)
                          (("1" (lift-if)
                            (("1" (assert)
                              (("1"
                                (rewrite -10)
                                (("1"
                                  (expand ++ 1)
                                  (("1"
                                    (expand o 1)
                                    (("1"
                                      (expand ++ -5)
                                      (("1"
                                        (expand k 1)
                                        (("1"
                                          (expand o -5)
                                          (("1"
                                            (rewrite -11)
                                            (("1"
                                              (expand ++ 1)
                                              (("1"
                                                (expand o 1)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (rewrite -6)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (rewrite -8)
            (("2" (expand ρ0) (("2" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (epos!1 skolem-const-decl "syntaxic" tau nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (expand def-decl
            "{V | (sexpr?(U) IMPLIES sexpr?(V)) AND (scontext?(U) IMPLIES scontext?(V)) AND (ideep?(U) IMPLIES theory?(V)) AND (ikeep?(U) OR itype?(U) OR iterm?(U) IMPLIES scontext?(V))}"
            delta nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (O const-decl "finseq" finite_sequences nil)
    (theory_ adt-constructor-decl "[finseq[(scontext?)] -> (theory?)]"
     language nil)
    (++ const-decl "same(x)" language nil)
    (same type-eq-decl nil language nil)
    (k const-decl "(tccs?)" language nil)
    (TRUE const-decl "bool" booleans nil)
    (expand_preserves_theory formula-decl nil delta nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC49 0
  (τ0_TCC49-1 nil 3584986495
   ("" (skosimp* :preds? t) (("" (assert) nil nil)) nil)
   ((k const-decl "finseq[(scontext?)]" language nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC50 0
  (τ0_TCC50-1 nil 3584986495 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC51 0
  (τ0_TCC51-1 nil 3584986495 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (O const-decl "finseq" finite_sequences nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC52 0
  (τ0_TCC52-1 nil 3584986495 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible0? const-decl "bool" interp nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (τ0_TCC53 0
  (τ0_TCC53-1 nil 3584986495 ("" (subtype-tcc) nil nil)
   ((ρ0 const-decl "syntaxic" delta nil)) nil))
 (τ0_TCC54 0
  (τ0_TCC54-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (expand scontext? 1) (("" (propax) nil nil)) nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC55 0
  (τ0_TCC55-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (rewrite -5) (("" (assert) nil nil)) nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC56 0
  (τ0_TCC56-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (inst - "Γ!1 ++ k(const_var(ρ0(Γ!1)(A!1)))")
      (("" (inst - B!1) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((const_var adt-constructor-decl "[(sexpr?) -> (const_var?)]"
     language nil)
    (const_var? adt-recognizer-decl "[syntaxic -> boolean]" language
     nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC57 0
  (τ0_TCC57-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (inst?)
        (("" (flatten) (("" (assert) (("" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC58 0
  (τ0_TCC58-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (invoke (typepred "%1") (~ + "tcc?(%1)"))
        (("" (assert)
          (("" (inst?) (("" (flatten) (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (same type-eq-decl nil language nil)
    (++ const-decl "same(x)" language nil)
    (above nonempty-type-eq-decl nil integers nil)
    (forall_ const-decl "(tcc?)" init_context nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC59 0
  (τ0_TCC59-1 nil 3584986495 ("" (subtype-tcc) nil nil)
   ((ρ0 const-decl "syntaxic" delta nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (O const-decl "finseq" finite_sequences nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC60 0
  (τ0_TCC60-1 nil 3584986495 ("" (termination-tcc) nil nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil)
    (compatible0? const-decl "bool" interp nil))
   nil))
 (τ0_TCC61 0
  (τ0_TCC61-1 nil 3584986495 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC62 0
  (τ0_TCC62-1 nil 3584986495 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil))
   nil))
 (τ0_TCC63 0
  (τ0_TCC63-1 nil 3584986495 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (O const-decl "finseq" finite_sequences nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC64 0
  (τ0_TCC64-1 nil 3584986495 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (τ0_TCC65 0
  (τ0_TCC65-1 nil 3584986495 ("" (termination-tcc) nil nil)
   ((ρ0 const-decl "syntaxic" delta nil)) nil))
 (τ0_TCC66 0
  (τ0_TCC66-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (expand scontext? 1) (("" (propax) nil nil)) nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC67 0
  (τ0_TCC67-1 nil 3584986495 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (τ0_TCC68 0
  (τ0_TCC68-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (inst - "Γ!1 ++ k(const_var(ρ0(Γ!1)(A!1)))")
      (("" (inst - B!1) (("" (flatten) (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((const_var adt-constructor-decl "[(sexpr?) -> (const_var?)]"
     language nil)
    (const_var? adt-recognizer-decl "[syntaxic -> boolean]" language
     nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC69 0
  (τ0_TCC69-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (inst?) (("" (flatten) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((k const-decl "finseq[(scontext?)]" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC70 0
  (τ0_TCC70-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (invoke (typepred "%1") (~ + "tcc?(%1)"))
        (("" (assert) (("" (inst?) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (same type-eq-decl nil language nil)
    (++ const-decl "same(x)" language nil)
    (above nonempty-type-eq-decl nil integers nil)
    (forall_ const-decl "(tcc?)" init_context nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC71 0
  (τ0_TCC71-1 nil 3584986495 ("" (subtype-tcc) nil nil)
   ((ρ0 const-decl "syntaxic" delta nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (O const-decl "finseq" finite_sequences nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC72 0
  (τ0_TCC72-1 nil 3584986495 ("" (termination-tcc) nil nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil)
    (compatible0? const-decl "bool" interp nil))
   nil))
 (τ0_TCC73 0
  (τ0_TCC73-1 nil 3584986495 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC74 0
  (τ0_TCC74-1 nil 3584988346 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil))
   nil))
 (τ0_TCC75 0
  (τ0_TCC75-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (O const-decl "finseq" finite_sequences nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC76 0
  (τ0_TCC76-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (τ0_TCC77 0
  (τ0_TCC77-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((ρ0 const-decl "syntaxic" delta nil)) nil))
 (τ0_TCC78 0
  (τ0_TCC78-1 nil 3584988346
   ("" (skosimp* :preds? t)
    (("" (expand scontext? 1) (("" (propax) nil nil)) nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC79 0
  (τ0_TCC79-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (τ0_TCC80 0
  (τ0_TCC80-1 nil 3584988346
   ("" (skosimp* :preds? t)
    (("" (inst - "Γ!1 ++ k(const_var(ρ0(Γ!1)(T!1)))")
      (("" (inst - a!1) (("" (flatten) (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((const_var adt-constructor-decl "[(sexpr?) -> (const_var?)]"
     language nil)
    (const_var? adt-recognizer-decl "[syntaxic -> boolean]" language
     nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC81 0
  (τ0_TCC81-1 nil 3584988346
   ("" (skosimp* :preds? t) (("" (inst?) (("" (assert) nil nil)) nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC82 0
  (τ0_TCC82-1 nil 3584988346
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (invoke (typepred "%1") (~ + "tcc?(%1)"))
        (("" (assert)
          (("" (inst?) (("" (flatten) (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (same type-eq-decl nil language nil)
    (++ const-decl "same(x)" language nil)
    (above nonempty-type-eq-decl nil integers nil)
    (forall_ const-decl "(tcc?)" init_context nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC83 0
  (τ0_TCC83-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((bool_ const-decl "(sexpr?)" init_context nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (O const-decl "finseq" finite_sequences nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC84 0
  (τ0_TCC84-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC85 0
  (τ0_TCC85-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC86 0
  (τ0_TCC86-1 nil 3584988346 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil))
   nil))
 (τ0_TCC87 0
  (τ0_TCC87-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC88 0
  (τ0_TCC88-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (τ0_TCC89 0
  (τ0_TCC89-1 nil 3584988346
   ("" (skosimp* :preds? t)
    (("" (inst?)
      (("" (flatten)
        (("" (assert)
          (("" (reveal -2)
            (("" (inst - Γ!1)
              (("" (inst - a!1)
                (("" (flatten) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC90 0
  (τ0_TCC90-1 nil 3584988346
   ("" (skosimp* :preds? t)
    (("" (inst?)
      (("" (assert)
        (("" (assert)
          (("" (invoke (typepred "%1") (~ -16 "tccs?(%1)"))
            (("" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((same type-eq-decl nil language nil)
    (++ const-decl "same(x)" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC91 0
  (τ0_TCC91-1 nil 3584988346
   ("" (skosimp* :preds? t)
    (("" (inst?)
      (("" (flatten)
        (("" (assert)
          (("" (invoke (typepred "%1") (~ + "tcc?(%1)"))
            (("1" (assert)
              (("1" (invoke (typepred "%1") (~ -23 "tccs?(%1)"))
                (("1" (assert)
                  (("1" (invoke (typepred "%1") (~ + "tcc?(%1)"))
                    (("1" (assert) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (invoke (typepred "%1") (~ -22 "tccs?(%1)"))
                (("2" (assert)
                  (("2" (invoke (typepred "%1") (~ -3 "tccs?(%1)"))
                    (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("3" (reveal -2)
              (("3" (inst - Γ!1)
                (("3" (inst - a!1)
                  (("3" (flatten) (("3" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (same type-eq-decl nil language nil)
    (++ const-decl "same(x)" language nil)
    (above nonempty-type-eq-decl nil integers nil)
    (∼ def-decl "(tcc?)" supertype nil)
    (TYPEOF adt-accessor-decl "[(KTERM?) -> (sexpr?)]" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC92 0
  (τ0_TCC92-1 nil 3584988346
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (invoke (typepred "%1") (~ + "tcc?(%1)"))
        (("" (assert)
          (("" (invoke (typepred "%1") (~ + "tcc?(%1)"))
            (("" (assert)
              (("" (invoke (typepred "%1") (~ + "tcc?(%1)"))
                (("" (assert)
                  (("" (inst?) (("" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (same type-eq-decl nil language nil)
    (++ const-decl "same(x)" language nil)
    (above nonempty-type-eq-decl nil integers nil)
    (∼ def-decl "(tcc?)" supertype nil)
    (TYPEOF adt-accessor-decl "[(KTERM?) -> (sexpr?)]" language nil)
    (π const-decl "(tcc?)" tau nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC93 0
  (τ0_TCC93-1 nil 3584988346 ("" (termination-tcc) nil nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil)
    (compatible0? const-decl "bool" interp nil))
   nil))
 (τ0_TCC94 0
  (τ0_TCC94-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC95 0
  (τ0_TCC95-1 nil 3584988346 ("" (termination-tcc) nil nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil)
    (compatible0? const-decl "bool" interp nil))
   nil))
 (τ0_TCC96 0
  (τ0_TCC96-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC97 0
  (τ0_TCC97-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil))
   nil))
 (τ0_TCC98 0
  (τ0_TCC98-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (O const-decl "finseq" finite_sequences nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC99 0
  (τ0_TCC99-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (τ0_TCC100 0
  (τ0_TCC100-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((ρ0 const-decl "syntaxic" delta nil)) nil))
 (τ0_TCC101 0
  (τ0_TCC101-1 nil 3584988346
   ("" (skosimp* :preds? t)
    (("" (expand scontext? 1) (("" (propax) nil nil)) nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC102 0
  (τ0_TCC102-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (τ0_TCC103 0
  (τ0_TCC103-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((ρ0 const-decl "syntaxic" delta nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (O const-decl "finseq" finite_sequences nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (τ0_TCC104 0
  (τ0_TCC104-1 nil 3584988346
   ("" (skosimp* :preds? t)
    (("" (inst - "Γ!1 ++ k(const_var(ρ0(Γ!1)(A!1)))")
      (("" (inst - a!1) (("" (flatten) (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((const_var adt-constructor-decl "[(sexpr?) -> (const_var?)]"
     language nil)
    (const_var? adt-recognizer-decl "[syntaxic -> boolean]" language
     nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC105 0
  (τ0_TCC105-1 nil 3584988346
   ("" (skosimp* :preds? t) (("" (inst?) (("" (assert) nil nil)) nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC106 0
  (τ0_TCC106-1 nil 3584988346
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (invoke (typepred "%1") (~ + "tcc?(%1)"))
        (("" (assert)
          (("" (inst?) (("" (flatten) (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (same type-eq-decl nil language nil)
    (++ const-decl "same(x)" language nil)
    (above nonempty-type-eq-decl nil integers nil)
    (forall_ const-decl "(tcc?)" init_context nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC107 0
  (τ0_TCC107-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((ρ0 const-decl "syntaxic" delta nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (O const-decl "finseq" finite_sequences nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC108 0
  (τ0_TCC108-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC109 0
  (τ0_TCC109-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC110 0
  (τ0_TCC110-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil))
   nil))
 (τ0_TCC111 0
  (τ0_TCC111-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC112 0
  (τ0_TCC112-1 nil 3584988346 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (τ0_TCC113 0
  (τ0_TCC113-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((shift_size application-judgement
     "{V | type_size(V) = type_size(U)}" supertype nil))
   nil))
 (τ0_TCC114 0
  (τ0_TCC114-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((sexpr? adt-def-decl "boolean" language nil)) nil))
 (τ0_TCC115 0
  (τ0_TCC115-1 nil 3584988346
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (inst?)
        (("" (assert)
          (("" (flatten)
            (("" (assert)
              (("" (reveal -2)
                (("" (inst - Γ!1)
                  (("" (inst - a2!1)
                    (("" (flatten) (("" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC116 0
  (τ0_TCC116-1 nil 3584988346
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (invoke (typepred "%1") (~ + "tcc?(%1)"))
        (("" (assert)
          (("" (inst?) (("" (flatten) (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((shift_size application-judgement
     "{V | type_size(V) = type_size(U)}" supertype nil)
    (same type-eq-decl nil language nil)
    (++ const-decl "same(x)" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC117 0
  (τ0_TCC117-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC118 0
  (τ0_TCC118-1 nil 3584988346 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC119 0
  (τ0_TCC119-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil))
   nil))
 (τ0_TCC120 0
  (τ0_TCC120-1 nil 3584988346
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (inst?) (("" (flatten) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC121 0
  (τ0_TCC121-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC122 0
  (τ0_TCC122-1 nil 3584988346 ("" (termination-tcc) nil nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil)
    (compatible0? const-decl "bool" interp nil))
   nil))
 (τ0_TCC123 0
  (τ0_TCC123-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC124 0
  (τ0_TCC124-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil))
   nil))
 (τ0_TCC125 0
  (τ0_TCC125-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((sexpr? adt-def-decl "boolean" language nil)) nil))
 (τ0_TCC126 0
  (τ0_TCC126-1 nil 3584988346
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (inst?) (("" (flatten) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC127 0
  (τ0_TCC127-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC128 0
  (τ0_TCC128-1 nil 3584988346 ("" (termination-tcc) nil nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil)
    (compatible0? const-decl "bool" interp nil))
   nil))
 (τ0_TCC129 0
  (τ0_TCC129-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC130 0
  (τ0_TCC130-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil))
   nil))
 (τ0_TCC131 0
  (τ0_TCC131-1 nil 3584988346
   ("" (subtype-tcc)
    (("" (expand scontext? 1) (("" (propax) nil nil)) nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (compatible? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (τ0_TCC132 0
  (τ0_TCC132-1 nil 3584988346
   ("" (subtype-tcc)
    (("" (expand scontext? 1) (("" (propax) nil nil)) nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (compatible? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (τ0_TCC133 0
  (τ0_TCC133-1 nil 3584988346
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (expand scontext? 1) (("" (propax) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC134 0
  (τ0_TCC134-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC135 0
  (τ0_TCC135-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC136 0
  (τ0_TCC136-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil))
   nil))
 (τ0_TCC137 0
  (τ0_TCC137-1 nil 3584988346
   ("" (termination-tcc)
    (("1" (expand scontext? 1) (("1" (propax) nil nil)) nil)
     ("2" (expand scontext? 1) (("2" (propax) nil nil)) nil)
     ("3" (expand scontext? 1) (("3" (propax) nil nil)) nil)
     ("4" (expand scontext? 1) (("4" (propax) nil nil)) nil)
     ("5" (expand scontext? 1) (("5" (propax) nil nil)) nil)
     ("6" (expand scontext? 1) (("6" (propax) nil nil)) nil)
     ("7" (expand scontext? 1) (("7" (propax) nil nil)) nil)
     ("8" (expand scontext? 1) (("8" (propax) nil nil)) nil)
     ("9" (expand scontext? 1) (("9" (propax) nil nil)) nil)
     ("10" (expand scontext? 1) (("10" (propax) nil nil)) nil)
     ("11" (expand scontext? 1) (("11" (propax) nil nil)) nil)
     ("12" (expand scontext? 1) (("12" (propax) nil nil)) nil))
    nil)
   ((definition? const-decl "bool" language nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (O const-decl "finseq" finite_sequences nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (expand def-decl
            "{V | (sexpr?(U) IMPLIES sexpr?(V)) AND (scontext?(U) IMPLIES scontext?(V)) AND (ideep?(U) IMPLIES theory?(V)) AND (ikeep?(U) OR itype?(U) OR iterm?(U) IMPLIES scontext?(V))}"
            delta nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (compatible? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (τ0_TCC138 0
  (τ0_TCC138-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC139 0
  (τ0_TCC139-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC140 0
  (τ0_TCC140-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil))
   nil))
 (τ0_TCC141 0
  (τ0_TCC141-1 nil 3584988346
   ("" (subtype-tcc)
    (("1" (expand scontext? 1) (("1" (propax) nil nil)) nil)
     ("2" (expand scontext? 1) (("2" (propax) nil nil)) nil)
     ("3" (expand scontext? 1) (("3" (propax) nil nil)) nil)
     ("4" (expand scontext? 1) (("4" (propax) nil nil)) nil)
     ("5" (expand scontext? 1) (("5" (propax) nil nil)) nil)
     ("6" (expand scontext? 1) (("6" (propax) nil nil)) nil)
     ("7" (expand scontext? 1) (("7" (propax) nil nil)) nil)
     ("8" (expand scontext? 1) (("8" (propax) nil nil)) nil)
     ("9" (expand scontext? 1) (("9" (propax) nil nil)) nil)
     ("10" (expand scontext? 1) (("10" (propax) nil nil)) nil)
     ("11" (expand scontext? 1) (("11" (propax) nil nil)) nil)
     ("12" (expand scontext? 1) (("12" (propax) nil nil)) nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (compatible? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (sexpr? adt-def-decl "boolean" language nil))
   nil))
 (τ0_TCC142 0
  (τ0_TCC142-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC143 0
  (τ0_TCC143-1 nil 3584988346 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC144 0
  (τ0_TCC144-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil))
   nil))
 (τ0_TCC145 0
  (τ0_TCC145-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC146 0
  (τ0_TCC146-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (τ0_TCC147 0
  (τ0_TCC147-1 nil 3584988346
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (inst?)
        (("" (assert)
          (("" (flatten)
            (("" (assert)
              (("" (reveal -2)
                (("" (inst - Γ!1)
                  (("" (inst - a!1)
                    (("" (flatten) (("" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC148 0
  (τ0_TCC148-1 nil 3584988346
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (inst?)
        (("" (assert)
          (("" (invoke (typepred "%1") (~ "tccs?(%1)"))
            (("" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (same type-eq-decl nil language nil)
    (++ const-decl "same(x)" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC149 0
  (τ0_TCC149-1 nil 3584988346
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (invoke (typepred "%1") (~ + "tcc?(%1)"))
        (("1" (assert)
          (("1" (invoke (typepred "%1") (~ -15 "tccs?(%1)"))
            (("1" (assert)
              (("1" (invoke (typepred "%1") (~ + "tcc?(%1)"))
                (("1" (assert)
                  (("1" (inst?) (("1" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert)
          (("2" (invoke (typepred "%1") (~ - "tccs?(%1)"))
            (("2" (assert) (("2" (inst?) (("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil)
         ("3" (inst?)
          (("3" (assert)
            (("3" (flatten)
              (("3" (assert)
                (("3" (reveal -2)
                  (("3" (inst - Γ!1)
                    (("3" (inst - a!1)
                      (("3" (flatten) (("3" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (same type-eq-decl nil language nil)
    (++ const-decl "same(x)" language nil)
    (above nonempty-type-eq-decl nil integers nil)
    (≃ def-decl "(tcc?)" supertype nil)
    (TYPEOF adt-accessor-decl "[(KTERM?) -> (sexpr?)]" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC150 0
  (τ0_TCC150-1 nil 3584988346
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (expand scontext? 1) (("" (propax) nil nil)) nil)) nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC151 0
  (τ0_TCC151-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC152 0
  (τ0_TCC152-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC153 0
  (τ0_TCC153-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil))
   nil))
 (τ0_TCC154 0
  (τ0_TCC154-1 nil 3584988346
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (expand scontext? 1) (("" (propax) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC155 0
  (τ0_TCC155-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC156 0
  (τ0_TCC156-1 nil 3584988346 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC157 0
  (τ0_TCC157-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil))
   nil))
 (τ0_TCC158 0
  (τ0_TCC158-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (compatible0? const-decl "bool" interp nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC159 0
  (τ0_TCC159-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((empty_seq const-decl "finseq" finite_sequences nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC160 0
  (τ0_TCC160-1 nil 3584988346 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (rest const-decl "finseq[(scontext?)]" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (compatible? const-decl "bool" interp nil)
    (compatible0? const-decl "bool" interp nil))
   nil))
 (τ0_TCC161 0
  (τ0_TCC161-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (rest const-decl "finseq[(scontext?)]" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC162 0
  (τ0_TCC162-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (rest const-decl "finseq[(scontext?)]" language nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC163 0
  (τ0_TCC163-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (τ0_TCC164 0
  (τ0_TCC164-1 nil 3584988346 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC165 0
  (τ0_TCC165-1 nil 3584989791 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (rest const-decl "finseq[(scontext?)]" language nil))
   nil))
 (τ0_TCC166 0
  (τ0_TCC166-1 nil 3584989791 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (rest const-decl "finseq[(scontext?)]" language nil))
   nil))
 (τ0_TCC167 0
  (τ0_TCC167-1 nil 3585321239
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (inst?)
        (("" (flatten)
          (("" (assert) (("" (assert) (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (rest const-decl "finseq[(scontext?)]" language nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC168 0
  (τ0_TCC168-1 nil 3585321239
   ("" (skosimp* :preds? t)
    (("" (invoke (typepred "%1") (~ + "tcc?(%1)"))
      (("1" (assert)
        (("1" (assert)
          (("1" (inst?)
            (("1" (flatten)
              (("1" (assert) (("1" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil)
       ("2" (inst?)
        (("2" (flatten)
          (("2" (assert)
            (("2" (split 1)
              (("1" (flatten)
                (("1" (typepred ≃) (("1" (inst?) nil nil)) nil)) nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (assert) nil nil) ("4" (assert) nil nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (TYPEOF adt-accessor-decl "[(KTERM?) -> (sexpr?)]" language nil)
    (type_ shared-adt-accessor-decl
     "[{x: syntaxic | const_def?(x) OR const_var?(x) OR const_decl?(x) OR lam?(x)} -> (sexpr?)]"
     language nil)
    (lam? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (const_decl? adt-recognizer-decl "[syntaxic -> boolean]" language
     nil)
    (const_var? adt-recognizer-decl "[syntaxic -> boolean]" language
     nil)
    (const_def? adt-recognizer-decl "[syntaxic -> boolean]" language
     nil)
    (≃ def-decl "(tcc?)" supertype nil)
    (above nonempty-type-eq-decl nil integers nil)
    (++ const-decl "same(x)" language nil)
    (same type-eq-decl nil language nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (rest const-decl "finseq[(scontext?)]" language nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC169 0
  (τ0_TCC169-1 nil 3585321239 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (rest const-decl "finseq[(scontext?)]" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (t const-decl "(tcc?)" language nil)
    (π const-decl "(tcc?)" tau nil)
    (compatible? const-decl "bool" interp nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (τ0_TCC170 0
  (τ0_TCC170-1 nil 3585321239 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (rest const-decl "finseq[(scontext?)]" language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC171 0
  (τ0_TCC171-1 nil 3585321239 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (rest const-decl "finseq[(scontext?)]" language nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC172 0
  (τ0_TCC172-1 nil 3585321239 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (size def-decl "posnat" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (τ0_TCC173 0
  (τ0_TCC173-1 nil 3585321239 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC174 0
  (τ0_TCC174-1 nil 3585321239 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (compatible0? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC175 0
  (τ0_TCC175-1 nil 3585321239 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (τ0_TCC176 0
  (τ0_TCC176-1 nil 3585321239 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC177 0
  (τ0_TCC177-1 nil 3585321239 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (τ0_TCC178 0
  (τ0_TCC178-1 nil 3585321239
   ("" (skosimp* :preds? t)
    (("" (rewrite -3)
      (("" (assert)
        (("" (typepred sum)
          (("" (inst?) (("" (inst?) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((>= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (<= const-decl "bool" reals nil)
    (sum def-decl "{n: nat | FORALL (x: below[len]): f(x) <= n}"
     language nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC179 0
  (τ0_TCC179-1 nil 3585321239
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (expand typecheckable?)
        (("" (expand ^^ 3)
          (("" (assert)
            (("" (lift-if)
              (("" (split 3)
                (("1" (flatten)
                  (("1" (assert) (("1" (grind) nil nil)) nil)) nil)
                 ("2" (flatten)
                  (("2" (expand min 2) (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC180 0
  (τ0_TCC180-1 nil 3585321239 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (τ0_TCC181 0
  (τ0_TCC181-1 nil 3585321239 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (<= const-decl "bool" reals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (compatible? const-decl "bool" interp nil)
    (expandable? const-decl "bool" delta nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (typecheckable? const-decl "bool" tau nil))
   nil))
 (τ0_TCC182 0
  (τ0_TCC182-1 nil 3585321239
   ("" (skosimp* :preds? t)
    (("" (typepred "σ!1(pos!1)")
      (("1" (assert)
        (("1" (expand ρ0)
          (("1" (invoke (typepred "%1") (~ + "(scontext?)(%1)"))
            (("1" (assert)
              (("1" (flatten)
                (("1" (assert)
                  (("1" (expand sinterp? -3) (("1" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (assert) nil nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (expand def-decl
            "{V | (sexpr?(U) IMPLIES sexpr?(V)) AND (scontext?(U) IMPLIES scontext?(V)) AND (ideep?(U) IMPLIES theory?(V)) AND (ikeep?(U) OR itype?(U) OR iterm?(U) IMPLIES scontext?(V))}"
            delta nil)
    (TRUE const-decl "bool" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC183 0
  (τ0_TCC183-1 nil 3585321239
   ("" (skosimp* :preds? t)
    (("" (rewrite -4) (("" (rewrite size_iextract) nil nil)) nil)) nil)
   ((size_iextract formula-decl nil language nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC184 0
  (τ0_TCC184-1 nil 3585321239
   ("" (skosimp* :preds? t)
    (("" (typepred "k(tccsI!1)")
      (("" (assert)
        (("" (invoke (inst - "%1") (~ -11 "v!1(%1)(%)"))
          (("1" (invoke (inst - "%1") (~ -11 "v!1(%)(%1)"))
            (("1" (flatten) (("1" (assert) nil nil)) nil)
             ("2"
              (invoke (typepred! "%1" :implicit? t)
               (~ + "typecheckable?(%)(%1)"))
              (("2" (assert) nil nil)) nil))
            nil)
           ("2" (expand ρ0)
            (("2" (invoke (typepred "%1") (~ + "(scontext?)(%1)"))
              (("2" (typepred "σ!1`seq(pos!1)")
                (("2" (expand sinterp? -1) (("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (assert)
            (("3" (expand typecheckable? -3)
              (("3" (rewrite -4) (("3" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((k const-decl "(tccs?)" language nil)
    (σ!1 skolem-const-decl "finseq[(sinterp?)]" tau nil)
    (Γ!1 skolem-const-decl "finseq[(scontext?)]" tau nil)
    (pos!1 skolem-const-decl "int" tau nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (ideep adt-constructor-decl "[finseq[(sinterp?)] -> (ideep?)]"
     language nil)
    (TRUE const-decl "bool" booleans nil)
    (expand def-decl
            "{V | (sexpr?(U) IMPLIES sexpr?(V)) AND (scontext?(U) IMPLIES scontext?(V)) AND (ideep?(U) IMPLIES theory?(V)) AND (ikeep?(U) OR itype?(U) OR iterm?(U) IMPLIES scontext?(V))}"
            delta nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC185 0
  (τ0_TCC185-1 nil 3585321239
   ("" (skosimp* :preds? t)
    (("" (assert)
      (("" (invoke (inst - "%1") (~ -11 "v!1(%1)(%)"))
        (("1" (invoke (inst - "%1") (~ -11 "v!1(%)(%1)"))
          (("1" (flatten)
            (("1" (assert)
              (("1" (flatten)
                (("1" (assert)
                  (("1" (split 3)
                    (("1" (rewrite -11 :dont-delete? t)
                      (("1" (assert)
                        (("1" (reveal -2)
                          (("1" (inst - "Γ!1 ^^ (pos!1, length(Γ!1))")
                            (("1" (inst - "σ!1`seq(pos!1)")
                              (("1"
                                (flatten)
                                (("1"
                                  (assert)
                                  (("1"
                                    (hide
                                     -1
                                     -2
                                     -3
                                     -5
                                     -6
                                     -9
                                     -10
                                     -14
                                     -15
                                     -16)
                                    (("1"
                                      (typepred "σ!1`seq(pos!1)")
                                      (("1"
                                        (expand sinterp? -1)
                                        (("1"
                                          (split -2)
                                          (("1"
                                            (expand compatible?)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (split 1)
                                                (("1"
                                                  (expand ^^ 1)
                                                  (("1"
                                                    (lift-if)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (split 1)
                                                        (("1"
                                                          (grind)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (flatten)
                                                          (("2"
                                                            (assert)
                                                            (("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (skosimp* :preds? t)
                                                  (("2"
                                                    (case
                                                     "x!1 = pos!1")
                                                    (("1"
                                                      (expand
                                                       compatible0?)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (inst -7 x!1)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (hide-all-but
                                                         (1
                                                          2
                                                          -1
                                                          -10
                                                          -6
                                                          4))
                                                        (("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (invoke (typepred "%1") (~ + "tccs?(%1)"))
                      (("2" (assert) nil nil)) nil)
                     ("3" (rewrite -17 :dir rl)
                      (("3" (rewrite -6)
                        (("3" (assert)
                          (("3" (expand ++ 1)
                            (("3" (expand k 1)
                              (("3"
                                (expand o 1)
                                (("3"
                                  (rewrite -5 :dir rl)
                                  (("3"
                                    (expand ^^ 1)
                                    (("3"
                                      (lift-if)
                                      (("3"
                                        (split 1)
                                        (("1" (grind) nil nil)
                                         ("2"
                                          (flatten)
                                          (("2"
                                            (assert)
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2"
            (invoke (typepred! "%1" :implicit? t)
             (~ + "typecheckable?(%)(%1)"))
            (("2" (assert) nil nil)) nil))
          nil)
         ("2" (expand ρ0)
          (("2" (invoke (typepred "%1") (~ + "scontext?(%1)"))
            (("2" (typepred "σ!1`seq(pos!1)")
              (("2" (expand sinterp? -1) (("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil)
         ("3" (assert) (("3" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (TRUE const-decl "bool" booleans nil)
    (ideep adt-constructor-decl "[finseq[(sinterp?)] -> (ideep?)]"
     language nil)
    (O const-decl "finseq" finite_sequences nil)
    (++ const-decl "same(x)" language nil)
    (same type-eq-decl nil language nil)
    (k const-decl "(tccs?)" language nil)
    (below type-eq-decl nil naturalnumbers nil)
    (x!1 skolem-const-decl
     "below(length(^^[(scontext?)](Γ!1, (0, length(σ!1)))))" tau nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (expand def-decl
            "{V | (sexpr?(U) IMPLIES sexpr?(V)) AND (scontext?(U) IMPLIES scontext?(V)) AND (ideep?(U) IMPLIES theory?(V)) AND (ikeep?(U) OR itype?(U) OR iterm?(U) IMPLIES scontext?(V))}"
            delta nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (rest const-decl "finseq[(scontext?)]" language nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pos!1 skolem-const-decl "int" tau nil)
    (Γ!1 skolem-const-decl "finseq[(scontext?)]" tau nil)
    (σ!1 skolem-const-decl "finseq[(sinterp?)]" tau nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (size def-decl "posnat" language nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (keyword type-decl nil language nil)
    (KTHEORY? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tccs type-decl nil language nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (theory? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (expandable? const-decl "bool" delta nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (tccs? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (decls adt-accessor-decl "[(theory?) -> finseq[(scontext?)]]"
     language nil)
    (map adt-accessor-decl "[(tccs?) -> finseq[tccs]]" language nil)
    (KDECL? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (KINTERP? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (compatible? const-decl "bool" interp nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (ikeep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (itype? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (iterm? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (compatible0? const-decl "bool" interp nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (KTYPE? adt-recognizer-decl "[keyword -> boolean]" language nil)
    (tcc? adt-recognizer-decl "[tccs -> boolean]" language nil)
    (KTERM? adt-recognizer-decl "[keyword -> boolean]" language nil))
   nil))
 (τ0_TCC186 0
  (τ0_TCC186-1 nil 3585321239 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC187 0
  (τ0_TCC187-1 nil 3585321239 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (τ0_TCC188 0
  (τ0_TCC188-1 nil 3585364472 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (sexpr? adt-def-decl "boolean" language nil)
    (ρ0 const-decl "syntaxic" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (compatible? const-decl "bool" interp nil))
   nil))
 (δ_TCC1 0
  (δ_TCC1-1 nil 3584986495
   ("" (skosimp* :preds? t)
    (("" (expand expandable?)
      (("" (flatten)
        (("" (split 1)
          (("1" (assert)
            (("1" (flatten)
              (("1" (assert)
                (("1" (split -2)
                  (("1" (split 1)
                    (("1" (expand expand_ctx 1)
                      (("1" (use expand_size) (("1" (assert) nil nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (expand compatible0?)
                        (("2" (typepred expand_ctx)
                          (("2" (inst?)
                            (("2" (flatten)
                              (("2"
                                (expand ≡)
                                (("2"
                                  (flatten)
                                  (("2"
                                    (inst -3 0)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (lift-if)
                                          (("1"
                                            (split 1)
                                            (("1" (propax) nil nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (split 2)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (typepred
                                                       "expand_ctx(Γ!1)`seq(0)")
                                                      (("1"
                                                        (expand
                                                         scontext?
                                                         -1)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (flatten)
                                                  (("2"
                                                    (split 2)
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (typepred
                                                         "expand_ctx(Γ!1)`seq(0)")
                                                        (("1"
                                                          (expand
                                                           scontext?
                                                           -1)
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (expand expand_ctx 1)
                                      (("2"
                                        (use expand_size)
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (assert)
              (("2" (flatten)
                (("2" (hide -2)
                  (("2" (split 1)
                    (("1" (expand expand_ctx 1)
                      (("1" (use expand_size) (("1" (assert) nil nil))
                        nil))
                      nil)
                     ("2" (expand compatible?)
                      (("2" (flatten)
                        (("2" (split 1)
                          (("1" (expand expand_ctx 1)
                            (("1" (use expand_size)
                              (("1"
                                (assert)
                                (("1"
                                  (rewrite -4 :dir rl)
                                  (("1"
                                    (expand ^^ 1)
                                    (("1"
                                      (lift-if)
                                      (("1"
                                        (lift-if)
                                        (("1"
                                          (split 1)
                                          (("1" (grind) nil nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (expand min)
                                                (("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (skosimp* :preds? t)
                            (("2" (inst - x!1)
                              (("1"
                                (typepred expand_ctx)
                                (("1"
                                  (inst?)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (inst - x!1)
                                      (("1"
                                        (expand ≡)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (inst - x!1)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (lift-if)
                                                (("1"
                                                  (split -14)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (split -1)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (flatten)
                                                          (("1"
                                                            (expand ^^)
                                                            (("1"
                                                              (lift-if)
                                                              (("1"
                                                                (split
                                                                 -2)
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil)
                                                                 ("2"
                                                                  (flatten)
                                                                  (("2"
                                                                    (expand
                                                                     scontext?
                                                                     -3)
                                                                    (("2"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (flatten)
                                                        (("2"
                                                          (split -1)
                                                          (("1"
                                                            (flatten)
                                                            (("1"
                                                              (expand
                                                               scontext?
                                                               -3)
                                                              (("1"
                                                                (expand
                                                                 ^^)
                                                                (("1"
                                                                  (lift-if)
                                                                  (("1"
                                                                    (split
                                                                     -2)
                                                                    (("1"
                                                                      (flatten)
                                                                      (("1"
                                                                        (typepred
                                                                         x!1)
                                                                        (("1"
                                                                          (assert)
                                                                          (("1"
                                                                            (split
                                                                             -17)
                                                                            (("1"
                                                                              (split
                                                                               -15)
                                                                              (("1"
                                                                                (assert)
                                                                                (("1"
                                                                                  (flatten)
                                                                                  (("1"
                                                                                    (assert)
                                                                                    nil
                                                                                    nil))
                                                                                  nil))
                                                                                nil)
                                                                               ("2"
                                                                                (flatten)
                                                                                (("2"
                                                                                  (assert)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (flatten)
                                                                              (("2"
                                                                                (assert)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (flatten)
                                                                      (("2"
                                                                        (assert)
                                                                        (("2"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (propax)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (expand ^^ -2)
                                        (("2"
                                          (lift-if)
                                          (("2"
                                            (assert)
                                            (("2"
                                              (split -2)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (expand ^^)
                                (("2"
                                  (assert)
                                  (("2"
                                    (lift-if)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (split -1)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (assert)
                                            (("1" (grind) nil nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (flatten)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((≡ const-decl "bool" language nil) (< const-decl "bool" reals nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Γ!1 skolem-const-decl "finseq[(scontext?)]" tau nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (compatible0? const-decl "bool" interp nil)
    (expand_ctx const-decl "{Δ | Δ ≡ Γ}" delta nil)
    (empty_seq const-decl "finseq" finite_sequences nil)
    (TRUE const-decl "bool" booleans nil)
    (expand_size formula-decl nil delta nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (compatible? const-decl "bool" interp nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (^^ const-decl "finseq" finite_sequences nil)
    (U!1 skolem-const-decl "(expandable?(Γ!1))" tau nil)
    (x!1 skolem-const-decl
     "below(length(expand_ctx(Γ!1) ^^ (0, length(map(U!1)))))" tau nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (expand def-decl
            "{V | (sexpr?(U) IMPLIES sexpr?(V)) AND (scontext?(U) IMPLIES scontext?(V)) AND (ideep?(U) IMPLIES theory?(V)) AND (ikeep?(U) OR itype?(U) OR iterm?(U) IMPLIES scontext?(V))}"
            delta nil)
    (++ const-decl "finseq[(scontext?)]" language nil)
    (O const-decl "finseq" finite_sequences nil)
    (k const-decl "finseq[(scontext?)]" language nil)
    (ideep? adt-recognizer-decl "[syntaxic -> boolean]" language nil)
    (sinterp? adt-def-decl "boolean" language nil)
    (map adt-accessor-decl "[(ideep?) -> finseq[(sinterp?)]]" language
         nil)
    (below type-eq-decl nil naturalnumbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (expandable? const-decl "bool" delta nil))
   nil))
 (τ_TCC1 0
  (τ_TCC1-1 nil 3584286639
   ("" (skosimp* :preds? t)
    (("" (expand typecheckable?)
      (("" (split 1)
        (("1" (flatten)
          (("1" (typepred "expand_ctx(Γ!1)")
            (("1" (expand ≡)
              (("1" (flatten)
                (("1" (split -4)
                  (("1" (assert) nil nil) ("2" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (assert)
            (("2" (typepred "expand_ctx(Γ!1)")
              (("2" (expand ≡) (("2" (propax) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (≡ const-decl "bool" language nil)
    (expand_ctx const-decl "{Δ | Δ ≡ Γ}" delta nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (syntaxic type-decl nil language nil)
    (scontext? adt-def-decl "boolean" language nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (typecheckable? const-decl "bool" tau nil))
   nil)))

