(term
 (const_apply_TCC1 0
  (const_apply_TCC1-1 nil 3579016031 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (fun type-decl nil term nil) (const? const-decl "bool" term nil)
    (empty_seq const-decl "finseq" finite_sequences nil))
   nil))
 (const_fun_TCC1 0
  (const_fun_TCC1-1 nil 3579016031 ("" (subtype-tcc) nil nil) nil nil))
 (skolem_fun_TCC1 0
  (skolem_fun_TCC1-1 nil 3579016031 ("" (subtype-tcc) nil nil) nil
   nil))
 (lt_irreflexive 0
  (lt_irreflexive-1 nil 3579453702
   ("" (expand (irreflexive? <))
    (("" (skeep)
      (("" (lift-if)
        (("" (prop)
          (("" (typepred "<< :: (strict_well_founded?[term])")
            (("" (case "x << x")
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subterm adt-def-decl "boolean" term nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (args adt-accessor-decl
          "[d: (apply?) -> {l: finseq[term] | l`length = arity(fun(d))}]"
          term nil)
    (fun adt-accessor-decl "[(apply?) -> fun]" term nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (fun type-decl nil term nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (apply? adt-recognizer-decl "[term -> boolean]" term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (well_founded? const-decl "bool" orders nil)
    (strict_order? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (term type-decl nil term nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (irreflexive? const-decl "bool" relations nil)
    (< const-decl "bool" term nil))
   nil))
 (subterm_ltlt_equal 0
  (subterm_ltlt_equal-1 nil 3579453317
   ("" (expand subterm) (("" (expand <<) (("" (grind) nil nil)) nil))
    nil)
   ((<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (subterm adt-def-decl "boolean" term nil))
   shostak))
 (ltlt_subterm_equal 0
  (ltlt_subterm_equal-1 nil 3579285935
   ("" (skeep)
    (("" (rewrite subterm_ltlt_equal)
      (("" (prop)
        (("" (typepred "<< :: (strict_well_founded?[term])")
          (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((subterm_ltlt_equal formula-decl nil term nil)
    (term type-decl nil term nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (well_founded? const-decl "bool" orders nil)
    (strict_order? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (irreflexive? const-decl "bool" relations nil))
   shostak))
 (lt_TC_is_ltlt 0
  (lt_TC_is_ltlt-1 nil 3579454213
   ("" (apply-extensionality :hide? t)
    (("" (iff)
      (("" (prop)
        (("1" (lemma TC_LFP[term])
          (("1" (inst -1 "<<" "<")
            (("1" (grind)
              (("1" (typepred "<< :: pred[[term, term]]")
                (("1" (grind :if-match nil) nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (generalize "x!2" "y")
          (("2" (induct y)
            (("1" (grind) nil nil)
             ("2" (skeep)
              (("2" (expand every -1)
                (("2" (expand "<<" -2)
                  (("2" (skeep)
                    (("2" (inst -1 "z")
                      (("2" (expand nth)
                        (("2" (rewrite subterm_ltlt_equal)
                          (("2" (grind)
                            (("1" (rewrite TC_expand_left 1)
                              (("1" (grind) nil nil)) nil)
                             ("2" (grind)
                              (("2"
                                (rewrite TC_expand_left 2)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (subterm_ltlt_equal formula-decl nil term nil)
    (apply adt-constructor-decl
           "[[fun: fun, {l: finseq[term] | l`length = arity(fun)}] -> (apply?)]"
           term nil)
    (TC_expand_left formula-decl nil more_relations_props nil)
    (term_induction formula-decl nil term nil)
    (TC_LFP formula-decl nil more_relations_props nil)
    (subterm adt-def-decl "boolean" term nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (args adt-accessor-decl
          "[d: (apply?) -> {l: finseq[term] | l`length = arity(fun(d))}]"
          term nil)
    (fun adt-accessor-decl "[(apply?) -> fun]" term nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (fun type-decl nil term nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (apply? adt-recognizer-decl "[term -> boolean]" term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (transitive? const-decl "bool" relations nil)
    (irreflexive? const-decl "bool" relations nil)
    (strict_order? const-decl "bool" orders nil)
    (well_founded? const-decl "bool" orders nil)
    (lt_irreflexive name-judgement "(irreflexive?[term])" term nil)
    (TC_is_transitive application-judgement "(transitive?[T])"
     more_orders_props nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (TC inductive-decl "bool" relations nil)
    (< const-decl "bool" term nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (boolean nonempty-type-decl nil booleans nil)
    (term type-decl nil term nil))
   shostak))
 (ltlt_RC_is_subterm 0
  (ltlt_RC_is_subterm-1 nil 3579455039
   ("" (grind)
    (("" (apply-extensionality :hide? t)
      (("" (rewrite ltlt_subterm_equal) (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((term type-decl nil term nil)
    (boolean nonempty-type-decl nil booleans nil)
    (subterm adt-def-decl "boolean" term nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (RC const-decl "bool" relations nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (/= const-decl "boolean" notequal nil)
    (ltlt_subterm_equal formula-decl nil term nil)
    (RC_preserves_transitive application-judgement "(transitive?[T])"
     more_orders_props nil)
    (RC_is_reflexive application-judgement "(reflexive?[T])"
     more_orders_props nil))
   shostak))
 (lt_RTC_is_subterm 0
  (lt_RTC_is_subterm-1 nil 3579453479
   ("" (rewrite RTC_is_RC_TC)
    (("" (rewrite lt_TC_is_ltlt)
      (("" (grind)
        (("" (apply-extensionality :hide? t)
          (("" (rewrite ltlt_subterm_equal) (("" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lt_TC_is_ltlt formula-decl nil term nil)
    (RC const-decl "bool" relations nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (subterm adt-def-decl "boolean" term nil)
    (/= const-decl "boolean" notequal nil)
    (ltlt_subterm_equal formula-decl nil term nil)
    (RC_is_reflexive application-judgement "(reflexive?[T])"
     more_orders_props nil)
    (RC_preserves_transitive application-judgement "(transitive?[T])"
     more_orders_props nil)
    (TC_is_transitive application-judgement "(transitive?[T])"
     more_orders_props nil)
    (lt_irreflexive name-judgement "(irreflexive?[term])" term nil)
    (term type-decl nil term nil) (< const-decl "bool" term nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (RTC_is_RC_TC formula-decl nil more_relations_props nil))
   shostak))
 (ltlt_is_finite 0
  (ltlt_finite-1 nil 3580498674
   ("" (lemma "konigs[term]")
    (("" (inst -1 "<")
      (("1" (rewrite lt_TC_is_ltlt) (("1" (grind) nil nil)) nil)
       ("2" (split)
        (("1" (typepred "<< :: [term, term -> bool]")
          (("1" (lemma restrict_well_founded[term])
            (("1" (inst -1 "<" "<<")
              (("1" (lemma lt_TC_is_ltlt)
                (("1" (lemma TC_is_extension[term])
                  (("1" (inst -1 "<" _ _)
                    (("1" (decompose-equality) (("1" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand finitely_branching?)
          (("2" (skeep)
            (("2" (rewrite is_finite_surj :dir rl)
              (("2" (case "var?(x)")
                (("1" (inst 1 "0" "LAMBDA (n: below(0)): x")
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                 ("2"
                  (inst 2 "args(x)`length"
                   "LAMBDA (n: below(args(x)`length)): args(x)(n)")
                  (("1" (grind) nil nil) ("2" (grind) nil nil)
                   ("3" (grind) nil nil) ("4" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lt_irreflexive name-judgement "(irreflexive?[term])" term nil)
    (finitely_branching? const-decl "bool" more_orders_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (< const-decl "bool" term nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (lt_TC_is_ltlt formula-decl nil term nil)
    (set type-eq-decl nil sets nil)
    (is_finite_surj formula-decl nil finite_sets nil)
    (x skolem-const-decl "term" term nil)
    (FALSE const-decl "bool" booleans nil)
    (surjective? const-decl "bool" functions nil)
    (var? adt-recognizer-decl "[term -> boolean]" term nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (TC_is_extension formula-decl nil more_relations_props nil)
    (TC inductive-decl "bool" relations nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (TC_is_transitive application-judgement "(transitive?[T])"
     more_orders_props nil)
    (irreflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (strict_order? const-decl "bool" orders nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (subterm adt-def-decl "boolean" term nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (apply? adt-recognizer-decl "[term -> boolean]" term nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (fun type-decl nil term nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (fun adt-accessor-decl "[(apply?) -> fun]" term nil)
    (args adt-accessor-decl
          "[d: (apply?) -> {l: finseq[term] | l`length = arity(fun(d))}]"
          term nil)
    (below type-eq-decl nil naturalnumbers nil)
    (restrict_well_founded formula-decl nil more_orders_props nil)
    (konigs judgement-tcc nil more_orders_props nil)
    (term type-decl nil term nil))
   shostak))
 (subterm_is_finite 0
  (subterm_is_finite-1 nil 3580499091
   ("" (use ltlt_is_finite)
    (("" (skeep)
      (("" (case "{ t | subterm(t, s) } = add(s, { t | t << s })")
        (("1" (rewrite -1)
          (("1" (inst?)
            (("1" (use finite_add[term])
              (("1" (use finite_add[term])
                (("1" (lemma "finite_add[term]")
                  (("1" (inst -1 "{ t | t << s }" "s") nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (apply-extensionality)
          (("2" (lemma subterm_ltlt_equal)
            (("2" (expand add)
              (("2" (rewrite -1) (("2" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((member const-decl "bool" sets nil)
    (subterm_ltlt_equal formula-decl nil term nil)
    (finite_add formula-decl nil finite_sets nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (s skolem-const-decl "term" term nil)
    (is_finite const-decl "bool" finite_sets nil)
    (term type-decl nil term nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (subterm adt-def-decl "boolean" term nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (ltlt_is_finite formula-decl nil term nil))
   shostak))
 (match?_TCC1 0
  (match?_TCC1-1 nil 3580500804 ("" (use ltlt_is_finite) nil nil)
   ((ltlt_is_finite formula-decl nil term nil)) nil))
 (match?_TCC2 0
  (match?_TCC2-1 nil 3580500804
   ("" (expand well_founded?)
    (("" (skeep)
      (("" (case "p(FALSE)")
        (("1" (grind) nil nil)
         ("2" (skeep) (("2" (inst 2 y) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (p skolem-const-decl "pred[boolean]" term nil)
    (y skolem-const-decl "bool" term nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (FALSE const-decl "bool" booleans nil)
    (well_founded? const-decl "bool" orders nil))
   nil))
 (match?_TCC3 0
  (match?_TCC3-1 nil 3580500804
   ("" (use wf_nat) (("" (grind) nil nil)) nil)
   ((well_founded? const-decl "bool" orders nil)
    (restrict const-decl "R" restrict nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (wf_nat formula-decl nil naturalnumbers nil))
   nil))
 (match?_TCC4 0
  (match?_TCC4-1 nil 3580501977
   (""
    (lemma
     "wf_pair[bool, nat, LAMBDA (b1, b2: bool): NOT b1 AND b2, restrict[[real, real], [nat, nat], boolean](<)]")
    (("1" (grind) nil nil)
     ("2" (use wf_nat) (("2" (grind) nil nil)) nil)
     ("3" (use "match?_TCC2") nil nil))
    nil)
   ((match?_TCC2 subtype-tcc nil term nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (le const-decl "bool" wf_pair nil)
    (wf_pair name-judgement "(well_founded?[[L, R]])" wf_pair nil)
    (pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (wf_pair judgement-tcc nil wf_pair nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil))
   nil))
 (match?_TCC5 0
  (match?_TCC5-1 nil 3580501977 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (term type-decl nil term nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (fun type-decl nil term nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil))
   nil))
 (match?_TCC6 0
  (match?_TCC6-1 nil 3580502263
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (flatten)
          (("" (expand le)
            (("" (flatten)
              (("" (lemma "card_strict_subset[term]")
                (("" (inst?)
                  (("1" (inst -1 "{ t | t << s!1}")
                    (("1" (split)
                      (("1" (rewrite card_def)
                        (("1" (rewrite card_def) nil nil)) nil)
                       ("2" (expand strict_subset?)
                        (("2" (hide 2)
                          (("2" (bddsimp)
                            (("1" (decompose-equality)
                              (("1"
                                (inst -1 "args!1(n!1)")
                                (("1"
                                  (typepred
                                   "<< :: [term, term -> bool]")
                                  (("1"
                                    (expand strict_well_founded?)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (use
                                         well_founded_is_irreflexive[term])
                                        (("1"
                                          (expand irreflexive?)
                                          (("1"
                                            (inst?)
                                            (("1"
                                              (rewrite 1)
                                              (("1" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil)
                             ("2" (expand subset?)
                              (("2"
                                (skeep)
                                (("2"
                                  (expand member)
                                  (("2"
                                    (typepred
                                     "<< :: [term, term -> bool]")
                                    (("2"
                                      (expand strict_well_founded?)
                                      (("2"
                                        (flatten)
                                        (("2"
                                          (expand strict_order?)
                                          (("2"
                                            (flatten)
                                            (("2"
                                              (expand transitive?)
                                              (("2"
                                                (inst
                                                 -2
                                                 "x"
                                                 "finseq_appl[term](args!1)(n!1)"
                                                 "s!1")
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (use ltlt_is_finite) nil nil))
                    nil)
                   ("2" (lemma ltlt_is_finite)
                    (("2" (grind :if-match all) nil nil)) nil)
                   ("3" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (args!1 skolem-const-decl
     "{l: finseq[term] | l`length = arity(f!1)}" term nil)
    (f!1 skolem-const-decl "fun" term nil)
    (n!1 skolem-const-decl "nat" term nil)
    (< const-decl "bool" reals nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (ltlt_is_finite formula-decl nil term nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (card_def formula-decl nil finite_sets nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (irreflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (strict_order? const-decl "bool" orders nil)
    (Card const-decl "nat" finite_sets nil)
    (subterm adt-def-decl "boolean" term nil)
    (well_founded? const-decl "bool" orders nil)
    (well_founded_is_irreflexive judgement-tcc nil more_orders_props
     nil)
    (strict_subset? const-decl "bool" sets nil)
    (s!1 skolem-const-decl "term" term nil)
    (injective? const-decl "bool" functions nil)
    (card_strict_subset formula-decl nil finite_sets nil)
    (le const-decl "bool" wf_pair nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (fun type-decl nil term nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (term type-decl nil term nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (match?_TCC7 0
  (match?_TCC7-1 nil 3580577127 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (term type-decl nil term nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (fun type-decl nil term nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (index shared-adt-accessor-decl "[fun -> nat]" term nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (subterm adt-def-decl "boolean" term nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Card const-decl "nat" finite_sets nil)
    (le const-decl "bool" wf_pair nil))
   nil))
 (match?_TCC8 0
  (match?_TCC8-1 nil 3580577127 ("" (subtype-tcc) nil nil) nil nil))
 (match?_TCC9 0
  (match?_TCC9-1 nil 3580577127 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (term type-decl nil term nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (fun type-decl nil term nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil))
   nil))
 (match?_TCC10 0
  (match?_TCC10-1 nil 3580577127
   ("" (skolem-typepred)
    (("" (flatten)
      (("" (skolem-typepred)
        (("" (expand le)
          (("" (flatten)
            (("" (lemma "card_strict_subset[term]")
              ((""
                (inst -1 "{ t | t << finseq_appl[term](args!1)(i!1) }"
                 "{ t | t << s!1 }")
                (("1" (hide 2)
                  (("1" (split -1)
                    (("1" (rewrite card_def)
                      (("1" (rewrite card_def) nil nil)) nil)
                     ("2" (expand strict_subset?)
                      (("2" (split 1)
                        (("1" (expand subset?)
                          (("1" (skeep)
                            (("1" (expand member)
                              (("1"
                                (typepred "<< :: [term, term -> bool]")
                                (("1"
                                  (expand strict_well_founded?)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (expand strict_order?)
                                      (("1"
                                        (expand transitive?)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (inst
                                             -2
                                             "x"
                                             "finseq_appl[term](args!1)(i!1)"
                                             "s!1")
                                            (("1" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (decompose-equality)
                          (("2" (typepred "<< :: [term, term -> bool]")
                            (("2" (expand strict_well_founded?)
                              (("2"
                                (flatten)
                                (("2"
                                  (use
                                   well_founded_is_irreflexive[term])
                                  (("2"
                                    (expand irreflexive?)
                                    (("2"
                                      (inst?)
                                      (("2"
                                        (inst?)
                                        (("2"
                                          (rewrite 1)
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (use ltlt_is_finite) nil nil)
                 ("3" (lemma ltlt_is_finite)
                  (("3" (grind :if-match all) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((le const-decl "bool" wf_pair nil)
    (card_strict_subset formula-decl nil finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (ltlt_is_finite formula-decl nil term nil)
    (strict_subset? const-decl "bool" sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (well_founded_is_irreflexive judgement-tcc nil more_orders_props
     nil)
    (apply? adt-recognizer-decl "[term -> boolean]" term nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (strict_order? const-decl "bool" orders nil)
    (subterm adt-def-decl "boolean" term nil)
    (Card const-decl "nat" finite_sets nil)
    (well_founded? const-decl "bool" orders nil)
    (irreflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (card_def formula-decl nil finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (s!1 skolem-const-decl "term" term nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (f!1 skolem-const-decl "fun" term nil)
    (args!1 skolem-const-decl
     "{l: finseq[term] | l`length = arity(f!1)}" term nil)
    (i!1 skolem-const-decl "below(arity(f!1))" term nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (fun type-decl nil term nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (term type-decl nil term nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (V_TCC1 0
  (V_TCC1-1 nil 3578336763
   ("" (grind-with-ext) (("" (decompose-equality) nil nil)) nil)
   ((index adt-accessor-decl "[(var?) -> nat]" term nil)
    (term_v_extensionality formula-decl nil term nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (term type-decl nil term nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (var? adt-recognizer-decl "[term -> boolean]" term nil)
    (v adt-constructor-decl "[nat -> (var?)]" term nil)
    (FALSE const-decl "bool" booleans nil) (fun type-decl nil term nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (apply? adt-recognizer-decl "[term -> boolean]" term nil)
    (apply adt-constructor-decl
           "[[fun: fun, {l: finseq[term] | l`length = arity(fun)}] -> (apply?)]"
           term nil)
    (< const-decl "bool" reals nil) (set type-eq-decl nil sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (subterm adt-def-decl "boolean" term nil))
   nil))
 (V_TCC2 0
  (V_TCC2-1 nil 3578933016
   ("" (grind :rewrites (some_exists list2set_member)) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (subterm adt-def-decl "boolean" term nil)
    (finseq2set const-decl "set[T]" set_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (set type-eq-decl nil sets nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (fun type-decl nil term nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (term type-decl nil term nil)
    (below type-eq-decl nil nat_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (V_TCC3 0
  (V_TCC3-1 nil 3578933016
   ("" (grind :if-match nil)
    (("" (apply-extensionality :hide? t)
      (("1" (iff)
        (("1" (prop)
          (("1" (skolem-typepred)
            (("1" (expand finseq2set)
              (("1" (skolem-typepred)
                (("1" (inst 1 "i!1")
                  (("1" (inst -4 "k!1") (("1" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (skolem-typepred) (("2" (grind) nil nil)) nil))
          nil))
        nil)
       ("2" (skolem-typepred)
        (("2" (expand finseq2set)
          (("2" (skolem-typepred) (("2" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((finseq2set const-decl "set[T]" set_props nil)
    (f!1 skolem-const-decl "fun" term nil)
    (args!1 skolem-const-decl
     "{l: finseq[term] | l`length = arity(f!1)}" term nil)
    (< const-decl "bool" reals nil)
    (apply? adt-recognizer-decl "[term -> boolean]" term nil)
    (fun adt-accessor-decl "[(apply?) -> fun]" term nil)
    (args adt-accessor-decl
          "[d: (apply?) -> {l: finseq[term] | l`length = arity(fun(d))}]"
          term nil)
    (t!1 skolem-const-decl "term" term nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (FALSE const-decl "bool" booleans nil)
    (apply adt-constructor-decl
           "[[fun: fun, {l: finseq[term] | l`length = arity(fun)}] -> (apply?)]"
           term nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (x!1 skolem-const-decl "nat" term nil)
    (z!1 skolem-const-decl "below[args!1`length]" term nil)
    (i!1 skolem-const-decl "below(args!1`length)" term nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (term type-decl nil term nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (var? adt-recognizer-decl "[term -> boolean]" term nil)
    (v adt-constructor-decl "[nat -> (var?)]" term nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (fun type-decl nil term nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (subterm adt-def-decl "boolean" term nil)
    (member const-decl "bool" sets nil))
   nil))
 (vars_subterm 0
  (vars_subterm-1 nil 3578952583
   ("" (induct-and-simplify s :if-match nil :exclude subterm)
    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (finseq2set const-decl "set[T]" set_props nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (fun type-decl nil term nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (apply1_var!1 skolem-const-decl "fun" term nil)
    (apply2_var!1 skolem-const-decl
     "{l: finseq[term] | l`length = arity(apply1_var!1)}" term nil)
    (below type-eq-decl nil naturalnumbers nil)
    (z!1 skolem-const-decl "below[apply2_var!1`length]" term nil)
    (args adt-accessor-decl
          "[d: (apply?) -> {l: finseq[term] | l`length = arity(fun(d))}]"
          term nil)
    (fun adt-accessor-decl "[(apply?) -> fun]" term nil)
    (apply? adt-recognizer-decl "[term -> boolean]" term nil)
    (t!1 skolem-const-decl "term" term nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (member const-decl "bool" sets nil) (term type-decl nil term nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (subterm adt-def-decl "boolean" term nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (subset? const-decl "bool" sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (var? adt-recognizer-decl "[term -> boolean]" term nil)
    (v adt-constructor-decl "[nat -> (var?)]" term nil)
    (V def-decl "{ns: set[nat] | ns = ({n: nat | subterm(v(n), t)})}"
     term nil)
    (term_induction formula-decl nil term nil))
   shostak))
 (vars_ltlt 0
  (vars_ltlt-1 nil 3578952667
   ("" (induct-and-simplify s :if-match nil :exclude subterm)
    (("" (expand every)
      (("" (inst -1 "z!1")
        (("" (inst?)
          (("" (case "t!1 = apply2_var!1(z!1)")
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (fun type-decl nil term nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (z!1 skolem-const-decl "below[apply2_var!1`length]" term nil)
    (below type-eq-decl nil naturalnumbers nil)
    (apply2_var!1 skolem-const-decl
     "{l: finseq[term] | l`length = arity(apply1_var!1)}" term nil)
    (apply1_var!1 skolem-const-decl "fun" term nil)
    (finseq2set const-decl "set[T]" set_props nil)
    (t!1 skolem-const-decl "term" term nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (apply? adt-recognizer-decl "[term -> boolean]" term nil)
    (fun adt-accessor-decl "[(apply?) -> fun]" term nil)
    (args adt-accessor-decl
          "[d: (apply?) -> {l: finseq[term] | l`length = arity(fun(d))}]"
          term nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (member const-decl "bool" sets nil) (term type-decl nil term nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (subset? const-decl "bool" sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (subterm adt-def-decl "boolean" term nil)
    (var? adt-recognizer-decl "[term -> boolean]" term nil)
    (v adt-constructor-decl "[nat -> (var?)]" term nil)
    (V def-decl "{ns: set[nat] | ns = ({n: nat | subterm(v(n), t)})}"
     term nil)
    (term_induction formula-decl nil term nil))
   shostak))
 (vars_is_finite 0
  (vars_is_finite-1 nil 3580499816
   ("" (lemma subterm_is_finite)
    (("" (skeep)
      (("" (typepred "V(s)")
        (("" (rewrite -1)
          (("" (case "is_finite({ t | var?(t) AND subterm(t, s) })")
            (("1" (rewrite is_finite_surj :dir rl)
              (("1" (rewrite is_finite_surj :dir rl)
                (("1" (skeep)
                  (("1"
                    (inst 1 "N" "LAMBDA (n: below[N]): index(f(n))")
                    (("1" (lazy-grind :exclude subterm) nil nil)
                     ("2" (typepred f)
                      (("2" (skeep)
                        (("2" (inst -1 "n")
                          (("2" (case "v(index(f(n))) = f(n)")
                            (("1" (rewrite -1) (("1" (grind) nil nil))
                              nil)
                             ("2" (decompose-equality) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (inst -1 "s")
              (("2" (expand is_finite)
                (("2" (skeep)
                  (("2"
                    (inst 1 "N"
                     "LAMBDA (t| var?(t) AND subterm(t,s)): f(t)")
                    (("2" (lazy-grind :exclude subterm) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((is_finite_surj formula-decl nil finite_sets nil)
    (term_v_extensionality formula-decl nil term nil)
    (surjective? const-decl "bool" functions nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (x!1 skolem-const-decl "below[N]" term nil)
    (y!1 skolem-const-decl "({n: nat | subterm(v(n), s)})" term nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (f skolem-const-decl
     "[below[N] -> ({t | var?(t) AND subterm(t, s)})]" term nil)
    (s skolem-const-decl "term" term nil)
    (index adt-accessor-decl "[(var?) -> nat]" term nil)
    (below type-eq-decl nil nat_types nil)
    (N skolem-const-decl "nat" term nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (is_finite const-decl "bool" finite_sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (term type-decl nil term nil)
    (subterm adt-def-decl "boolean" term nil)
    (var? adt-recognizer-decl "[term -> boolean]" term nil)
    (v adt-constructor-decl "[nat -> (var?)]" term nil)
    (V def-decl "{ns: set[nat] | ns = ({n: nat | subterm(v(n), t)})}"
     term nil)
    (subterm_is_finite formula-decl nil term nil))
   shostak))
 (FS_TCC1 0
  (FS_TCC1-1 nil 3579033390 ("" (grind-with-ext) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (emptyset const-decl "set" sets nil)
    (below type-eq-decl nil nat_types nil)
    (term type-decl nil term nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (args type-eq-decl nil term nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (apply? adt-recognizer-decl "[term -> boolean]" term nil)
    (apply adt-constructor-decl
           "[[fun: fun, {l: finseq[term] | l`length = arity(fun)}] -> (apply?)]"
           term nil)
    (var? adt-recognizer-decl "[term -> boolean]" term nil)
    (v adt-constructor-decl "[nat -> (var?)]" term nil)
    (FALSE const-decl "bool" booleans nil)
    (< const-decl "bool" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (pred type-eq-decl nil defined_types nil)
    (fun type-decl nil term nil) ( macro-decl "set[T]" set_props nil)
    (subterm adt-def-decl "boolean" term nil))
   nil))
 (FS_TCC2 0
  (FS_TCC2-1 nil 3579033390 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (term type-decl nil term nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (fun type-decl nil term nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (set type-eq-decl nil sets nil)
    (finseq2set const-decl "set[T]" set_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (subterm adt-def-decl "boolean" term nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pred type-eq-decl nil defined_types nil))
   nil))
 (FS_TCC3 0
  (FS_TCC3-1 nil 3579033390
   ("" (grind :if-match nil)
    (("" (expand restrict)
      (("" (apply-extensionality :hide? t)
        (("1" (iff)
          (("1" (prop)
            (("1" (grind) nil nil)
             ("2" (skolem-typepred)
              (("2" (expand finseq2set)
                (("2" (skolem-typepred)
                  (("2" (inst -4 "p!1")
                    (("2" (inst -4 "k!1")
                      (("2" (rewrite -4)
                        (("2" (beta)
                          (("2" (skolem-typepred)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (skolem-typepred)
              (("3" (prop)
                (("1" (decompose-equality) nil nil)
                 ("2" (skolem-typepred)
                  (("2" (inst -4 "p!1")
                    (("2" (inst -4 "args!1(z!1)")
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skolem-typepred)
          (("2" (flatten)
            (("2" (skolem-typepred)
              (("2" (expand finseq2set) (("2" (lazy-grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((p!1 skolem-const-decl "pred[fun]" term nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (f!1 skolem-const-decl "fun" term nil)
    (finseq2set const-decl "set[T]" set_props nil)
    (args!1 skolem-const-decl
     "{l: finseq[term] | l`length = arity(f!1)}" term nil)
    (< const-decl "bool" reals nil)
    (fun adt-accessor-decl "[(apply?) -> fun]" term nil)
    (args adt-accessor-decl
          "[d: (apply?) -> {l: finseq[term] | l`length = arity(fun(d))}]"
          term nil)
    (t!1 skolem-const-decl "term" term nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (var? adt-recognizer-decl "[term -> boolean]" term nil)
    (v adt-constructor-decl "[nat -> (var?)]" term nil)
    (FALSE const-decl "bool" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (z!1 skolem-const-decl "below[args!1`length]" term nil)
    (i!1 skolem-const-decl "below(args!1`length)" term nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (fun type-decl nil term nil)
    (pred type-eq-decl nil defined_types nil)
    (term type-decl nil term nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (args type-eq-decl nil term nil)
    (apply? adt-recognizer-decl "[term -> boolean]" term nil)
    (apply adt-constructor-decl
           "[[fun: fun, {l: finseq[term] | l`length = arity(fun)}] -> (apply?)]"
           term nil)
    (subterm adt-def-decl "boolean" term nil)
    (member const-decl "bool" sets nil))
   nil))
 (FS_subterm 0
  (FS_subterm-1 nil 3579033712
   ("" (induct-and-simplify s :exclude subterm :if-match nil)
    (("1" (grind) nil nil)
     ("2" (expand every)
      (("2" (expand subterm -2)
        (("2" (typepred "x!1")
          (("2" (prop)
            (("1" (grind) nil nil)
             ("2" (skolem-typepred)
              (("2" (inst -4 "z!1")
                (("2" (inst 2 "apply2_var!1(z!1)")
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((args adt-accessor-decl
          "[d: (apply?) -> {l: finseq[term] | l`length = arity(fun(d))}]"
          term nil)
    (fun adt-accessor-decl "[(apply?) -> fun]" term nil)
    (apply1_var!1 skolem-const-decl "fun" term nil)
    (apply2_var!1 skolem-const-decl
     "{l: finseq[term] | l`length = arity(apply1_var!1)}" term nil)
    (i!1 skolem-const-decl "below(apply2_var!1`length)" term nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (finseq2set const-decl "set[T]" set_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (z!1 skolem-const-decl "below[apply2_var!1`length]" term nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (member const-decl "bool" sets nil) (term type-decl nil term nil)
    (boolean nonempty-type-decl nil booleans nil)
    (fun type-decl nil term nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (subterm adt-def-decl "boolean" term nil)
    (set type-eq-decl nil sets nil)
    (subset? const-decl "bool" sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (args type-eq-decl nil term nil)
    (apply? adt-recognizer-decl "[term -> boolean]" term nil)
    (apply adt-constructor-decl
           "[[fun: fun, {l: finseq[term] | l`length = arity(fun)}] -> (apply?)]"
           term nil)
    (FS def-decl "{fs: set[(p)] |
         fs =
          ({f: (p) | EXISTS (args: args(f)): subterm(apply(f, args), t)})}"
     term nil)
    (term_induction formula-decl nil term nil))
   shostak))
 (FS_ltlt 0
  (FS_ltlt-1 nil 3579033872
   ("" (grind :exclude <<)
    (("" (expand "<<")
      (("" (lift-if)
        (("" (prop)
          (("" (lemma FS_subterm)
            (("" (skolem-typepred)
              (("" (inst -2 "args(s!1)(z!1)" "t!1" "p!1")
                (("" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (term type-decl nil term nil)
    (apply? adt-recognizer-decl "[term -> boolean]" term nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (fun adt-accessor-decl "[(apply?) -> fun]" term nil)
    (args adt-accessor-decl
          "[d: (apply?) -> {l: finseq[term] | l`length = arity(fun(d))}]"
          term nil)
    (finseq2set const-decl "set[T]" set_props nil)
    (set type-eq-decl nil sets nil)
    (s!1 skolem-const-decl "term" term nil)
    (below type-eq-decl nil naturalnumbers nil)
    (z!1 skolem-const-decl "below[args(s!1)`length]" term nil)
    (FS def-decl "{fs: set[(p)] |
         fs =
          ({f: (p) | EXISTS (args: args(f)): subterm(apply(f, args), t)})}"
     term nil)
    (subterm adt-def-decl "boolean" term nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (FS_subterm formula-decl nil term nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (fun type-decl nil term nil)
    (pred type-eq-decl nil defined_types nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil))
   shostak))
 (UFS_subterm 0
  (UFS_subterm-1 nil 3579034265
   ("" (use FS_subterm) (("" (grind) nil nil)) nil)
   ((UFS const-decl "{us: set[(ufun?)] |
         us = ({uf | EXISTS (args: args(uf)): subterm(apply(uf, args), t)})}"
     term nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (subterm adt-def-decl "boolean" term nil)
    (fun type-decl nil term nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (ufun? adt-recognizer-decl "[fun -> boolean]" term nil)
    (FS_subterm formula-decl nil term nil))
   shostak))
 (UFS_ltlt 0
  (UFS_ltlt-1 nil 3579034273
   ("" (use FS_ltlt) (("" (grind) nil nil)) nil)
   ((UFS const-decl "{us: set[(ufun?)] |
         us = ({uf | EXISTS (args: args(uf)): subterm(apply(uf, args), t)})}"
     term nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil) (fun type-decl nil term nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (ufun? adt-recognizer-decl "[fun -> boolean]" term nil)
    (FS_ltlt formula-decl nil term nil))
   shostak))
 (IFS_subterm 0
  (IFS_subterm-1 nil 3579034300
   ("" (use FS_subterm) (("" (grind) nil nil)) nil)
   ((IFS const-decl "{is: set[(ifun?)] |
         is =
          ({ifun |
              EXISTS (args: args(ifun)): subterm(apply(ifun, args), t)})}"
     term nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (subterm adt-def-decl "boolean" term nil)
    (fun type-decl nil term nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (ifun? adt-recognizer-decl "[fun -> boolean]" term nil)
    (FS_subterm formula-decl nil term nil))
   shostak))
 (IFS_ltlt 0
  (IFS_ltlt-1 nil 3579034307
   ("" (use FS_ltlt) (("" (grind) nil nil)) nil)
   ((IFS const-decl "{is: set[(ifun?)] |
         is =
          ({ifun |
              EXISTS (args: args(ifun)): subterm(apply(ifun, args), t)})}"
     term nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil) (fun type-decl nil term nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (ifun? adt-recognizer-decl "[fun -> boolean]" term nil)
    (FS_ltlt formula-decl nil term nil))
   shostak))
 (uparrow_TCC1 0
  (uparrow_TCC1-1 nil 3580577127 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (uparrow_TCC2 0
  (uparrow_TCC2-1 nil 3580577127 ("" (subtype-tcc) nil nil) nil nil))
 (uparrow_TCC3 0
  (uparrow_TCC3-1 nil 3580577127 ("" (subtype-tcc) nil nil) nil nil))
 (uparrow_TCC4 0
  (uparrow_TCC4-1 nil 3580577127 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (smap const-decl "{vs | vs`length = ks`length}" smap nil))
   nil))
 (uparrow_TCC5 0
  (uparrow_TCC5-1 nil 3580577127 ("" (subtype-tcc) nil nil) nil nil))
 (parsubst_TCC1 0
  (parsubst_TCC1-1 nil 3578942454
   ("" (grind :rewrites map_length)
    ((""
      (case "FORALL (l: list[{ s | s << t!1 }]): length[term](l) = length(l)")
      (("1" (grind) nil nil) ("2" (induct-and-simplify l) nil nil))
      nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (V def-decl "{ns: set[nat] | ns = ({n: nat | subterm(v(n), t)})}"
     term nil)
    (v adt-constructor-decl "[nat -> (var?)]" term nil)
    (var? adt-recognizer-decl "[term -> boolean]" term nil)
    (subterm adt-def-decl "boolean" term nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil) (term type-decl nil term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (parsubst_TCC2 0
  (parsubst_TCC2-1 nil 3578946022
   ("" (grind :if-match nil :exclude subterm)
    (("" (inst -5 "v!1")
      (("" (case "s!1 << t!1")
        (("1" (use vars_subterm) (("1" (grind) nil nil)) nil)
         ("2" (grind) nil nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (below type-eq-decl nil nat_types nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" term nil) (term type-decl nil term nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (parsubst_TCC3 0
  (parsubst_TCC3-1 nil 3578949854
   ("" (grind)
    (("" (typepred "(mapping!1`seq(i!1 - q!1)  q!1)")
      (("" (grind) nil nil)) nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (subterm adt-def-decl "boolean" term nil)
    (var? adt-recognizer-decl "[term -> boolean]" term nil)
    (v adt-constructor-decl "[nat -> (var?)]" term nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    ( def-decl "{s | V(s) = ({n | n >= i AND member((n - i), V(t))})}"
     term nil)
    (< const-decl "bool" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (term type-decl nil term nil) (< const-decl "bool" term nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (member const-decl "bool" sets nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (singleton const-decl "(singleton?)" sets nil)
    (V def-decl "{ns: set[nat] | ns = ({n: nat | subterm(v(n), t)})}"
     term nil))
   nil))
 (parsubst_TCC4 0
  (parsubst_TCC4-1 nil 3579016031 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (term type-decl nil term nil) (< const-decl "bool" term nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (subterm adt-def-decl "boolean" term nil)
    (var? adt-recognizer-decl "[term -> boolean]" term nil)
    (v adt-constructor-decl "[nat -> (var?)]" term nil)
    (V def-decl "{ns: set[nat] | ns = ({n: nat | subterm(v(n), t)})}"
     term nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (member const-decl "bool" sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (parsubst_TCC5 0
  (parsubst_TCC5-1 nil 3579016031
   ("" (grind :if-match nil :exclude <<)
    (("" (use vars_ltlt) (("" (grind) nil nil)) nil)) nil)
   ((vars_ltlt formula-decl nil term nil)
    (apply? adt-recognizer-decl "[term -> boolean]" term nil)
    (apply adt-constructor-decl
           "[[fun: fun, {l: finseq[term] | l`length = arity(fun)}] -> (apply?)]"
           term nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (subset? const-decl "bool" sets nil)
    (< const-decl "bool" reals nil)
    (v!1 skolem-const-decl "(V(s!1))" term nil)
    (s!1 skolem-const-decl "{s | s << t!1}" term nil)
    (t!1 skolem-const-decl "{t | t < mapping!1`length + q!1}" term nil)
    (q!1 skolem-const-decl "nat" term nil)
    (mapping!1 skolem-const-decl "finseq[term]" term nil)
    (args!1 skolem-const-decl
     "{l: finseq[term] | l`length = arity(f!1)}" term nil)
    (f!1 skolem-const-decl "fun" term nil)
    (finseq2set const-decl "set[T]" set_props nil)
    (member const-decl "bool" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (set type-eq-decl nil sets nil)
    (subterm adt-def-decl "boolean" term nil)
    (var? adt-recognizer-decl "[term -> boolean]" term nil)
    (v adt-constructor-decl "[nat -> (var?)]" term nil)
    (V def-decl "{ns: set[nat] | ns = ({n: nat | subterm(v(n), t)})}"
     term nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (term type-decl nil term nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (fun type-decl nil term nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (< const-decl "bool" term nil))
   nil))
 (parsubst_TCC6 0
  (parsubst_TCC6-1 nil 3579016031 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (smap const-decl "{vs | vs`length = ks`length}" smap nil))
   nil))
 (parsubst_TCC7 0
  (parsubst_TCC7-1 nil 3579016031
   ("" (grind :exclude << :if-match nil)
    (("" (inst -4 "(q!1, mapping!1)")
      (("" (inst -4 "args!1`seq(i!1)")
        (("" (inst -7 "(q!1, mapping!1)")
          (("" (inst -7 "args!1`seq(i!1)")
            (("" (inst -7 "v!1") (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((finseq2set const-decl "set[T]" set_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (apply? adt-recognizer-decl "[term -> boolean]" term nil)
    (apply adt-constructor-decl
           "[[fun: fun, {l: finseq[term] | l`length = arity(fun)}] -> (apply?)]"
           term nil)
    (smap const-decl "{vs | vs`length = ks`length}" smap nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (term type-decl nil term nil) (< const-decl "bool" term nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (subterm adt-def-decl "boolean" term nil)
    (var? adt-recognizer-decl "[term -> boolean]" term nil)
    (v adt-constructor-decl "[nat -> (var?)]" term nil)
    (V def-decl "{ns: set[nat] | ns = ({n: nat | subterm(v(n), t)})}"
     term nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (fun type-decl nil term nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (member const-decl "bool" sets nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (fsubst_TCC1 0
  (fsubst_TCC1-1 nil 3578944847 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (fun type-decl nil term nil)
    (ufun? adt-recognizer-decl "[fun -> boolean]" term nil)
    (term type-decl nil term nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (subterm adt-def-decl "boolean" term nil)
    (var? adt-recognizer-decl "[term -> boolean]" term nil)
    (v adt-constructor-decl "[nat -> (var?)]" term nil)
    (V def-decl "{ns: set[nat] | ns = ({n: nat | subterm(v(n), t)})}"
     term nil)
    (i!1 skolem-const-decl "nat" term nil)
    (t!1 skolem-const-decl "{t | t < arity(uf!1)}" term nil)
    (uf!1 skolem-const-decl "(ufun?)" term nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" term nil))
   nil))
 (fsubst_TCC2 0
  (fsubst_TCC2-1 nil 3578944847 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (fun type-decl nil term nil)
    (ufun? adt-recognizer-decl "[fun -> boolean]" term nil)
    (term type-decl nil term nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (V def-decl "{ns: set[nat] | ns = ({n: nat | subterm(v(n), t)})}"
     term nil)
    (v adt-constructor-decl "[nat -> (var?)]" term nil)
    (var? adt-recognizer-decl "[term -> boolean]" term nil)
    (subterm adt-def-decl "boolean" term nil)
    (set type-eq-decl nil sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (smap const-decl "{vs | vs`length = ks`length}" smap nil)
    (< const-decl "bool" term nil))
   nil))
 (fsubst_TCC3 0
  (fsubst_TCC3-1 nil 3578949854
   ("" (grind :if-match nil)
    (("" (typepred "parsubst(0, nargs!1)")
      (("" (inst -1 "t!1")
        (("" (inst -1 "v!2")
          (("" (split)
            (("1" (grind) nil nil)
             ("2" (skolem-typepred)
              (("2" (rewrite -11)
                (("2" (beta)
                  (("2" (expand finseq_appl)
                    (("2" (inst -7 "(uf!1, t!1)")
                      (("2" (inst -7 "args!1`seq(i!1)")
                        (("1" (inst -7 "q!1")
                          (("1" (prop)
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finseq2set const-decl "set[T]" set_props nil)
    (v!3 skolem-const-decl "(V(args!1`seq(i!1)))" term nil)
    (v!3 skolem-const-decl "(V(args!1`seq(i!1)))" term nil)
    (t!1 skolem-const-decl "{t | t < arity(uf!1)}" term nil)
    (uf!1 skolem-const-decl "(ufun?)" term nil)
    (apply adt-constructor-decl
           "[[fun: fun, {l: finseq[term] | l`length = arity(fun)}] -> (apply?)]"
           term nil)
    (FALSE const-decl "bool" booleans nil)
    (i!1 skolem-const-decl "below(nargs!1`length)" term nil)
    (nargs!1 skolem-const-decl "{vs | vs`length = args!1`length}" term
     nil)
    (args!1 skolem-const-decl
     "{l: finseq[term] | l`length = arity(f!1)}" term nil)
    (f!1 skolem-const-decl "fun" term nil)
    (s!1 skolem-const-decl "term" term nil)
    (args adt-accessor-decl
          "[d: (apply?) -> {l: finseq[term] | l`length = arity(fun(d))}]"
          term nil)
    (fun adt-accessor-decl "[(apply?) -> fun]" term nil)
    (apply? adt-recognizer-decl "[term -> boolean]" term nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (set type-eq-decl nil sets nil)
    (subterm adt-def-decl "boolean" term nil)
    (var? adt-recognizer-decl "[term -> boolean]" term nil)
    (v adt-constructor-decl "[nat -> (var?)]" term nil)
    (V def-decl "{ns: set[nat] | ns = ({n: nat | subterm(v(n), t)})}"
     term nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (member const-decl "bool" sets nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (parsubst def-decl "{r |
         FORALL (v: (V(r))):
           v < q OR
            (EXISTS (i: below(mapping`length)):
               member(v - q, V(finseq_appl[term](mapping)(i))))}" term
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (fun type-decl nil term nil)
    (ufun? adt-recognizer-decl "[fun -> boolean]" term nil)
    (term type-decl nil term nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (< const-decl "bool" term nil)
    (smap const-decl "{vs | vs`length = ks`length}" smap nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (fsubst_TCC4 0
  (fsubst_TCC4-1 nil 3579016882 ("" (subtype-tcc) nil nil)
   ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil)
    (smap const-decl "{vs | vs`length = ks`length}" smap nil))
   nil))
 (fsubst_TCC5 0
  (fsubst_TCC5-1 nil 3579016882
   ("" (grind :if-match nil)
    (("" (inst -7 "(uf!1, t!1)")
      (("" (inst -7 "args!1`seq(i!1)")
        (("" (inst -7 "q!1")
          (("" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((v!3 skolem-const-decl "(V(args!1`seq(i!1)))" term nil)
    (fun adt-accessor-decl "[(apply?) -> fun]" term nil)
    (args adt-accessor-decl
          "[d: (apply?) -> {l: finseq[term] | l`length = arity(fun(d))}]"
          term nil)
    (s!1 skolem-const-decl "term" term nil)
    (f!1 skolem-const-decl "fun" term nil)
    (args!1 skolem-const-decl
     "{l: finseq[term] | l`length = arity(f!1)}" term nil)
    (i!1 skolem-const-decl "below(arity(f!1))" term nil)
    (v!3 skolem-const-decl "(V(args!1`seq(i!1)))" term nil)
    (q!1 skolem-const-decl "nat" term nil)
    (t!1 skolem-const-decl "{t | t < arity(uf!1)}" term nil)
    (uf!1 skolem-const-decl "(ufun?)" term nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (finseq2set const-decl "set[T]" set_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (member const-decl "bool" sets nil)
    (apply adt-constructor-decl
           "[[fun: fun, {l: finseq[term] | l`length = arity(fun)}] -> (apply?)]"
           term nil)
    (apply? adt-recognizer-decl "[term -> boolean]" term nil)
    (V def-decl "{ns: set[nat] | ns = ({n: nat | subterm(v(n), t)})}"
     term nil)
    (v adt-constructor-decl "[nat -> (var?)]" term nil)
    (var? adt-recognizer-decl "[term -> boolean]" term nil)
    (subterm adt-def-decl "boolean" term nil)
    (set type-eq-decl nil sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (fun type-decl nil term nil)
    (ufun? adt-recognizer-decl "[fun -> boolean]" term nil)
    (term type-decl nil term nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (< const-decl "bool" term nil)
    (smap const-decl "{vs | vs`length = ks`length}" smap nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
     nil))
   nil))
 (fsubst_TCC6 0
  (fsubst_TCC6-1 nil 3579016882 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (fun type-decl nil term nil)
    (ufun? adt-recognizer-decl "[fun -> boolean]" term nil)
    (term type-decl nil term nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" term nil)
    (arity shared-adt-accessor-decl "[fun -> nat]" term nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (finseq type-eq-decl nil finite_sequences nil)
    (x1!1 skolem-const-decl "below[args!1`length]" term nil)
    (args!1 skolem-const-decl
     "{l: finseq[term] | l`length = arity(f!1)}" term nil)
    (f!1 skolem-const-decl "fun" term nil)
    (t!1 skolem-const-decl "{t | t < arity(uf!1)}" term nil)
    (uf!1 skolem-const-decl "(ufun?)" term nil)
    (V def-decl "{ns: set[nat] | ns = ({n: nat | subterm(v(n), t)})}"
     term nil)
    (v adt-constructor-decl "[nat -> (var?)]" term nil)
    (var? adt-recognizer-decl "[term -> boolean]" term nil)
    (set type-eq-decl nil sets nil)
    (<< adt-def-decl "(strict_well_founded?[term])" term nil)
    (subterm adt-def-decl "boolean" term nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" reals nil))
   nil)))

