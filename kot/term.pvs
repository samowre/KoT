% A term is either a variable, or the application of a function symbol to a list of arguments
term: THEORY
BEGIN
  lists: LIBRARY "../lists"
  IMPORTING lists@more_list_props
  IMPORTING lists@list2_props
  IMPORTING more_finseq_props
  IMPORTING assoc2, smap, setmap
  IMPORTING set_props
  CONVERSION- singleton_elt

  fun: DATATYPE
  BEGIN
    ifun(index, arity: nat): ifun?
    ufun(index, arity: nat): ufun?
  END fun

  term: DATATYPE
  BEGIN
    v(index: nat): var?
    apply(fun: fun, args: { l: finseq[term] | l`length = arity(fun) }): apply?
  END term

  s, t, r: VAR term
  ss, ts: VAR set[term]
  i, n: VAR nat
  is, ns: VAR set[nat]
  uf: VAR (ufun?)

  skolem?(s): bool =
    apply?(s) AND ufun?(fun(s)) AND arity(fun(s)) = 0
  skolem: TYPE = (skolem?)

  % Computes the set of variables present in a term.
  % This is intended to be used in specifications only, and may not be executable.
  V(t): RECURSIVE set[nat] =
    CASES t OF
      v(n): singleton(n),
      apply(f, args): V(args :: set[term])
    ENDCASES
  MEASURE t BY <<

  vars_subterm: THEOREM n ∈ V(t) IFF subterm(v(n), t)
  
  % vars only increases
  vars_increases: THEOREM
    t << s IMPLIES V(t) ⊂ V(s)

  % Uninterpreted Function Symbols of a term
  UFS(t): RECURSIVE set[(ufun?)] =
    CASES t OF
      v(n): ∅,
      apply(f, args): { uf | uf = f OR uf ∈ UFS(args :: set[term]) }
    ENDCASES
  MEASURE t BY <<

  % Rename variables
  % TODO: injection, equivalence
  α(rename: (bijective?[nat, nat]))(s): RECURSIVE term =
    CASES s OF
      v(i): v(rename(i)),
      apply(f, args): apply(f, smap[{ t | t << s }, term]
                                   (LAMBDA (t | t << s): α(rename)(t))(args))
    ENDCASES
  MEASURE s BY <<
				   
  % The new variables is the renaming of the old ones
  alpha_vars: RECURSIVE JUDGEMENT
    α(rename: (bijective?[nat, nat]))(s: term) HAS_TYPE { t | V(t) = rename(V(s)) }

  ;≃(s, t): MACRO bool = EXISTS (rename: (bijective?[nat, nat])): α(rename)(s) = t
  alpha_equiv(s, t): bool = s ≃ t

  alpha_structure: THEOREM
    (s ≃ t) AND apply?(s) IMPLIES apply?(t)

  alpha_identity: THEOREM
    α(LAMBDA n: n)(s) = s
    
  alpha_term_reflexive: THEOREM
    s ≃ s

  alpha_term_inverse: THEOREM
    FORALL (rename: (bijective?[nat, nat])):
      α(rename)(s) = t IMPLIES α(inverse(rename))(t) = s

  alpha_term_symmetry: THEOREM
    (s ≃ t) IMPLIES (t ≃ s)

  alpha_term_composition: THEOREM
    FORALL (rename, rename2: (bijective?[nat, nat])):
      α(rename)(s) = t IMPLIES α(rename2)(t) = α(rename2 o rename)(s)

  alpha_term_transitivity: THEOREM
    (s ≃ t) AND (t ≃ r) IMPLIES (s ≃ r)

  alpha_term_equiv: JUDGEMENT
    alpha_equiv HAS_TYPE (equivalence?[term])

  % Parallel substitution in a term using a mapping function from variables to terms.
  parsubst(s: term, mapping: [nat -> term]): RECURSIVE term =
    CASES s OF
      v(i): mapping(i),
      apply(f, args): apply(f, smap[{t | t << s }, term]
                                   (LAMBDA (t | t << s): parsubst(t, mapping))(args))
    ENDCASES
  MEASURE s BY <<

  % Information about the new set of variables as a recursive judgement
  parsubst_map_vars: RECURSIVE JUDGEMENT
    parsubst(s: term, mapping: [nat -> term]) HAS_TYPE { t | V(t) ⊂ V(mapping(V(s))) }

  % Paralel substitution, with association lists
  % Again, we can know a superset of the new variables
  parsubst(s: term, vars: list[nat], (vals: finseq[term] | vals`length = length(vars))):
    term =
%    { r: term | V(r) ⊂ (V(s) - vars) ∪ V(vals :: set[term]) } =
%TODO    { r | V(r) ⊂ (V(s) \ vars) ∪ V(vals) }
    parsubst(s, LAMBDA i: assoc2[nat, term](i, vars, vals, v(i)))
    
%  parsubst_vars: JUDGEMENT
%    parsubst(s: term, vars: list[nat], (vals: finseq[term] | vals`length = length(vars)))
%      HAS_TYPE { r: term | V(r) ⊂ (V(s) - vars) ∪ V(vals :: set[term]) }

  % Single substitution is actually a parallel substitution
  % We know a superset of the new variables
  subst(s, n, t): term =
%TODO    { r | V(r) ⊂ (V(s) \ n) ∪ V(t) }
    parsubst(s, LAMBDA i: IF i = n THEN t ELSE v(i) ENDIF)

  % Interprets an uninterpreted function by a body.
  % There is no restriction on the variables present in the replacement function.
  fsubst(s,
        (u: (ufun?)),
	(vars: (uniques?[nat]) | length(vars) = arity(u)),
	t):
    RECURSIVE term =
%TODO { r | V(r) ⊂ V(s) ∪ (V(t) \ vars) }
    CASES s OF
      v(i): s,
      apply(f, args):
        LET nargs = smap[{ t | t << s }, term]
	                (LAMBDA (r: term | r << s): fsubst(r, u, vars, t))(args) IN
	IF f = u
	  THEN parsubst(t, vars, nargs)
	  ELSE apply(f, nargs)
	ENDIF
    ENDCASES
  MEASURE s BY <<
END term
