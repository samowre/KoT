% A term is either a variable, or the application of a function symbol to a list of arguments
term: THEORY
BEGIN
  lists: LIBRARY "../lists"
  IMPORTING lists@more_list_props
  IMPORTING lists@list2_props
  IMPORTING more_finseq_props
  IMPORTING assoc2, smap, setmap
  IMPORTING wf_pair
  IMPORTING set_props
  % TODO: move this to set_props
  CONVERSION- singleton_elt

  % A function is interpreted or uninterpreted
  fun: DATATYPE
  BEGIN
    ifun(index, arity: nat): ifun?
    ufun(index, arity: nat): ufun?
  END fun

  % Terms of functions and variables
  term: DATATYPE
  BEGIN
    v(index: nat): var?
    apply(fun: fun, args: { l: finseq[term] | l`length = arity(fun) }): apply?
  END term

  s, t, r: VAR term
  ss, ts: VAR set[term]
  i, n: VAR nat
  is, ns: VAR set[nat]
  uf: VAR (ufun?)

  skolem?(s): bool =
    apply?(s) AND ufun?(fun(s)) AND arity(fun(s)) = 0
  skolem: TYPE = (skolem?)

  skolem_equal: THEOREM
    FORALL (x, y: skolem): fun(x) = fun(y) IMPLIES x = y

  sk(i): term = apply(ufun(i, 0), empty_seq)

  skfree_aux(s: term, ts: finseq[{ t: term | t << s }], i: upto(ts`length), x: skolem):
    RECURSIVE bool =
    IF i = ts`length THEN TRUE
    ELSE LET tsi = ts(i) IN
      CASES tsi OF
       v(j): skfree_aux(s, ts, i + 1, x),
       apply(f, args):
         IF tsi = x THEN FALSE
	 ELSE skfree_aux(tsi, args, 0, x) AND skfree_aux(s, ts, i + 1, x) ENDIF
      ENDCASES
    ENDIF
  MEASURE (s, (ts`length - i) :: nat) BY le[term, nat, <<, <]

  skfree(s: term, x: skolem): bool =
    CASES s OF
      v(i): TRUE,
      apply(f, args):
        IF s = x THEN FALSE
	ELSE skfree_aux(s, args, 0, x) ENDIF
    ENDCASES

  % Computes the set of variables present in a term.
  % This is intended to be used in specifications only, and may not be executable.
  V(t): RECURSIVE set[nat] =
    CASES t OF
      v(n): singleton(n),
      apply(f, args): V(args :: set[term])
    ENDCASES
  MEASURE t BY <<

  vars_subterm: THEOREM n ∈ V(t) IFF subterm(v(n), t)
  
  % vars only increases
  vars_increases: THEOREM
    t << s IMPLIES V(t) ⊂ V(s)

  % Uninterpreted Function Symbols of a term
  UFS(t): RECURSIVE set[(ufun?)] =
    CASES t OF
      v(n): ∅,
      apply(f, args): { uf | uf = f OR uf ∈ UFS(args :: set[term]) }
    ENDCASES
  MEASURE t BY <<

  UFS_subterm: THEOREM
    uf ∈ UFS(t) IFF EXISTS (args: finseq[term] | args`length = arity(uf)): subterm(apply(uf, args), t)

  skfree_aux_UFS: RECURSIVE JUDGEMENT
    skfree_aux(s: term, ts: finseq[{ t: term | t << s }], i: upto(ts`length), x: skolem)
      HAS_TYPE { b: bool | b = FORALL (j: below(ts`length)): j >= i IMPLIES fun(x) ∉ UFS(ts`seq(j)) }

  skfree_UFS: JUDGEMENT
    skfree(s: term, x: skolem) HAS_TYPE { b: bool | b = fun(x) ∉ UFS(s) }

  % Rename variables
  α(rename: (bijective?[nat, nat]))(s): RECURSIVE term =
    CASES s OF
      v(i): v(rename(i)),
      apply(f, args): apply(f, smap[{ t | t << s }, term]
                                   (LAMBDA (t | t << s): α(rename)(t))(args))
    ENDCASES
  MEASURE s BY <<
				   
  % The new variables is the renaming of the old ones
  alpha_vars: RECURSIVE JUDGEMENT
    α(rename: (bijective?[nat, nat]))(s: term) HAS_TYPE { t | V(t) = rename(V(s)) }

  alpha_equiv(s, t): bool = EXISTS (rename: (bijective?[nat, nat])): α(rename)(s) = t
  ;≃(s, t): MACRO bool = alpha_equiv(s, t)

  alpha_identity: THEOREM
    α(LAMBDA n: n)(s) = s
    
  alpha_term_reflexive: THEOREM
    s ≃ s

  alpha_term_inverse: THEOREM
    FORALL (rename: (bijective?[nat, nat])):
      α(rename)(s) = t IMPLIES α(inverse(rename))(t) = s

  alpha_term_symmetry: THEOREM
    (s ≃ t) IMPLIES (t ≃ s)

  alpha_term_composition: THEOREM
    FORALL (rename, rename2: (bijective?[nat, nat])):
      α(rename)(s) = t IMPLIES α(rename2)(t) = α(rename2 o rename)(s)

  alpha_term_transitivity: THEOREM
    (s ≃ t) AND (t ≃ r) IMPLIES (s ≃ r)

  alpha_term_equiv: JUDGEMENT
    alpha_equiv HAS_TYPE (equivalence?[term])

  % Parallel substitution in a term using a mapping function from variables to terms.
  parsubst(s: term, mapping: [nat -> term]): RECURSIVE term =
    CASES s OF
      v(i): mapping(i),
      apply(f, args): apply(f, smap[{t | t << s }, term]
                                   (LAMBDA (t | t << s): parsubst(t, mapping))(args))
    ENDCASES
  MEASURE s BY <<

  % Information about the new set of variables as a recursive judgement
  parsubst_map_vars: RECURSIVE JUDGEMENT
    parsubst(s: term, mapping: [nat -> term]) HAS_TYPE { t | V(t) ⊂ V(mapping(V(s))) }

  % Paralel substitution, with association lists
  % Again, we can know a superset of the new variables
  parsubst(s: term, vars: list[nat], (vals: finseq[term] | vals`length = length(vars))):
    term =
%    { r: term | V(r) ⊂ (V(s) - vars) ∪ V(vals :: set[term]) } =
%TODO    { r | V(r) ⊂ (V(s) \ vars) ∪ V(vals) }
    parsubst(s, LAMBDA i: assoc2[nat, term](i, vars, vals, v(i)))
    
%  parsubst_vars: JUDGEMENT
%    parsubst(s: term, vars: list[nat], (vals: finseq[term] | vals`length = length(vars)))
%      HAS_TYPE { r: term | V(r) ⊂ (V(s) - vars) ∪ V(vals :: set[term]) }

  % Single substitution is actually a parallel substitution
  % We know a superset of the new variables
  subst(s, n, t): term =
%TODO    { r | V(r) ⊂ (V(s) \ n) ∪ V(t) }
    parsubst(s, LAMBDA i: IF i = n THEN t ELSE v(i) ENDIF)

  % Interprets an uninterpreted function by a body.
  % There is no restriction on the variables present in the replacement function.
  fsubst(s,
        (u: (ufun?)),
	(vars: (uniques?[nat]) | length(vars) = arity(u)),
	t):
    RECURSIVE term =
%TODO { r | V(r) ⊂ V(s) ∪ (V(t) \ vars) }
    CASES s OF
      v(i): s,
      apply(f, args):
        LET nargs = smap[{ t | t << s }, term]
	                (LAMBDA (r: term | r << s): fsubst(r, u, vars, t))(args) IN
	IF f = u
	  THEN parsubst(t, vars, nargs)
	  ELSE apply(f, nargs)
	ENDIF
    ENDCASES
  MEASURE s BY <<
END term
