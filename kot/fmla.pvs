fmla: THEORY
BEGIN
  IMPORTING term

  pred: DATATYPE
  BEGIN
    ipred(index, arity: nat): ipred?
    upred(index, arity: nat): upred?
  END pred

  % A first-order formula over terms
  fmla: DATATYPE
  BEGIN
    atom(pred: pred, args: { l: finseq[term] | l`length = arity(pred) }): atom?
    f_not(arg: fmla): f_not?
    f_or(larg, rarg: fmla): f_or?
    f_exists(bvar: nat, body: fmla): f_exists?
  END fmla

  s, t: VAR term
  ss, ts: VAR set[term]
  f, g: VAR fmla
  fs, gs: VAR set[fmla]
  i, n: VAR nat
  is, ns: VAR set[nat]
  li, ln: VAR list[nat]

  uf: VAR (ufun?)
  up: VAR (upred?)

  % Readable constructors
  ;¬(f): fmla    = f_not(f)
  ;∨(f, g): fmla = f_or(f, g)
  ;∧(f, g): fmla = ¬(¬f ∨ ¬g)
  ;⇒(f, g): fmla = ¬f ∨ ¬g
  ;⇔(f, g): fmla = (f ⇒ g) ∨ (g ⇒ f)
  ;◇(n)(f): fmla = f_exists(n, f)
  ;◇(ln)(f): RECURSIVE fmla =
    CASES ln OF
      null: f,
      cons(n, t): f_exists(n, (◇t)(f))
    ENDCASES
  MEASURE length(ln)
  ;□(n)(f): fmla  = ¬(◇n)(f)
  ;□(ln)(f): fmla = ¬(◇ln)(f)

  % Free variables of a formula
  % This is intended to be used in specifications only, and may not be executable.
  FV(f): RECURSIVE set[nat] =
    CASES f OF
      atom(p, args): V(args :: set[term]),
      f_not(g): FV(g),
      f_or(g, h): FV(g) ∪ FV(h),
      f_exists(n, b): FV(b) - n
    ENDCASES
  MEASURE f BY <<

  % A formula without free variables is a sentence
  sentence?(f): bool = empty?(FV(f))

  % Bound variables (i.e, variables bound by an ∃, whether they actually are used or not)
  BV(f): RECURSIVE set[nat] =
    CASES f OF
      atom(p, args): ∅,
      f_not(g): BV(g),
      f_or(g, h): BV(g) ∪ BV(h),
      f_exists(n, b): n ∪ BV(b)
    ENDCASES
  MEASURE f BY <<

  % The variables of a formula are both the free and bound variables
  V(f): set[nat] = FV(f) ∪ BV(f)

  % Checks whether the variables in ns are not bound in formula f
  freefor(f, ns): bool =
    empty?(ns ∩ BV(f)) % TODO: disjoint?(ns, BV(f))

  % A term or a formula is free w.r.t f if is variables are free
  freefor(f, t): MACRO bool =
    freefor(f, V(t))
  freefor(f, g): MACRO bool =
    freefor(f, V(g))

  % Uninterpreted Function Symbols of a formula
  UFS(f): RECURSIVE set[(ufun?)] =
    CASES f OF
      atom(p, args): UFS(args :: set[term]),
      f_not(g): UFS(g),
      f_or(g, h): UFS(g) ∪ UFS(h),
      f_exists(n, b): UFS(b)
    ENDCASES
  MEASURE f BY <<

  % Uninterpreted Predicate Symbols of a formula
  UPS(f): RECURSIVE set[(upred?)] =
    CASES f OF
      atom(p, args): { up | up = p },
      f_not(g): UPS(g),
      f_or(g, h): UPS(g) ∪ UPS(h),
      f_exists(n, b): UPS(b)
    ENDCASES
  MEASURE f BY <<

  % Parallel substitution of variables in a formula through a mapping
  % We can actually have more informations about the free variables of the
  % new formula
  parsubst(f: fmla, mapping: [n: nat -> { t | t = v(n) OR freefor(f, t) }]):
%TODO: { h | FV(h) ⊂ V(setmap(mapping))(FV(f)) AND
%            BV(h) = BV(f) }
    RECURSIVE fmla =
    CASES f OF
      atom(p, args): atom(p, smap(LAMBDA t: parsubst(t, mapping))(args)),
      f_not(g): f_not(parsubst(g, mapping)),
      f_or(g, h): f_or(parsubst(g, mapping), parsubst(h, mapping)),
      f_exists(n, b): f_exists(n, parsubst(b, mapping))
    ENDCASES
  MEASURE f BY <<

  % Parallel substitution with an association list
  parsubst(f: fmla,
           vars: list[nat],
	   (vals: finseq[{ t | freefor(f, t) }] | vals`length = length(vars))): fmla =
%TODO: { h | FV(h) ⊂ (FV(f) - vars) ∪ V(vals) AND
%            BV(h) = BV(f) }
    parsubst(f, LAMBDA i: assoc2[nat, { t | t = v(i) OR freefor(f, t) }](i, vars, vals, v(i)))

  % Single substitution can come in handy
  subst(f, n, (t | freefor(f, t))): fmla =
% TODO { h | FV(h) ⊂ (FV(f) - n) ∪ V(t) AND
%            BV(h) = BV(f) }
    parsubst(f, LAMBDA i: IF i = n THEN t ELSE v(i) ENDIF)

  % Substitutes an uninterpreted function symbol with a term
  fsubst(f,
         (u: (ufun?)),
	 (vars: (uniques?[nat]) | length(vars) = arity(u)),
	 (t | freefor(f, t))):
    RECURSIVE fmla =
%TODO { h | FV(h) ⊂ FV(f) ∪ (V(t) - vars) AND
%           BV(h) = BV(f) }
    CASES f OF
      atom(p, args): atom(p, smap(LAMBDA s: fsubst(s, u, vars, t))(args)),
      f_not(g): f_not(fsubst(g, u, vars, t)),
      f_or(g, h): f_or(fsubst(g, u, vars, t), fsubst(h, u, vars, t)),
      f_exists(n, b): f_exists(n, fsubst(b, u, vars, t))
    ENDCASES
  MEASURE f BY <<

  % Substitutes an unintepreted predicate symbol with  formula
  psubst(f,
         (u: (upred?)),
	 (vars: (uniques?[nat]) | length(vars) = arity(u)),
	 (g | FV(g) ⊂ vars AND freefor(f, g))):
    RECURSIVE fmla =
%TODO { h | FV(h) ⊂ FV(f) ∪ (FV(g) - vars) AND
%           BV(h) ⊂ BV(f) ∪ BV(g) }
    CASES f OF
      atom(p, args):
        IF p = u
	  THEN parsubst(g, vars, args)
	  ELSE f
	ENDIF,
      f_not(h): f_not(psubst(h, u, vars, g)),
      f_or(l, r): f_or(psubst(l, u, vars, g), psubst(r, u, vars, g)),
      f_exists(n, b): f_exists(n, psubst(b, u, vars, g))
    ENDCASES
  MEASURE f BY <<
END fmla

%   equal_subst_aux(s: term,
%                   (ss: list[[term, term]] | every(LAMBDA (r, t): r << s)(ss)),
% 		  mapping: [nat -> term],
%                   equal_subst: [r: { r | r << s}, t: term -> { b: bool | b = (t = parsubst(mapping)(r)) }]):
%     RECURSIVE { b: bool | b = every(LAMBDA (r, t): t = parsubst(mapping)(r))(ss) } =
%     CASES ss OF
%       null: TRUE,
%       cons(h, t):
%         equal_subst(h`1, h`2) AND equal_subst_aux(s, t, mapping, equal_subst)
%     ENDCASES
%   MEASURE length(ss)

%   equal_subst(s, t: term, mapping: [nat -> term]):
%     RECURSIVE { b: bool | b = (t = parsubst(mapping)(s)) } =
%     CASES s OF
%       v(i): mapping(i) = t,
%       apply(f, args):
%         CASES t OF
% 	  v(i): FALSE,
% 	  apply(g, args2):
% 	    f = g AND equal_subst_aux(s, zip(args, args(t)), mapping, LAMBDA (r | r << s), t: equal_subst(r, t, mapping))
% 	ENDCASES
%     ENDCASES
%   MEASURE s BY <<

% END fmla

% % % % Need to assert that t has no FV outside vars, and vars is a set.
% % % % If s is a function app with f=u, then substitute in t the variables vars 
% % % % with the call parameters in ss in witch we substitute recursively
% % % % (u ss1..ssN) -> [ss/vars]t (fsubst in each ss recursively)

% % % fmla_equal(A, B, (A_vars, B_vars: list[(var?)])): RECURSIVE bool =
% % %   CASES A OF
% % %     atom(p, ss): (atom?(B) AND pred(B) = p AND
% % %                   reduce2(TRUE,
% % % 		          LAMBDA s, t, (b:bool):
% % % 			    b AND term_equal(s, t, A_vars, B_vars),
% % % 			  ss, args(B))),
% % %     f_not(A1): (f_not?(B) AND fmla_equal(A1, arg(B), A_vars, B_vars)),
% % %     f_or(A1, A2): (f_or?(B) AND fmla_equal(A1, arg1(B), A_vars, B_vars) AND
% % %                    fmla_equal(A2, arg2(B), A_vars, B_vars)), 
% % %     f_exists(y, A1): (f_exists?(B) AND
% % %                      fmla_equal(A1, body(B),
% % % 		                cons(y, A_vars),
% % % 				cons(bvar(B), B_vars)))
% % %   ENDCASES
% % %   MEASURE A BY <<

% % %   sentence_list_cons:  LEMMA
% % %     FORALL (A, AA):
% % %     sentence?(A) & sentence_list?(AA) <=> sentence_list?(cons(A, AA))

% % %   sentence_list_append:  LEMMA
% % %     FORALL (AA, BB):
% % %     sentence_list?(AA) & sentence_list?(BB) <=>sentence_list?(append(AA, BB))

% % END fmla
