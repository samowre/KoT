% A symbol is a (interpreted or not) predicate or function
symbol: DATATYPE WITH SUBTYPES pred?, fun?
BEGIN
  ipred(index, arity: nat): ipred? : pred?
  upred(index, arity: nat): upred? : pred?
  ifun(index, arity: nat): ifun?   : fun?
  ufun(index, arity: nat): ufun?   : fun?
END symbol

% A term is either a variable, or the application of a function symbol to a list of arguments
term: DATATYPE
BEGIN
  IMPORTING symbol
  v(index: nat): var?
  apply(fun: (fun?), args: { l: finseq[term] | l`length = arity(fun) }): apply?
END term

% A first-order formula over terms
fmla: DATATYPE
BEGIN
  IMPORTING term
  atom(pred: (pred?), args: { l: finseq[term] | l`length = arity(pred) }): atom?
  f_not(arg: fmla): f_not?
  f_or(larg, rarg: fmla): f_or?
  f_exists(bvar: nat, body: fmla): f_exists?
END fmla

term_props: THEORY
BEGIN
  lists: LIBRARY "../lists"
  IMPORTING term
  IMPORTING lists@more_list_props
  IMPORTING lists@list2_props
  IMPORTING more_finseq_props
  IMPORTING assoc2, smap, setmap
  IMPORTING set_props
  CONVERSION- singleton_elt

  s, t: VAR term
  ss, ts: VAR set[term]
  i, n: VAR nat
  is, ns: VAR set[nat]
  uf: VAR (ufun?)

  % Computes the set of variables present in a term.
  % This is intended to be used in specifications only, and may not be executable.
  V(t): RECURSIVE set[nat] =
    CASES t OF
      v(n): singleton(n),
      apply(f, args): V(args :: set[term])
    ENDCASES
  MEASURE t BY <<

  vars_subterm: THEOREM n ∈ V(t) IFF subterm(v(n), t)
  
  % vars only increases
  vars_increases: THEOREM
    t << s IMPLIES V(t) ⊂ V(s)

  % Uninterpreted Function Symbols of a term
  UFS(t): RECURSIVE set[(ufun?)] =
    CASES t OF
      v(n): ∅,
      apply(f, args): { uf | uf = f OR uf ∈ UFS(args :: set[term]) }
    ENDCASES
  MEASURE t BY <<

  % Rename variables
  % TODO: injection, equivalence
  alpha(s: term, rename: [nat -> nat]): RECURSIVE term =
    CASES s OF
      v(i): v(rename(i)),
      apply(f, args): apply(f, smap[{ t | t << s}, term]
                                   (LAMBDA (t | t << s): alpha(t, rename))(args))
    ENDCASES
  MEASURE s BY <<

  % The new variables is the renaming of the old ones
  alpha_vars: RECURSIVE JUDGEMENT
    alpha(s: term, rename: [nat -> nat]) HAS_TYPE { t | V(t) = rename(V(s)) }

  % Parallel substitution in a term using a mapping function from variables to terms.
  parsubst(s: term, mapping: [nat -> term]): RECURSIVE term =
    CASES s OF
      v(i): mapping(i),
      apply(f, args): apply(f, smap[{t | t << s }, term]
                                   (LAMBDA (t | t << s): parsubst(t, mapping))(args))
    ENDCASES
  MEASURE s BY <<

  % Information about the new set of variables as a recursive judgement
  parsubst_map_vars: RECURSIVE JUDGEMENT
    parsubst(s: term, mapping: [nat -> term]) HAS_TYPE { t | V(t) ⊂ V(mapping(V(s))) }

  % Paralel substitution, with association lists
  % Again, we can know a superset of the new variables
  parsubst(s: term, vars: list[nat], (vals: finseq[term] | vals`length = length(vars))):
    term =
%    { r: term | V(r) ⊂ (V(s) - vars) ∪ V(vals :: set[term]) } =
%TODO    { r | V(r) ⊂ (V(s) \ vars) ∪ V(vals) }
    parsubst(s, LAMBDA i: assoc2[nat, term](i, vars, vals, v(i)))

%  parsubst_vars: JUDGEMENT
%    parsubst(s: term, vars: list[nat], (vals: finseq[term] | vals`length = length(vars)))
%      HAS_TYPE { r: term | V(r) ⊂ (V(s) - vars) ∪ V(vals :: set[term]) }

  % Single substitution is actually a parallel substitution
  % We know a superset of the new variables
  subst(s, n, t): term =
%TODO    { r | V(r) ⊂ (V(s) \ n) ∪ V(t) }
    parsubst(s, LAMBDA i: IF i = n THEN t ELSE v(i) ENDIF)

  % Interprets an uninterpreted function by a body.
  % There is no restriction on the variables present in the replacement function.
  fsubst(s,
        (u: (ufun?)),
	(vars: (uniques?[nat]) | length(vars) = arity(u)),
	t):
    RECURSIVE term =
%TODO { r | V(r) ⊂ V(s) ∪ (V(t) \ vars) }
    CASES s OF
      v(i): s,
      apply(f, args):
        LET nargs = smap[{ t | t << s }, term]
	                (LAMBDA (r: term | r << s): fsubst(r, u, vars, t))(args) IN
	IF f = u
	  THEN parsubst(t, vars, nargs)
	  ELSE apply(f, nargs)
	ENDIF
    ENDCASES
  MEASURE s BY <<
END term_props

fmla_props: THEORY
BEGIN
  IMPORTING term
  IMPORTING fmla
  IMPORTING term_props

  s, t: VAR term
  ss, ts: VAR set[term]
  f, g: VAR fmla
  fs, gs: VAR set[fmla]
  i, n: VAR nat
  is, ns: VAR set[nat]
  li, ln: VAR list[nat]

  uf: VAR (ufun?)
  up: VAR (upred?)

  % Readable constructors
  ;¬(f): fmla    = f_not(f)
  ;∨(f, g): fmla = f_or(f, g)
  ;∧(f, g): fmla = ¬(¬f ∨ ¬g)
  ;⇒(f, g): fmla = ¬f ∨ ¬g
  ;⇔(f, g): fmla = (f ⇒ g) ∨ (g ⇒ f)
  ;◇(n)(f): fmla = f_exists(n, f)
  ;◇(ln)(f): RECURSIVE fmla =
    CASES ln OF
      null: f,
      cons(n, t): f_exists(n, (◇t)(f))
    ENDCASES
  MEASURE length(ln)
  ;□(n)(f): fmla  = ¬(◇n)(f)
  ;□(ln)(f): fmla = ¬(◇ln)(f)

  % Free variables of a formula
  % This is intended to be used in specifications only, and may not be executable.
  FV(f): RECURSIVE set[nat] =
    CASES f OF
      atom(p, args): V(args :: set[term]),
      f_not(g): FV(g),
      f_or(g, h): FV(g) ∪ FV(h),
      f_exists(n, b): FV(b) - n
    ENDCASES
  MEASURE f BY <<

  % A formula without free variables is a sentence
  sentence?(f): bool = empty?(FV(f))

  % Bound variables (i.e, variables bound by an ∃, whether they actually are used or not)
  BV(f): RECURSIVE set[nat] =
    CASES f OF
      atom(p, args): ∅,
      f_not(g): BV(g),
      f_or(g, h): BV(g) ∪ BV(h),
      f_exists(n, b): n ∪ BV(b)
    ENDCASES
  MEASURE f BY <<

  % The variables of a formula are both the free and bound variables
  V(f): set[nat] = FV(f) ∪ BV(f)

  % Checks whether the variables in ns are not bound in formula f
  freefor(f, ns): bool =
    empty?(ns ∩ BV(f)) % TODO: disjoint?(ns, BV(f))

  % A term or a formula is free w.r.t f if is variables are free
  freefor(f, t): MACRO bool =
    freefor(f, V(t))
  freefor(f, g): MACRO bool =
    freefor(f, V(g))

  % Uninterpreted Function Symbols of a formula
  UFS(f): RECURSIVE set[(ufun?)] =
    CASES f OF
      atom(p, args): UFS(args :: set[term]),
      f_not(g): UFS(g),
      f_or(g, h): UFS(g) ∪ UFS(h),
      f_exists(n, b): UFS(b)
    ENDCASES
  MEASURE f BY <<

  % Uninterpreted Predicate Symbols of a formula
  UPS(f): RECURSIVE set[(upred?)] =
    CASES f OF
      atom(p, args): { up | up = p },
      f_not(g): UPS(g),
      f_or(g, h): UPS(g) ∪ UPS(h),
      f_exists(n, b): UPS(b)
    ENDCASES
  MEASURE f BY <<

  % Parallel substitution of variables in a formula through a mapping
  % We can actually have more informations about the free variables of the
  % new formula
  parsubst(f: fmla, mapping: [n: nat -> { t | t = v(n) OR freefor(f, t) }]):
%TODO: { h | FV(h) ⊂ V(setmap(mapping))(FV(f)) AND
%            BV(h) = BV(f) }
    RECURSIVE fmla =
    CASES f OF
      atom(p, args): atom(p, smap(LAMBDA t: parsubst(t, mapping))(args)),
      f_not(g): f_not(parsubst(g, mapping)),
      f_or(g, h): f_or(parsubst(g, mapping), parsubst(h, mapping)),
      f_exists(n, b): f_exists(n, parsubst(b, mapping))
    ENDCASES
  MEASURE f BY <<

  % Parallel substitution with an association list
  parsubst(f: fmla,
           vars: list[nat],
	   (vals: finseq[{ t | freefor(f, t) }] | vals`length = length(vars))): fmla =
%TODO: { h | FV(h) ⊂ (FV(f) - vars) ∪ V(vals) AND
%            BV(h) = BV(f) }
    parsubst(f, LAMBDA i: assoc2[nat, { t | t = v(i) OR freefor(f, t) }](i, vars, vals, v(i)))

  % Single substitution can come in handy
  subst(f, n, (t | freefor(f, t))): fmla =
% TODO { h | FV(h) ⊂ (FV(f) - n) ∪ V(t) AND
%            BV(h) = BV(f) }
    parsubst(f, LAMBDA i: IF i = n THEN t ELSE v(i) ENDIF)

  % Substitutes an uninterpreted function symbol with a term
  fsubst(f,
         (u: (ufun?)),
	 (vars: (uniques?[nat]) | length(vars) = arity(u)),
	 (t | freefor(f, t))):
    RECURSIVE fmla =
%TODO { h | FV(h) ⊂ FV(f) ∪ (V(t) - vars) AND
%           BV(h) = BV(f) }
    CASES f OF
      atom(p, args): atom(p, smap(LAMBDA s: fsubst(s, u, vars, t))(args)),
      f_not(g): f_not(fsubst(g, u, vars, t)),
      f_or(g, h): f_or(fsubst(g, u, vars, t), fsubst(h, u, vars, t)),
      f_exists(n, b): f_exists(n, fsubst(b, u, vars, t))
    ENDCASES
  MEASURE f BY <<

  % Substitutes an unintepreted predicate symbol with  formula
  psubst(f,
         (u: (upred?)),
	 (vars: (uniques?[nat]) | length(vars) = arity(u)),
	 (g | FV(g) ⊂ vars AND freefor(f, g))):
    RECURSIVE fmla =
%TODO { h | FV(h) ⊂ FV(f) ∪ (FV(g) - vars) AND
%           BV(h) ⊂ BV(f) ∪ BV(g) }
    CASES f OF
      atom(p, args):
        IF p = u
	  THEN parsubst(g, vars, args)
	  ELSE f
	ENDIF,
      f_not(h): f_not(psubst(h, u, vars, g)),
      f_or(l, r): f_or(psubst(l, u, vars, g), psubst(r, u, vars, g)),
      f_exists(n, b): f_exists(n, psubst(b, u, vars, g))
    ENDCASES
  MEASURE f BY <<
END fmla_props

%   equal_subst_aux(s: term,
%                   (ss: list[[term, term]] | every(LAMBDA (r, t): r << s)(ss)),
% 		  mapping: [nat -> term],
%                   equal_subst: [r: { r | r << s}, t: term -> { b: bool | b = (t = parsubst(mapping)(r)) }]):
%     RECURSIVE { b: bool | b = every(LAMBDA (r, t): t = parsubst(mapping)(r))(ss) } =
%     CASES ss OF
%       null: TRUE,
%       cons(h, t):
%         equal_subst(h`1, h`2) AND equal_subst_aux(s, t, mapping, equal_subst)
%     ENDCASES
%   MEASURE length(ss)

%   equal_subst(s, t: term, mapping: [nat -> term]):
%     RECURSIVE { b: bool | b = (t = parsubst(mapping)(s)) } =
%     CASES s OF
%       v(i): mapping(i) = t,
%       apply(f, args):
%         CASES t OF
% 	  v(i): FALSE,
% 	  apply(g, args2):
% 	    f = g AND equal_subst_aux(s, zip(args, args(t)), mapping, LAMBDA (r | r << s), t: equal_subst(r, t, mapping))
% 	ENDCASES
%     ENDCASES
%   MEASURE s BY <<

% END fmla

% % % % Need to assert that t has no FV outside vars, and vars is a set.
% % % % If s is a function app with f=u, then substitute in t the variables vars 
% % % % with the call parameters in ss in witch we substitute recursively
% % % % (u ss1..ssN) -> [ss/vars]t (fsubst in each ss recursively)

% % % fmla_equal(A, B, (A_vars, B_vars: list[(var?)])): RECURSIVE bool =
% % %   CASES A OF
% % %     atom(p, ss): (atom?(B) AND pred(B) = p AND
% % %                   reduce2(TRUE,
% % % 		          LAMBDA s, t, (b:bool):
% % % 			    b AND term_equal(s, t, A_vars, B_vars),
% % % 			  ss, args(B))),
% % %     f_not(A1): (f_not?(B) AND fmla_equal(A1, arg(B), A_vars, B_vars)),
% % %     f_or(A1, A2): (f_or?(B) AND fmla_equal(A1, arg1(B), A_vars, B_vars) AND
% % %                    fmla_equal(A2, arg2(B), A_vars, B_vars)), 
% % %     f_exists(y, A1): (f_exists?(B) AND
% % %                      fmla_equal(A1, body(B),
% % % 		                cons(y, A_vars),
% % % 				cons(bvar(B), B_vars)))
% % %   ENDCASES
% % %   MEASURE A BY <<

% % %   sentence_list_cons:  LEMMA
% % %     FORALL (A, AA):
% % %     sentence?(A) & sentence_list?(AA) <=> sentence_list?(cons(A, AA))

% % %   sentence_list_append:  LEMMA
% % %     FORALL (AA, BB):
% % %     sentence_list?(AA) & sentence_list?(BB) <=>sentence_list?(append(AA, BB))

% % END fmla
