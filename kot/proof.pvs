proof	: THEORY

%A proof is an array where each element is a semi-proof of a sequent, i.e., 
%a proof from other sequents.  A semi-proof consists of an array consisting of
%a sequent and proof rule.  The sequent must follow from prior sequents
%by the proof rules.  Some of the sequents in a semi-proof can be lemmas
%in which case, they are linked to semi-proofs in the larger proof.  Thus
%a proof is 2-dimensional.  The reason is so that we try to keep proofs
%parametric with respect to proofs of lemmas.

  BEGIN

  proof: DATATYPE
    % ———————————— (Ax)
    %  ⊢ A, ¬A, Γ
    ax(A: sentence, conc: sequent): ax?
    %  ⊢ A, Γ    ⊢ ¬A, Σ
    % ——————————————————— (Cut)
    %        ⊢ Γ, Σ
    cut(A: sentence, H1: proof, H2: proof): cut?
    %    ⊢ A, Γ                  ⊢ B, Γ
    % ————————————— (⋁R₁)   ————————————— (⋁R₂)
    %  ⊢ A ∨ B, Γ             ⊢ A ∨ B, Γ
    orr(A: sentence, B: sentence, H: proof): orr?
    %  ⊢ ¬A, Γ      ⊢ ¬B, Σ
    % —————————————————————— (⋁L)
    %     ⊢ ¬(A ∨ B), Γ, Σ
    orl(A: sentence, B: sentence, H1: proof, H2: proof): orl?
    %     ⊢ A, Γ
    % ——————————— (¬)
    %  ⊢ ¬¬A, Γ
    neg(A: sentence, H: proof): negr?
    %  ⊢ A[t/x], Γ
    % ————————————— (∃R)
    %   ⊢ ∃x.A, Γ
    existsr(t: term, x: nat, (A: fmla | FV(A) ⊂ singleton(x) ), H: proof): existsr?
    %  ⊢ A[y/x], Γ
    % ————————————— (∀R)
    %   ⊢ ∀x.A, Γ
    forallr(y: skolem, x: nat, (A: fmla | FV(A) ⊂ singleton(x)), H: proof): forallr?
    %      ⊢ Γ
    % —————————————— (Fλ)
    %  ⊢ Γ[λvs.t/f]
    fschema(f: ufun, (vs: list[nat] | length(vs) = arity(f)),
            (t: term | V(t) ⊂ vs), H: proof): fschema?
    %       ⊢ Γ
    % —————————————— (Pλ)
    %  ⊢ Γ[λvs.A/p]
    ∀x. p(x) ⊢ ∃x. p(x)
    pschema(p: upred, (vs: list[nat] | length(vs) = arity(p)),
            (A: fmla | FV(A) ⊂ vs), H: proof): pschema?
    % ———————— (Refl)
    % ⊢ t = t
    refl(t: term, conc: sequent): refl?
    % ————————————————————————————————————————————————————————— (F₌)
    % ⊢ x₁ ≠ y₁, ..., xₙ ≠ yₙ, f(x₁, ..., xₙ) = f(y₁, ..., yₙ)
    fcongruence(f: fun, xs: finseq[skolem], (ys: finseq[skolem] | ys`length = xs`length)):
      fcongruence?
    % ————————————————————————————————————————————————————————— (P₌)
    % ⊢ x₁ ≠ y₁, ..., xₙ ≠ yₙ, p(x₁, ..., xₙ), ¬p(y₁, ..., yₙ)
    pcongruence(p: pred, xs: finseq[skolem], (ys: finseq[skolem] | ys`length = xs`length)):
      pcongruence?
    % ————— (Lemma)     Using this rule requires it to be conditional to a proof
    %  ⊢ Σ              of the lemma ⊢ Σ.
    lemma_(lem: sequent, conc: sequent): lemma?
  END proof

  CONVERSION+ conc

  % sequent = set[sentence]
  〈〉(x: sentence, y: sentence): sequent = x ∪ y

  ↝(lemmas: set[sequent], Π: proof): RECURSIVE bool =
    CASES Π OF
      ax(A, Γ): 〈 A, ¬A 〉 ⊂ Γ,
      cut(A, H1, H2, Γ):
	       A ∈ H1 AND (¬A) ∈ H2
	AND %——————————————————————————%
	    〈 (H1 - A), (H2 - ¬A) 〉 ⊂ Γ
        AND lemmas ↝ H1 AND lemmas ↝ H2
      orr(A, B, H, Γ):
            (A ∈ H OR B ∈ H)
	AND %————————————————%
	        (A ∨ B) ∈ Γ
	AND lemmas ↝ H,
      orl(A, B, H1, H2, Γ):
             (¬A) ∈ H1 AND (¬B) ∈ H2
	AND %——————————————————————————%
	            ¬(A ∨ B) ∈ Γ
	AND lemmas ↝ H1 AND lemmas ↝ H2,
      neg(A, H, Γ):
              A ∈ H
	AND %—————————%
             (¬¬A) ∈ Γ
	AND lemmas ↝ H,
      existsr(t, x, A, H, Γ):
             A(x ← t) ∈ H
        AND %—————————————%
	      (◇x)(A) ∈ Γ
        AND lemmas ↝ H,
      forallr(y, x, A, H, Γ):
             A(x ← y) ∈ H
	AND %—————————————%
	      (□x)(A) ∈ Γ
	AND sk(y) ∉ Γ AND lemmas ↝ H,
      fschema(f, vs, t, H, Γ):
        subst(H, f, vs, t) ⊂ Γ
	AND lemmas ↝ H
      pschema(p, vs, A, H):
        subst(H, p, vs, A) ⊂ Γ
	AND lemmas ↝ H
      refl(t: term, Γ):
        (t ≐ t) ∈ Γ,
      fcongruence(f, xs, ys, Γ):
        every2(LAMBDA (x, y: skolem): (¬(x ≐ y)) ∈ Γ, xs, ys) AND
	(apply(f, xs) ≐ apply(f, ys)) ∈ Γ
      pcongruence(p, xs, ys, Γ):
        every2(LAMBDA (x, y: skolem): (¬(x ≐ y)) ∈ Γ, xs, ys) AND
	atom(p, xs) ∈ Γ AND
	(¬atom(p, xs)) ∈ Γ
      lemma_(Σ, Γ):
        Σ ∈ lemmas AND Σ ⊂ Γ
    ENDCASES
  MEASURE p BY <<

  ↝(lemmas: set[sequent], seqs: list[proof]): RECURSIVE bool =
    CASES seqs OF
      null: TRUE,
      cons(Π, tl): lemmas ↝ Π AND (lemmas ∪ Π) ↝ tl
    ENDCASES
  MEASURE length(seqs)

  consequence?(lemmas: set[sequent])(Γ: sequent): bool =
    EXISTS (p: proof | lemmas ↝ p): Γ = conc(p)

  theorem?(Γ: sequent): bool = consequence?(∅)(Γ)

  %for fmla type
  importing fmla
  % added with subtypes...
  rule: DATATYPE WITH SUBTYPES no_premise?, one_premise?, two_premise? 
  BEGIN
   ax: ax?	: no_premise?
   subset: subsetr? : one_premise?
   orr: orr?	: one_premise?
   norr : norr?	: two_premise?
   neg : neg? 	: one_premise?
   cut(cut_fmla: fmla) : cut?		: two_premise?
   existsr(witness: term): existsr?	: one_premise?
   allr(skoconst: (ufun?)): allr? 	: one_premise?
   fschema(fun: (ufun?), vars: list[(var?)], body: term): fscheme?  : one_premise?
   pschema(fun: (upred?), vars: list[(var?)], body: fmla): pscheme? : one_premise?
   reflex: reflex? 	  	        : no_premise?
   % renamed to lemma_
   lemma_(index: nat) : lemma?		: no_premise?
  END rule

  %for sequent type
  importing sequents

  proof_step : TYPE
   = [# sequent: sequent,
        rule: rule,
	subs: list[nat] #]
  
  %replaced finite_seq with finseq
  proof_seq: TYPE =  finseq[proof_step]

  R, S: VAR proof_step
  RR, SS: VAR proof_seq

  ne_proof_seq: TYPE = {RR | RR`length > 0}

  nRR, nSS: VAR ne_proof_seq
  
  %deleted :nRR
  %added `sequent at the end
  conclusion(nRR): sequent =
    (nRR`seq(nRR`length - 1))`sequent
  
  checkProof(lemmas: finseq[sequent])(RR): bool =
    (FORALL (i: below(RR`length)):
     % checks if rule has enough parameters
     (LET R = RR`seq(i) IN
      (one_premise?(R`rule) OR two_premise?(R`rule)
       => (cons?(R`subs) AND car(R`subs) < i)) AND
      (two_premise?(R`rule) => (cons?(cdr(R`subs)) AND
				car(cdr(R`subs)) < i )) AND
      (CASES R`rule OF
       ax : ax_rule?(R`sequent),
       subset: subset_rule?(RR`seq(car(R`subs))`sequent ,R`sequent),
       %replaced R`sequence with RR.seq
       orr : or_rule?(RR`seq(car(R`subs))`sequent, R`sequent),
       norr: nor_rule?(RR`seq(car(R`subs))`sequent,
	               RR`seq(car(cdr(R`subs)))`sequent,
	               R`sequent),
       neg : neg_rule?(RR`seq(car(R`subs))`sequent, R`sequent),
       cut(A): cut_rule?(A, RR`seq(car(R`subs))`sequent,
                            RR`seq(car(cdr(R`subs)))`sequent,
			    R`sequent),
       existsr(u):
         exists_rule?(u, RR`seq(car(R`subs))`sequent, R`sequent),
       allr(f): forall_rule?(f, RR`seq(car(R`subs))`sequent, R`sequent),
       fschema(u, vars, s): fschema_rule?(u, vars, s, RR`seq(car(R`subs))`sequent, R`sequent),
       pschema(p, vars, A): pschema_rule?(p, vars, A, RR`seq(car(R`subs))`sequent, R`sequent),
       reflex: reflex_rule?(R`sequent),
       lemma_(i): (i < lemmas`length AND
                  R`sequent = lemmas(i))
      ENDCASES)))


    proof: DATATYPE
     BEGIN
       compose(lemma_proofs : finseq[ne_proof_seq], 
               main : (checkProof(map(conclusion)(lemma_proofs)))): compose?
     END proof
  
%Each proof_entry can be independently checked.  We can then
%compose these into a proof whe0re we associate proofs with
%the lemmas.  Since we are not actually interested in running
%the proof checker, we can live with tree-like proofs.
%The lemmas include function and predicate definitions.
%A whole proof is then relative to these definitions.
%A predicate definition is given as p(x, y, z) <-> A, whereas a
%function definition has the form (all x: exists! y: A(x, y)) => A(x, f(x)).

		  

  					  

  					  
  

  END proof
