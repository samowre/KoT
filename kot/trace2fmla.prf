(trace2fmla (translate_lit_TCC1 0 (translate_lit_TCC1-1 nil 3482187575 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (m formal-const-decl "nat" trace2fmla nil) (n formal-const-decl "nat" trace2fmla nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (i formal-const-decl "upto(n)" trace2fmla nil) (tr_literal? const-decl "bool" trace_resolution nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (translate_lit_TCC2 0 (translate_lit_TCC2-1 nil 3482187575 ("" (subtype-tcc) (("" (grind) nil nil)) nil) ((pred? adt-def-decl "boolean" funpred_adt nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (m formal-const-decl "nat" trace2fmla nil) (n formal-const-decl "nat" trace2fmla nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (i formal-const-decl "upto(n)" trace2fmla nil) (tr_literal? const-decl "bool" trace_resolution nil)) nil)) (translate_lit_TCC3 0 (translate_lit_TCC3-1 nil 3482187575 ("" (subtype-tcc) (("" (grind) nil nil)) nil) ((length def-decl "nat" list_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (m formal-const-decl "nat" trace2fmla nil) (n formal-const-decl "nat" trace2fmla nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (i formal-const-decl "upto(n)" trace2fmla nil) (tr_literal? const-decl "bool" trace_resolution nil)) nil)) (translate_lit_TCC4 0 (translate_lit_TCC4-1 nil 3482187575 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (m formal-const-decl "nat" trace2fmla nil) (n formal-const-decl "nat" trace2fmla nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (i formal-const-decl "upto(n)" trace2fmla nil) (tr_literal? const-decl "bool" trace_resolution nil) (prop_atom? const-decl "bool" resolution nil) (literal? const-decl "bool" resolution nil)) nil)) (translate_lit_TCC5 0 (translate_lit_TCC5-1 nil 3482187575 ("" (subtype-tcc) (("" (grind) nil nil)) nil) ((pred? adt-def-decl "boolean" funpred_adt nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (m formal-const-decl "nat" trace2fmla nil) (n formal-const-decl "nat" trace2fmla nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (i formal-const-decl "upto(n)" trace2fmla nil) (tr_literal? const-decl "bool" trace_resolution nil)) nil)) (translate_lit_TCC6 0 (translate_lit_TCC6-1 nil 3482187575 ("" (subtype-tcc) (("" (grind) nil nil)) nil) ((length def-decl "nat" list_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (m formal-const-decl "nat" trace2fmla nil) (n formal-const-decl "nat" trace2fmla nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (i formal-const-decl "upto(n)" trace2fmla nil) (tr_literal? const-decl "bool" trace_resolution nil)) nil)) (translate_lit_TCC7 0 (translate_lit_TCC7-1 nil 3482187575 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (m formal-const-decl "nat" trace2fmla nil) (n formal-const-decl "nat" trace2fmla nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (i formal-const-decl "upto(n)" trace2fmla nil) (tr_literal? const-decl "bool" trace_resolution nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (prop_atom? const-decl "bool" resolution nil) (literal? const-decl "bool" resolution nil)) nil)) (index_index 0 (index_index-1 nil 3482187759 ("" (grind) nil nil) ((mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (nzint nonempty-type-eq-decl nil integers nil) (tr_literal? const-decl "bool" trace_resolution nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (translate_lit const-decl "(literal?)" trace2fmla nil) (prop_atom? const-decl "bool" resolution nil) (index const-decl "posnat" resolution nil) (i formal-const-decl "upto(n)" trace2fmla nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (n formal-const-decl "nat" trace2fmla nil) (m formal-const-decl "nat" trace2fmla nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (index const-decl "posnat" trace_resolution nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak)) (translate_lit_equiv 0 (translate_lit_equiv-2 "" 3542729155 ("" (skosimp) (("" (split) (("1" (flatten) (("1" (expand translate_lit) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (case "FORALL (k, l: (atom?)): k = l => index(pred(k)) = index(pred(l)) ") (("1" (inst -1 "atom(upred(k!1, 0), null)" "atom(upred(l!1, 0), null)") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (grind) (("2" (case "FORALL (k, l: (atom?)): f_not(k) = f_not(l) => index(pred(k)) = index(pred(l)) ") (("1" (inst -1 "atom(upred(-k!1, 0), null)" "atom(upred(-l!1, 0), null)") (("1" (grind) nil nil)) nil) ("2" (grind) (("2" (grind) (("2" (case "FORALL (k, l: (f_not?)): atom?(arg(k)) AND atom?(arg(l)) AND k = l => index(pred(arg(k))) = index(pred(arg(l)))") (("1" (inst -1 "f_not(k!2)" "f_not(l!2)") (("1" (grind) nil nil)) nil) ("2" (skosimp) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) nil shostak) (translate_lit_equiv-1 nil 3483132565 ("" (skosimp) (("" (split) (("1" (flatten) (("1" (expand translate_lit) (("1" (lift-if) (("1" (split) (("1" (lift-if) (("1" (split) (("1" (flatten) (("1" (case "FORALL (k, l: (atom?)): k = l => index(pred(k)) = index(pred(l)) ") (("1" (inst -1 "atom(upred(k!1, 0), null)" "atom(upred(l!1, 0), null)") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (grind) (("2" (case "FORALL (k, l: (atom?)): f_not(k) = f_not(l) => index(pred(k)) = index(pred(l)) ") (("1" (inst -1 "atom(upred(-k!1, 0), null)" "atom(upred(-l!1, 0), null)") (("1" (grind) nil nil)) nil) ("2" (grind) (("2" (grind) (("2" (case "FORALL (k, l: (f_not?)): atom?(arg(k)) AND atom?(arg(l)) AND k = l => index(pred(arg(k))) = index(pred(arg(l)))") (("1" (inst -1 "f_not(k!2)" "f_not(l!2)") (("1" (grind) nil nil)) nil) ("2" (skosimp) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ((translate_lit const-decl "(literal?)" trace2fmla nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (nzint nonempty-type-eq-decl nil integers nil) (m formal-const-decl "nat" trace2fmla nil) (n formal-const-decl "nat" trace2fmla nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (i formal-const-decl "upto(n)" trace2fmla nil) (tr_literal? const-decl "bool" trace_resolution nil) (k!1 skolem-const-decl "(tr_literal?)" trace2fmla nil) (l!1 skolem-const-decl "(tr_literal?)" trace2fmla nil) (term type-decl nil fmla nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (arity shared-adt-accessor-decl "[funpred -> nat]" funpred_adt nil) (atom adt-constructor-decl "[[pred: (pred?), {ss: list[term] | length(ss) = arity(pred)}] -> (atom?)]" fmla nil) (upred? adt-recognizer-decl "[funpred -> boolean]" funpred_adt nil) (upred adt-constructor-decl "[[nat, nat] -> (upred?)]" funpred_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (fmla type-decl nil fmla nil) (boolean nonempty-type-decl nil booleans nil) (atom? adt-recognizer-decl "[fmla -> boolean]" fmla nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (funpred type-decl nil funpred_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (index shared-adt-accessor-decl "[funpred -> nat]" funpred_adt nil) (pred? adt-def-decl "boolean" funpred_adt nil) (pred adt-accessor-decl "[(atom?) -> (pred?)]" fmla nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (arg adt-accessor-decl "[(f_not?) -> fmla]" fmla nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (f_not? adt-recognizer-decl "[fmla -> boolean]" fmla nil) (f_not adt-constructor-decl "[fmla -> (f_not?)]" fmla nil)) shostak)) (translate_clause_TCC1 0 (translate_clause_TCC1-1 nil 3482245688 ("" (induct cl) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skolem-typepred) (("3" (flatten) (("3" (lemma tr_clause_prop) (("3" (inst -1 "cons(cons1_var!1, cons2_var!1)") (("3" (flatten) (("3" (hide -2) (("3" (replace -5) (("3" (split -1) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (flatten) (("3" (assert) (("3" (hide -4) (("3" (lemma clause_prop) (("3" (expand map 2) (("3" (inst -1 "cons(translate_lit(cons1_var!1),
                   map(translate_lit)(cons2_var!1))") (("3" (flatten) (("3" (hide -1) (("3" (assert) (("3" (lemma index_index) (("3" (lemma index_index) (("3" (inst -1 cons1_var!1) (("3" (inst -2 "car(cons2_var!1)") (("3" (replace -1) (("3" (expand map 1 2) (("3" (lift-if) (("3" (split 1) (("1" (grind) nil nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (tr_clause_prop formula-decl nil trace_resolution nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (prop_atom? const-decl "bool" resolution nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (index_index formula-decl nil trace2fmla nil) (clause_prop formula-decl nil resolution nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (index const-decl "posnat" resolution nil) (sorted? def-decl "bool" sortedlist nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (index const-decl "posnat" trace_resolution nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (nzint nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (m formal-const-decl "nat" trace2fmla nil) (n formal-const-decl "nat" trace2fmla nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (i formal-const-decl "upto(n)" trace2fmla nil) (tr_literal? const-decl "bool" trace_resolution nil) (translate_lit const-decl "(literal?)" trace2fmla nil) (map adt-def-decl "list[T1]" list_adt_map nil) (clause? const-decl "bool" resolution nil) (literal? const-decl "bool" resolution nil) (fmla type-decl nil fmla nil) (tr_clause? const-decl "bool" trace_resolution nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil)) nil)) (clause_clause 0 (clause_clause-2 "" 3542729866 ("" (induct cl) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skolem-typepred) (("3" (flatten) (("3" (skolem-typepred) (("3" (split 2) (("1" (expand member 1 1) (("1" (flatten) (("1" (split -1) (("1" (grind) nil nil) ("2" (expand translate_clause 1 1) (("2" (expand map 1 1) (("2" (expand member 1 1) (("2" (lemma tr_clause_prop) (("2" (inst -1 "cons(cons1_var!1, cons2_var!1)") (("2" (flatten) (("2" (hide -2) (("2" (replace -7 -1) (("2" (split -1) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (flatten) (("3" (assert) (("3" (hide -6) (("3" (inst -6 k!1) (("3" (flatten) (("3" (hide -7) (("3" (replace -3) (("3" (expand translate_clause -6) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4) (("2" (expand translate_clause 1) (("2" (expand map 1) (("2" (expand member 1) (("2" (flatten) (("2" (split -1) (("1" (expand translate_lit -1) (("1" (lift-if -1) (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (assert) (("1" (case "pred(atom(upred(k!1, 0), null)) = pred(atom(upred(cons1_var!1, 0), null))") (("1" (assert) (("1" (case "index(upred(k!1, 0)) = index(upred(cons1_var!1, 0))") (("1" (assert) nil nil) ("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (replace -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma tr_clause_prop) (("2" (inst -1 "cons(cons1_var!1, cons2_var!1)") (("2" (flatten) (("2" (hide -2) (("2" (replace -7) (("2" (split -1) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (case "arg(f_not(atom(upred(abs(k!1), 0), null))) = arg(f_not(atom(upred(abs(cons1_var!1), 0), null)))") (("1" (assert) (("1" (case "pred(atom(upred(abs(k!1), 0), null)) = pred(atom(upred(abs(cons1_var!1), 0), null))") (("1" (assert) (("1" (case "index(upred(abs(k!1), 0)) = index(upred(abs(cons1_var!1), 0))") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma tr_clause_prop) (("2" (inst -1 "cons(cons1_var!1, cons2_var!1)") (("2" (flatten) (("2" (hide -2) (("2" (replace -6) (("2" (split -1) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (flatten) (("3" (assert) (("3" (inst -6 k!1) (("3" (flatten) (("3" (hide -6) (("3" (expand translate_clause -6) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (clause_clause-1 nil 3482677228 ("" (induct cl) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skolem-typepred) (("3" (flatten) (("3" (skolem-typepred) (("3" (split 2) (("1" (expand member 1 1) (("1" (flatten) (("1" (split -1) (("1" (grind) nil nil) ("2" (expand translate_clause 1 1) (("2" (expand map 1 1) (("2" (expand member 1 1) (("2" (lemma tr_clause_prop) (("2" (inst -1 "cons(cons1_var!1, cons2_var!1)") (("2" (flatten) (("2" (hide -2) (("2" (replace -7 -1) (("2" (split -1) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (flatten) (("3" (assert) (("3" (hide -6) (("3" (inst -6 k!1) (("3" (flatten) (("3" (hide -7) (("3" (replace -3) (("3" (expand translate_clause -6) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4) (("2" (expand translate_clause 1) (("2" (expand map 1) (("2" (expand member 1) (("2" (flatten) (("2" (split -1) (("1" (expand translate_lit -1) (("1" (lift-if -1) (("1" (lift-if -1) (("1" (split -1) (("1" (lift-if -1) (("1" (split -1) (("1" (flatten) (("1" (assert) (("1" (case "pred(atom(upred(k!1, 0), null)) = pred(atom(upred(cons1_var!1, 0), null))") (("1" (assert) (("1" (case "index(upred(k!1, 0)) = index(upred(cons1_var!1, 0))") (("1" (assert) nil nil) ("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (replace -3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (lemma tr_clause_prop) (("2" (inst -1 "cons(cons1_var!1, cons2_var!1)") (("2" (flatten) (("2" (hide -2) (("2" (replace -7) (("2" (split -1) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (grind) nil nil)) nil) ("2" (flatten) (("2" (case "arg(f_not(atom(upred(abs(k!1), 0), null))) = arg(f_not(atom(upred(abs(cons1_var!1), 0), null)))") (("1" (assert) (("1" (case "pred(atom(upred(abs(k!1), 0), null)) = pred(atom(upred(abs(cons1_var!1), 0), null))") (("1" (assert) (("1" (case "index(upred(abs(k!1), 0)) = index(upred(abs(cons1_var!1), 0))") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil) ("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma tr_clause_prop) (("2" (inst -1 "cons(cons1_var!1, cons2_var!1)") (("2" (flatten) (("2" (hide -2) (("2" (replace -6) (("2" (split -1) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (flatten) (("3" (assert) (("3" (inst -6 k!1) (("3" (flatten) (("3" (hide -6) (("3" (expand translate_clause -6) (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (f_not? adt-recognizer-decl "[fmla -> boolean]" fmla nil) (arg adt-accessor-decl "[(f_not?) -> fmla]" fmla nil) (f_not adt-constructor-decl "[fmla -> (f_not?)]" fmla nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (funpred type-decl nil funpred_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (atom? adt-recognizer-decl "[fmla -> boolean]" fmla nil) (pred? adt-def-decl "boolean" funpred_adt nil) (pred adt-accessor-decl "[(atom?) -> (pred?)]" fmla nil) (term type-decl nil fmla nil) (length def-decl "nat" list_props nil) (arity shared-adt-accessor-decl "[funpred -> nat]" funpred_adt nil) (atom adt-constructor-decl "[[pred: (pred?), {ss: list[term] | length(ss) = arity(pred)}] -> (atom?)]" fmla nil) (upred? adt-recognizer-decl "[funpred -> boolean]" funpred_adt nil) (upred adt-constructor-decl "[[nat, nat] -> (upred?)]" funpred_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (index shared-adt-accessor-decl "[funpred -> nat]" funpred_adt nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (tr_clause_prop formula-decl nil trace_resolution nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (map adt-def-decl "list[T1]" list_adt_map nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (sorted? def-decl "bool" sortedlist nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (index const-decl "posnat" trace_resolution nil) (list_induction formula-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (nzint nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (m formal-const-decl "nat" trace2fmla nil) (n formal-const-decl "nat" trace2fmla nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (i formal-const-decl "upto(n)" trace2fmla nil) (tr_literal? const-decl "bool" trace_resolution nil) (translate_clause const-decl "(clause?)" trace2fmla nil) (clause? const-decl "bool" resolution nil) (translate_lit const-decl "(literal?)" trace2fmla nil) (literal? const-decl "bool" resolution nil) (fmla type-decl nil fmla nil) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (tr_clause? const-decl "bool" trace_resolution nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil)) shostak)) (translate_cons_TCC1 0 (translate_cons_TCC1-1 nil 3482245688 ("" (skosimp) (("" (assert) (("" (typepred ck!1) (("" (grind) nil nil)) nil)) nil)) nil) ((abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (index const-decl "posnat" trace_resolution nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (sorted? def-decl "bool" sortedlist nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (/= const-decl "boolean" notequal nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (m formal-const-decl "nat" trace2fmla nil) (n formal-const-decl "nat" trace2fmla nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (i formal-const-decl "upto(n)" trace2fmla nil) (tr_literal? const-decl "bool" trace_resolution nil) (tr_clause? const-decl "bool" trace_resolution nil)) nil)) (translate_cons_TCC2 0 (translate_cons_TCC2-1 nil 3482805344 ("" (skosimp) (("" (typepred ck!1) (("" (expand tr_clause? -2) (("" (expand sorted? -2) (("" (lift-if -2) (("" (split -2) (("1" (grind) nil nil) ("2" (flatten) (("2" (lift-if -1) (("2" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand tr_clause? 3) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((tr_clause? const-decl "bool" trace_resolution nil) (tr_literal? const-decl "bool" trace_resolution nil) (i formal-const-decl "upto(n)" trace2fmla nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (n formal-const-decl "nat" trace2fmla nil) (m formal-const-decl "nat" trace2fmla nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (nzint nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (sorted? def-decl "bool" sortedlist nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (index const-decl "posnat" trace_resolution nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (translate_cons 0 (translate_cons-1 nil 3482679632 ("" (skolem!) (("" (flatten) (("" (expand translate_clause 1 1) (("" (expand map) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((map adt-def-decl "list[T1]" list_adt_map nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (translate_lit const-decl "(literal?)" trace2fmla nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (translate_clause const-decl "(clause?)" trace2fmla nil)) shostak)) (translate_list 0 (translate_list-1 nil 3483130122 ("" (grind) nil nil) ((abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (translate_lit const-decl "(literal?)" trace2fmla nil) (map adt-def-decl "list[T1]" list_adt_map nil)) shostak)) (member_list 0 (member_list-1 nil 3483131339 ("" (skosimp) (("" (generalize listA!1 listA) (("" (induct listA) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skosimp) (("3" (split 1) (("1" (flatten) (("1" (expand member 1) (("1" (lift-if) (("1" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (lemma translate_list) (("2" (inst -1 "cons(cons1_var!1, cons2_var!1)") (("2" (assert) (("2" (replace -1 2) (("2" (assert) (("2" (replace -1 3) (("2" (assert) (("2" (delete -3) (("2" (expand member -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand member 1) (("2" (flatten) (("2" (lemma translate_list) (("2" (inst -1 "cons(cons1_var!1, cons2_var!1)") (("2" (assert) (("2" (replace -1 -2) (("2" (expand member -2) (("2" (lemma translate_lit_equiv) (("2" (inst -1 "k!1" "cons1_var!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (/= const-decl "boolean" notequal nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (m formal-const-decl "nat" trace2fmla nil) (n formal-const-decl "nat" trace2fmla nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (i formal-const-decl "upto(n)" trace2fmla nil) (tr_literal? const-decl "bool" trace_resolution nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (fmla type-decl nil fmla nil) (literal? const-decl "bool" resolution nil) (translate_lit const-decl "(literal?)" trace2fmla nil) (map adt-def-decl "list[T1]" list_adt_map nil) (translate_lit_equiv formula-decl nil trace2fmla nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (translate_list formula-decl nil trace2fmla nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (list_induction formula-decl nil list_adt nil)) shostak)) (translate_cons_list 0 (translate_cons_list-1 nil 3483130857 ("" (skosimp) (("" (generalize listA!1 "listA") (("" (induct listA) (("1" (grind) nil nil) ("2" (skosimp) (("2" (expand subset + 1) (("2" (expand subset + 2) (("2" (lift-if) (("2" (split) (("1" (grind) nil nil) ("2" (flatten) (("2" (lemma translate_list) (("2" (inst -1 "cons(cons1_var!1, cons2_var!1)") (("2" (assert) (("2" (replace -1 2) (("2" (assert) (("2" (case "member(cons1_var!1, listB!1)") (("1" (replace -1 2) (("1" (replace -3 2) (("1" (lemma member_list) (("1" (inst -1 "cons1_var!1" "listB!1") (("1" (replace -1 2 RL) (("1" (replace -2 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma member_list) (("2" (inst -1 "cons1_var!1" "listB!1") (("2" (replace 1 -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (/= const-decl "boolean" notequal nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (m formal-const-decl "nat" trace2fmla nil) (n formal-const-decl "nat" trace2fmla nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (i formal-const-decl "upto(n)" trace2fmla nil) (tr_literal? const-decl "bool" trace_resolution nil) (= const-decl "[T, T -> boolean]" equalities nil) (subset def-decl "bool" minlist nil) (fmla type-decl nil fmla nil) (literal? const-decl "bool" resolution nil) (map adt-def-decl "list[T1]" list_adt_map nil) (translate_lit const-decl "(literal?)" trace2fmla nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (translate_list formula-decl nil trace2fmla nil) (member_list formula-decl nil trace2fmla nil) (member def-decl "bool" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (list_induction formula-decl nil list_adt nil)) shostak)) (neg_translate_TCC1 0 (neg_translate_TCC1-1 nil 3482804348 ("" (subtype-tcc) (("" (grind) nil nil)) nil) ((abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (nzint nonempty-type-eq-decl nil integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (tr_literal? const-decl "bool" trace_resolution nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (m formal-const-decl "nat" trace2fmla nil) (n formal-const-decl "nat" trace2fmla nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (i formal-const-decl "upto(n)" trace2fmla nil)) nil)) (neg_translate 0 (neg_translate-1 nil 3483109938 ("" (skosimp) (("" (grind) nil nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (f_neg const-decl "fmla" fmla nil) (translate_lit const-decl "(literal?)" trace2fmla nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil)) shostak)) (cons_cdr_inclusion 0 (cons_cdr_inclusion-1 nil 3483119898 ("" (skosimp) (("" (generalize cl!1 "cl") (("" (induct cl) (("1" (delete 2) (("1" (typepred cl!2) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil) ("3" (skosimp) (("3" (expand tr_clause? -2) (("3" (expand sorted? -2) (("3" (lift-if -2) (("3" (split -2) (("1" (expand subset -3) (("1" (flatten) (("1" (replace -4 -2) (("1" (expand tr_clause? -2) (("1" (expand sorted? -2) (("1" (lift-if -2) (("1" (replace -1 -2) (("1" (expand subset 1) (("1" (lift-if) (("1" (split) (("1" (propax) nil nil) ("2" (flatten) (("2" (lemma translate_cons) (("2" (inst -1 "cons(cons1_var!1, cons2_var!1)") (("2" (assert) (("2" (replace -1 2) (("2" (assert) (("2" (hide 1) (("2" (expand member +) (("2" (flatten) (("2" (delete 1) (("2" (lemma clause_clause) (("2" (inst -1 "ck!1" "cons1_var!1") (("2" (replace -5 -1) (("2" (lemma member_lit_member_fmla) (("2" (flatten) (("2" (inst -1 "translate_lit(cons1_var!1)" "translate_clause(ck!1)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand tr_clause? -3) (("2" (replace -2 -3) (("2" (expand subset -4) (("2" (flatten) (("2" (replace -5 -3) (("2" (expand subset 2) (("2" (lift-if 2) (("2" (split) (("1" (propax) nil nil) ("2" (flatten) (("2" (split) (("1" (assert) (("1" (lemma translate_cons) (("1" (inst -1 "cons(cons1_var!1, cons2_var!1)") (("1" (assert) (("1" (replace -1 1) (("1" (assert) (("1" (expand member 1) (("1" (flatten) (("1" (delete 1) (("1" (lemma clause_clause) (("1" (inst -1 "ck!1" "cons1_var!1") (("1" (replace -6 -1) (("1" (assert) (("1" (lemma member_lit_member_fmla) (("1" (inst -1 "translate_lit(cons1_var!1)" "translate_clause(ck!1)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma translate_cons) (("2" (inst -1 "cons(cons1_var!1, cons2_var!1)") (("2" (assert) (("2" (replace -1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (translate_clause const-decl "(clause?)" trace2fmla nil) (clause? const-decl "bool" resolution nil) (literal? const-decl "bool" resolution nil) (fmla type-decl nil fmla nil) (tr_clause? const-decl "bool" trace_resolution nil) (subset def-decl "bool" minlist nil) (tr_literal? const-decl "bool" trace_resolution nil) (i formal-const-decl "upto(n)" trace2fmla nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (n formal-const-decl "nat" trace2fmla nil) (m formal-const-decl "nat" trace2fmla nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (nzint nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (translate_cons formula-decl nil trace2fmla nil) (member def-decl "bool" list_props nil) (member_lit_member_fmla formula-decl nil resolution nil) (translate_lit const-decl "(literal?)" trace2fmla nil) (clause_clause formula-decl nil trace2fmla nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (map adt-def-decl "list[T1]" list_adt_map nil) (sorted? def-decl "bool" sortedlist nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (index const-decl "posnat" trace_resolution nil) (NOT const-decl "[bool -> bool]" booleans nil) (list_induction formula-decl nil list_adt nil)) shostak)) (append_inclusion 0 (append_inclusion-1 nil 3482848762 ("" (skosimp) (("" (generalize cl!1 cl) (("" (induct cl) (("1" (delete 2) (("1" (typepred cl!2) (("1" (propax) nil nil)) nil)) nil) ("2" (flatten) (("2" (grind) nil nil)) nil) ("3" (skosimp) (("3" (expand tr_clause? -2) (("3" (expand sorted? -2) (("3" (lift-if -2) (("3" (split -2) (("1" (expand tr_clause? -2) (("1" (expand sorted? -2) (("1" (lift-if -2) (("1" (split) (("1" (replace -2 -1) (("1" (expand subset -3) (("1" (flatten) (("1" (replace -4 -1) (("1" (lemma translate_cons) (("1" (inst -1 "cons(cons1_var!1, cons2_var!1)") (("1" (assert) (("1" (replace -1 1) (("1" (expand subset +) (("1" (lemma member_append (a "translate_lit(cons1_var!1)" k "sq!1" l "translate_clause(cm!1)")) (("1" (replace -1 1) (("1" (flatten) (("1" (delete 1) (("1" (lemma clause_clause) (("1" (inst -1 "cm!1" "cons1_var!1") (("1" (replace -6 -1) (("1" (assert) (("1" (lemma member_lit_member_fmla) (("1" (inst -1 "translate_lit(cons1_var!1)" "translate_clause(cm!1)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand tr_clause? -3) (("2" (replace -2 -3) (("2" (expand subset -4) (("2" (flatten) (("2" (replace -5 -3) (("2" (lemma translate_cons) (("2" (inst -1 "cons(cons1_var!1, cons2_var!1)") (("2" (assert) (("2" (replace -1 2) (("2" (expand subset 2) (("2" (lemma member_append (a "translate_lit(cons1_var!1)" k "sq!1" l "translate_clause(cm!1)")) (("2" (replace -1 2) (("2" (flatten) (("2" (delete 2) (("2" (lemma clause_clause) (("2" (inst -1 "cm!1" "cons1_var!1") (("2" (replace -7 -1) (("2" (lemma member_lit_member_fmla) (("2" (inst -1 "translate_lit(cons1_var!1)" "translate_clause(cm!1)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((sequent type-eq-decl nil sequents nil) (sentence_list? const-decl "bool" fmla nil) (append def-decl "list[T]" list_props nil) (translate_clause const-decl "(clause?)" trace2fmla nil) (clause? const-decl "bool" resolution nil) (literal? const-decl "bool" resolution nil) (fmla type-decl nil fmla nil) (tr_clause? const-decl "bool" trace_resolution nil) (subset def-decl "bool" minlist nil) (tr_literal? const-decl "bool" trace_resolution nil) (i formal-const-decl "upto(n)" trace2fmla nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (n formal-const-decl "nat" trace2fmla nil) (m formal-const-decl "nat" trace2fmla nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (nzint nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (/= const-decl "boolean" notequal nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (member_append formula-decl nil minlist nil) (translate_lit const-decl "(literal?)" trace2fmla nil) (clause_clause formula-decl nil trace2fmla nil) (member_lit_member_fmla formula-decl nil resolution nil) (translate_cons formula-decl nil trace2fmla nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (map adt-def-decl "list[T1]" list_adt_map nil) (sorted? def-decl "bool" sortedlist nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (index const-decl "posnat" trace_resolution nil) (NOT const-decl "[bool -> bool]" booleans nil) (list_induction formula-decl nil list_adt nil)) shostak)) (translate_include_res 0 (translate_include_res-1 nil 3483128926 ("" (skosimp) (("" (assert) (("" (lemma translate_list) (("" (inst -1 "cons(find_pivot(nck!1, ncl!1), resolution(nck!1, ncl!1))") (("" (assert) (("" (expand translate_clause 1) (("" (replace -1 1 RL) (("" (lemma translate_cons_list) (("" (inst -1 "nck!1" "cons(find_pivot(nck!1, ncl!1), resolution(nck!1, ncl!1))") (("" (assert) (("" (lemma subset_lit_subset_fmla) (("" (inst -1 "map(translate_lit)(nck!1)" "map(translate_lit)
                 (cons(find_pivot(nck!1, ncl!1), resolution(nck!1, ncl!1)))") (("" (replace -1 1) (("" (replace -2 1 RL) (("" (lemma include_res) (("" (inst -1 "nck!1" "ncl!1") (("" (replace -5 -1) (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (/= const-decl "boolean" notequal nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (m formal-const-decl "nat" trace2fmla nil) (n formal-const-decl "nat" trace2fmla nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (i formal-const-decl "upto(n)" trace2fmla nil) (tr_literal? const-decl "bool" trace_resolution nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (tr_clause? const-decl "bool" trace_resolution nil) (ne_tr_clause? const-decl "bool" trace_resolution nil) (exist_pivot? def-decl "bool" trace_resolution nil) (member def-decl "bool" list_props nil) (tr_neg const-decl "(tr_literal?)" trace_resolution nil) (find_pivot def-decl "{k | member(k, nck) AND member(tr_neg(k), ncl)}" trace_resolution nil) (resolution const-decl "(tr_clause?)" trace_resolution nil) (translate_clause const-decl "(clause?)" trace2fmla nil) (translate_cons_list formula-decl nil trace2fmla nil) (fmla type-decl nil fmla nil) (literal? const-decl "bool" resolution nil) (map adt-def-decl "list[T1]" list_adt_map nil) (translate_lit const-decl "(literal?)" trace2fmla nil) (include_res formula-decl nil trace_resolution nil) (subset_lit_subset_fmla formula-decl nil resolution nil) (translate_list formula-decl nil trace2fmla nil)) shostak)) (translate_include_res2_TCC1 0 (translate_include_res2_TCC1-1 nil 3483103764 ("" (skosimp) (("" (skosimp) (("" (typepred "find_pivot[m, n, i](nck!1, ncl!1)") (("" (expand tr_literal?) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (resolution const-decl "(tr_clause?)" trace_resolution nil) (delete_pivot const-decl "{cl |
         FORALL l:
           member(l, cl) <=>
            member(l, ck) AND (NOT l = pivot) AND (NOT l = tr_neg(pivot))}" trace_resolution nil) (not_true_clauses const-decl "bool" trace_resolution nil) (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzint_abs_is_pos application-judgement "{j: posint | j >= i}" real_defs nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (m formal-const-decl "nat" trace2fmla nil) (n formal-const-decl "nat" trace2fmla nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (i formal-const-decl "upto(n)" trace2fmla nil) (tr_literal? const-decl "bool" trace_resolution nil) (tr_clause? const-decl "bool" trace_resolution nil) (ne_tr_clause? const-decl "bool" trace_resolution nil) (exist_pivot? def-decl "bool" trace_resolution nil) (member def-decl "bool" list_props nil) (tr_neg const-decl "(tr_literal?)" trace_resolution nil) (find_pivot def-decl "{k | member(k, nck) AND member(tr_neg(k), ncl)}" trace_resolution nil)) nil)) (translate_include_res2 0 (translate_include_res2-1 nil 3483137007 ("" (skosimp) (("" (assert) (("" (expand translate_clause) (("" (lemma translate_cons_list) (("" (lemma translate_list) (("" (inst -1 "cons(-find_pivot(nck!1, ncl!1), resolution(nck!1, ncl!1))") (("" (assert) (("" (replace -1 1 RL) (("" (hide -1) (("" (inst -1 "ncl!1" "cons(-find_pivot(nck!1, ncl!1), resolution(nck!1, ncl!1))") (("" (lemma subset_lit_subset_fmla) (("" (inst -1 "map(translate_lit)(ncl!1)" "map(translate_lit)
              ((cons(-find_pivot(nck!1, ncl!1), resolution(nck!1, ncl!1))))") (("" (replace -1 1) (("" (replace -2 1 RL) (("" (lemma include_res) (("" (hide -2 -3) (("" (inst -1 "nck!1" "ncl!1") (("" (assert) (("" (flatten) (("" (hide -1 -3 -4) (("" (lemma subset_numpred_nzint) (("" (inst -1 "ncl!1" "cons(-find_pivot(nck!1, ncl!1), resolution(nck!1, ncl!1))") (("" (lemma subset_tr_lit_subset_nzint) (("" (inst -1 "ncl!1" "cons(-find_pivot(nck!1, ncl!1), resolution(nck!1, ncl!1))") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (translate_cons_list formula-decl nil trace2fmla nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (/= const-decl "boolean" notequal nil) (int nonempty-type-eq-decl nil integers nil) (nzint nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (m formal-const-decl "nat" trace2fmla nil) (n formal-const-decl "nat" trace2fmla nil) (<= const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (i formal-const-decl "upto(n)" trace2fmla nil) (tr_literal? const-decl "bool" trace_resolution nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (tr_clause? const-decl "bool" trace_resolution nil) (ne_tr_clause? const-decl "bool" trace_resolution nil) (exist_pivot? def-decl "bool" trace_resolution nil) (member def-decl "bool" list_props nil) (tr_neg const-decl "(tr_literal?)" trace_resolution nil) (find_pivot def-decl "{k | member(k, nck) AND member(tr_neg(k), ncl)}" trace_resolution nil) (resolution const-decl "(tr_clause?)" trace_resolution nil) (translate_lit const-decl "(literal?)" trace2fmla nil) (map adt-def-decl "list[T1]" list_adt_map nil) (literal? const-decl "bool" resolution nil) (fmla type-decl nil fmla nil) (delete_pivot const-decl "{cl |
         FORALL l:
           member(l, cl) <=>
            member(l, ck) AND (NOT l = pivot) AND (NOT l = tr_neg(pivot))}" trace_resolution nil) (subset_tr_lit_subset_nzint formula-decl nil trace_resolution nil) (subset_numpred_nzint formula-decl nil trace_resolution nil) (include_res formula-decl nil trace_resolution nil) (subset_lit_subset_fmla formula-decl nil resolution nil) (translate_list formula-decl nil trace2fmla nil) (translate_clause const-decl "(clause?)" trace2fmla nil)) shostak)))
