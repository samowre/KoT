




more_finseq_props [ T:TYPE ] : THEORY
  BEGIN
  IMPORTING finseq_basic_props[T]

  s, s1, s2: VAR finseq[T]
  p: VAR PRED[T]
  a,b,c: VAR T
  x,y,z: VAR T
  bl(s): TYPE = below(length(s))
  ul(s): TYPE = upto(length(s))
  c: VAR [nat,nat]
  i,j,k,l: VAR nat
  


    % uniques
  uniques_aux?(s,(i:ul(s))): RECURSIVE bool =
  	IF i=length(s) THEN TRUE
	ELSE NOT member_aux(s(i),s,i+1) AND uniques_aux?(s,i+1)
	ENDIF
  MEASURE length(s) - i
  uniques?(s): bool = uniques_aux?(s,0)
    % Find
  findi(p, s, (i: upto(s`length))):
    RECURSIVE lift[{ i: below(s`length) | p(s(i)) }] =
    	 IF i = s`length THEN bottom
    	 ELSIF p(s(i)) THEN up(i)
    	 ELSE findi(p, s, i + 1)
    	 ENDIF
  MEASURE s`length - i

  find(p, s): lift[{ i: below(s`length) | p(s(i)) }] =
    findi(p, s, 0)

 
 

  
  % Characterisation of comon functions

    % Unique
  uniques_nth: LEMMA uniques?(s) IFF
  	       	     FORALL (i,j:bl(s)): i /= j IMPLIES s(i) /= s(j)
    % Find
  findi_exists: THEOREM
    FORALL (i: upto(s`length)):
      (EXISTS (j: subrange(i, s`length - 1)): p(s(j))) IMPLIES up?(findi(p, s, i))

  find_exists: THEOREM
    (EXISTS (i: below(s`length)): p(s(i))) IMPLIES up?(find(p, s))
  


 
 
 


  END more_finseq_props



% define map, finseq2
% finseq2list
% finseq2set

% list2set
