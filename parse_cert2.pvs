
parse_cert2 % parse a text file containing a certificate
		: THEORY
  BEGIN
  
  IMPORTING PVSio@stdtokenizer
  IMPORTING PVSio@stdio
  IMPORTING PVSio@stdglobal

  get_file_name : string = 
  let file_name: string = query_line("PicoSAT proof file name: ") in
  if not fexists(file_name) then
    throw ("e")
  else file_name
  endif

  % reads ints from stream until s found
  % returns the list of read ints in reverse order
  read_until_stop( t: Tokenizer, 
  		   acc: list[int]) : recursive list[int] =		
    let w:string = next_token(t) in
    if not int?(w) then 
      acc
    else 
      read_until_stop(go_next(t), cons(str2int(w), acc))
    endif 
  measure t`length - t`pos

  % similar to the previous function, returns nat list
  read_nat_until_stop( t: Tokenizer, 
  		       acc: list[nat]) : RECURSIVE list[nat] = 
    let w = next_token(t) in
    if not int?(w) then 
      reverse(acc)
    else 
      let wi = str2int(w) in
      if wi >= 0 
      then
        read_nat_until_stop(go_next(t), cons(wi, acc)) 
      else throw("e")
      endif 
    endif
  measure t`length - t`pos

  

  % reads clause from stream, 
  % updates maxv if elements of the clause are higher than the current val
  read_clause(t: Tokenizer, maxv: Mutable[nat]): list[int] = 
    let w = next_token(t) in
    if w = "*" 
    then 
    % no clause
      null 
    else 
    % w = first literal of the clause
    % r = clause\w in reversed order
      let r = read_until_stop(go_next(t), null[nat]) in
    %rr = clause\w in normal order
      let rr = reverse(r) in
      % wi = int value of w
      let wi =  str2int(w) in
      %small error? tmp not compared with wi?
      let tmp = abs(
		    if cons?(r) 
		    then max(abs(car(r)), abs(car(rr))) 
		    else wi 
		    endif) in
      let b = 
      if tmp > val(maxv) 
      then
	set(maxv, tmp)
      else skip
      endif 
      in
      cons(wi, rr) 
    endif

  print_list(l: list[int]): recursive void = 
    if null?(l) 
    then 
      print("~%")
    else 
      print(car(l)) & 
      print(" ") & 
      print_list(cdr(l))
    endif
    measure length(l)
  
  pico_data: TYPE = [# max_lit: nat, 
   	       	       nr_clauses: nat, 
		       r_clause_list: list[list[int]], 
		       r_antec_list: list[list[nat]] #] 

  % stores the value returned by read_rec
  aux_fdata: Global[ pico_data, 
  	     	     (#max_lit:= 0, 
		      nr_clauses:= 0, 
		      r_clause_list:= null[list[int]], 
		      r_antec_list:= null[list[nat]]#)]
  % true if read_rec has been called once
  aux_bool: Global[bool, false]

  parse_line( line: string, 
  	      max: Mutable[nat], 
	      clause: Mutable[list[list[int]]],
	      antec: Mutable[list[list[nat]]] ): void =
    let t:Tokenizer = str2tokenizer(line) in 
    % read line number
    let skip1 = go_next(t) in
    % read clause
    % add new clause
    let cl = read_clause(skip1, max) in
    set(clause, cons(cl, val(clause) )) &
    %read antecedents
    set(antec, cons( read_nat_until_stop( consume(skip1, length(cl)), 
    	       	     			  null[nat]), 
    	             val(antec)))

  parse_file(s:string):pico_data

  % reads a file once and stores the result in aux_fdata
  read_rec : pico_data =
  %if bool set
  if val(aux_bool) 
  %return existing data
  then val(aux_fdata)
  else 
 %   let f = fopenin(get_file_name) in
    % number of lines
 %   let c = ref[nat](0) in
    % meximum literal
 %   let max = ref[nat](0) in
    % 0 = line#, 1 = clause, 2 = antecedents
 %   let clause = ref(null[list[int]]) in	
    % antecedents
 %   let antec = ref(null[list[nat]]) in
 %   let b = 
 %     while(not eof?(f), 
%	parse_line(fread_line(f), max, clause, antec) & set(c, val(c)+1)
 %       ) & 
 %   fclose(f) & 
 %   print("finished reading") &
    %set bool to true
 
 %   in
 %     let maxi:nat =  val(max) + 1 in
 %     let nci:nat = val(c) in
 %     let rcl:list[list[int]] = val(clause) in
 %     let ral:list[list[nat]] = val(antec) in
      let result = parse_file(get_file_name) in
 %     (# max_lit:= maxi, 
 %      nr_clauses:= nci, 
 %      r_clause_list:= rcl, 
 %      r_antec_list := ral #) in
      % set result
      let s = set(aux_fdata, result) & set(aux_bool, true) in
      % return result
      result
  endif

  %read the file
  fdata: pico_data = read_rec

  m: nat = fdata`max_lit
  n: nat = fdata`nr_clauses
  rcl: list[list[int]] = fdata`r_clause_list
  ral: list[list[nat]] = fdata`r_antec_list


  IMPORTING trace_resolution2[m, n, n]

  %verify if l is a list of tr_literal
  lit_list?(l: list[int]): recursive bool = 
    if null?(l) 
    then 
      true
    else 
      car(l) /=0 and tr_literal?(car(l)) and lit_list?(cdr(l))
    endif
  measure length(l)


  %verify if l has type chain(nc)
  chain?(l:list[nat], nc: nat): recursive bool = 
    if null?(l) 
    then 
      true
    else 
      car(l) < nc and chain?(cdr(l), nc)
    endif
  measure length(l)

  empty_cert: certificate = 
  	      lambda (i:below(n)): (#cl := null, chn:= null #)

  % build a certificate
  build_cert( 
    pnc:{i:nat|i <= n}, 
    prcl: list[list[int]], 
    pral: list[list[nat]], 
    aux: certificate): recursive certificate = 
  if pnc = 0 or null?(prcl) or null?(pral)then 
    if pnc /= 0 or not null?(prcl) or not null?(pral) 
    then
      throw("e")  
    else let p = print("build_cert done") in aux 
    endif
  elsif lit_list?(car(prcl)) 
  	and sorted?(car(prcl)) 
	and chain?(car(pral), pnc-1) 
  then 
    let ch_pnc: chain(pnc-1) = car(pral) in
    build_cert( 
      pnc-1, 
      cdr(prcl), 
      cdr(pral), 
      aux with [(pnc-1) := (# cl:= car(prcl), 
      	       		      chn := ch_pnc #) ])	
  else 
    throw("e")
  endif
  measure pnc

  % true if the last resolution chain produces an empty clause
  verify: bool = 
  catch("e", 
        let cert = resolve(build_cert(n, rcl, ral, empty_cert)) in
          set(aux_bool, false) & 
          null?(cert(n-1)`cl), 
        lambda ( e:Exception[string]): 
	       println(
			tag(e)
			+ " exception: " 
			+ val(e) 
			+ " INVALID CERTIFICATE"))

  END parse_cert2
