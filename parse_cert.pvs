parse_cert % parse a text file containing a certificate
		: THEORY

  BEGIN

  
  IMPORTING PVSio@stdtokenizer
  IMPORTING PVSio@stdio

  get_file_name : string = 
    query_line("PicoSAT proof file name: ")
  
  read_file_name : void = 
    LET file_name: string = get_file_name IN
    IF NOT fexists(file_name) THEN
    print("no such file")
    ELSE 
    LET tok = file2tokenizer(file_name) IN
    IF error?(tok) OR eot?(tok)
    THEN print("empty tokenizer")
    ELSE print(next_token(tok))
    ENDIF
    ENDIF

  open_input_file : IStream =
    LET s = get_file_name IN
      fopenin(s)

  % reads ints from stream until 0 found
  % returns the list of read ints in reverse order
  read_until_zero(f: IStream) : list[int] =		
    let w = ref(fread_int(f)) in
    let aux = ref(null[int]) in 
    let b2 = 
      while(val(w) /= 0, 
        set(aux, cons[int](val(w), aux)) & 
	set(w, fread_int(f))) in
    aux

  read_nat_until_zero(f: IStream) : list[nat] = 
    let w = ref(fread_int(f)) in
    let aux = ref(null[nat]) in 
    let b2 = 
      while(val(w) /= 0, 
        if val(w) > 0 
	then
          set(aux, cons[nat](val(w), aux)) & 
	  set(w, fread_int(f)) 
	else skip 
	endif ) 
	in
    aux

  % reads clause from stream, 
  % updates maxv if elements of clause are higher than the actual val
  read_clause(f:IStream, maxv: Mutable[real]): list[int] = 
    let w = fread_word(f) in
    if w = "*" 
    then 
      null 
    else 
      let r = read_until_zero(f) in
      let rr = reverse(r) in
      let wi =  str2int(w) in
      let tmp = abs(if cons?(r) then max(abs(car(r)), abs(car(rr))) else wi endif) in
      let b = 
      if tmp > val(maxv) 
      then
	set(maxv, tmp)
      else skip
      endif 
      in
      cons(wi, rr) 
    endif

  print_list(l: list[int]): recursive void = 
    if null?(l) 
    then 
      print("~%")
    else 
      print(car(l)) & 
      print(" ") & 
      print_list(cdr(l))
    endif
    measure length(l)
  
  pico_data: TYPE = [# max_lit: nat, nr_clauses: nat, r_clause_list: list[list[int]], r_antec_list: list[list[nat]] #] 

  read_rec : pico_data = 
  let f = fopenin(get_file_name) in
  let c = ref(1) in
  let max = ref(0) in
  let mode = ref(0) in
  let clause = ref(null[list[int]]) in	
  let antec = ref(null[list[nat]]) in
  let w = ref("") in
  let b = 
    while(not eof?(f), 
      if val(mode) = 0 
      then  
        %read line number
        set(w, fread_word(f)) & 
	set(mode, 1)
      elsif val(mode) = 1 
      then
        %read clause
	if integer?(val(c)) and val(c) >= 0 
	then
	% add new close
	  let cl = read_clause(f, max) in
          set(clause, cons(cl, val(clause) ))
	else skip 
	endif &
	set(mode, 2) 
      else 
        %read antecedents
        set(antec, cons(read_nat_until_zero(f), val(antec))) & 
	set(c, val(c)+1) & 
	set(mode, 0)
      endif) & 
    print(val(c)) & 
    print(val(max)) &
    if cons?[list[number]](val(clause)) 
    then
      print(val(c)+1) & 
      print_list( car(val(clause)) ) 
    else 
      skip 
    endif &
    fclose(f) in
    let maxi:nat = if integer?(val(max)) and val(max) > 0 then val(max) else 0 endif in
    let nci:nat = if integer?(val(c)) and val(c) > 0 then val(c) else 0 endif in
    let rcl:list[list[int]] = val(clause) in
    let ral:list[list[nat]] = val(antec) in
     
    (# max_lit:= maxi, nr_clauses:= nci, r_clause_list:= rcl, r_antec_list := ral #)

  %read the file

  %b: void = set(mfdata, read_rec)
  fdata: pico_data =  read_rec
  mfdata: Mutable[pico_data] = ref(fdata)
  %fdata: pico_data = def(new, read_rec)

  m: nat = val(mfdata)`max_lit
  n: nat = val(mfdata)`nr_clauses
  rcl: list[list[int]] = val(mfdata)`r_clause_list
  ral: list[list[nat]] = val(mfdata)`r_antec_list



  IMPORTING trace_resolution[m, n, n]

  %verify if l is a list of tr_literal
  lit_list?(l: list[int]): recursive bool = 
  if null?(l) then true
  else car(l) /=0 and tr_literal?(car(l)) and lit_list?(cdr(l))
  endif
  measure length(l)

%  valid_clauses?(ll: list[list[int]]): recursive bool = 
%  if null?(ll) then true
%  else lit_list?(car(ll)) and sorted?(car(ll)) and valid_clauses?(cdr(ll))
%  endif
%  measure length(ll)

  %verify if l has type chain(nc)
  chain?(l:list[nat], nc: nat): recursive bool = 
  if null?(l) then true
  else car(l)<nc and chain?(cdr(l), nc)
  endif
  measure length(l)

%  valid_chains?(ll: list[list[nat]], nc: nat): recursive bool = 
%  if nc = 0 then null?(ll)
%  elsif null?(ll) then true	     
%  else chain?(car(ll), nc) and valid_chains?(cdr(ll), nc-1)
%  endif
%  measure length(ll)

  % build a certificate
  build_cert(
    pmax_lit:nat, 
    pnc:{i:nat|i<n}, 
    prcl: list[list[int]], 
    pral: list[list[nat]], 
    aux: certificate): recursive certificate = 
  if pnc = 0 or null?(prcl) or null?(pral)
  then aux
  elsif lit_list?(car(prcl)) and sorted?(car(prcl)) and chain?(car(pral), pnc) 
  then 
    let ch_pnc: chain(pnc) = car(pral) in
    build_cert(
      pmax_lit, 
      pnc-1, 
      cdr(prcl), 
      cdr(pral), 
      aux with [(pnc) := (# cl:= car(prcl), chn := ch_pnc #) ])	
  else aux
  endif
  measure pnc

  empty_cert: certificate = lambda (i:below(n)): (#cl := null, chn:= null #)
  
  error_cert: certificate = empty_cert with [(n)`cl := cons(1, null)]

  verify: bool = 
  let cert = build_cert(m, n, rcl, ral, empty_cert) in
  null?(cert(n)`cl)

  %lit_list(m,n, l:list[int]): recursive bool = 
  %if null?(l) then true	      
  %else tr_lit?[m, n, n](car(l)) and lit_list(m, n, cdr(l))
  %endif
  %measure length(l)

  %clause_list(m, n, ll: list[list[int]]): recursive bool = 
  %if null?(ll) then true
  %else 
  %  lit_list(m,n,car(ll)) and 

  

  %check_cert: bool = 
  %let fdata = read_rec in
  %let max = fdata`max_lit in 
  %let nc = fdata`nr_clauses in
  %let rcl = fdata`r_clause_list in
  %let ral = fdata`r_antec_list in 
  %if fdata`max_lit = 0 or fdata`nr_clauses = 0 or (not sorted_lists(rcl)) or (not antec_lists(ral, nc)) 
  %then 
  %  false 
 % else 
  %  check(resolve(build_cert(fdata)))
    % check sorted clause
    % check antec smaller than current line
    % create certificate
    % apply resolution
  %endif

  END parse_cert
