
parse_cert3 % parse a text file containing a certificate
		: THEORY
  BEGIN
  
%  IMPORTING PVSio@stdtokenizer
  IMPORTING PVSio@stdio
  IMPORTING PVSio@stdglobal

  get_file_name : string = 
  let file_name: string = query_line("PicoSAT proof file name: ") in
  if not fexists(file_name) then
   let dbg = print("no file") in
    throw ("e")
  else file_name
  endif
  
  pico_data: TYPE = [# max_lit: nat, 
   	       	       nr_clauses: nat, 
		       r_clause_list: list[list[int]], 
		       r_antec_list: list[list[nat]] #] 

  % stores the value returned by read_rec
  aux_fdata: Global[ pico_data, 
  	     	     (#max_lit:= 0, 
		      nr_clauses:= 0, 
		      r_clause_list:= null[list[int]], 
		      r_antec_list:= null[list[nat]]#)]

  % true if read_rec has been called once
  aux_bool: Global[bool, false]

  parse_file(s:string): pico_data

  % reads a file once and stores the result in aux_fdata
  read_rec : pico_data =
    %if bool set
  if val(aux_bool) 
    %return existing data
  then val(aux_fdata)
  else 
    let result = parse_file(get_file_name) in
    let s = set(aux_fdata, result) & set(aux_bool, true) in
    result
  endif

  %read the file
  fdata: pico_data = read_rec

  print_pico_data(p:pico_data) : void= 
    print(p`max_lit + " " + p`nr_clauses) 

  m: nat = fdata`max_lit + 1
  n: nat = fdata`nr_clauses
  rcl: list[list[int]] = fdata`r_clause_list
  ral: list[list[nat]] = fdata`r_antec_list
  qv: nat = 0

  IMPORTING trace_resolution3[m, n, n]

  %verify if l is a list of tr_literal
  lit_list?(l: list[int]): recursive bool = 
    if null?(l) 
    then 
      true
    else 
      car(l) /=0 and tr_literal?(car(l)) and lit_list?(cdr(l))
    endif
  measure length(l)


  build_clause_array(j: below(n), prcl: list[list[int]], acc: array_of_clauses): recursive array_of_clauses =
    if null?(prcl) then acc
    elsif  lit_list?(car(prcl)) 
  	   and sorted?(car(prcl)) 
    then 
	build_clause_array(j-1, cdr(prcl), acc with [(j):= car(prcl)])
    else throw("e")
    endif
  measure length(prcl)

  build_chain_list(j: below(n), pral: list[list[int]], acc: (list_of_chains_offset?(j))): recursive (list_of_chains_offset?(j)) = 
    if null?(pral) then acc
    elsif chain?(j)(car(pral)) then build_chain_list(j-1, cdr(pral), cons(car(pral), acc))
    else throw("e")
    endif
  measure length(pral)


  % true if the last resolution chain produces an empty clause
  verify: bool = 
  catch("e", 
  	let ini_cl_array: array_of_clauses = build_clause_array(n-1, rcl, lambda (i:below(n)): null) in
	let ini_ch_list: (list_of_chains?) = build_chain_list(n-1, ral, null) in
        let cl_array = resolve( ini_ch_list, ini_cl_array ) in
          set(aux_bool, false) & 
          null?(cl_array(n-1)), 
        lambda ( e:Exception[string]): 
	       print(
			tag(e)
			+ " exception: " 
			+ val(e) 
			+ " INVALID CERTIFICATE"))

  END parse_cert3
