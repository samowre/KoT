(clauses
 (resolve_aux_TCC1 0
  (resolve_aux_TCC1-1 nil 3525461591 ("" (subtype-tcc) nil nil) nil
   nil))
 (resolve_aux_TCC2 0
  (resolve_aux_TCC2-1 nil 3525461591 ("" (termination-tcc) nil nil) nil
   nil))
 (resolve_aux_TCC3 0
  (resolve_aux_TCC3-1 nil 3525461591 ("" (termination-tcc) nil nil) nil
   nil))
 (resolve_aux_TCC4 0
  (resolve_aux_TCC4-1 nil 3525461591 ("" (termination-tcc) nil nil) nil
   nil))
 (resolve_aux_TCC5 0
  (resolve_aux_TCC5-1 nil 3525461591 ("" (termination-tcc) nil nil) nil
   nil))
 (resolve_aux_TCC6 0
  (resolve_aux_TCC6-1 nil 3525628562 ("" (subtype-tcc) nil nil) nil
   nil))
 (resolve_aux_TCC7 0
  (resolve_aux_TCC7-1 nil 3525628562 ("" (termination-tcc) nil nil) nil
   nil))
 (resolve_aux_TCC8 0
  (resolve_aux_TCC8-1 nil 3525628562 ("" (termination-tcc) nil nil) nil
   nil))
 (resolve_aux_TCC9 0
  (resolve_aux_TCC9-1 nil 3525628562 ("" (subtype-tcc) nil nil) nil
   nil))
 (satisfies_TCC1 0
  (satisfies_TCC1-1 nil 3525547613 ("" (subtype-tcc) nil nil) nil nil))
 (satisfies_TCC2 0
  (satisfies_TCC2-1 nil 3525547613 ("" (subtype-tcc) nil nil) nil nil))
 (FV_TCC1 0
  (FV_TCC1-1 nil 3526059822 ("" (termination-tcc) nil nil) nil nil))
 (FV_TCC2 0
  (FV_TCC2-1 nil 3526059822 ("" (subtype-tcc) nil nil) nil nil))
 (FV_TCC3 0
  (FV_TCC3-1 nil 3526059822 ("" (subtype-tcc) nil nil) nil nil))
 (FV_TCC4 0
  (FV_TCC4-1 nil 3526059822 ("" (termination-tcc) nil nil) nil nil))
 (FV_append 0
  (FV_append-1 nil 3526157446
   ("" (induct-and-simplify "cls1")
    (("1" (grind)
      (("1" (rewrite "union_commutative")
        (("1" (rewrite "union_empty") nil nil)) nil))
      nil)
     ("2" (grind) (("2" (rewrite "union_associative") nil nil)) nil))
    nil)
   ((FV def-decl "set[nat]" clauses nil)
    (clause type-eq-decl nil clauses nil)
    (union_associative formula-decl nil sets_lemmas nil)
    (union_empty formula-decl nil sets_lemmas nil)
    (union_commutative formula-decl nil sets_lemmas nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (FV def-decl "set[nat]" clauses nil)
    (append def-decl "list[T]" list_props nil)
    (union const-decl "set" sets nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (eqval_clause 0
  (eqval_clause-1 nil 3526062469
   ("" (induct "cl")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("l!1" "cl!1"))
      (("2" (skosimp*)
        (("2" (inst -1 "e1!1" "e2!1")
          (("2" (expand "satisfies" 1 :if-simplifies T)
            (("2" (expand "some" 1 :if-simplifies T)
              (("2" (split -1)
                (("1" (expand "satisfies" -1)
                  (("1" (replace -1 1)
                    (("1" (delete -1) (("1" (grind) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (delete 2)
                  (("2" (expand "eqval")
                    (("2" (skosimp)
                      (("2" (inst -2 "i!1") (("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (env type-eq-decl nil clauses nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (set type-eq-decl nil sets nil)
    (eqval const-decl "bool" clauses nil)
    (clause type-eq-decl nil clauses nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list_induction formula-decl nil list_adt nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (lookup const-decl "bool" clauses nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (singleton const-decl "(singleton?)" sets nil)
    (union const-decl "set" sets nil)
    (nonempty_union1 application-judgement "(nonempty?)" sets nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (eqval_clauses 0
  (eqval_clauses-1 nil 3526062988
   ("" (induct "cls")
    (("1" (skosimp*) (("1" (grind) nil nil)) nil)
     ("2" (skolem 1 ("cl!1" "rest!1"))
      (("2" (skosimp*)
        (("2" (inst -1 "e1!1" "e2!1")
          (("2" (split -1)
            (("1" (expand "satisfies" 1)
              (("1" (expand "satisfies" -1)
                (("1" (expand "every" :if-simplifies T)
                  (("1" (replace -1 1)
                    (("1" (delete -1)
                      (("1" (expand "FV")
                        (("1" (lemma "eqval_clause")
                          (("1" (inst -1 "cl!1" "e1!1" "e2!1")
                            (("1" (split -1)
                              (("1"
                                (replace -1 1)
                                (("1" (propax) nil nil))
                                nil)
                               ("2"
                                (delete 2)
                                (("2"
                                  (expand "eqval")
                                  (("2"
                                    (skosimp)
                                    (("2"
                                      (inst -2 "i!1")
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (eqval_clause formula-decl nil clauses nil)
    (union const-decl "set" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (lookup const-decl "bool" clauses nil) nil nil
    (minus_int_is_int application-judgement "int" integers nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil) nil
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil) nil
    (= const-decl "[T, T -> boolean]" equalities nil) nil
    (eqval const-decl "bool" clauses nil)
    (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (env type-eq-decl nil clauses nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil))
   shostak))
 (sat_append 0
  (sat_append-1 nil 3525548696
   ("" (auto-rewrite-theory "list_props")
    (("" (induct-and-simplify "cl1") nil nil)) nil)
   ((list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (clause type-eq-decl nil clauses nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (env type-eq-decl nil clauses nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (append def-decl "list[T]" list_props nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list_induction formula-decl nil list_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (sat_reverse 0
  (sat_reverse-1 nil 3525548734
   ("" (induct "cl")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("h!1" "t!1"))
      (("2" (skosimp*)
        (("2" (expand "reverse" :if-simplifies T)
          (("2" (lemma "sat_append") (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (clause type-eq-decl nil clauses nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (env type-eq-decl nil clauses nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (reverse def-decl "list[T]" list_props nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list_induction formula-decl nil list_adt nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (lookup const-decl "bool" clauses nil)
    (sat_append formula-decl nil clauses nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (sat_rev_append 0
  (sat_rev_append-1 nil 3525548884
   ("" (skosimp*)
    (("" (rewrite "rev_append_char")
      (("" (lemma "sat_reverse")
        (("" (lemma "sat_append") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((sat_reverse formula-decl nil clauses nil)
    (env type-eq-decl nil clauses nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (reverse def-decl "list[T]" list_props nil)
    (lookup const-decl "bool" clauses nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (sat_append formula-decl nil clauses nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (clause type-eq-decl nil clauses nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (rev_append_char formula-decl nil lists nil))
   shostak))
 (sat_cons 0
  (sat_cons-1 nil 3525616156 ("" (grind) nil nil)
   ((minus_int_is_int application-judgement "int" integers nil)
    (lookup const-decl "bool" clauses nil)
    (clause type-eq-decl nil clauses nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (sat_cons_inv 0
  (sat_cons_inv-1 nil 3525620296 ("" (grind) nil nil)
   ((minus_int_is_int application-judgement "int" integers nil)
    (lookup const-decl "bool" clauses nil)
    (clause type-eq-decl nil clauses nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (res_lemma 0
  (res_lemma-1 nil 3525616329
   ("" (skosimp*)
    (("" (lemma "sat_cons_inv")
      (("" (inst-cp -1 "e!1" "h!1" "c1!1")
        (("" (inst-cp -1 "e!1" "-h!1" "c2!1")
          (("" (delete -1)
            (("" (prop)
              (("" (delete -3)
                (("" (delete -3)
                  (("" (delete 2)
                    (("" (delete 2)
                      (("" (expand "satisfies")
                        (("" (split)
                          (("1" (flatten)
                            (("1" (split)
                              (("1"
                                (flatten)
                                (("1" (assert) nil nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (split)
                              (("1" (flatten) nil nil)
                               ("2"
                                (flatten)
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (env type-eq-decl nil clauses nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (clause type-eq-decl nil clauses nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (sat_cons_inv formula-decl nil clauses nil))
   shostak))
 (resolve_aux 0
  (resolve_aux-1 nil 3525616674
   ("" (lemma "sat_cons")
    (("" (lemma "sat_rev_append")
      (("" (induct "cl1")
        (("1" (grind) nil nil)
         ("2" (skolem 1 ("h!1" "t!1"))
          (("2" (flatten)
            (("2" (induct "cl2")
              (("1" (grind) nil nil)
               ("2" (skolem 1 ("h!2" "t!2"))
                (("2" (flatten)
                  (("2" (skosimp*)
                    (("2" (expand "resolve_aux" 1 :if-simplifies T)
                      (("2" (lift-if)
                        (("2" (split)
                          (("1" (flatten)
                            (("1"
                              (inst -5 "cons(h!2,t!2)"
                               "cons(h!1,acc!1)" "e!1" "flag!1")
                              (("1" (grind) nil nil)) nil))
                            nil)
                           ("2" (flatten)
                            (("2" (split)
                              (("1"
                                (flatten)
                                (("1"
                                  (inst
                                   -5
                                   "t!2"
                                   "cons(h!1,acc!1)"
                                   "e!1"
                                   "flag!1")
                                  (("1" (grind) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (split)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (inst
                                       -6
                                       "t!2"
                                       "acc!1"
                                       "e!1"
                                       "FALSE")
                                      (("1"
                                        (split -6)
                                        (("1" (propax) nil nil)
                                         ("2"
                                          (delete -3)
                                          (("2"
                                            (delete 2)
                                            (("2"
                                              (expand
                                               "resolve_aux_cond")
                                              (("2"
                                                (flatten)
                                                (("2"
                                                  (split)
                                                  (("1"
                                                    (propax)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    nil
                                                    nil)
                                                   ("3"
                                                    (flatten)
                                                    (("3"
                                                      (rewrite-with-fnum
                                                       -4)
                                                      (("3"
                                                        (lemma
                                                         "res_lemma")
                                                        (("3"
                                                          (lemma
                                                           "res_lemma")
                                                          (("3"
                                                            (delete -8)
                                                            (("3"
                                                              (delete
                                                               -1)
                                                              (("3"
                                                                (delete
                                                                 1)
                                                                (("3"
                                                                  (inst
                                                                   -1
                                                                   "e!1"
                                                                   "-h!2"
                                                                   "t!1"
                                                                   "t!2")
                                                                  (("3"
                                                                    (split
                                                                     -1)
                                                                    (("1"
                                                                      (propax)
                                                                      nil
                                                                      nil)
                                                                     ("2"
                                                                      (propax)
                                                                      nil
                                                                      nil)
                                                                     ("3"
                                                                      (propax)
                                                                      nil
                                                                      nil)
                                                                     ("4"
                                                                      (assert)
                                                                      nil
                                                                      nil)
                                                                     ("5"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("3"
                                          (delete -3)
                                          (("3"
                                            (delete -5)
                                            (("3"
                                              (delete -3)
                                              (("3"
                                                (delete -4)
                                                (("3"
                                                  (delete 2)
                                                  (("3"
                                                    (expand
                                                     "resolve_aux"
                                                     :if-simplifies
                                                     T)
                                                    (("3"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (split)
                                      (("1"
                                        (split 2)
                                        (("1" (flatten) nil nil)
                                         ("2"
                                          (flatten)
                                          (("2"
                                            (inst
                                             -1
                                             "cons(h!2,acc!1)"
                                             "e!1"
                                             "flag!1")
                                            (("2"
                                              (split -1)
                                              (("1" (propax) nil nil)
                                               ("2"
                                                (delete 3)
                                                (("2"
                                                  (expand
                                                   "resolve_aux_cond"
                                                   1)
                                                  (("2"
                                                    (flatten)
                                                    (("2"
                                                      (split)
                                                      (("1"
                                                        (split)
                                                        (("1"
                                                          (propax)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (expand
                                                           "resolve_aux_cond"
                                                           -2)
                                                          (("2"
                                                            (split)
                                                            (("1"
                                                              (split)
                                                              (("1"
                                                                (grind)
                                                                nil
                                                                nil)
                                                               ("2"
                                                                (grind)
                                                                nil
                                                                nil)
                                                               ("3"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("3"
                                                (delete 3)
                                                (("3"
                                                  (delete -5)
                                                  (("3"
                                                    (delete -4)
                                                    (("3"
                                                      (delete -3)
                                                      (("3"
                                                        (expand
                                                         "resolve_aux"
                                                         -2
                                                         :if-simplifies
                                                         T)
                                                        (("3"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (split)
                                        (("1"
                                          (prop)
                                          (("1" (grind) nil nil))
                                          nil)
                                         ("2"
                                          (prop)
                                          (("2"
                                            (inst
                                             -1
                                             "cons(h!2,acc!1)"
                                             "e!1"
                                             "flag!1")
                                            (("2"
                                              (split -1)
                                              (("1" (propax) nil nil)
                                               ("2"
                                                (expand
                                                 "resolve_aux_cond"
                                                 1)
                                                (("2"
                                                  (expand
                                                   "resolve_aux_cond"
                                                   -1)
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("3"
                                                (expand
                                                 "resolve_aux"
                                                 -2)
                                                (("3"
                                                  (delete 3)
                                                  (("3"
                                                    (delete -5)
                                                    (("3"
                                                      (delete -3)
                                                      (("3"
                                                        (delete -3)
                                                        (("3"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sat_cons formula-decl nil clauses nil)
    (list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (clause type-eq-decl nil clauses nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (env type-eq-decl nil clauses nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (resolve_aux_cond const-decl "bool" clauses nil)
    (lift type-decl nil lift_adt nil)
    (up? adt-recognizer-decl "[lift -> boolean]" lift_adt nil)
    (resolve_aux def-decl "lift[clause]" clauses nil)
    (down adt-accessor-decl "[(up?) -> T]" lift_adt nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list_induction formula-decl nil list_adt nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (lookup const-decl "bool" clauses nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (res_lemma formula-decl nil clauses nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (FALSE const-decl "bool" booleans nil)
    (ltlit const-decl "bool" clauses nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (rev_append def-decl "list[T]" lists nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (sat_rev_append formula-decl nil clauses nil))
   shostak))
 (resolve_char 0
  (resolve_char-1 nil 3525625781
   ("" (skosimp)
    (("" (skosimp*)
      (("" (expand "resolve")
        (("" (lemma "resolve_aux") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((resolve const-decl "lift[clause]" clauses nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (resolve_aux_cond const-decl "bool" clauses nil)
    (lookup const-decl "bool" clauses nil)
    (resolve_aux formula-decl nil clauses nil))
   shostak))
 (insert_TCC1 0
  (insert_TCC1-1 nil 3525628562 ("" (subtype-tcc) nil nil) nil nil))
 (insert_TCC2 0
  (insert_TCC2-1 nil 3525628562 ("" (termination-tcc) nil nil) nil
   nil))
 (insert 0
  (insert-1 nil 3525630587 ("" (induct-and-simplify "cl") nil nil)
   ((ltlit const-decl "bool" clauses nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (insert def-decl "clause" clauses nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (env type-eq-decl nil clauses nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (clause type-eq-decl nil clauses nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (mkclause_TCC1 0
  (mkclause_TCC1-1 nil 3525628562 ("" (termination-tcc) nil nil) nil
   nil))
 (mkclause 0
  (mkclause-1 nil 3525630645
   ("" (lemma "insert")
    (("" (lemma "sat_cons_inv")
      (("" (induct-and-simplify "cl") nil nil)) nil))
    nil)
   ((insert formula-decl nil clauses nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (mkclause def-decl "clause" clauses nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (env type-eq-decl nil clauses nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (clause type-eq-decl nil clauses nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (sat_cons_inv formula-decl nil clauses nil))
   shostak))
 (itresolve_aux_TCC1 0
  (itresolve_aux_TCC1-1 nil 3525628562 ("" (subtype-tcc) nil nil) nil
   nil))
 (itresolve_aux_TCC2 0
  (itresolve_aux_TCC2-1 nil 3525628562 ("" (termination-tcc) nil nil)
   nil nil))
 (itresolve_aux_TCC3 0
  (itresolve_aux_TCC3-1 nil 3525628562 ("" (subtype-tcc) nil nil) nil
   nil))
 (itresolve_aux 0
  (itresolve_aux-1 nil 3525628562
   ("" (lemma "resolve_char")
    (("" (induct-and-simplify "cls") nil nil)) nil)
   ((resolve_aux def-decl "lift[clause]" clauses nil)
    (int nonempty-type-eq-decl nil integers nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (resolve const-decl "lift[clause]" clauses nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (clause type-eq-decl nil clauses nil)
    (down adt-accessor-decl "[(up?) -> T]" lift_adt nil)
    (itresolve_aux def-decl "lift[clause]" clauses nil)
    (up? adt-recognizer-decl "[lift -> boolean]" lift_adt nil)
    (lift type-decl nil lift_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (env type-eq-decl nil clauses nil)
    (resolve_char formula-decl nil clauses nil))
   shostak))
 (itresolve 0
  (itresolve-1 nil 3525628852
   ("" (lemma "itresolve_aux") (("" (grind) nil nil)) nil)
   ((minus_int_is_int application-judgement "int" integers nil)
    (itresolve const-decl "lift[clause]" clauses nil)
    (lookup const-decl "bool" clauses nil)
    (env type-eq-decl nil clauses nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (clause type-eq-decl nil clauses nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (itresolve_aux formula-decl nil clauses nil))
   shostak)))

