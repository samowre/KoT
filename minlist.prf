(minlist (minlistx_TCC1 0 (minlistx_TCC1-1 nil 3368668190 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (T formal-type-decl nil minlist nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil)) (minlistx_TCC2 0 (minlistx_TCC2-1 nil 3368668190 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (T formal-type-decl nil minlist nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (minlistx_TCC3 0 (minlistx_TCC3-1 nil 3368668190 ("" (skosimp* :preds? T) (("" (typepred "v!1(l1!1, key!1, c!1, k!1)") (("1" (replace -5 -1 :dir rl) (("1" (rewrite "member" 1) (("1" (assert) (("1" (replace -5 -2 :dir rl) (("1" (skosimp*) (("1" (rewrite "member" -8) (("1" (ground) (("1" (grind) nil nil) ("2" (inst - "b!1") (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil)) nil)) nil) ((<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (member def-decl "bool" list_props nil) (list type-decl nil list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (T formal-type-decl nil minlist nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil)) (minlistx_TCC4 0 (minlistx_TCC4-1 nil 3368668190 ("" (grind :if-match nil) (("1" (typepred "v!1(l1!1, key!1, c!1, key!1(c!1))") (("1" (grind) nil nil)) nil) ("2" (typepred "v!1(l1!1, key!1, c!1, key!1(c!1))") (("2" (grind) nil nil)) nil) ("3" (typepred "v!1(l1!1, key!1, c!1, key!1(c!1))") (("3" (grind) nil nil)) nil) ("4" (typepred "v!1(l1!1, key!1, c!1, key!1(c!1))") (("4" (grind) nil nil)) nil) ("5" (typepred "v!1(l1!1, key!1, a!1, m!1)") (("5" (grind) nil nil)) nil) ("6" (typepred "v!1(l1!1, key!1, a!1, m!1)") (("6" (grind :if-match all) nil nil)) nil) ("7" (typepred "v!1(l1!1, key!1, a!1, m!1)") (("7" (grind :if-match all) nil nil)) nil) ("8" (typepred "v!1(l1!1, key!1, a!1, m!1)") (("8" (grind :if-match all) nil nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (T formal-type-decl nil minlist nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (minlistx_TCC5 0 (minlistx_TCC5-2 nil 3394225773 ("" (skosimp* :preds? T) (("" (typepred "v!1(l1!1, key!1, a!1, m!1)") (("1" (rewrite "member" 2) (("1" (assert) (("1" (replace -5 2) (("1" (rewrite "member" 2) (("1" (rewrite "member" -1) (("1" (ground) (("1" (skosimp*) (("1" (rewrite "member" -1) (("1" (rewrite "member" -1) (("1" (ground) (("1" (inst - "b!1") (("1" (rewrite "member" -3) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (rewrite "member" -1) (("2" (rewrite "member" -1) (("2" (ground) (("1" (inst - "b!1") (("1" (rewrite "member" -3) nil nil)) nil) ("2" (case "key!1(c!1) >=  key!1(a!1)") (("1" (inst - "a!1") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil) ("3" (inst - "b!1") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ((<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (member def-decl "bool" list_props nil) (list type-decl nil list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (T formal-type-decl nil minlist nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil)) nil) (minlistx_TCC5-1 nil 3368668190 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (T formal-type-decl nil minlist nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (member def-decl "bool" list_props nil)) nil)) (minlistx_TCC6 0 (minlistx_TCC6-1 nil 3383533874 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (T formal-type-decl nil minlist nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (member def-decl "bool" list_props nil)) nil)) (minlist_TCC1 0 (minlist_TCC1-1 nil 3368652894 ("" (grind) (("1" (typepred "minlistx(cdr[T](l!1), key!1, car[T](l!1), key!1(car[T](l!1)))") (("1" (grind) nil nil)) nil) ("2" (typepred "minlistx(cdr[T](l!1), key!1, car[T](l!1), key!1(car[T](l!1)))") (("2" (grind) nil nil)) nil) ("3" (typepred "minlistx(cdr[T](l!1), key!1, car[T](l!1), key!1(car[T](l!1)))") (("3" (grind) nil nil)) nil)) nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (minlistx def-decl "{c |
         member(c, cons(a, l)) AND
          (FORALL b: member(b, cons(a, l)) IMPLIES key(c) <= key(b))}" minlist nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (real nonempty-type-from-decl nil reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil minlist nil) (list type-decl nil list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (member def-decl "bool" list_props nil)) nil)) (every_and 0 (every_and-1 nil 3378237551 ("" (induct-and-simplify "l") nil nil) ((list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil minlist nil) (list_induction formula-decl nil list_adt nil)) shostak)) (every_suffix?_TCC1 0 (every_suffix?_TCC1-1 nil 3378248877 ("" (subtype-tcc) nil nil) nil nil)) (every_suffix?_TCC2 0 (every_suffix?_TCC2-1 nil 3378248877 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) nil)) (every_suffix_impl 0 (every_suffix_impl-1 nil 3378248878 ("" (induct-and-simplify "l") nil nil) ((list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every_suffix? def-decl "bool" minlist nil) (T formal-type-decl nil minlist nil) (list_induction formula-decl nil list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)) shostak)) (member_nth 0 (member_nth-1 nil 3378609591 ("" (induct "l") (("1" (grind) nil nil) ("2" (grind :if-match nil) (("2" (case "n!1 > 0") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (> const-decl "bool" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil minlist nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (member def-decl "bool" list_props nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak)) (nthcdr_TCC1 0 (nthcdr_TCC1-1 nil 3378610515 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil minlist nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (nthcdr_TCC2 0 (nthcdr_TCC2-1 nil 3378610515 ("" (grind) (("" (expand "length" -) (("" (lift-if) (("" (ground) nil nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil minlist nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (nthcdr_TCC3 0 (nthcdr_TCC3-1 nil 3378610515 ("" (grind) (("" (expand "length" -) (("" (grind) nil nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil minlist nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil)) nil)) (nthcdr_TCC4 0 (nthcdr_TCC4-1 nil 3379624375 ("" (grind) (("" (expand "length" -) (("" (lift-if) (("" (ground) nil nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil minlist nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil)) nil)) (length_nthcdr 0 (length_nthcdr-1 nil 3378611490 ("" (induct "l") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (case "n!1 > 0") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (> const-decl "bool" reals nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil minlist nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nthcdr def-decl "(cons?[T])" minlist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak)) (nth_nthcdr_TCC1 0 (nth_nthcdr_TCC1-1 nil 3378610515 ("" (subtype-tcc) nil nil) nil nil)) (nth_nthcdr_TCC2 0 (nth_nthcdr_TCC2-1 nil 3378610515 ("" (skosimp*) (("" (rewrite "length_nthcdr") (("" (grind) nil nil)) nil)) nil) ((length_nthcdr formula-decl nil minlist nil) (T formal-type-decl nil minlist nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) nil)) (nth_nthcdr 0 (nth_nthcdr-1 nil 3378610516 ("" (induct "l") (("1" (grind) nil nil) ("2" (skosimp* :preds? T) (("2" (case "i!1 > 0") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("3" (skosimp*) (("3" (rewrite "length_nthcdr") (("3" (grind) nil nil)) nil)) nil)) nil) ((length_nthcdr formula-decl nil minlist nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil minlist nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil nat_types nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nthcdr def-decl "(cons?[T])" minlist nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) shostak)) (nthcdr_nthcdr 0 (nthcdr_nthcdr-1 nil 3380171282 ("" (induct "l") (("1" (grind) nil nil) ("2" (grind :if-match nil) (("2" (expand "nthcdr" +) (("2" (grind) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skosimp* :preds? T) (("3" (rewrite "length_nthcdr") nil nil)) nil)) nil)) nil) ((length_nthcdr formula-decl nil minlist nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (i!1 skolem-const-decl "below(length(cons(cons1_var!1, cons2_var!1)))" minlist nil) (cons2_var!1 skolem-const-decl "list[T]" minlist nil) (cons1_var!1 skolem-const-decl "T" minlist nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil minlist nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil nat_types nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nthcdr def-decl "(cons?[T])" minlist nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil)) shostak)) (nthcdr_every_suffix 0 (nthcdr_every_suffix-1 nil 3380168015 ("" (induct "l") (("1" (grind) nil nil) ("2" (grind :if-match nil) (("1" (expand "nthcdr" +) (("1" (grind) nil nil)) nil) ("2" (expand "nthcdr" +) (("2" (grind) nil nil)) nil)) nil)) nil) ((cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil minlist nil) (nthcdr def-decl "(cons?[T])" minlist nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (every_suffix? def-decl "bool" minlist nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak)) (every_suffix_nthcdr 0 (every_suffix_nthcdr-1 nil 3378952516 ("" (induct-and-simplify "l" :if-match nil) (("1" (typepred "i!1") (("1" (grind) nil nil)) nil) ("2" (typepred "i!1") (("2" (grind) nil nil)) nil) ("3" (case "i!1>0") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ((> const-decl "bool" reals nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (every_suffix? def-decl "bool" minlist nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nthcdr def-decl "(cons?[T])" minlist nil) (T formal-type-decl nil minlist nil) (list_induction formula-decl nil list_adt nil)) shostak)) (nthcar_cdr 0 (nthcar_cdr-1 nil 3379459200 ("" (induct-and-simplify "l" :if-match nil) (("1" (typepred "i!1") (("1" (grind) nil nil)) nil) ("2" (typepred "i!1") (("2" (case "i!1 > 0") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ((cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (> const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (append def-decl "list[T]" list_props nil) (below type-eq-decl nil nat_types nil) (nthcar def-decl "list[T]" minlist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nthcdr def-decl "(cons?[T])" minlist nil) (T formal-type-decl nil minlist nil) (list_induction formula-decl nil list_adt nil)) shostak)) (car_nthcar_TCC1 0 (car_nthcar_TCC1-1 nil 3380173641 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil minlist nil) (list type-decl nil list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (nthcar def-decl "list[T]" minlist nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (car_nthcar 0 (car_nthcar-1 nil 3380173642 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil minlist nil) (list type-decl nil list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (nthcar def-decl "list[T]" minlist nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak)) (car_nthcdr 0 (car_nthcdr-1 nil 3380215949 ("" (induct-and-simplify "l" :if-match nil) (("1" (expand "nthcdr" +) (("1" (grind :if-match nil) (("1" (grind) nil nil)) nil)) nil) ("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (below type-eq-decl nil nat_types nil) (nthcdr def-decl "(cons?[T])" minlist nil) (nth def-decl "T" list_props nil) (T formal-type-decl nil minlist nil) (list_induction formula-decl nil list_adt nil)) shostak)) (length_nthcar 0 (length_nthcar-1 nil 3382829940 ("" (induct "l") (("1" (assert) nil nil) ("2" (grind) nil nil) ("3" (grind :if-match nil) (("3" (case "i!1=0") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil minlist nil) (nthcar def-decl "list[T]" minlist nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak)) (nthcdr_append_TCC1 0 (nthcdr_append_TCC1-1 nil 3383533874 ("" (skosimp*) (("" (rewrite "length_append") (("" (typepred "i!1") (("" (assert) nil nil)) nil)) nil)) nil) ((length_append formula-decl nil list_props nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (T formal-type-decl nil minlist nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil)) nil)) (nthcdr_append 0 (nthcdr_append-1 nil 3383533875 ("" (induct "l") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skosimp*) (("3" (case "i!1 = 0") (("1" (grind) nil nil) ("2" (grind) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (grind :rewrites "length_append") nil nil)) nil)) nil) ((length_append formula-decl nil list_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil minlist nil) (nthcdr def-decl "(cons?[T])" minlist nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (append def-decl "list[T]" list_props nil)) shostak)) (delete_TCC1 0 (delete_TCC1-1 nil 3388327376 ("" (subtype-tcc) (("" (grind) nil nil)) nil) ((member def-decl "bool" list_props nil) (/= const-decl "boolean" notequal nil)) nil)) (delete_TCC2 0 (delete_TCC2-1 nil 3388327376 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) nil)) (delete_TCC3 0 (delete_TCC3-1 nil 3388327376 ("" (grind) (("1" (typepred "v!1(b!1, k!1)") (("1" (grind) nil nil)) nil) ("2" (typepred "v!1(b!1, k!1)") (("2" (grind) nil nil)) nil) ("3" (typepred "v!1(b!1, k!1)") (("3" (grind) nil nil)) nil)) nil) ((AND const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (T formal-type-decl nil minlist nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (member def-decl "bool" list_props nil) (/= const-decl "boolean" notequal nil)) nil)) (delete_TCC4 0 (delete_TCC4-1 nil 3388327376 ("" (grind) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) nil)) (delete_TCC5 0 (delete_TCC5-1 nil 3388330770 ("" (grind :if-match nil) (("1" (typepred "v!1(a!1, k!1)") (("1" (inst?) (("1" (ground) nil nil)) nil)) nil) ("2" (typepred "v!1(a!1, k!1)") (("2" (inst?) (("2" (ground) nil nil)) nil)) nil) ("3" (typepred "v!1(a!1, k!1)") (("3" (inst?) (("3" (ground) nil nil)) nil)) nil)) nil) ((AND const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (T formal-type-decl nil minlist nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (/= const-decl "boolean" notequal nil) (member def-decl "bool" list_props nil)) nil)) (member_append 0 (member_append-1 nil 3388330174 ("" (induct-and-simplify "k") nil nil) ((list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (member def-decl "bool" list_props nil) (append def-decl "list[T]" list_props nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil minlist nil) (list_induction formula-decl nil list_adt nil)) shostak)) (subset_TCC1 0 (subset_TCC1-1 nil 3392062366 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) nil)) (suffix?_TCC1 0 (suffix?_TCC1-1 nil 3392062366 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) nil)) (suffix_transitivity 0 (suffix_transitivity-1 nil 3392062366 ("" (induct "l") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (rewrite "suffix?" -2) (("2" (ground) (("2" (inst - "l1!1" "l2!1") (("2" (rewrite "suffix?" 1) (("2" (ground) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil minlist nil) (suffix? def-decl "bool" minlist nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak)) (suffix_transitivity_induction 0 (suffix_transitivity_induction-1 nil 3392062675 ("" (grind) nil nil) ((suffix? def-decl "bool" minlist nil)) shostak)) (suffix_null 0 (suffix_null-1 nil 3393859835 ("" (skolem 1 ("l1!1" "_")) (("" (induct-and-simplify "l2") nil nil)) nil) ((list_induction formula-decl nil list_adt nil) (T formal-type-decl nil minlist nil) (suffix? def-decl "bool" minlist nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak)) (suffix_length 0 (suffix_length-1 nil 3393877033 ("" (skolem 1 ("l1!1" "_")) (("" (induct-and-simplify "l2") (("" (replace -1) (("" (assert) nil nil)) nil)) nil)) nil) ((list_induction formula-decl nil list_adt nil) (T formal-type-decl nil minlist nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (suffix? def-decl "bool" minlist nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak)) (suffix_cons 0 (suffix_cons-1 nil 3475792895 ("" (induct l1) (("1" (grind) nil nil) ("2" (skolem-typepred) (("2" (flatten) (("2" (skolem-typepred) (("2" (flatten) (("2" (expand suffix? 1) (("2" (flatten) (("2" (expand suffix? -2) (("2" (split -2) (("1" (grind) (("1" (case "l2!1 = cons2_var!1") (("1" (grind) (("1" (expand suffix? 3) (("1" (lift-if 3) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (grind) (("2" (delete 2 3 4) (("2" (case "l2!1 = cdr(cons(a!1, l2!1))") (("1" (case "cons2_var!1 = cdr(cons(cons1_var!1, cons2_var!1))") (("1" (replace -1 1) (("1" (replace -2 1) (("1" (replace -3 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 a!1 l2!1) (("2" (replace -1 -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil minlist nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (suffix? def-decl "bool" minlist nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak)) (suffix_member 0 (suffix_member-1 nil 3394227109 ("" (skolem 1 ("l1!1" "_")) (("" (induct "l2") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (rewrite "suffix?" -2) (("2" (split -2) (("1" (replace -1) (("1" (grind) nil nil)) nil) ("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (suffix? def-decl "bool" minlist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (member def-decl "bool" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (T formal-type-decl nil minlist nil) (list_induction formula-decl nil list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)) shostak)) (some_member 0 (some_member-1 nil 3475793779 ("" (induct-and-simplify "l") nil nil) ((list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (some adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (T formal-type-decl nil minlist nil) (list_induction formula-decl nil list_adt nil)) shostak)) (presuffix_nil 0 (presuffix_nil-1 nil 3394227287 ("" (induct-and-simplify "l") nil nil) ((list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (presuffix def-decl "list[T]" minlist nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (T formal-type-decl nil minlist nil) (list_induction formula-decl nil list_adt nil)) shostak)) (some_nth 0 (some_nth-1 nil 3462932621 ("" (induct "l") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "some" +) (("2" (ground) (("1" (inst?) (("1" (ground) (("1" (skosimp*) (("1" (inst + "i!1 + 1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("2" (inst 3 0) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (inst?) (("2" (ground) (("2" (skosimp*) (("2" (inst + "i!1 + 1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (inst?) (("3" (ground) (("3" (skosimp*) (("3" (case "i!1 = 0") (("1" (grind) nil nil) ("2" (inst + "i!1 - 1") (("1" (grind) nil nil) ("2" (grind) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (cons2_var!1 skolem-const-decl "list[T]" minlist nil) (i!1 skolem-const-decl "below(length(cons2_var!1))" minlist nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons1_var!1 skolem-const-decl "T" minlist nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (i!1 skolem-const-decl "below(length(cons2_var!1))" minlist nil) (= const-decl "[T, T -> boolean]" equalities nil) (i!1 skolem-const-decl "below(length(cons(cons1_var!1, cons2_var!1)))" minlist nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil minlist nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (some adt-def-decl "boolean" list_adt nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak)) (find_TCC1 0 (find_TCC1-1 nil 3463936152 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil minlist nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (find_TCC2 0 (find_TCC2-1 nil 3463936152 ("" (subtype-tcc) nil nil) nil nil)) (find_TCC3 0 (find_TCC3-1 nil 3463936152 ("" (skosimp*) (("" (ground) (("" (grind) nil nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (some adt-def-decl "boolean" list_adt nil)) nil)) (find_TCC4 0 (find_TCC4-1 nil 3463936152 ("" (grind) nil nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil)) nil)) (find_TCC5 0 (find_TCC5-1 nil 3463936152 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) nil)) (find_TCC6 0 (find_TCC6-1 nil 3463936152 ("" (skosimp* :preds? t) (("" (grind) (("" (typepred "v!1(P!1, k!1)") (("" (ground) nil nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (some adt-def-decl "boolean" list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (T formal-type-decl nil minlist nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil)) nil)) (find_TCC7 0 (find_TCC7-1 nil 3463937007 ("" (skosimp* :preds? t) (("" (typepred "v!1(P!1, k!1)") (("" (ground) (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (skosimp*) (("3" (expand "nth" -1) (("3" (ground) (("1" (grind) nil nil) ("2" (typepred "j!1") (("2" (inst - "j!1 - 1") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) (("6" (case "j!1 = 0") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((some adt-def-decl "boolean" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (T formal-type-decl nil minlist nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil)) (some_every 0 (some_every-1 nil 3463942791 ("" (induct-and-simplify "l") nil nil) ((list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (some adt-def-decl "boolean" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (T formal-type-decl nil minlist nil) (list_induction formula-decl nil list_adt nil)) shostak)) (find_zero 0 (find_zero-1 nil 3463942652 ("" (skosimp*) (("" (typepred "find(P!1, l!1)") (("" (use "some_nth") (("" (rewrite "some_every") (("" (ground) (("1" (inst? +) nil nil) ("2" (inst? +) nil nil)) nil)) nil)) nil)) nil)) nil) ((find def-decl "{i: upto(length(l)) |
         (i > 0 =>
           (P(nth(l, i - 1)) &
             (FORALL (j: below(i - 1)): NOT P(nth(l, j)))))
          & (i = 0 => NOT some(P)(l))}" minlist nil) (some adt-def-decl "boolean" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (T formal-type-decl nil minlist nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (some_every formula-decl nil minlist nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (some_nth formula-decl nil minlist nil)) shostak)) (find_nonzero_TCC1 0 (find_nonzero_TCC1-1 nil 3463943932 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil)) (find_nonzero_TCC2 0 (find_nonzero_TCC2-1 nil 3463943932 ("" (subtype-tcc) nil nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (find def-decl "{i: upto(length(l)) |
         (i > 0 =>
           (P(nth(l, i - 1)) &
             (FORALL (j: below(i - 1)): NOT P(nth(l, j)))))
          & (i = 0 => NOT some(P)(l))}" minlist nil) (some adt-def-decl "boolean" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (<= const-decl "bool" reals nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (T formal-type-decl nil minlist nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) nil)) (find_nonzero 0 (find_nonzero-1 nil 3463943933 ("" (skosimp*) (("" (typepred "find(P!1, l!1)") (("" (grind) nil nil)) nil)) nil) ((find def-decl "{i: upto(length(l)) |
         (i > 0 =>
           (P(nth(l, i - 1)) &
             (FORALL (j: below(i - 1)): NOT P(nth(l, j)))))
          & (i = 0 => NOT some(P)(l))}" minlist nil) (some adt-def-decl "boolean" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (upto nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (T formal-type-decl nil minlist nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak)) (rassoc2_TCC1 0 (rassoc2_TCC1-1 nil 3475041293 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) nil)) (setlist?_TCC1 0 (setlist?_TCC1-1 nil 3475041293 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) nil)) (list2set_member 0 (list2set_member-1 nil 3475074977 ("" (induct-and-simplify "k") nil nil) ((list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (set type-eq-decl nil sets nil) (list2set def-decl "set[T]" list2set nil) (member def-decl "bool" list_props nil) (T formal-type-decl nil minlist nil) (list_induction formula-decl nil list_adt nil) (emptyset const-decl "set" sets nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil)) shostak)) (subset_member 0 (subset_member-1 nil 3475074742 ("" (induct "k") (("1" (grind) nil nil) ("2" (grind :if-match nil) (("1" (inst?) (("1" (replace -1 :hide? t) (("1" (grind :rewrites "list2set_member") nil nil)) nil)) nil) ("2" (inst?) (("2" (replace -1 :hide? t) (("2" (inst?) (("2" (grind :rewrites "list2set_member") nil nil)) nil)) nil)) nil) ("3" (inst?) (("3" (replace -1 :hide? t) (("3" (skosimp*) (("3" (inst?) (("3" (ground) nil nil)) nil)) nil)) nil)) nil) ("4" (inst? -2) (("4" (grind :rewrites "list2set_member") nil nil)) nil)) nil)) nil) ((add const-decl "(nonempty?)" sets nil) (list2set_member formula-decl nil minlist nil) (emptyset const-decl "set" sets nil) (member const-decl "bool" sets nil) (list_induction formula-decl nil list_adt nil) (T formal-type-decl nil minlist nil) (list2set def-decl "set[T]" list2set nil) (subset? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (subset def-decl "bool" minlist nil) (= const-decl "[T, T -> boolean]" equalities nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak)) (every_member_subset 0 (every_member_subset-1 nil 3482786280 ("" (induct k) (("1" (grind) nil nil) ("2" (skosimp) (("2" (skosimp) (("2" (split) (("1" (flatten) (("1" (skosimp) (("1" (expand subset -1) (("1" (flatten) (("1" (expand member -3) (("1" (split -3) (("1" (grind) nil nil) ("2" (inst -4 l!1) (("2" (replace -3) (("2" (flatten) (("2" (inst -4 a!1) (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand subset 1) (("2" (split) (("1" (inst -1 cons1_var!1) (("1" (grind) nil nil)) nil) ("2" (inst -2 l!1) (("2" (assert) (("2" (skolem-typepred) (("2" (flatten) (("2" (inst -1 a!1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list_induction formula-decl nil list_adt nil) (T formal-type-decl nil minlist nil) (member def-decl "bool" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (subset def-decl "bool" minlist nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak)) (setify_TCC1 0 (setify_TCC1-1 nil 3475041293 ("" (grind) nil nil) ((setlist? def-decl "bool" minlist nil) (subset def-decl "bool" minlist nil)) nil)) (setify_TCC2 0 (setify_TCC2-1 nil 3475041293 ("" (termination-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) nil)) (setify_TCC3 0 (setify_TCC3-1 nil 3475041293 ("" (skosimp* :preds? t) (("" (typepred "v!1(k!1)") (("1" (grind) (("1" (rewrite "subset_member") (("1" (expand "subset?") (("1" (grind :polarity? t) (("1" (inst?) (("1" (rewrite "subset_member") (("1" (inst? :polarity? t) (("1" (ground) (("1" (rewrite "list2set_member") nil nil) ("2" (rewrite "list2set_member") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind :rewrites ("subset_member" "list2set_member")) (("2" (expand "subset?") (("2" (grind :polarity? t) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil) ((subset def-decl "bool" minlist nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (setlist? def-decl "bool" minlist nil) (list type-decl nil list_adt nil) (T formal-type-decl nil minlist nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (list2set def-decl "set[T]" list2set nil) (add const-decl "(nonempty?)" sets nil) (subset_member formula-decl nil minlist nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (member const-decl "bool" sets nil) (list2set_member formula-decl nil minlist nil) (subset? const-decl "bool" sets nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil)) (setify_TCC4 0 (setify_TCC4-1 nil 3475074741 ("" (skosimp* :preds? t) (("" (typepred "v!1(k!1)") (("1" (grind :rewrites ("subset_member" "list2set_member")) (("1" (expand "subset?") (("1" (inst?) (("1" (skosimp*) (("1" (hide -2) (("1" (inst - "x!1") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind :rewrites ("subset_member" "list2set_member") :if-match nil) (("2" (inst - "x!1") (("2" (grind) nil nil)) nil)) nil) ("3" (grind :rewrites ("subset_member" "list2set_member")) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ((subset def-decl "bool" minlist nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (setlist? def-decl "bool" minlist nil) (list type-decl nil list_adt nil) (T formal-type-decl nil minlist nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (subset? const-decl "bool" sets nil) (list2set_member formula-decl nil minlist nil) (member const-decl "bool" sets nil) (list2set def-decl "set[T]" list2set nil) (add const-decl "(nonempty?)" sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (subset_member formula-decl nil minlist nil) (member def-decl "bool" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil)) (setify_null 0 (setify_null-1 nil 3475127571 ("" (induct-and-simplify "l") nil nil) ((list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (setlist? def-decl "bool" minlist nil) (subset def-decl "bool" minlist nil) (setify def-decl "{k | setlist?(k) AND subset(k, l) AND subset(l, k)}" minlist nil) (T formal-type-decl nil minlist nil) (list_induction formula-decl nil list_adt nil) (member def-decl "bool" list_props nil)) shostak)) (delete_append 0 (delete_append-1 nil 3475777254 ("" (induct-and-simplify "k") nil nil) ((list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (bool nonempty-type-eq-decl nil booleans nil) (member def-decl "bool" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (delete def-decl "{l1 | (FORALL c: member(c, l1) = (c /= a AND member(c, l)))}" minlist nil) (append def-decl "list[T]" list_props nil) (T formal-type-decl nil minlist nil) (list_induction formula-decl nil list_adt nil)) shostak)) (every_forall 0 (every_forall-1 nil 3479851588 ("" (induct-and-simplify "l" :if-match nil) (("1" (inst?) (("1" (rewrite -1) (("1" (inst? :polarity? t) (("1" (ground) nil nil)) nil)) nil)) nil) ("2" (rewrite -1) (("2" (hide -1) (("2" (grind :polarity? t) nil nil)) nil)) nil) ("3" (grind :polarity? t) nil nil)) nil) ((list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (every adt-def-decl "boolean" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (T formal-type-decl nil minlist nil) (list_induction formula-decl nil list_adt nil)) shostak)) (some_exists 0 (some_exists-1 nil 3479852153 ("" (induct-and-simplify "l" :if-match nil) (("1" (grind :polarity? t) nil nil) ("2" (rewrite -1) (("2" (grind :polarity? t) nil nil)) nil) ("3" (rewrite -1) (("3" (grind :polarity? t) nil nil)) nil)) nil) ((list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (some adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (T formal-type-decl nil minlist nil) (list_induction formula-decl nil list_adt nil)) shostak)) (member_suffix 0 (member_suffix-1 nil 3479852581 ("" (induct-and-simplify "l1" :if-match nil) (("1" (replace -2) (("1" (assert) nil nil)) nil) ("2" (replace -2) (("2" (assert) nil nil)) nil) ("3" (grind :polarity? t) nil nil)) nil) ((list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (suffix? def-decl "bool" minlist nil) (member def-decl "bool" list_props nil) (T formal-type-decl nil minlist nil) (list_induction formula-decl nil list_adt nil)) shostak)))
