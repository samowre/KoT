minlist   [T : TYPE ]
		: THEORY

  BEGIN

   a, b, c: VAR T
   l, l1, l2, k: VAR list[T]

   minlistx(l,  (key : [T -> real]), a, (m : real | key(a) = m)): RECURSIVE
     {c | member(c, cons(a, l)) AND (FORALL b: member(b,cons(a,l)) IMPLIES key(c) <= key(b))}
   = (CASES l OF
       cons(c, l1):
         LET k = key(c)
          IN IF k < m
              THEN minlistx(l1, key, c, k)
              ELSE minlistx(l1, key, a, m)
             ENDIF,
        null: a
       ENDCASES)
     MEASURE length(l)

   func : VAR [T -> real]

   minlist((l: (cons?[T])), (key : [T -> real])):
      {c | member(c, l) AND (FORALL b: member(b, l) IMPLIES key(c)<=key(b))}
    = minlistx(cdr(l), key, car(l), key(car(l)))


  P, Q: VAR PRED[T]

  pp, qq: VAR [(cons?[T])-> bool]

  member_nth: LEMMA
    (FORALL (n: below(length(l))): 
      member(nth(l, n), l))

  nthcdr(l, (n:below[length(l)])): RECURSIVE (cons?[T]) =
    IF n = 0 THEN l ELSE nthcdr(cdr(l), n-1) ENDIF
   MEASURE length(l)

  length_nthcdr: LEMMA
   FORALL (n: below(length(l))): 
     length(nthcdr(l, n)) = length(l) - n

  nth_nthcdr: LEMMA
    FORALL (i: below(length(l))), (j: below(length(l) - i)): 
     nth(l, i + j) = nth(nthcdr(l, i), j)

  nthcdr_nthcdr: LEMMA
     FORALL (i: below(length(l))), (j: below(length(l) - i)): 
     nthcdr(nthcdr(l, i), j) = nthcdr(l, i+ j)
     
  nth(l)(i:below(length(l))): T = nth(l, i)

  nthcdr_every_suffix: LEMMA
    every_suffix?(pp)(l) IMPLIES
       (FORALL (i: below(length(l))):
           every_suffix?(pp)(nthcdr(l, i)))

  every_suffix_nthcdr: LEMMA
      every_suffix?(pp)(l) IMPLIES
       (FORALL (i: below(length(l))):
         cons?(nthcdr(l, i)) IMPLIES
           pp(nthcdr(l, i)))

  nthcar(l, (n:below[length(l)])): RECURSIVE list[T] =
    IF n = 0 THEN null ELSE cons(car(l), nthcar(cdr(l), n-1)) ENDIF
   MEASURE length(l)

  nthcar_cdr: LEMMA
   (FORALL (i:below(length(l))): 
    append(nthcar(l, i), nthcdr(l, i)) = l)

  car_nthcar: LEMMA
  FORALL (l: (cons?[T])), (i: below(length(l))): 
    i > 0 => 
     car(nthcar(l, i)) = car(l)

  car_nthcdr: LEMMA
     FORALL (l: (cons?[T])), (i: below(length(l))): 
      car(nthcdr(l, i)) = nth(l, i)

    length_nthcar: LEMMA FORALL (l: (cons?[T])), (i: below(length(l))): length(nthcar(l, i)) = i;

   nthcdr_append: LEMMA
     FORALL (l: (cons?[T])), (i: below(length(l))):
      nthcdr(append(l, k), i) = append(nthcdr(l, i), k)

   subset(k, l): RECURSIVE bool =
    (CASES k OF
     null: TRUE,
     cons(a, l1): member(a, l) AND subset(l1, l)
     ENDCASES)
    MEASURE length(k)

IMPORTING lists
     
    find(P, l): RECURSIVE {i : upto(length(l)) |
                             (i > 0 => (P(nth(l, i-1)) &
                                        (FORALL (j: below(i-1)):
					    NOT P(nth(l, j)))))
	                    & (i = 0 => NOT some(P)(l))}
     = CASES l OF
        null: 0,
	cons(b, k): IF P(b) THEN 1 ELSIF find(P, k) = 0 THEN 0 ELSE 1 + find(P, k) ENDIF
       ENDCASES
       MEASURE length(l)

     CONVERSION+ K_conversion

     find_zero: LEMMA
       find(P, l) = 0 IFF every(NOT P)(l);

     find_nonzero: LEMMA
       find(P, l) > 0 IMPLIES
            P(nth(l, find(P, l) - 1)) AND
            (FORALL (j : below(find(P, l) - 1)): NOT P(nth(l, j)))

     rassoc2(a, k, l): RECURSIVE T =
       CASES k OF
         null: a,
	 cons(b, k1): (IF cons?(l)
	                THEN IF a = b
			     THEN car(l)
			     ELSE rassoc2(a, k1, cdr(l))
			     ENDIF
			ELSE a ENDIF)
       ENDCASES
      MEASURE length(k)

     maxlist((l | cons?(l)), (key : [T -> real])): T =
       minlist(l, (LAMBDA a: -key(a)))

     list2set_member: LEMMA list2set(k)(a) = member(a, k)

     subset_member: LEMMA subset(k, l) = subset?(k, l)

     every_member_subset: LEMMA subset(k, l) <=> (FORALL a: member(a, k) => member(a, l))

     setify_null: LEMMA
       null?(setify(l)) = null?(l)

     delete_append: LEMMA
       delete(a, append(k, l)) = append(delete(a, k), delete(a, l))

  END minlist
