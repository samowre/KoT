(rule (goodproof?_TCC1 0 (goodproof?_TCC1-1 nil 3474924292 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (fmla type-decl nil fmla nil) (list type-decl nil list_adt nil) (sentence_list? const-decl "bool" fmla nil) (sequent type-eq-decl nil sequents nil) (<< adt-def-decl "(well_founded?[proof])" rule nil) (list2set def-decl "set[T]" list2set nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (subset? const-decl "bool" sets nil) (or_rule? const-decl "bool" sequents nil)) nil)) (goodproof?_TCC2 0 (goodproof?_TCC2-1 nil 3474924292 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (fmla type-decl nil fmla nil) (list type-decl nil list_adt nil) (sentence_list? const-decl "bool" fmla nil) (sequent type-eq-decl nil sequents nil) (<< adt-def-decl "(well_founded?[proof])" rule nil) (list2set def-decl "set[T]" list2set nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (subset? const-decl "bool" sets nil) (nor_rule? const-decl "bool" sequents nil)) nil)) (goodproof?_TCC3 0 (goodproof?_TCC3-1 nil 3474924292 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (fmla type-decl nil fmla nil) (list type-decl nil list_adt nil) (sentence_list? const-decl "bool" fmla nil) (sequent type-eq-decl nil sequents nil) (<< adt-def-decl "(well_founded?[proof])" rule nil) (list2set def-decl "set[T]" list2set nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (subset? const-decl "bool" sets nil) (nor_rule? const-decl "bool" sequents nil)) nil)) (goodproof?_TCC4 0 (goodproof?_TCC4-1 nil 3474924292 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (fmla type-decl nil fmla nil) (list type-decl nil list_adt nil) (sentence_list? const-decl "bool" fmla nil) (sequent type-eq-decl nil sequents nil) (<< adt-def-decl "(well_founded?[proof])" rule nil) (list2set def-decl "set[T]" list2set nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (subset? const-decl "bool" sets nil) (neg_rule? const-decl "bool" sequents nil)) nil)) (goodproof?_TCC5 0 (goodproof?_TCC5-1 nil 3474924292 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (fmla type-decl nil fmla nil) (list type-decl nil list_adt nil) (sentence_list? const-decl "bool" fmla nil) (sequent type-eq-decl nil sequents nil) (<< adt-def-decl "(well_founded?[proof])" rule nil) (sentence? const-decl "bool" fmla nil) (list2set def-decl "set[T]" list2set nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (subset? const-decl "bool" sets nil) (cut_rule? const-decl "bool" sequents nil)) nil)) (goodproof?_TCC6 0 (goodproof?_TCC6-1 nil 3474924292 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (fmla type-decl nil fmla nil) (list type-decl nil list_adt nil) (sentence_list? const-decl "bool" fmla nil) (sequent type-eq-decl nil sequents nil) (<< adt-def-decl "(well_founded?[proof])" rule nil) (sentence? const-decl "bool" fmla nil) (list2set def-decl "set[T]" list2set nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (subset? const-decl "bool" sets nil) (cut_rule? const-decl "bool" sequents nil)) nil)) (goodproof?_TCC7 0 (goodproof?_TCC7-1 nil 3474924292 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (fmla type-decl nil fmla nil) (list type-decl nil list_adt nil) (sentence_list? const-decl "bool" fmla nil) (sequent type-eq-decl nil sequents nil) (<< adt-def-decl "(well_founded?[proof])" rule nil) (list2set def-decl "set[T]" list2set nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (subset? const-decl "bool" sets nil) (exists_rule? const-decl "bool" sequents nil)) nil)) (goodproof?_TCC8 0 (goodproof?_TCC8-1 nil 3474924292 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (funpred type-decl nil funpred_adt nil) (ufun? adt-recognizer-decl "[funpred -> boolean]" funpred_adt nil) (fmla type-decl nil fmla nil) (list type-decl nil list_adt nil) (sentence_list? const-decl "bool" fmla nil) (sequent type-eq-decl nil sequents nil) (<< adt-def-decl "(well_founded?[proof])" rule nil) (freesymbols def-decl "list[(usymb?)]" fmla nil) (freesymbols def-decl "list[(usymb?)]" fmla nil) (f_neg const-decl "fmla" fmla nil) (list2set def-decl "set[T]" list2set nil) (member const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (subset? const-decl "bool" sets nil) (forall_rule? const-decl "bool" sequents nil)) nil)) (goodproof?_TCC9 0 (goodproof?_TCC9-1 nil 3474924292 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (funpred type-decl nil funpred_adt nil) (ufun? adt-recognizer-decl "[funpred -> boolean]" funpred_adt nil) (term type-decl nil fmla nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (var? adt-recognizer-decl "[term -> boolean]" fmla nil) (fmla type-decl nil fmla nil) (sentence_list? const-decl "bool" fmla nil) (sequent type-eq-decl nil sequents nil) (<< adt-def-decl "(well_founded?[proof])" rule nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (fschema_rule? const-decl "bool" sequents nil)) nil)) (goodproof?_TCC10 0 (goodproof?_TCC10-1 nil 3474924292 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (funpred type-decl nil funpred_adt nil) (upred? adt-recognizer-decl "[funpred -> boolean]" funpred_adt nil) (term type-decl nil fmla nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (var? adt-recognizer-decl "[term -> boolean]" fmla nil) (fmla type-decl nil fmla nil) (sentence_list? const-decl "bool" fmla nil) (sequent type-eq-decl nil sequents nil) (<< adt-def-decl "(well_founded?[proof])" rule nil) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil) (pschema_rule? const-decl "bool" sequents nil)) nil)) (reflex_thm_TCC1 0 (reflex_thm_TCC1-1 nil 3474924292 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (fmla type-decl nil fmla nil) (list type-decl nil list_adt nil) (sequent type-eq-decl nil sequents nil) (term type-decl nil fmla nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (var? adt-recognizer-decl "[term -> boolean]" fmla nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (termvars def-decl "list[(var?)]" fmla nil) (nterm type-eq-decl nil rule nil) (f_eq const-decl "fmla" sequents nil) (termvars def-decl "list[(var?)]" fmla nil) (append def-decl "list[T]" list_props nil) (freevars def-decl "list[(var?)]" fmla nil) (freevars def-decl "list[(var?)]" fmla nil) (sentence_list? const-decl "bool" fmla nil)) nil)) (reflex_thm 0 (reflex_thm-1 nil 3474924292 ("" (grind) (("" (inst + "reflex(cons(atom(ipred(0, 2), (: ns!1, ns!1 :)), G!1))") (("" (grind :defs !) nil nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (freevars def-decl "list[(var?)]" fmla nil) (freevars def-decl "list[(var?)]" fmla nil) (append def-decl "list[T]" list_props nil) (termvars def-decl "list[(var?)]" fmla nil) (proof type-decl nil rule nil) (reflex? adt-recognizer-decl "[proof -> boolean]" rule nil) (reflex adt-constructor-decl "[sequent -> (reflex?)]" rule nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (funpred type-decl nil funpred_adt nil) (pred? adt-def-decl "boolean" funpred_adt nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (arity shared-adt-accessor-decl "[funpred -> nat]" funpred_adt nil) (atom? adt-recognizer-decl "[fmla -> boolean]" fmla nil) (atom adt-constructor-decl "[[pred: (pred?), {ss: list[term] | length(ss) = arity(pred)}] -> (atom?)]" fmla nil) (ipred? adt-recognizer-decl "[funpred -> boolean]" funpred_adt nil) (ipred adt-constructor-decl "[[nat, nat] -> (ipred?)]" funpred_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (equality? const-decl "bool" sequents nil) (nth def-decl "T" list_props nil) (refl_equality? const-decl "bool" sequents nil) (reflex_rule? const-decl "bool" sequents nil) (goodproof? def-decl "bool" rule nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (fmla type-decl nil fmla nil) (list type-decl nil list_adt nil) (sentence_list? const-decl "bool" fmla nil) (sequent type-eq-decl nil sequents nil) (term type-decl nil fmla nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (var? adt-recognizer-decl "[term -> boolean]" fmla nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (termvars def-decl "list[(var?)]" fmla nil) (nterm type-eq-decl nil rule nil) (theorem? const-decl "bool" rule nil) (f_eq const-decl "fmla" sequents nil)) shostak)) (trans_thm_TCC1 0 (trans_thm_TCC1-1 nil 3474925722 ("" (grind) nil nil) ((f_eq const-decl "fmla" sequents nil) (termvars def-decl "list[(var?)]" fmla nil) (append def-decl "list[T]" list_props nil) (freevars def-decl "list[(var?)]" fmla nil) (freevars def-decl "list[(var?)]" fmla nil) (sentence_list? const-decl "bool" fmla nil)) nil)) (trans_thm 0 (trans_thm-2 "" 3542728547 ("" (grind) (("" (inst + "pschema(upred(0, 2), (: v(0), v(1) :), f_eq(v(0), v(1)),
                           (: atom(ipred(0, 2), (: nr!1, nt!1 :)),
                 f_not(atom(ipred(0, 2), (: nr!1, ns!1 :))),
                 f_not(atom(ipred(0, 2), (: ns!1, nt!1 :))) :),
                  pcongruence((: atom(upred(0, 2), (: nr!1, nt!1 :)),
                 f_not(atom(upred(0, 2), (: nr!1, ns!1 :))),
                 f_not(f_eq(ns!1, nt!1)) :)))") (("" (grind) (("1" (decompose-equality -4) (("1" (assert) nil nil)) nil) ("2" (decompose-equality -4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) nil shostak) (trans_thm-1 nil 3474926238 ("" (grind) (("" (inst + "pschema(upred(0, 2), (: v(0), v(1) :), f_eq(v(0), v(1)),
                         (: atom(ipred(0, 2), (: nr!1, nt!1 :)),
               f_not(atom(ipred(0, 2), (: nr!1, ns!1 :))),
               f_not(atom(ipred(0, 2), (: ns!1, nt!1 :))) :),
                pcongruence((: atom(upred(0, 2), (: nr!1, nt!1 :)),
               f_not(atom(upred(0, 2), (: nr!1, ns!1 :))),
               f_not(f_eq(ns!1, nt!1)) :)))") (("" (grind) nil nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (freevars def-decl "list[(var?)]" fmla nil) (freevars def-decl "list[(var?)]" fmla nil) (append def-decl "list[T]" list_props nil) (termvars def-decl "list[(var?)]" fmla nil) (proof type-decl nil rule nil) (funpred type-decl nil funpred_adt nil) (upred? adt-recognizer-decl "[funpred -> boolean]" funpred_adt nil) (fmla type-decl nil fmla nil) (sentence_list? const-decl "bool" fmla nil) (sequent type-eq-decl nil sequents nil) (pscheme? adt-recognizer-decl "[proof -> boolean]" rule nil) (pschema adt-constructor-decl "[[(upred?), list[(var?)], fmla, sequent, proof] -> (pscheme?)]" rule nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (upred adt-constructor-decl "[[nat, nat] -> (upred?)]" funpred_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (v adt-constructor-decl "[nat -> (var?)]" fmla nil) (null adt-constructor-decl "(null?)" list_adt nil) (pred? adt-def-decl "boolean" funpred_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (arity shared-adt-accessor-decl "[funpred -> nat]" funpred_adt nil) (atom? adt-recognizer-decl "[fmla -> boolean]" fmla nil) (atom adt-constructor-decl "[[pred: (pred?), {ss: list[term] | length(ss) = arity(pred)}] -> (atom?)]" fmla nil) (ipred? adt-recognizer-decl "[funpred -> boolean]" funpred_adt nil) (ipred adt-constructor-decl "[[nat, nat] -> (ipred?)]" funpred_adt nil) (f_not? adt-recognizer-decl "[fmla -> boolean]" fmla nil) (f_not adt-constructor-decl "[fmla -> (f_not?)]" fmla nil) (pcongruence? adt-recognizer-decl "[proof -> boolean]" rule nil) (pcongruence adt-constructor-decl "[sequent -> (pcongruence?)]" rule nil) (v_index adt-accessor-decl "[(var?) -> nat]" fmla nil) (finite_emptyset name-judgement "finite_set" finite_sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (goodproof? def-decl "bool" rule nil) (pcongruence_rule? const-decl "bool" sequents nil) (reduce2 def-decl "T" map2 nil) (member def-decl "bool" list_props nil) (pschema_rule? const-decl "bool" sequents nil) (psubst def-decl "fmla" fmla nil) (parsubst const-decl "fmla" fmla nil) (parsubstr def-decl "fmla" fmla nil) (map adt-def-decl "list[T1]" list_adt_map nil) (parsubst def-decl "term" fmla nil) (rassoc2 def-decl "T" minlist nil) (max_index const-decl "nat" fmla nil) (subset? const-decl "bool" sets nil) (add const-decl "(nonempty?)" sets nil) (member const-decl "bool" sets nil) (emptyset const-decl "set" sets nil) (list2set def-decl "set[T]" list2set nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (term type-decl nil fmla nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (var? adt-recognizer-decl "[term -> boolean]" fmla nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (termvars def-decl "list[(var?)]" fmla nil) (nterm type-eq-decl nil rule nil) (theorem? const-decl "bool" rule nil) (f_eq const-decl "fmla" sequents nil)) shostak)) (f_exists_TCC1 0 (f_exists_TCC1-1 nil 3542723864 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (term type-decl nil fmla nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (var? adt-recognizer-decl "[term -> boolean]" fmla nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) nil)) (f_exists_bindings_TCC1 0 (f_exists_bindings_TCC1-1 nil 3542723864 ("" (termination-tcc) nil nil) ((<< adt-def-decl "(well_founded?[fmla])" fmla nil)) nil)))
