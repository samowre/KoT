list_filter_props[T: TYPE]: THEORY
BEGIN
  l, m,pp,np: VAR list[T]
  p: VAR pred[T]
  pi: VAR pred[[nat,T]]
  x: VAR T
  i,j: VAR nat
  
  filter_member: RECURSIVE JUDGEMENT
    filter(l, p) HAS_TYPE { m | FORALL x: member(x, m) IFF p(x) AND member(x, l) }

  filter_cons: THEOREM filter(cons(x, l), p) =
    IF p(x) THEN cons(x, filter(l, p)) 
  	    ELSE filter(l, p) ENDIF
  filter_null: THEOREM filter(null,p) = null 

  filter_append: LEMMA
    filter(append(l, m), p) = append(filter(l, p), filter(m, p))

  % Returns the sublist of l verifying p and the one verifying not p
  partition_aux(l,pi,i): RECURSIVE [list[T],list[T]] = 
  	CASES l OF
	   null: (null,null),
 	   cons(h,t): LET (pp,np) = partition_aux(t,pi,i+1) IN
	   	      IF pi(i,h) THEN (cons(h,pp),np)
		      	      	 ELSE (pp,cons(h,np))
 		      ENDIF
	ENDCASES
  MEASURE length(l)
  
  partition_pos(l,pi): [list[T],list[T]] = partition_aux(l,pi,0)
  partition(l,p): MACRO [list[T],list[T]] = partition_pos(l,LAMBDA i,x: p(x))

  % The same as filter, except that the predicates may depend on the position of the element
  filter_pos(l,pi): list[T] = proj_1(partition_pos(l,pi))


  % Specifictations: 
    % Characterisation
  partition_aux_char: RECURSIVE JUDGEMENT partition_aux(l,pi,i) HAS_TYPE 
  	{ (pp,np) | FORALL x: 
	  	  (member(x,pp) IFF EXISTS (j:below(length(l))): nth(l,j)=x AND pi(i+j,x)) AND 
  		  (member(x,np) IFF EXISTS (j:below(length(l))): nth(l,j)=x AND NOT pi(i+j,x)) }
  partition_char: JUDGEMENT partition_pos(l,pi) HAS_TYPE 
  	{ (pp,np) | FORALL x:  
		  (member(x,pp) IFF EXISTS (i:below(length(l))): nth(l,i)=x AND pi(i,x)) AND 
  		  (member(x,np) IFF EXISTS (i:below(length(l))): nth(l,i)=x AND NOT pi(i,x)) }

  partition_member: LEMMA member(x,l) IFF member(x,partition_pos(l,pi)`1) OR 
  		    	  	      	  member(x,partition_pos(l,pi)`2)
    % Partition does not depend on the third argument of partition_aux
  partition_no_pos: LEMMA partition_aux(l,LAMBDA i,x: p(x),j) = partition(l,p)
    % Partition if just 2 filters. It hence inherits of all properties of filter
  partition_filter: LEMMA partition(l,p) = (filter(l,p),filter(l,LAMBDA x: NOT p(x)))

    % Partitioning with [not p] is just swapping the results
  partition_neg: LEMMA LET (pp,np)=partition_pos(l,pi) IN partition_pos(l,LAMBDA i,x: NOT pi(i,x)) = (np,pp)
    % Partition_pos is just 2 filters_pos
  partition_filter_pos: LEMMA partition_pos(l,pi) = (filter_pos(l,pi),filter_pos(l,LAMBDA i,x: NOT pi(i,x)))
    % If p does not use the position, filter = filter_pos
  filter_filter_pos: LEMMA filter(l,p) = filter_pos(l,LAMBDA i,x: p(x))


  % With comon functions
  partiton_append: LEMMA 
  	partition_pos(append(l,m),pi) = ( append(partition_pos(l,pi)`1,partition_pos(m,pi)`1) ,
				      	  append(partition_pos(l,pi)`2,partition_pos(m,pi)`2) )
  partition_reverse: LEMMA
  	partition_pos(reverse(l),pi) = ( reverse(partition_pos(l,pi)`1) , 
				       	 reverse(partition_pos(l,pi)`2) )

  
END list_filter_props

list_subterm_props[T:TYPE]: THEORY
BEGIN
  IMPORTING adt_props

 %% Properties on the subterm order
  subterm_char: THEOREM
    subterm(l, m) IFF CASES m OF
      null: null?(l),
      cons(h, t): l = m OR subterm(l, t)
    ENDCASES

  % Used as a rewrite rule in proof of subterm_append
  subterm_cons: LEMMA
    subterm(l, cons(x, m)) = (l = cons(x, m) OR subterm(l, m))

  % subterm actually is suffix
  subterm_append: THEOREM
    subterm(l2, l) IMPLIES EXISTS l1: l = append(l1, l2)
  append_subterm: THEOREM
    subterm(l2, append(l1, l2))

  % Subterm properties
  subterm_length: LEMMA subterm(l, m) IMPLIES length(l) <= length(m)
  subterm_null: LEMMA subterm(null, l)
  subterm_cons1: LEMMA subterm(l, cons(x, l))
  subterm_cons2: LEMMA subterm(cons(x, l), m) IMPLIES subterm(l, m)
  subterm_subset: LEMMA subterm(l, m) IMPLIES subset?(l, m)
END list_subterm_props

%% Properties on lists of a single type
more_list_props[T: TYPE]: THEORY
BEGIN
  IMPORTING adt_props
  IMPORTING list_filter_props
  
  l, m, l1, l2: VAR list[T]
  ll: VAR list[list[T]]
  p: VAR pred[T]
  P: VAR pred[list[T]]
  a, b, c: VAR T
  x, y, z: VAR T

  %% Characterization of lists as the set of its elements
  % Currified version of member
  member(l)(x): MACRO bool = member(x, l)

  % Useful auto-rewrites on length
  length_cons: LEMMA 
    length(cons(x,l)) = length(l) + 1
  length_cdr: LEMMA 
    cons?(l) IMPLIES length(cdr(l)) = length(l) - 1
  AUTO_REWRITE length_cons
 
  % Better characterization of filter
%  filter_member: JUDGEMENT
%    filter(l, p) HAS_TYPE { m | FORALL x: member(x, m) IFF p(x) AND member(x, l) }



  filter_append: LEMMA
    filter(append(l, m), p) = append(filter(l, p), filter(m, p))

  % Remove (all instances of) an element from a list
  remove(a, l): MACRO { m | FORALL x: member(x, m) IFF (x /= a AND member(x, l)) } =
    filter(l, LAMBDA x: x /= a)

  % Useful conversion between every/some and forall/exists
  % The same conversion with nth instead of member is already
  % in the prelude for every (and the theorem for some can be
  % obtained from double negation, cf adt_props).
  every_forall: THEOREM
    every(p)(l) IFF (FORALL (x | member(x, l)): p(x))

  some_exists: THEOREM
    some(p)(l) IFF (EXISTS (x | member(x, l)): p(x))

  % Subset relation
  subset?(l, m): bool = every(member(m))(l)
  member_subset: THEOREM subset?(l, m) IFF (FORALL x: member(x, l) IMPLIES member(x, m))
  subset_order: THEOREM preorder?(subset?)

  subset_null: THEOREM subset?(null,m)
  subset_cons: THEOREM subset?(cons(x,l),m) IFF member(x,m) AND subset?(l,m)

  % Set equality
  equal?(l, m): bool = subset?(l, m) AND subset?(m, l)
  member_equal: THEOREM equal?(l, m) IFF (FORALL x: member(x, l) IFF member(x, m))
  equal_equiv: THEOREM equivalence?(equal?)
  equal_reflexive: THEOREM equal?(l, l)
  equal_transitive: THEOREM
    equal?(l, l1) AND equal?(l1, l2) IMPLIES equal?(l, l2)
  equal_symmetric: THEOREM
    equal?(l1, l2) IMPLIES equal?(l2, l1)
  cons_equal: THEOREM member(x, l) IMPLIES equal?(l, cons(x, l))

  % Specification of common list functions with cons
  append_cons: THEOREM append(cons(x,l),m) = cons(x,append(l,m))
  reverse_null: THEOREM reverse(null) = null[T]
  reverse_cons: THEOREM reverse(cons(x,l))= append(reverse(l),cons(x,null))  

  % More precise specifications with nth
  nth_cons: LEMMA
    FORALL (i: below(1 + length(l))):
      nth(cons(x, l), i) = IF i = 0 THEN x ELSE nth(l, i - 1) ENDIF
  nth_cdr: LEMMA
    FORALL (i: below(length(l) - 1)):
      cons?(l) IMPLIES nth(cdr(l), i) = nth(l, i + 1)
  nth_append: THEOREM
    FORALL (i: below(length(l) + length(m))):
      nth(append(l, m), i) = IF i < length(l)
                               THEN nth(l, i)
			       ELSE nth(m, i - length(l))
			     ENDIF
  nth_reverse: THEOREM
    FORALL (i: below(length(l))):
      nth(reverse(l), i) = nth(l, length(l) - i - 1)
  nth_equal: THEOREM
    ( length(l1) = length(l2) AND FORALL (i: below(length(l1))): nth(l1, i) = nth(l2, i) )
    IFF l1 = l2

  % Specification of common list functions with member
  member_append: THEOREM
    member(x, append(l, m)) IFF member(x, l) OR member(x, m)
  member_reverse: THEOREM
    member(x, reverse(l)) IFF member(x, l)
  member_nth: THEOREM
    member(x, l) IFF (EXISTS (i: below(length(l))): nth(l, i) = x)


  % Flattens a list of lists
  flatten(ll: list[list[T]]): list[T] = reduce(null, (LAMBDA l, m: append(l, m)))(ll)
  flatten_null: THEOREM flatten(null) = null
  flatten_cons: THEOREM flatten(cons(l, ll)) = append(l, flatten(ll))
  flatten_member: THEOREM
      member(x, flatten(ll)) IFF (EXISTS l: member(x, l) AND member(l, ll))
      
  % Lists without duplication
  uniques?(l): RECURSIVE bool =
    CASES l OF
      null: TRUE,
      cons(h, t): NOT member(h, t) AND uniques?(t)
    ENDCASES
  MEASURE length(l)

  uniques(l): RECURSIVE { m | uniques?(m) AND equal?(m, l) } =
    CASES l OF
      null: null,
      cons(h, t):
        IF member(h, t)
	  THEN uniques(t)
	  ELSE cons(h, uniques(t))
	ENDIF
    ENDCASES
  MEASURE length(l)

  % Find an element satisfying a predicate
  find(p, l):
    RECURSIVE lift[{ x: (p) | EXISTS (i: below(length(l))): x = nth(l, i) AND FORALL (j: below(i)): NOT p(nth(l, j)) }] =
    CASES l OF
      null: bottom,
      cons(h, t):
        IF p(h)
	  THEN up(h)
	  ELSE find(p, t)
	ENDIF
    ENDCASES
  MEASURE length(l)

  find_some: THEOREM
    some(p)(l) IFF up?(find(p, l))

  find_first(p, l):
    RECURSIVE lift[{ i: below(length(l)) |
                        p(nth(l, i)) AND FORALL (j: below(i)): NOT p(nth(l, j)) }] =
    CASES l OF
      null: bottom,
      cons(h, t):
        IF p(h)
	  THEN up(0)
	  ELSE CASES find_first(p, t) OF
	         bottom: bottom,
		 up(r): up(r + 1)
	       ENDCASES
	ENDIF
    ENDCASES
  MEASURE length(l)
  
  find_first_some: THEOREM
    some(p)(l) IFF up?(find_first(p, l))

  find_char: THEOREM
    CASES find(p, l) OF
      bottom: NOT some(p)(l),
      up(r): p(r) AND member(r, l)
    ENDCASES
  
  %% Less usual functions
  % More efficient way to compute append(reverse(l1), l2)
  rev_append(l1, l2): RECURSIVE list[T] =
    CASES l1 OF
      null: l2,
      cons(x, t1): rev_append(t1, cons(x, l2))
    ENDCASES
  MEASURE length(l1)

  % Characterisation of rev_append
  rev_append_char: THEOREM
    rev_append(l1, l2) = append(reverse(l1), l2)
  AUTO_REWRITE rev_append_char

  %% Properties on the subterm order
  subterm_char: THEOREM
    subterm(l, m) IFF CASES m OF
      null: null?(l),
      cons(h, t): l = m OR subterm(l, t)
    ENDCASES

  % Used as a rewrite rule in proof of subterm_append
  subterm_cons: LEMMA
    subterm(l, cons(x, m)) = (l = cons(x, m) OR subterm(l, m))

  % subterm actually is suffix
  subterm_append: THEOREM
    subterm(l2, l) IMPLIES EXISTS l1: l = append(l1, l2)
  append_subterm: THEOREM
    subterm(l2, append(l1, l2))

  % Subterm properties
  subterm_length: LEMMA subterm(l, m) IMPLIES length(l) <= length(m)
  subterm_null: LEMMA subterm(null, l)
  subterm_cons1: LEMMA subterm(l, cons(x, l))
  subterm_cons2: LEMMA subterm(cons(x, l), m) IMPLIES subterm(l, m)
  subterm_subset: LEMMA subterm(l, m) IMPLIES subset?(l, m)
END more_list_props


list2_props[K: TYPE, V: TYPE]: THEORY
BEGIN
  IMPORTING adt_props[list[[K, V]]]
  IMPORTING more_list_props[[K, V]]
  
  k, x: VAR K
  ks, xs: VAR list[K]
  v, y: VAR V
  vs, ys: VAR list[V]
  vf: VAR finseq[V]
  p: VAR [K, V]
  l: VAR list[[K, V]]

  % zip creates a list of pairs from a pair of lists
  zip(ks, (vs | length(vs) = length(ks))):
    RECURSIVE { l | length(l) = length(ks) AND FORALL (i: below(length(ks))): nth(l, i) = (nth(ks, i), nth(vs, i)) } =
    CASES ks OF
      null: null,
      cons(h, t): cons((h, car(vs)), zip(t, cdr(vs)))
    ENDCASES
  MEASURE length(ks)

  has_key(k, l): bool = some(LAMBDA (x: K, y: V): x = k)(l)

  assoc(k, l): lift[{ v | EXISTS (i: below(length(l))): nth(l, i) = (k, v) AND FORALL (j: below(i)): nth(l, i)`1 /= k }] =
    CASES find(LAMBDA (x: K, y: V): x = k, l) OF
      bottom: bottom,
      up(lift): up(lift`2)
    ENDCASES

  assoc_up: THEOREM
    up?(assoc(k, l)) IFF has_key(k, l)

  assoc(k, l, v):
    { y | y = v OR EXISTS (i: below(length(l))): nth(l, i) = (k, y) } =
    CASES assoc(k, l) OF
      bottom: v,
      up(res): res
    ENDCASES

  remove_assoc(k, l): list[[K, V]] =
    filter(l, LAMBDA (x: K, y: V): x /= k)

  remove_assoc_cons: THEOREM
    remove_assoc(k, cons(p, l)) =
      IF k = p`1
        THEN remove_assoc(k, l)
	ELSE cons(p, remove_assoc(k, l))
      ENDIF

  remove_assoc_assoc: THEOREM
    assoc(x, remove_assoc(k, l)) = IF x = k THEN bottom ELSE assoc(x, l) ENDIF
END list2_props

list_map_props[S: TYPE, T: TYPE]: THEORY
BEGIN
  IMPORTING more_list_props
  
  f: VAR [T -> S]
  F: VAR [T -> list[S]]
  l: VAR list[T]
  m: VAR list[S]
  x: VAR T
  s: VAR S

  member_map: THEOREM
    member(x, l) IMPLIES member(f(x), map(f, l))
  
  map_member: THEOREM
    member(s, map(f, l)) IMPLIES (EXISTS x: f(x) = s AND member(x, l))

  mymap(l: list[T], f: [{ x | member(x, l) } -> S]): RECURSIVE list[S] =
    CASES l OF
      null: null,
      cons(h, t): cons(f(h), mymap(t, restrict(f)))
    ENDCASES
  MEASURE l BY <<
END list_map_props
