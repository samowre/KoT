(minlist (total_order 0
          (total_order-1 nil 3578420902
           ("" (typepred key) (("" (lazy-grind :if-match all) nil nil))
            nil)
           ((real_le_is_total_order name-judgement
             "(total_order?[real])" real_props nil)
            (total_order? const-decl "bool" orders nil)
            (dichotomous? const-decl "bool" orders nil)
            (partial_order? const-decl "bool" orders nil)
            (antisymmetric? const-decl "bool" relations nil)
            (preorder? const-decl "bool" orders nil)
            (transitive? const-decl "bool" relations nil)
            (reflexive? const-decl "bool" relations nil)
            (boolean nonempty-type-decl nil booleans nil)
            (bool nonempty-type-eq-decl nil booleans nil)
            (NOT const-decl "[bool -> bool]" booleans nil)
            (T formal-type-decl nil minlist nil)
            (number nonempty-type-decl nil numbers nil)
            (number_field_pred const-decl "[number -> boolean]"
             number_fields nil)
            (number_field nonempty-type-from-decl nil number_fields
             nil)
            (real_pred const-decl "[number_field -> boolean]" reals
                       nil)
            (real nonempty-type-from-decl nil reals nil)
            (injective? const-decl "bool" functions nil)
            (key formal-const-decl "{k: [T -> real] | injective?(k)}"
             minlist nil))
           shostak))
         (strict_total_order 0
          (strict_total_order-1 nil 3578420950
           ("" (typepred key) (("" (postpone) nil nil)) nil) nil
           shostak))
         (min_le 0
          (min_le-1 nil 3578336775 ("" (grind) nil nil)
           ((real_le_is_total_order name-judgement
             "(total_order?[real])" real_props nil)
            (min const-decl "T" minlist nil))
           shostak))
         (max_ge 0
          (max_ge-1 nil 3578336780 ("" (grind) nil nil)
           ((real_le_is_total_order name-judgement
             "(total_order?[real])" real_props nil)
            (max const-decl "T" minlist nil))
           shostak))
         (min_min 0
          (min_min-1 nil 3578339040 ("" (grind) nil nil)
           ((real_le_is_total_order name-judgement
             "(total_order?[real])" real_props nil)
            (min const-decl "T" minlist nil))
           shostak))
         (max_max 0
          (max_max-1 nil 3578339046 ("" (grind) nil nil)
           ((real_le_is_total_order name-judgement
             "(total_order?[real])" real_props nil)
            (max const-decl "T" minlist nil))
           shostak))
         (min_aux_TCC1 0
          (min_aux_TCC1-1 nil 3578333407 ("" (grind) nil nil)
           ((boolean nonempty-type-decl nil booleans nil)
            (bool nonempty-type-eq-decl nil booleans nil)
            (NOT const-decl "[bool -> bool]" booleans nil)
            (number nonempty-type-decl nil numbers nil)
            (= const-decl "[T, T -> boolean]" equalities nil)
            (T formal-type-decl nil minlist nil)
            (number_field_pred const-decl "[number -> boolean]"
             number_fields nil)
            (number_field nonempty-type-from-decl nil number_fields
             nil)
            (real_pred const-decl "[number_field -> boolean]" reals
                       nil)
            (real nonempty-type-from-decl nil reals nil)
            (injective? const-decl "bool" functions nil)
            (key formal-const-decl "{k: [T -> real] | injective?(k)}"
             minlist nil)
            (real_le_is_total_order name-judgement
             "(total_order?[real])" real_props nil)
            (member def-decl "bool" list_props nil))
           nil))
         (min_aux_TCC2 0
          (min_aux_TCC2-1 nil 3578333407 ("" (subtype-tcc) nil nil)
           ((boolean nonempty-type-decl nil booleans nil)
            (bool nonempty-type-eq-decl nil booleans nil)
            (NOT const-decl "[bool -> bool]" booleans nil)
            (number nonempty-type-decl nil numbers nil)
            (= const-decl "[T, T -> boolean]" equalities nil)
            (T formal-type-decl nil minlist nil)
            (number_field_pred const-decl "[number -> boolean]"
             number_fields nil)
            (number_field nonempty-type-from-decl nil number_fields
             nil)
            (real_pred const-decl "[number_field -> boolean]" reals
                       nil)
            (real nonempty-type-from-decl nil reals nil)
            (injective? const-decl "bool" functions nil)
            (key formal-const-decl "{k: [T -> real] | injective?(k)}"
             minlist nil))
           nil))
         (min_aux_TCC3 0
          (min_aux_TCC3-1 nil 3578333407 ("" (termination-tcc) nil nil)
           ((boolean nonempty-type-decl nil booleans nil)
            (bool nonempty-type-eq-decl nil booleans nil)
            (NOT const-decl "[bool -> bool]" booleans nil)
            (number nonempty-type-decl nil numbers nil)
            (= const-decl "[T, T -> boolean]" equalities nil)
            (T formal-type-decl nil minlist nil)
            (number_field_pred const-decl "[number -> boolean]"
             number_fields nil)
            (number_field nonempty-type-from-decl nil number_fields
             nil)
            (real_pred const-decl "[number_field -> boolean]" reals
                       nil)
            (real nonempty-type-from-decl nil reals nil)
            (injective? const-decl "bool" functions nil)
            (key formal-const-decl "{k: [T -> real] | injective?(k)}"
             minlist nil)
            (length def-decl "nat" list_props nil)
            (nnint_plus_posint_is_posint application-judgement "posint"
             integers nil)
            (real_lt_is_strict_total_order name-judgement
             "(strict_total_order?[real])" real_props nil))
           nil))
         (min_aux_TCC4 0
          (min_aux_TCC4-1 nil 3578333407
           ("" (grind)
            (("1" (typepred "v!1(t!1,c!1,key(c!1))")
              (("1" (grind) nil nil)) nil)
             ("2" (typepred "v!1(t!1,c!1,key(c!1))")
              (("2" (grind) nil nil)) nil)
             ("3" (typepred "v!1(t!1,c!1,key(c!1))")
              (("3" (grind) nil nil)) nil)
             ("4" (typepred "v!1(t!1,c!1,key(c!1))")
              (("4" (grind) nil nil)) nil))
            nil)
           ((<= const-decl "bool" reals nil)
            (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
            (cons adt-constructor-decl "[[T, list] -> (cons?)]"
                  list_adt nil)
            (cons? adt-recognizer-decl "[list -> boolean]" list_adt
             nil)
            (AND const-decl "[bool, bool -> bool]" booleans nil)
            (length def-decl "nat" list_props nil)
            (nat nonempty-type-eq-decl nil naturalnumbers nil)
            (>= const-decl "bool" reals nil)
            (int nonempty-type-eq-decl nil integers nil)
            (integer_pred const-decl "[rational -> boolean]" integers
                          nil)
            (rational nonempty-type-from-decl nil rationals nil)
            (rational_pred const-decl "[real -> boolean]" rationals
                           nil)
            (< const-decl "bool" reals nil)
            (list type-decl nil list_adt nil)
            (real_le_is_total_order name-judgement
             "(total_order?[real])" real_props nil)
            (real_lt_is_strict_total_order name-judgement
             "(strict_total_order?[real])" real_props nil)
            (boolean nonempty-type-decl nil booleans nil)
            (bool nonempty-type-eq-decl nil booleans nil)
            (NOT const-decl "[bool -> bool]" booleans nil)
            (number nonempty-type-decl nil numbers nil)
            (= const-decl "[T, T -> boolean]" equalities nil)
            (T formal-type-decl nil minlist nil)
            (number_field_pred const-decl "[number -> boolean]"
             number_fields nil)
            (number_field nonempty-type-from-decl nil number_fields
             nil)
            (real_pred const-decl "[number_field -> boolean]" reals
                       nil)
            (real nonempty-type-from-decl nil reals nil)
            (injective? const-decl "bool" functions nil)
            (key formal-const-decl "{k: [T -> real] | injective?(k)}"
             minlist nil)
            (member def-decl "bool" list_props nil))
           nil))
         (min_aux_TCC5 0
          (min_aux_TCC5-1 nil 3578333407 ("" (termination-tcc) nil nil)
           ((boolean nonempty-type-decl nil booleans nil)
            (bool nonempty-type-eq-decl nil booleans nil)
            (NOT const-decl "[bool -> bool]" booleans nil)
            (number nonempty-type-decl nil numbers nil)
            (= const-decl "[T, T -> boolean]" equalities nil)
            (T formal-type-decl nil minlist nil)
            (number_field_pred const-decl "[number -> boolean]"
             number_fields nil)
            (number_field nonempty-type-from-decl nil number_fields
             nil)
            (real_pred const-decl "[number_field -> boolean]" reals
                       nil)
            (real nonempty-type-from-decl nil reals nil)
            (injective? const-decl "bool" functions nil)
            (key formal-const-decl "{k: [T -> real] | injective?(k)}"
             minlist nil)
            (length def-decl "nat" list_props nil)
            (nnint_plus_posint_is_posint application-judgement "posint"
             integers nil)
            (real_lt_is_strict_total_order name-judgement
             "(strict_total_order?[real])" real_props nil))
           nil))
         (min_aux_TCC6 0
          (min_aux_TCC6-1 nil 3578333407
           ("" (grind)
            (("1" (typepred "v!1(t!1,a!1,m!1)")
              (("1" (grind :if-match all) nil nil)) nil)
             ("2" (typepred "v!1(t!1,a!1,m!1)")
              (("2" (grind :if-match all) nil nil)) nil)
             ("3" (typepred "v!1(t!1,a!1,m!1)")
              (("3" (grind :if-match all) nil nil)) nil)
             ("4" (typepred "v!1(t!1,a!1,m!1)")
              (("4" (grind :if-match all) nil nil)) nil))
            nil)
           ((<= const-decl "bool" reals nil)
            (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
            (cons adt-constructor-decl "[[T, list] -> (cons?)]"
                  list_adt nil)
            (cons? adt-recognizer-decl "[list -> boolean]" list_adt
             nil)
            (AND const-decl "[bool, bool -> bool]" booleans nil)
            (length def-decl "nat" list_props nil)
            (nat nonempty-type-eq-decl nil naturalnumbers nil)
            (>= const-decl "bool" reals nil)
            (int nonempty-type-eq-decl nil integers nil)
            (integer_pred const-decl "[rational -> boolean]" integers
                          nil)
            (rational nonempty-type-from-decl nil rationals nil)
            (rational_pred const-decl "[real -> boolean]" rationals
                           nil)
            (< const-decl "bool" reals nil)
            (list type-decl nil list_adt nil)
            (real_le_is_total_order name-judgement
             "(total_order?[real])" real_props nil)
            (real_lt_is_strict_total_order name-judgement
             "(strict_total_order?[real])" real_props nil)
            (boolean nonempty-type-decl nil booleans nil)
            (bool nonempty-type-eq-decl nil booleans nil)
            (NOT const-decl "[bool -> bool]" booleans nil)
            (number nonempty-type-decl nil numbers nil)
            (= const-decl "[T, T -> boolean]" equalities nil)
            (T formal-type-decl nil minlist nil)
            (number_field_pred const-decl "[number -> boolean]"
             number_fields nil)
            (number_field nonempty-type-from-decl nil number_fields
             nil)
            (real_pred const-decl "[number_field -> boolean]" reals
                       nil)
            (real nonempty-type-from-decl nil reals nil)
            (injective? const-decl "bool" functions nil)
            (key formal-const-decl "{k: [T -> real] | injective?(k)}"
             minlist nil)
            (member def-decl "bool" list_props nil))
           nil))
         (min_TCC1 0
          (min_TCC1-1 nil 3578333407
           ("" (grind)
            (("1"
              (typepred
               "min_aux(cdr[T](l!1), car[T](l!1), key(car[T](l!1)))")
              (("1" (grind :if-match all) nil nil)) nil)
             ("2"
              (typepred
               "min_aux(cdr[T](l!1), car[T](l!1), key(car[T](l!1)))")
              (("2" (grind :if-match all) nil nil)) nil)
             ("3"
              (typepred
               "min_aux(cdr[T](l!1), car[T](l!1), key(car[T](l!1)))")
              (("3" (grind :if-match all) nil nil)) nil))
            nil)
           ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
            (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
            (min_aux def-decl "{c |
         member(c, cons(a, l)) AND
          (FORALL b: member(b, cons(a, l)) IMPLIES key(c) <= key(b))}"
             minlist nil)
            (<= const-decl "bool" reals nil)
            (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
            (cons adt-constructor-decl "[[T, list] -> (cons?)]"
                  list_adt nil)
            (AND const-decl "[bool, bool -> bool]" booleans nil)
            (key formal-const-decl "{k: [T -> real] | injective?(k)}"
             minlist nil)
            (injective? const-decl "bool" functions nil)
            (= const-decl "[T, T -> boolean]" equalities nil)
            (real nonempty-type-from-decl nil reals nil)
            (real_pred const-decl "[number_field -> boolean]" reals
                       nil)
            (number_field nonempty-type-from-decl nil number_fields
             nil)
            (number_field_pred const-decl "[number -> boolean]"
             number_fields nil)
            (number nonempty-type-decl nil numbers nil)
            (real_le_is_total_order name-judgement
             "(total_order?[real])" real_props nil)
            (boolean nonempty-type-decl nil booleans nil)
            (bool nonempty-type-eq-decl nil booleans nil)
            (NOT const-decl "[bool -> bool]" booleans nil)
            (T formal-type-decl nil minlist nil)
            (list type-decl nil list_adt nil)
            (cons? adt-recognizer-decl "[list -> boolean]" list_adt
             nil)
            (member def-decl "bool" list_props nil))
           nil))
         (min_cons 0
          (min_cons-1 nil 3578336371
           ("" (skeep)
            (("" (typepred "min(l)")
              (("" (typepred "min(cons(x,l))")
                (("" (typepred key)
                  (("" (lazy-grind :if-match all) nil nil)) nil))
                nil))
              nil))
            nil)
           ((min const-decl
                 "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES key(x) <= key(y))}"
                 minlist nil)
            (key formal-const-decl "{k: [T -> real] | injective?(k)}"
             minlist nil)
            (injective? const-decl "bool" functions nil)
            (<= const-decl "bool" reals nil)
            (real nonempty-type-from-decl nil reals nil)
            (real_pred const-decl "[number_field -> boolean]" reals
                       nil)
            (number_field nonempty-type-from-decl nil number_fields
             nil)
            (number_field_pred const-decl "[number -> boolean]"
             number_fields nil)
            (number nonempty-type-decl nil numbers nil)
            (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
            (AND const-decl "[bool, bool -> bool]" booleans nil)
            (cons? adt-recognizer-decl "[list -> boolean]" list_adt
             nil)
            (member def-decl "bool" list_props nil)
            (list type-decl nil list_adt nil)
            (T formal-type-decl nil minlist nil)
            (NOT const-decl "[bool -> bool]" booleans nil)
            (bool nonempty-type-eq-decl nil booleans nil)
            (boolean nonempty-type-decl nil booleans nil)
            (real_le_is_total_order name-judgement
             "(total_order?[real])" real_props nil)
            (real_lt_is_strict_total_order name-judgement
             "(strict_total_order?[real])" real_props nil)
            (min_aux def-decl "{c |
         member(c, cons(a, l)) AND
          (FORALL b: member(b, cons(a, l)) IMPLIES key(c) <= key(b))}"
             minlist nil)
            (min const-decl "T" minlist nil)
            (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
            (= const-decl "[T, T -> boolean]" equalities nil)
            (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
            (cons adt-constructor-decl "[[T, list] -> (cons?)]"
                  list_adt nil))
           shostak))
         (min_append_TCC1 0
          (min_append_TCC1-1 nil 3578333407 ("" (grind) nil nil)
           ((append def-decl "list[T]" list_props nil)) nil))
         (min_append 0
          (min_append-1 nil 3578338444
           ("" (induct-and-simplify l1 :rewrites min_cons :exclude min)
            (("" (expand min 2 4) (("" (grind :exclude min) nil nil))
              nil))
            nil)
           ((min_aux def-decl "{c |
         member(c, cons(a, l)) AND
          (FORALL b: member(b, cons(a, l)) IMPLIES key(c) <= key(b))}"
             minlist nil)
            (min_cons formula-decl nil minlist nil)
            (min_min formula-decl nil minlist nil)
            (append def-decl "list[T]" list_props nil)
            (cons? adt-recognizer-decl "[list -> boolean]" list_adt
             nil)
            (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
            (bool nonempty-type-eq-decl nil booleans nil)
            (boolean nonempty-type-decl nil booleans nil)
            (list type-decl nil list_adt nil)
            (= const-decl "[T, T -> boolean]" equalities nil)
            (AND const-decl "[bool, bool -> bool]" booleans nil)
            (member def-decl "bool" list_props nil)
            (number nonempty-type-decl nil numbers nil)
            (number_field_pred const-decl "[number -> boolean]"
             number_fields nil)
            (number_field nonempty-type-from-decl nil number_fields
             nil)
            (real_pred const-decl "[number_field -> boolean]" reals
                       nil)
            (real nonempty-type-from-decl nil reals nil)
            (<= const-decl "bool" reals nil)
            (injective? const-decl "bool" functions nil)
            (key formal-const-decl "{k: [T -> real] | injective?(k)}"
             minlist nil)
            (min const-decl
                 "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES key(x) <= key(y))}"
                 minlist nil)
            (min const-decl "T" minlist nil)
            (T formal-type-decl nil minlist nil)
            (list_induction formula-decl nil list_adt nil))
           shostak))
         (min_reverse_TCC1 0
          (min_reverse_TCC1-1 nil 3578333407
           ("" (lemma length_reverse[T])
            (("" (lazy-grind :exclude reverse) nil nil)) nil)
           ((nnint_plus_posint_is_posint application-judgement "posint"
             integers nil)
            (length def-decl "nat" list_props nil)
            (cons? adt-recognizer-decl "[list -> boolean]" list_adt
             nil)
            (list type-decl nil list_adt nil)
            (NOT const-decl "[bool -> bool]" booleans nil)
            (bool nonempty-type-eq-decl nil booleans nil)
            (boolean nonempty-type-decl nil booleans nil)
            (length_reverse formula-decl nil list_props nil)
            (T formal-type-decl nil minlist nil))
           nil))
         (min_reverse 0
          (min_reverse-1 nil 3578339232
           ("" (grind :rewrites member_reverse :defs nil :if-match all)
            (("" (typepred "min(l!1)")
              (("" (typepred "min(reverse(l!1))")
                (("" (lemma member_reverse)
                  ((""
                    (grind :if-match all :rewrites member_reverse
                     :exclude (reverse min))
                    (("1" (typepred key)
                      (("1"
                        (grind :if-match all :rewrites member_reverse
                         :exclude (reverse min))
                        nil nil))
                      nil)
                     ("2" (typepred key)
                      (("2"
                        (grind :if-match all :rewrites member_reverse
                         :exclude (reverse min))
                        nil nil))
                      nil)
                     ("3" (typepred key)
                      (("3"
                        (grind :if-match all :rewrites member_reverse
                         :exclude (reverse min))
                        nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ((min const-decl
                 "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES key(x) <= key(y))}"
                 minlist nil)
            (key formal-const-decl "{k: [T -> real] | injective?(k)}"
             minlist nil)
            (injective? const-decl "bool" functions nil)
            (<= const-decl "bool" reals nil)
            (real nonempty-type-from-decl nil reals nil)
            (real_pred const-decl "[number_field -> boolean]" reals
                       nil)
            (number_field nonempty-type-from-decl nil number_fields
             nil)
            (number_field_pred const-decl "[number -> boolean]"
             number_fields nil)
            (number nonempty-type-decl nil numbers nil)
            (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
            (AND const-decl "[bool, bool -> bool]" booleans nil)
            (member def-decl "bool" list_props nil)
            (member_reverse formula-decl nil more_list_props nil)
            (real_le_is_total_order name-judgement
             "(total_order?[real])" real_props nil)
            (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
            (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
            (reverse def-decl "list[T]" list_props nil)
            (boolean nonempty-type-decl nil booleans nil)
            (bool nonempty-type-eq-decl nil booleans nil)
            (NOT const-decl "[bool -> bool]" booleans nil)
            (T formal-type-decl nil minlist nil)
            (list type-decl nil list_adt nil)
            (cons? adt-recognizer-decl "[list -> boolean]" list_adt
             nil))
           shostak))
         (min_subset 0
          (min_subset-1 nil 3578339560
           ("" (lazy-grind :if-match all :defs nil)
            (("" (typepred "min(l1!1)")
              (("" (typepred "min(l2!1)")
                (("" (use member_subset)
                  (("" (grind :if-match all :exclude (reverse min)) nil
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ((min const-decl
                 "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES key(x) <= key(y))}"
                 minlist nil)
            (key formal-const-decl "{k: [T -> real] | injective?(k)}"
             minlist nil)
            (injective? const-decl "bool" functions nil)
            (<= const-decl "bool" reals nil)
            (real nonempty-type-from-decl nil reals nil)
            (real_pred const-decl "[number_field -> boolean]" reals
                       nil)
            (number_field nonempty-type-from-decl nil number_fields
             nil)
            (number_field_pred const-decl "[number -> boolean]"
             number_fields nil)
            (number nonempty-type-decl nil numbers nil)
            (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
            (AND const-decl "[bool, bool -> bool]" booleans nil)
            (member def-decl "bool" list_props nil)
            (member_subset formula-decl nil more_list_props nil)
            (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
            (subset? const-decl "bool" more_list_props nil)
            (every adt-def-decl "boolean" list_adt nil)
            (real_le_is_total_order name-judgement
             "(total_order?[real])" real_props nil)
            (boolean nonempty-type-decl nil booleans nil)
            (bool nonempty-type-eq-decl nil booleans nil)
            (NOT const-decl "[bool -> bool]" booleans nil)
            (T formal-type-decl nil minlist nil)
            (list type-decl nil list_adt nil)
            (cons? adt-recognizer-decl "[list -> boolean]" list_adt
             nil))
           shostak))
         (min_filter_TCC1 0
          (min_filter_TCC1-1 nil 3578333407
           ("" (skeep)
            (("" (typepred "filter(l,p)")
              (("" (inst - "min(l)")
                (("" (typepred "min(l)") (("" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ((AND const-decl "[bool, bool -> bool]" booleans nil)
            (PRED type-eq-decl nil defined_types nil)
            (cons? adt-recognizer-decl "[list -> boolean]" list_adt
             nil)
            (filter def-decl "list[T]" filters nil)
            (pred type-eq-decl nil defined_types nil)
            (member def-decl "bool" list_props nil)
            (list type-decl nil list_adt nil)
            (IFF const-decl "[bool, bool -> bool]" booleans nil)
            (T formal-type-decl nil minlist nil)
            (NOT const-decl "[bool -> bool]" booleans nil)
            (bool nonempty-type-eq-decl nil booleans nil)
            (boolean nonempty-type-decl nil booleans nil)
            (filter_member application-judgement
             "{m | FORALL (x: T): member(x, m) IFF p(x) AND member(x, l)}"
             minlist nil)
            (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
            (real_le_is_total_order name-judgement
             "(total_order?[real])" real_props nil)
            (min const-decl
                 "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES key(x) <= key(y))}"
                 minlist nil)
            (key formal-const-decl "{k: [T -> real] | injective?(k)}"
             minlist nil)
            (injective? const-decl "bool" functions nil)
            (<= const-decl "bool" reals nil)
            (real nonempty-type-from-decl nil reals nil)
            (real_pred const-decl "[number_field -> boolean]" reals
                       nil)
            (number_field nonempty-type-from-decl nil number_fields
             nil)
            (number_field_pred const-decl "[number -> boolean]"
             number_fields nil)
            (number nonempty-type-decl nil numbers nil)
            (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
           nil))
         (min_filter 0
          (min_filter-1 nil 3578339670
           ("" (skeep)
            (("" (typepred "min(l)")
              (("" (typepred "filter(l,p)")
                (("" (typepred "min(filter(l,p))")
                  (("" (typepred key)
                    (("" (grind :if-match all :exclude (filter min))
                      nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ((min const-decl
                 "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES key(x) <= key(y))}"
                 minlist nil)
            (key formal-const-decl "{k: [T -> real] | injective?(k)}"
             minlist nil)
            (injective? const-decl "bool" functions nil)
            (<= const-decl "bool" reals nil)
            (real nonempty-type-from-decl nil reals nil)
            (real_pred const-decl "[number_field -> boolean]" reals
                       nil)
            (number_field nonempty-type-from-decl nil number_fields
             nil)
            (number_field_pred const-decl "[number -> boolean]"
             number_fields nil)
            (number nonempty-type-decl nil numbers nil)
            (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
            (AND const-decl "[bool, bool -> bool]" booleans nil)
            (cons? adt-recognizer-decl "[list -> boolean]" list_adt
             nil)
            (member def-decl "bool" list_props nil)
            (list type-decl nil list_adt nil)
            (T formal-type-decl nil minlist nil)
            (NOT const-decl "[bool -> bool]" booleans nil)
            (bool nonempty-type-eq-decl nil booleans nil)
            (boolean nonempty-type-decl nil booleans nil)
            (real_le_is_total_order name-judgement
             "(total_order?[real])" real_props nil)
            (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
            (PRED type-eq-decl nil defined_types nil)
            (filter def-decl "list[T]" filters nil)
            (pred type-eq-decl nil defined_types nil)
            (IFF const-decl "[bool, bool -> bool]" booleans nil)
            (filter_member application-judgement
             "{m | FORALL (x: T): member(x, m) IFF p(x) AND member(x, l)}"
             minlist nil))
           shostak)))
(maxlist (IMP_minlist_TCC1 0
          (IMP_minlist_TCC1-1 nil 3578338293
           ("" (grind) (("" (typepred key) (("" (grind) nil nil)) nil))
            nil)
           ((key formal-const-decl "{k: [T -> real] | injective?(k)}"
             maxlist nil)
            (real nonempty-type-from-decl nil reals nil)
            (real_pred const-decl "[number_field -> boolean]" reals
                       nil)
            (number_field nonempty-type-from-decl nil number_fields
             nil)
            (number_field_pred const-decl "[number -> boolean]"
             number_fields nil)
            (number nonempty-type-decl nil numbers nil)
            (T formal-type-decl nil maxlist nil)
            (NOT const-decl "[bool -> bool]" booleans nil)
            (bool nonempty-type-eq-decl nil booleans nil)
            (boolean nonempty-type-decl nil booleans nil)
            (minus_real_is_real application-judgement "real" reals nil)
            (injective? const-decl "bool" functions nil)
            (rev_key const-decl "real" maxlist nil))
           nil))
         (max_TCC1 0
          (max_TCC1-1 nil 3578333218
           ("" (skeep)
            (("" (typepred "min[T,rev_key](l)")
              (("1" (expand rev_key)
                (("1" (lazy-grind :if-match all :defs nil)
                  (("1" (typepred key)
                    (("1" (hide -2 -3 2)
                      (("1" (lazy-grind :if-match all) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (typepred key)
                (("2" (lazy-grind :if-match all) nil nil)) nil))
              nil))
            nil)
           ((min const-decl
                 "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES key(x) <= key(y))}"
                 minlist nil)
            (rev_key const-decl "real" maxlist nil)
            (<= const-decl "bool" reals nil)
            (real nonempty-type-from-decl nil reals nil)
            (real_pred const-decl "[number_field -> boolean]" reals
                       nil)
            (number_field nonempty-type-from-decl nil number_fields
             nil)
            (number_field_pred const-decl "[number -> boolean]"
             number_fields nil)
            (number nonempty-type-decl nil numbers nil)
            (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
            (AND const-decl "[bool, bool -> bool]" booleans nil)
            (cons? adt-recognizer-decl "[list -> boolean]" list_adt
             nil)
            (member def-decl "bool" list_props nil)
            (list type-decl nil list_adt nil)
            (T formal-type-decl nil maxlist nil)
            (NOT const-decl "[bool -> bool]" booleans nil)
            (bool nonempty-type-eq-decl nil booleans nil)
            (boolean nonempty-type-decl nil booleans nil)
            (injective? const-decl "bool" functions nil)
            (real_le_is_total_order name-judgement
             "(total_order?[real])" real_props nil)
            (minus_real_is_real application-judgement "real" reals nil)
            (key formal-const-decl "{k: [T -> real] | injective?(k)}"
             maxlist nil)
            (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
            (min_aux def-decl "{c |
         member(c, cons(a, l)) AND
          (FORALL b: member(b, cons(a, l)) IMPLIES key(c) <= key(b))}"
             minlist nil)
            (cons adt-constructor-decl "[[T, list] -> (cons?)]"
                  list_adt nil)
            (- const-decl "[numfield -> numfield]" number_fields nil)
            (numfield nonempty-type-eq-decl nil number_fields nil)
            (= const-decl "[T, T -> boolean]" equalities nil)
            (car adt-accessor-decl "[(cons?) -> T]" list_adt nil))
           nil))
         (max_min 0
          (max_min-1 nil 3578339865
           ("" (typepred key) (("" (grind) nil nil)) nil)
           ((min const-decl "T" minlist nil)
            (max const-decl "T" minlist nil)
            (rev_key const-decl "real" maxlist nil)
            (IF const-decl "[boolean, T, T -> T]" if_def nil)
            (<= const-decl "bool" reals nil)
            (real_le_is_total_order name-judgement
             "(total_order?[real])" real_props nil)
            (minus_real_is_real application-judgement "real" reals nil)
            (boolean nonempty-type-decl nil booleans nil)
            (bool nonempty-type-eq-decl nil booleans nil)
            (NOT const-decl "[bool -> bool]" booleans nil)
            (T formal-type-decl nil maxlist nil)
            (number nonempty-type-decl nil numbers nil)
            (number_field_pred const-decl "[number -> boolean]"
             number_fields nil)
            (number_field nonempty-type-from-decl nil number_fields
             nil)
            (real_pred const-decl "[number_field -> boolean]" reals
                       nil)
            (real nonempty-type-from-decl nil reals nil)
            (injective? const-decl "bool" functions nil)
            (key formal-const-decl "{k: [T -> real] | injective?(k)}"
             maxlist nil))
           shostak))
         (min_max 0
          (min_max-1 nil 3578339887
           ("" (typepred key) (("" (grind) nil nil)) nil)
           ((max const-decl "T" minlist nil)
            (min const-decl "T" minlist nil)
            (rev_key const-decl "real" maxlist nil)
            (IF const-decl "[boolean, T, T -> T]" if_def nil)
            (<= const-decl "bool" reals nil)
            (real_le_is_total_order name-judgement
             "(total_order?[real])" real_props nil)
            (minus_real_is_real application-judgement "real" reals nil)
            (boolean nonempty-type-decl nil booleans nil)
            (bool nonempty-type-eq-decl nil booleans nil)
            (NOT const-decl "[bool -> bool]" booleans nil)
            (T formal-type-decl nil maxlist nil)
            (number nonempty-type-decl nil numbers nil)
            (number_field_pred const-decl "[number -> boolean]"
             number_fields nil)
            (number_field nonempty-type-from-decl nil number_fields
             nil)
            (real_pred const-decl "[number_field -> boolean]" reals
                       nil)
            (real nonempty-type-from-decl nil reals nil)
            (injective? const-decl "bool" functions nil)
            (key formal-const-decl "{k: [T -> real] | injective?(k)}"
             maxlist nil))
           shostak)))
(sortedlist
 (sorted?_TCC1 0
  (sorted?_TCC1-1 nil 3482515380 ("" (termination-tcc) nil nil)
   ((length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (cdr_sorted 0
  (cdr_sorted-1 nil 3578234647 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? def-decl "bool" sortedlist nil))
   shostak))
 (car_sorted 0
  (car_sorted-1 nil 3578063647
   ("" (induct sl)
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (expand sorted? 1 2)
      (("3" (skeep)
        (("3" (skeep)
          (("3" (prop)
            (("1" (inst - a)
              (("1" (grind :exclude sorted? :if-match all)
                (("1" (grind)
                  (("1" (case "a=car(cons2_var)")
                    (("1" (grind) nil nil)
                     ("2" (grind)
                      (("2" (expand member -3) (("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (key formal-const-decl "{k: [T -> real] | injective?(k)}"
     sortedlist nil)
    (injective? const-decl "bool" functions nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (member def-decl "bool" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? def-decl "bool" sortedlist nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (nth_sorted 0
  (nth_sorted-1 nil 3578163072
   ("" (induct l)
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skeep)
      (("3" (prop)
        (("1" (skeep)
          (("1" (inst - "i-1" "j-1")
            (("1" (expand nth +)
              (("1" (lift-if)
                (("1" (prop)
                  (("1" (lift-if)
                    (("1" (prop)
                      (("1" (grind) nil nil)
                       ("2" (use member_nth (x "nth(cons2_var,j-1)"))
                        (("1"
                          (use car_sorted
                               (a
                                "nth(cons2_var,j-1)"
                                sl
                                "cons(cons1_var,cons2_var)"))
                          (("1" (prop)
                            (("1" (inst + "j-1")
                              (("1"
                                (hide -1 -2 -3 -4 -5 -6 2 3 5)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide -2 -3 -1 -4 -5 -6 -7 3)
                            (("2" (grind) nil nil)) nil))
                          nil)
                         ("2" (hide -2 -3 -1 -4 -5 -6 -7 3)
                          (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil) ("3" (assert) nil nil)
                   ("4" (assert) nil nil) ("5" (assert) nil nil)
                   ("6" (assert) nil nil) ("7" (assert) nil nil)
                   ("8" (assert)
                    (("8" (lift-if)
                      (("8" (prop)
                        (("8"
                          (use car_sorted
                               (a
                                "nth(cons2_var,i-1)"
                                sl
                                "cons(cons1_var,cons2_var)"))
                          (("8" (prop)
                            (("1" (assert) nil nil)
                             ("2"
                              (use member_nth (x "nth(cons2_var,i-1)"))
                              (("2"
                                (prop)
                                (("2" (inst + "i-1") nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (typepred j)
                (("2" (hide -2 -3)
                  (("2"
                    (use car_sorted
                         (a "nth(cons(cons1_var,cons2_var),i)" sl
                          "cons(cons1_var,cons2_var)"))
                    (("2" (grind)
                      (("2"
                        (use member_nth
                             (x "nth(cons(cons1_var,cons2_var),i)"))
                        (("2" (prop)
                          (("2" (inst + "i-1")
                            (("1" (grind)
                              (("1"
                                (expand nth 1 2)
                                (("1"
                                  (grind :exclude nth)
                                  (("1"
                                    (hide 1 2 3 4)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (grind)
                              (("2"
                                (typepred i)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (typepred i)
              (("3" (grind)
                (("1"
                  (use car_sorted
                       (a "nth(cons2_var,j-1)" sl
                        "cons(cons1_var,cons2_var)"))
                  (("1" (use member_nth (x "nth(cons2_var,j-1)"))
                    (("1" (grind) nil nil)) nil))
                  nil)
                 ("2"
                  (use car_sorted
                       (a "nth(cons2_var,j-1)" sl
                        "cons(cons1_var,cons2_var)"))
                  (("1" (use member_nth (x "nth(cons2_var,j-1)"))
                    (("1" (grind) nil nil)) nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand sorted? +)
          (("2" (lift-if)
            (("2" (prop)
              (("2" (inst - 0 1)
                (("1" (grind) nil nil) ("2" (grind) nil nil)
                 ("3" (grind) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (grind) nil nil)
         ("4" (hide 1 3)
          (("4" (skeep)
            (("4" (inst - "i+1" "j+1")
              (("1" (grind) nil nil) ("2" (grind) nil nil)
               ("3" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (TRUE const-decl "bool" booleans nil)
    (member def-decl "bool" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (car_sorted formula-decl nil sortedlist nil)
    (member_nth formula-decl nil more_list_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (key formal-const-decl "{k: [T -> real] | injective?(k)}"
     sortedlist nil)
    (injective? const-decl "bool" functions nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (sorted? def-decl "bool" sortedlist nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (s_member_TCC1 0
  (s_member_TCC1-1 nil 3577837025 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? def-decl "bool" sortedlist nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (s_member_TCC2 0
  (s_member_TCC2-1 nil 3577837025 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? def-decl "bool" sortedlist nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (s_remove_TCC1 0
  (s_remove_TCC1-1 nil 3577837025 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? def-decl "bool" sortedlist nil)
    (member def-decl "bool" list_props nil))
   nil))
 (s_remove_TCC2 0
  (s_remove_TCC2-1 nil 3577837025
   ("" (skeep)
    (("" (prop)
      (("1" (typepred sl) (("1" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (prop)
          (("1" (typepred sl)
            (("1" (use car_sorted) (("1" (grind) nil nil)) nil)) nil)
           ("2" (grind) nil nil) ("3" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? def-decl "bool" sortedlist nil)
    (car_sorted formula-decl nil sortedlist nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member def-decl "bool" list_props nil))
   nil))
 (s_remove_TCC3 0
  (s_remove_TCC3-1 nil 3577837025
   ("" (grind-with-lemmas car_sorted :exclude sorted? :if-match all)
    (("" (lemma car_sorted)
      (("" (inst - x!1 sl!1) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((car_sorted formula-decl nil sortedlist nil)
    (sorted? def-decl "bool" sortedlist nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member def-decl "bool" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (s_remove_TCC4 0
  (s_remove_TCC4-1 nil 3577837025
   ("" (skeep)
    (("" (prop)
      (("1" (expand sorted?)
        (("1" (lift-if)
          (("1" (prop)
            (("1" (typepred "v(a,slt)")
              (("1" (inst - "car(v(a,slt))")
                (("1" (lemma car_sorted)
                  (("1" (inst - "car(v(a,slt))" sl)
                    (("1" (grind) nil nil)
                     ("2" (typepred sl) (("2" (grind) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (typepred sl) (("2" (grind) nil nil)) nil))
                nil)
               ("2" (typepred sl) (("2" (grind) nil nil)) nil))
              nil)
             ("2" (typepred "v(a,slt)")
              (("1" (propax) nil nil)
               ("2" (typepred sl) (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep)
        (("2" (expand member +)
          (("2" (typepred "v(a,slt)")
            (("1" (inst - x) (("1" (grind) nil nil)) nil)
             ("2" (typepred sl) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((key formal-const-decl "{k: [T -> real] | injective?(k)}"
     sortedlist nil)
    (injective? const-decl "bool" functions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (car_sorted formula-decl nil sortedlist nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (sorted? def-decl "bool" sortedlist nil))
   nil))
 (s_remove_TCC5 0
  (s_remove_TCC5-1 nil 3578427204 ("" (termination-tcc) nil nil) nil
   nil))
 (s_remove_TCC6 0
  (s_remove_TCC6-1 nil 3578427204 ("" (subtype-tcc) nil nil) nil nil))
 (s_insert_TCC1 0
  (s_insert_TCC1-1 nil 3577837025
   ("" (grind) (("" (typepred key) (("" (grind) nil nil)) nil)) nil)
   ((key formal-const-decl "{k: [T -> real] | injective?(k)}"
     sortedlist nil)
    (injective? const-decl "bool" functions nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (member def-decl "bool" list_props nil)
    (sorted? def-decl "bool" sortedlist nil))
   nil))
 (s_insert_TCC2 0
  (s_insert_TCC2-1 nil 3577837025
   ("" (grind :exclude sorted?)
    (("1" (typepred key) (("1" (grind) nil nil)) nil)
     ("2" (grind) nil nil))
    nil)
   ((key formal-const-decl "{k: [T -> real] | injective?(k)}"
     sortedlist nil)
    (injective? const-decl "bool" functions nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? def-decl "bool" sortedlist nil)
    (member def-decl "bool" list_props nil))
   nil))
 (s_insert_TCC3 0
  (s_insert_TCC3-1 nil 3577837025
   ("" (skeep)
    (("" (skeep)
      (("" (prop)
        (("" (grind) (("" (typepred key) (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member def-decl "bool" list_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (injective? const-decl "bool" functions nil)
    (key formal-const-decl "{k: [T -> real] | injective?(k)}"
     sortedlist nil))
   nil))
 (s_insert_TCC4 0
  (s_insert_TCC4-1 nil 3577837025
   ("" (skeep)
    (("" (prop)
      (("1" (expand sorted?)
        (("1" (typepred "v(a,slt)")
          (("1" (inst - "car(v(a,slt))")
            (("1" (lemma car_sorted)
              (("1" (inst - "car(v(a,slt))" sl)
                (("1" (grind) nil nil)
                 ("2" (typepred sl) (("2" (grind) nil nil)) nil))
                nil))
              nil)
             ("2" (grind) nil nil)
             ("3" (typepred sl) (("3" (grind) nil nil)) nil))
            nil)
           ("2" (typepred sl) (("2" (grind) nil nil)) nil))
          nil))
        nil)
       ("2" (skeep)
        (("2" (typepred "v(a,slt)")
          (("1" (inst - x)
            (("1" (expand member 1 1) (("1" (grind) nil nil)) nil))
            nil)
           ("2" (typepred sl) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((key formal-const-decl "{k: [T -> real] | injective?(k)}"
     sortedlist nil)
    (injective? const-decl "bool" functions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (car_sorted formula-decl nil sortedlist nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (sorted? def-decl "bool" sortedlist nil))
   nil))
 (sort_TCC1 0
  (sort_TCC1-1 nil 3577837025 ("" (grind) nil nil)
   ((sorted? def-decl "bool" sortedlist nil)
    (member def-decl "bool" list_props nil))
   nil))
 (sort_TCC2 0
  (sort_TCC2-1 nil 3577837025 ("" (grind) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (sort_TCC3 0
  (sort_TCC3-1 nil 3577837025
   ("" (skeep)
    (("" (skeep)
      (("" (typepred "v(lt)")
        (("" (typepred "s_insert(h,v(lt))")
          (("" (inst - x)
            (("" (inst - x)
              (("" (typepred key) (("" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((s_insert def-decl
     "{s: (sorted?) | FORALL x: member(x, s) IFF key(x) = key(a) OR member(x, sl)}"
     sortedlist nil)
    (key formal-const-decl "{k: [T -> real] | injective?(k)}"
     sortedlist nil)
    (injective? const-decl "bool" functions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? def-decl "bool" sortedlist nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil))
   nil))
 (s_member_member 0
  (s_member_member-1 nil 3578055388
   ("" (induct-and-simplify sl :exclude sorted?)
    (("1" (lemma car_sorted)
      (("1" (inst - a!1 "cons(cons1_var!1,cons2_var!1)")
        (("1" (grind) nil nil)) nil))
      nil)
     ("2" (typepred key) (("2" (grind) nil nil)) nil)
     ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil)
     ("6" (grind) nil nil))
    nil)
   ((key formal-const-decl "{k: [T -> real] | injective?(k)}"
     sortedlist nil)
    (injective? const-decl "bool" functions nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (car_sorted formula-decl nil sortedlist nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? def-decl "bool" sortedlist nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (s_member def-decl "bool" sortedlist nil)
    (member def-decl "bool" list_props nil)
    (T formal-type-decl nil sortedlist nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (s_remove_remove 0
  (s_remove_remove-1 nil 3578071003
   ("" (induct sl)
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skeep)
      (("3" (skeep)
        (("3" (prop)
          (("1" (expand s_remove +)
            (("1" (lift-if)
              (("1" (prop)
                (("1" (typepred key)
                  (("1" (inst - a)
                    (("1" (expand filter +)
                      (("1" (lemma car_sorted)
                        (("1"
                          (inst - "car(cons2_var)"
                           "cons(cons1_var,cons2_var)")
                          (("1" (expand s_remove -4)
                            (("1" (grind :exclude (sorted? filter)) nil
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind :exclude (sorted?))
                  (("2" (expand s_remove)
                    (("2" (grind :exclude (sorted? filter))
                      (("1" (grind) nil nil) ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil)
                 ("3" (inst - a)
                  (("3" (expand filter +)
                    (("3" (grind :exclude (sorted? filter)) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (filter_member application-judgement
     "{m | FORALL (x: T): member(x, m) IFF p(x) AND member(x, l)}"
     sortedlist nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (car_sorted formula-decl nil sortedlist nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (pred type-eq-decl nil defined_types nil)
    (s_remove def-decl "{s: (sorted?) |
         FORALL x: member(x, s) IFF NOT key(x) = key(a) AND member(x, sl)}"
     sortedlist nil)
    (key formal-const-decl "{k: [T -> real] | injective?(k)}"
     sortedlist nil)
    (injective? const-decl "bool" functions nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (sorted? def-decl "bool" sortedlist nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (insert_remove 0
  (insert_remove-1 nil 3578072551
   ("" (induct-and-simplify sl :exclude sorted?)
    (("1" (typepred key)
      (("1" (expand s_insert +) (("1" (grind) nil nil)) nil)) nil)
     ("2" (grind) nil nil) ("3" (grind) nil nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? def-decl "bool" sortedlist nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (injective? const-decl "bool" functions nil)
    (key formal-const-decl "{k: [T -> real] | injective?(k)}"
     sortedlist nil)
    (s_insert def-decl
     "{s: (sorted?) | FORALL x: member(x, s) IFF key(x) = key(a) OR member(x, sl)}"
     sortedlist nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (s_remove def-decl "{s: (sorted?) |
         FORALL x: member(x, s) IFF NOT key(x) = key(a) AND member(x, sl)}"
     sortedlist nil)
    (T formal-type-decl nil sortedlist nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (remove_insert 0
  (remove_insert-1 nil 3578072670
   ("" (induct-and-simplify sl :exclude sorted?) (("" (grind) nil nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? def-decl "bool" sortedlist nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (injective? const-decl "bool" functions nil)
    (key formal-const-decl "{k: [T -> real] | injective?(k)}"
     sortedlist nil)
    (s_remove def-decl "{s: (sorted?) |
         FORALL x: member(x, s) IFF NOT key(x) = key(a) AND member(x, sl)}"
     sortedlist nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_insert def-decl
     "{s: (sorted?) | FORALL x: member(x, s) IFF key(x) = key(a) OR member(x, sl)}"
     sortedlist nil)
    (T formal-type-decl nil sortedlist nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (insert_no_change 0
  (insert_no_change-1 nil 3578072686
   ("" (induct sl)
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skeep)
      (("3" (skeep)
        (("3" (expand s_insert +)
          (("3" (prop)
            (("1" (lift-if)
              (("1" (prop)
                (("1" (decompose-equality) (("1" (grind) nil nil)) nil)
                 ("2" (typepred key) (("2" (grind) nil nil)) nil)
                 ("3" (decompose-equality)
                  (("3" (inst - a) (("3" (grind) nil nil)) nil)) nil))
                nil))
              nil)
             ("2" (lift-if)
              (("2" (grind)
                (("2" (lemma car_sorted)
                  (("2" (inst - a "cons(cons1_var,cons2_var)")
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("3" (grind) nil nil) ("4" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((car_sorted formula-decl nil sortedlist nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (< const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (s_insert def-decl
     "{s: (sorted?) | FORALL x: member(x, s) IFF key(x) = key(a) OR member(x, sl)}"
     sortedlist nil)
    (key formal-const-decl "{k: [T -> real] | injective?(k)}"
     sortedlist nil)
    (injective? const-decl "bool" functions nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? def-decl "bool" sortedlist nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (remove_no_change 0
  (remove_no_change-1 nil 3578073080
   ("" (induct sl)
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skeep)
      (("3" (skeep)
        (("3" (split -1)
          (("1" (prop)
            (("1" (expand s_remove -1)
              (("1" (lift-if)
                (("1" (prop)
                  (("1" (grind) nil nil)
                   ("2" (use s_member_member) (("2" (grind) nil nil))
                    nil)
                   ("3" (inst - a)
                    (("3" (decompose-equality)
                      (("3" (typepred key) (("3" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand s_remove +)
              (("2" (lift-if)
                (("2" (prop)
                  (("1" (typepred key) (("1" (grind) nil nil)) nil)
                   ("2" (inst - a) (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (s_member def-decl "bool" sortedlist nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (s_member_member formula-decl nil sortedlist nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (s_remove def-decl "{s: (sorted?) |
         FORALL x: member(x, s) IFF NOT key(x) = key(a) AND member(x, sl)}"
     sortedlist nil)
    (key formal-const-decl "{k: [T -> real] | injective?(k)}"
     sortedlist nil)
    (injective? const-decl "bool" functions nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? def-decl "bool" sortedlist nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (s_subset?_TCC1 0
  (s_subset?_TCC1-1 nil 3577837025
   ("" (skeep)
    (("" (skeep) (("" (typepred sl1) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? def-decl "bool" sortedlist nil))
   nil))
 (s_subset?_TCC2 0
  (s_subset?_TCC2-1 nil 3577837025
   ("" (skeep)
    (("" (skeep) (("" (typepred sl2) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? def-decl "bool" sortedlist nil))
   nil))
 (s_subset?_TCC3 0
  (s_subset?_TCC3-1 nil 3577837025 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? def-decl "bool" sortedlist nil)
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (s_subset?_TCC4 0
  (s_subset?_TCC4-1 nil 3577837025
   ("" (skeep)
    (("" (skeep) (("" (typepred sl2) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? def-decl "bool" sortedlist nil))
   nil))
 (s_subset?_TCC5 0
  (s_subset?_TCC5-1 nil 3577837025 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? def-decl "bool" sortedlist nil)
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (s_subset?_TCC6 0
  (s_subset?_TCC6-1 nil 3577837025 ("" (cond-disjoint-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? def-decl "bool" sortedlist nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (s_subset?_TCC7 0
  (s_subset?_TCC7-1 nil 3577837025 ("" (cond-coverage-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? def-decl "bool" sortedlist nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (s_equal?_TCC1 0
  (s_equal?_TCC1-1 nil 3578245369 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? def-decl "bool" sortedlist nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (s_equal?_TCC2 0
  (s_equal?_TCC2-1 nil 3578245369 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? def-decl "bool" sortedlist nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (s_equal?_TCC3 0
  (s_equal?_TCC3-1 nil 3578245369 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? def-decl "bool" sortedlist nil)
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (sorted_uniques 0
  (sorted_uniques-1 nil 3578073858
   ("" (induct-and-simplify sl :exclude sorted?)
    (("1" (lemma car_sorted)
      (("1" (inst - cons1_var!1 "cons(cons1_var!1,cons2_var!1)")
        (("1" (grind) nil nil)) nil))
      nil)
     ("2" (grind) nil nil))
    nil)
   ((car_sorted formula-decl nil sortedlist nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? def-decl "bool" sortedlist nil)
    (uniques? def-decl "bool" more_list_props nil)
    (T formal-type-decl nil sortedlist nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (s_subset_subset 0
  (s_subset_subset-1 nil 3578074019
   ("" (auto-rewrite-theory more_list_props[T] :exclude member_nth)
    (("" (induct sl2)
      (("1" (grind) nil nil)
       ("2" (grind)
        (("1" (expand s_subset?) (("1" (grind) nil nil)) nil)
         ("2" (expand s_subset?) (("2" (grind) nil nil)) nil))
        nil)
       ("3" (skeep)
        (("3" (skeep)
          (("3" (use cdr_sorted (sl "cons(cons1_var,cons2_var)"))
            (("3" (prop)
              (("1" (inst - sl1)
                (("1" (expand s_subset? -1)
                  (("1" (lift-if)
                    (("1" (prop)
                      (("1" (grind) nil nil) ("2" (grind) nil nil)
                       ("3" (lift-if)
                        (("3" (prop)
                          (("1" (grind) nil nil) ("2" (grind) nil nil)
                           ("3" (hide -1 -2 -4 -5 1 2 3 4)
                            (("3" (use member_subset)
                              (("3"
                                (use
                                 member_subset
                                 (m "cons(cons1_var,cons2_var)"))
                                (("3"
                                  (prop)
                                  (("3"
                                    (skeep)
                                    (("3"
                                      (inst - x)
                                      (("3" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (lift-if)
                        (("4" (prop)
                          (("1" (grind) nil nil)
                           ("2" (reveal *)
                            (("2" (inst - "cdr(sl1)")
                              (("2"
                                (prop)
                                (("1"
                                  (use-with "member_subset" 3)
                                  (("1"
                                    (use-with "member_subset" -3)
                                    (("1"
                                      (prop)
                                      (("1"
                                        (skeep)
                                        (("1"
                                          (inst - x)
                                          (("1"
                                            (typepred key)
                                            (("1"
                                              (grind :if-match all)
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("3" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand s_subset? +)
                (("2" (lift-if)
                  (("2" (prop)
                    (("1" (grind) nil nil)
                     ("2" (lift-if)
                      (("2" (prop)
                        (("1" (inst - sl1)
                          (("1" (use member_subset)
                            (("1" (hide -4)
                              (("1"
                                (prop)
                                (("1"
                                  (inst - "car(sl1)")
                                  (("1"
                                    (lemma car_sorted)
                                    (("1"
                                      (inst
                                       -
                                       "car(sl1)"
                                       "cons(cons1_var,cons2_var)")
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (inst - "cdr(sl1)")
                          (("2" (prop)
                            (("1" (grind) nil nil)
                             ("2" (use-with "member_subset" 1)
                              (("2"
                                (use-with "member_subset" -3)
                                (("2"
                                  (prop)
                                  (("2"
                                    (skeep)
                                    (("2"
                                      (inst - x)
                                      (("2"
                                        (hide -2 -5 -6 -7 2 3 4 5 6)
                                        (("2"
                                          (typepred sl1)
                                          (("2"
                                            (use sorted_uniques)
                                            (("2"
                                              (prop)
                                              (("1"
                                                (typepred key)
                                                (("1"
                                                  (expand member -2)
                                                  (("1"
                                                    (grind :defs nil)
                                                    (("1"
                                                      (delete -3)
                                                      (("1"
                                                        (use
                                                         sorted_uniques
                                                         (sl sl1))
                                                        (("1"
                                                          (expand
                                                           uniques?)
                                                          (("1"
                                                            (lift-if)
                                                            (("1"
                                                              (prop)
                                                              (("1"
                                                                (hide
                                                                 -1
                                                                 -3
                                                                 -4
                                                                 1
                                                                 3
                                                                 4
                                                                 5
                                                                 6)
                                                                (("1"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (inst - sl1)
                          (("3" (prop)
                            (("1" (grind) nil nil)
                             ("2" (use-with "member_subset" -1)
                              (("2"
                                (use-with "member_subset" 1)
                                (("2"
                                  (prop)
                                  (("2"
                                    (skeep)
                                    (("2"
                                      (inst - x)
                                      (("2"
                                        (prop)
                                        (("2"
                                          (typepred key)
                                          (("2"
                                            (expand member -2)
                                            (("2"
                                              (use
                                               car_sorted
                                               (a "cons1_var" sl sl1))
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? def-decl "bool" sortedlist nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (s_subset? def-decl "bool" sortedlist nil)
    (subset? const-decl "bool" more_list_props nil)
    (T formal-type-decl nil sortedlist nil)
    (list_induction formula-decl nil list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm_char formula-decl nil more_list_props nil)
    (member def-decl "bool" list_props nil)
    (member_subset formula-decl nil more_list_props nil)
    (subterm_po name-judgement "(partial_order?[list[T]])" adt_props
     nil)
    (subterm_cons formula-decl nil more_list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (key formal-const-decl "{k: [T -> real] | injective?(k)}"
     sortedlist nil)
    (injective? const-decl "bool" functions nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uniques? def-decl "bool" more_list_props nil)
    (sorted_uniques formula-decl nil sortedlist nil)
    (car_sorted formula-decl nil sortedlist nil)
    (cdr_sorted formula-decl nil sortedlist nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil))
   shostak))
 (s_equal_char 0
  (s_equal_char-1 nil 3578255840
   ("" (induct sl1)
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skeep)
      (("3" (skeep)
        (("3" (use cdr_sorted)
          (("3" (simplify)
            (("3" (prop)
              (("1" (expand s_equal? -1)
                (("1" (lift-if)
                  (("1" (prop)
                    (("1" (typepred key)
                      (("1" (inst - "cdr(sl2)")
                        (("1" (decompose-equality)
                          (("1" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand s_equal? +)
                (("2" (lift-if)
                  (("2" (prop)
                    (("1" (grind) nil nil)
                     ("2" (decompose-equality)
                      (("2" (inst - "cdr(sl2)")
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil))
                      nil)
                     ("3" (inst - "cdr(sl2)")
                      (("3" (decompose-equality)
                        (("3" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cdr_sorted formula-decl nil sortedlist nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (injective? const-decl "bool" functions nil)
    (key formal-const-decl "{k: [T -> real] | injective?(k)}"
     sortedlist nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (s_equal? def-decl "bool" sortedlist nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? def-decl "bool" sortedlist nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (s_equal_equal 0
  (s_equal_equal-1 nil 3578083479
   (""
    (induct-and-simplify sl1 :theories more_list_props[T] :defs nil
     :rewrites s_equal_char :exclude (equal_symmetric member_nth)
     :if-match nil)
    (("1" (grind) nil nil)
     ("2" (inst - "cdr(sl2!1)")
      (("1" (prop)
        (("1" (use s_equal_char)
          (("1" (prop)
            (("1" (inst - cons1_var!1)
              (("1" (inst - cons1_var!1)
                (("1" (decompose-equality 1)
                  (("1" (lemma car_sorted)
                    (("1"
                      (inst - "cons1_var!1"
                       "cons(cons1_var!1,cons2_var!1)")
                      (("1" (expand member -7 2)
                        (("1" (grind :defs nil) (("1" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (inst - x)
            (("2"
              (grind-with-lemmas car_sorted :if-match all :exclude
               sorted?)
              (("1" (reveal *)
                (("1" (hide -2 -3)
                  (("1" (inst - cons1_var!1)
                    (("1"
                      (use car_sorted
                           (sl "cons(cons1_var!1,cons2_var!1)" a x))
                      (("1" (use car_sorted (sl sl2!1 a cons1_var!1))
                        (("1" (hide 2 3)
                          (("1" (typepred key)
                            (("1" (grind :exclude (sorted?))
                              (("1"
                                (expand member -8)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (expand member -7)
                                (("2"
                                  (expand member -4)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (reveal *)
                (("2" (hide -2 -3)
                  (("2" (expand s_equal? +)
                    (("2" (lift-if)
                      (("2" (prop)
                        (("1" (grind) nil nil)
                         ("2" (lift-if)
                          (("2" (prop)
                            (("1" (inst - "car(sl2!1)")
                              (("1"
                                (use sorted_uniques)
                                (("1"
                                  (expand uniques?)
                                  (("1" (grind :defs nil) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (copy -1)
                              (("2"
                                (inst - "car(sl2!1)")
                                (("2"
                                  (use car_sorted)
                                  (("2"
                                    (use
                                     s_member_member
                                     (sl
                                      "cons(cons1_var!1,cons2_var!1)"))
                                    (("2"
                                      (grind :exclude sorted?)
                                      (("1"
                                        (hide
                                         -1
                                         -2
                                         -4
                                         -5
                                         1
                                         2
                                         4
                                         5
                                         7
                                         8
                                         9)
                                        (("1"
                                          (grind)
                                          (("1"
                                            (expand member)
                                            (("1" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (hide
                                         -1
                                         -2
                                         -4
                                         -5
                                         1
                                         2
                                         4
                                         5
                                         7
                                         8
                                         9)
                                        (("2"
                                          (expand member)
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (inst - "car(sl2!1)")
                              (("3"
                                (use
                                 s_member_member
                                 (sl "cons(cons1_var!1,cons2_var!1)"))
                                (("3"
                                  (use car_sorted)
                                  (("3"
                                    (grind :exclude sorted?)
                                    (("1"
                                      (hide
                                       -1
                                       -2
                                       -3
                                       -4
                                       1
                                       2
                                       3
                                       4
                                       5
                                       6
                                       8
                                       9
                                       10)
                                      (("1"
                                        (grind)
                                        (("1"
                                          (expand member)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (hide
                                       -1
                                       -2
                                       -3
                                       -4
                                       1
                                       2
                                       3
                                       4
                                       5
                                       6
                                       8
                                       9
                                       10)
                                      (("2"
                                        (expand member)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (expand member 5)
                (("3" (grind :exclude (member sorted?))
                  (("3" (reveal *)
                    (("3" (hide -2 -3)
                      (("3" (inst - "cons1_var!1")
                        (("3" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (use cdr_sorted) (("2" (grind) nil nil)) nil)
       ("3" (grind) nil nil))
      nil)
     ("3" (grind) nil nil))
    nil)
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (key formal-const-decl "{k: [T -> real] | injective?(k)}"
     sortedlist nil)
    (injective? const-decl "bool" functions nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (s_member def-decl "bool" sortedlist nil)
    (s_member_member formula-decl nil sortedlist nil)
    (uniques? def-decl "bool" more_list_props nil)
    (sorted_uniques formula-decl nil sortedlist nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (car_sorted formula-decl nil sortedlist nil)
    (cdr_sorted formula-decl nil sortedlist nil)
    (member def-decl "bool" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (member_equal formula-decl nil more_list_props nil)
    (s_equal_char formula-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? def-decl "bool" sortedlist nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (s_equal? def-decl "bool" sortedlist nil)
    (equal? const-decl "bool" more_list_props nil)
    (T formal-type-decl nil sortedlist nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (min_sorted_TCC1 0
  (min_sorted_TCC1-1 nil 3578427204 ("" (subtype-tcc) nil nil) nil
   nil))
 (min_sorted 0
  (min_sorted-1 nil 3578326877
   ("" (skeep)
    (("" (typepred "min(sl)")
      (("" (inst - "car(sl)")
        (("" (use car_sorted) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((sorted? def-decl "bool" sortedlist nil)
    (min const-decl
         "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES key(x) <= key(y))}"
         minlist nil)
    (key formal-const-decl "{k: [T -> real] | injective?(k)}"
     sortedlist nil)
    (injective? const-decl "bool" functions nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (member def-decl "bool" list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (car_sorted formula-decl nil sortedlist nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil))
   shostak))
 (s_before_before 0
  (s_before_before-1 nil 3578421217
   ("" (skeep)
    (("" (prop) (("1" (postpone) nil nil) ("2" (postpone) nil nil))
      nil))
    nil)
   nil shostak))
 (append_sorted 0
  (append_sorted-1 nil 3578083784
   ("" (induct sl1)
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skeep)
      (("3" (skeep)
        (("3" (prop)
          (("1" (expand (sorted? append) +)
            (("1" (use order_lcdr)
              (("1" (prop)
                (("1" (lift-if)
                  (("1" (prop)
                    (("1" (lemma member_append)
                      (("1"
                        (inst - cons2_var sl2
                         "car(append(cons2_var,sl2))")
                        (("1" (prop)
                          (("1"
                            (use car_sorted
                                 (a "car(append(cons2_var,sl2))"))
                            (("1" (grind :exclude sorted?) nil nil))
                            nil)
                           ("2" (use-with "order_char" -4)
                            (("2" (prop)
                              (("2"
                                (inst
                                 -
                                 cons1_var
                                 "car(append(cons2_var,sl2))")
                                (("2"
                                  (grind :exclude sorted?)
                                  nil
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (grind :exclude sorted?) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind :exclude sorted?) nil nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (use append_null (l "cons(cons1_var,cons2_var)"))
            (("2" (grind :exclude sorted?) nil nil)) nil)
           ("3" (use order_char)
            (("3" (prop)
              (("1" (grind) nil nil)
               ("2" (expand append -1)
                (("2" (expand sorted? -1)
                  (("2" (skeep)
                    (("2" (lift-if)
                      (("2" (prop)
                        (("1" (expand append -1)
                          (("1" (grind :exclude sorted?) nil nil)) nil)
                         ("2" (inst - sl2)
                          (("2" (prop)
                            (("2" (use order_char)
                              (("2"
                                (prop)
                                (("2"
                                  (inst - x y)
                                  (("2"
                                    (grind :exclude sorted?)
                                    (("1"
                                      (lemma car_sorted)
                                      (("1"
                                        (inst
                                         -
                                         "car(cons2_var)"
                                         "cons(cons1_var,cons2_var)")
                                        (("1"
                                          (rewrite every_forall)
                                          (("1"
                                            (inst - "car(cons2_var)")
                                            (("1"
                                              (grind :exclude sorted?)
                                              (("1"
                                                (expand member 1)
                                                (("1"
                                                  (grind
                                                   :exclude
                                                   sorted?)
                                                  nil
                                                  nil))
                                                nil)
                                               ("2"
                                                (expand member 1)
                                                (("2"
                                                  (grind
                                                   :exclude
                                                   sorted?)
                                                  nil
                                                  nil))
                                                nil)
                                               ("3"
                                                (expand member 1)
                                                (("3"
                                                  (grind
                                                   :exclude
                                                   sorted?)
                                                  nil
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (expand append -5)
                                              (("2"
                                                (grind
                                                 :exclude
                                                 sorted?)
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (expand append -5)
                                          (("2"
                                            (grind :exclude sorted?)
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (lemma car_sorted)
                                      (("2"
                                        (inst
                                         -
                                         "car(cons2_var)"
                                         "cons(cons1_var,cons2_var)")
                                        (("1"
                                          (rewrite every_forall)
                                          (("1"
                                            (inst - "car(cons2_var)")
                                            (("1"
                                              (grind :exclude sorted?)
                                              (("1"
                                                (expand member 1)
                                                (("1" (grind) nil nil))
                                                nil)
                                               ("2"
                                                (expand member 1)
                                                (("2" (grind) nil nil))
                                                nil)
                                               ("3"
                                                (expand member 1)
                                                (("3" (grind) nil nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (expand append -5)
                                              (("2"
                                                (grind
                                                 :exclude
                                                 sorted?)
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (expand append -5)
                                          (("2"
                                            (grind :exclude sorted?)
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("4" (grind) nil nil) ("5" (grind) nil nil)
           ("6" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (member_append formula-decl nil more_list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (car_sorted formula-decl nil sortedlist nil)
    (member def-decl "bool" list_props nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (append_null formula-decl nil list_props nil)
    (key formal-const-decl "{k: [T -> real] | injective?(k)}"
     sortedlist nil)
    (injective? const-decl "bool" functions nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pred type-eq-decl nil defined_types nil)
    (every_forall formula-decl nil more_list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (append def-decl "list[T]" list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (< const-decl "bool" sortedlist nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? def-decl "bool" sortedlist nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (filter_sorted 0
  (filter_sorted-1 nil 3577837025
   ("" (induct sl)
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skeep)
      (("3" (skeep)
        (("3" (expand filter +)
          (("3" (prop)
            (("1" (inst - p)
              (("1" (expand sorted? +)
                (("1" (lift-if)
                  (("1" (prop)
                    (("1"
                      (use car_sorted
                           (a "car(filter(cons2_var,p))" sl
                            "cons(cons1_var,cons2_var)"))
                      (("1" (grind :exclude sorted?)
                        (("1" (grind :exclude sorted?)
                          (("1" (grind :exclude sorted?)
                            (("1" (typepred "filter(cons2_var,p)")
                              (("1"
                                (inst - "car(filter(cons2_var,p))")
                                (("1"
                                  (grind :exclude sorted?)
                                  nil
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil) ("3" (grind) nil nil)
             ("4" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((filter_member application-judgement
     "{m | FORALL (x: T): member(x, m) IFF p(x) AND member(x, l)}"
     sortedlist nil)
    (car_sorted formula-decl nil sortedlist nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (pred type-eq-decl nil defined_types nil)
    (PRED type-eq-decl nil defined_types nil)
    (sorted? def-decl "bool" sortedlist nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil)))
(rev_sortedlist
 (IMP_sortedlist_TCC1 0
  (IMP_sortedlist_TCC1-1 nil 3578150680
   ("" (typepred key) (("" (grind) nil nil)) nil)
   ((rev_key const-decl "real" rev_sortedlist nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil rev_sortedlist nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (injective? const-decl "bool" functions nil)
    (key formal-const-decl "{k: [T -> real] | injective?(k)}"
     rev_sortedlist nil))
   nil))
 (rev_sorted 0
  (rev_sorted-1 nil 3578150904
   ("" (induct sl)
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skeep)
      (("3" (expand rev_sorted?)
        (("3" (expand reverse +)
          (("3" (use-with "append_sorted[T,rev_key]")
            (("1" (prop)
              (("1" (hide 1 4 3)
                (("1" (lemma "order_char[T,rev_key]")
                  (("1"
                    (inst - "reverse(cons2_var)"
                     "cons(cons1_var,null)")
                    (("1" (prop)
                      (("1" (grind) nil nil)
                       ("2" (skeep)
                        (("2" (use-with "member_reverse" -1)
                          (("2"
                            (use "car_sorted[T,key]"
                                 (a x sl "cons(cons1_var,cons2_var)"))
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil)
             ("2" (grind) nil nil) ("3" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((append def-decl "list[T]" list_props nil)
    (member def-decl "bool" list_props nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (member_reverse formula-decl nil more_list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (car_sorted formula-decl nil sortedlist nil)
    (< const-decl "bool" sortedlist nil)
    (append_sorted formula-decl nil sortedlist nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (rev_key const-decl "real" rev_sortedlist nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil rev_sortedlist nil)
    (reverse def-decl "list[T]" list_props nil)
    (rev_sorted? const-decl "bool" rev_sortedlist nil)
    (sorted? def-decl "bool" sortedlist nil)
    (key formal-const-decl "{k: [T -> real] | injective?(k)}"
     rev_sortedlist nil)
    (injective? const-decl "bool" functions nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (max_sorted_TCC1 0
  (max_sorted_TCC1-1 nil 3578327403
   ("" (grind :exclude (sorted? reverse))
    (("" (use length_reverse (l sl!1)) (("" (grind) nil nil)) nil))
    nil)
   ((length_reverse formula-decl nil list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (reverse def-decl "list[T]" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil rev_sortedlist nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (injective? const-decl "bool" functions nil)
    (key formal-const-decl "{k: [T -> real] | injective?(k)}"
     rev_sortedlist nil)
    (sorted? def-decl "bool" sortedlist nil))
   nil))
 (max_sorted 0
  (max_sorted-1 nil 3578327702
   ("" (skeep)
    (("" (all-typepreds)
      (("" (use rev_sorted)
        (("" (use member_reverse)
          (("" (inst - "car(reverse(sl))")
            (("" (use member_reverse (x "car(reverse(sl))"))
              (("" (use "car_sorted[T,rev_key]" (a "max(sl)"))
                (("1" (expand member -2 1)
                  (("1" (expand member -3 1)
                    (("1" (expand rev_sorted?)
                      (("1" (lazy-grind :if-match all :defs nil)
                        (("1" (use "length_reverse[T]")
                          (("1" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil rev_sortedlist nil)
    (list type-decl nil list_adt nil)
    (member def-decl "bool" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (injective? const-decl "bool" functions nil)
    (key formal-const-decl "{k: [T -> real] | injective?(k)}"
     rev_sortedlist nil)
    (max const-decl
         "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES key(y) <= key(x))}"
         maxlist nil)
    (sorted? def-decl "bool" sortedlist nil)
    (member_reverse formula-decl nil more_list_props nil)
    (rev_sorted? const-decl "bool" rev_sortedlist nil)
    (length_reverse formula-decl nil list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (min const-decl
         "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES key(x) <= key(y))}"
         minlist nil)
    (rev_key const-decl "real" maxlist nil)
    (length def-decl "nat" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rev_key const-decl "real" rev_sortedlist nil)
    (car_sorted formula-decl nil sortedlist nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (reverse def-decl "list[T]" list_props nil)
    (rev_sorted formula-decl nil rev_sortedlist nil))
   shostak)))

