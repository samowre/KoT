(sortedlist
 (sorted_aux?_TCC1 0
  (sorted_aux?_TCC1-1 nil 3578662238 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (irreflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (strict_order? const-decl "bool" orders nil)
    (trichotomous? const-decl "bool" orders nil)
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (nth_sorted_aux_TCC1 0
  (nth_sorted_aux_TCC1-1 nil 3578935016 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (nth_sorted_aux_TCC2 0
  (nth_sorted_aux_TCC2-1 nil 3578935016 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (irreflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (strict_order? const-decl "bool" orders nil)
    (trichotomous? const-decl "bool" orders nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (nth_sorted_aux_TCC3 0
  (nth_sorted_aux_TCC3-1 nil 3578935016
   ("" (grind :if-match nil)
    (("1" (inst - "(cons(th!1,ltt!1),lessp!1)")
      (("1" (prop)
        (("1" (case "i!1=0")
          (("1" (inst - 0 "j!1-1")
            (("1" (prop)
              (("1" (inst - "h!1" "th!1" "nth(cons(th!1,ltt!1),j!1-1)")
                (("1" (grind) nil nil)) nil)
               ("2" (grind) nil nil))
              nil))
            nil)
           ("2" (inst - "i!1-1" "j!1-1")
            (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("2" (inst - "(cons(th!1,ltt!1),lessp!1)")
      (("2" (prop)
        (("2" (skeep)
          (("2" (inst -7 "i+1" "j+1")
            (("1" (grind) nil nil)
             ("2" (typepred j) (("2" (grind) nil nil)) nil)
             ("3" (typepred i) (("3" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (inst -7 0 1)
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (grind) nil nil))
      nil))
    nil)
   ((j skolem-const-decl "below(length(cons(th!1, ltt!1)))" sortedlist
     nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (i skolem-const-decl "below(length(cons(th!1, ltt!1)))" sortedlist
     nil)
    (ltt!1 skolem-const-decl "list[T]" sortedlist nil)
    (th!1 skolem-const-decl "T" sortedlist nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (i!1 skolem-const-decl "below(length(l!1))" sortedlist nil)
    (l!1 skolem-const-decl "list[T]" sortedlist nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (irreflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (strict_order? const-decl "bool" orders nil)
    (trichotomous? const-decl "bool" orders nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil))
   nil))
 (sorted?_TCC1 0
  (sorted?_TCC1-1 nil 3578844547 ("" (use strict_total_order) nil nil)
   ((<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (strict_total_order formula-decl nil before_list nil))
   nil))
 (rev_sorted?_TCC1 0
  (rev_sorted?_TCC1-1 nil 3578662238
   ("" (use strict_total_order)
    (("" (grind :if-match nil :exclude <)
      (("1" (grind :if-match all) nil nil)
       ("2" (inst -2 z!1 y!1 x!1) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((strict_total_order? const-decl "bool" orders nil)
    (trichotomous? const-decl "bool" orders nil)
    (strict_order? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (irreflexive? const-decl "bool" relations nil)
    (/= const-decl "boolean" notequal nil)
    (< const-decl "bool" before_list nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (strict_total_order formula-decl nil before_list nil))
   nil))
 (nth_sorted 0
  (nth_sorted-1 nil 3578163072
   ("" (skeep)
    (("" (prop)
      (("1" (expand sorted?)
        (("1" (typepred "sorted_aux?(l,<)")
          (("1" (prop)
            (("1" (skeep)
              (("1" (prop)
                (("1" (inst - i j) (("1" (grind) nil nil)) nil)
                 ("2" (typepred <=)
                  (("2" (inst - j i)
                    (("2" (lazy-grind :if-match all) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand sorted?)
        (("2" (typepred "sorted_aux?(l,<)")
          (("2" (grind :if-match all) nil nil)) nil))
        nil))
      nil))
    nil)
   ((nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (< const-decl "bool" before_list nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (total_order? const-decl "bool" orders nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (partial_order? const-decl "bool" orders nil)
    (dichotomous? const-decl "bool" orders nil)
    (/= const-decl "boolean" notequal nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (sorted? const-decl "bool" sortedlist nil))
   shostak))
 (nth_revsorted 0
  (nth_revsorted-1 nil 3578938699
   ("" (skeep)
    (("" (prop)
      (("1" (expand rev_sorted?)
        (("1" (typepred "sorted_aux?(l,LAMBDA x,y: y<x)")
          (("1" (prop)
            (("1" (skeep)
              (("1" (prop)
                (("1" (inst - i j) (("1" (grind) nil nil)) nil)
                 ("2" (typepred <=)
                  (("2" (inst - j i)
                    (("2" (lazy-grind :if-match all) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (use strict_total_order)
            (("2" (hide -2 2)
              (("2" (grind :if-match nil :exclude <)
                (("1" (grind :if-match all) nil nil)
                 ("2" (inst -2 z!1 y!1 x!1) (("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand rev_sorted?)
        (("2" (typepred "sorted_aux?(l,LAMBDA x,y: y<x)")
          (("1" (grind :if-match all) nil nil)
           ("2" (hide -1 2)
            (("2" (use strict_total_order)
              (("2" (grind :if-match nil)
                (("1" (grind :if-match all) nil nil)
                 ("2" (grind :if-match all) nil nil)
                 ("3" (inst - z!1 y!1 x!1) (("3" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (< const-decl "bool" before_list nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (total_order? const-decl "bool" orders nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (partial_order? const-decl "bool" orders nil)
    (dichotomous? const-decl "bool" orders nil)
    (/= const-decl "boolean" notequal nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (irreflexive? const-decl "bool" relations nil)
    (strict_order? const-decl "bool" orders nil)
    (trichotomous? const-decl "bool" orders nil)
    (strict_total_order formula-decl nil before_list nil)
    (rev_sorted? const-decl "bool" sortedlist nil))
   shostak))
 (rev_sorted 0
  (rev_sorted-1 nil 3578680091
   ("" (skeep)
    (("" (use nth_sorted)
      (("" (use nth_revsorted)
        (("" (auto-rewrite (nth_reverse length_reverse))
          (("" (prop)
            (("1" (auto-rewrite (nth_reverse length_reverse))
              (("1" (skeep)
                (("1" (inst - "length(l)-j-1" "length(l)-i-1")
                  (("1" (rewrite nth_reverse)
                    (("1" (rewrite nth_reverse)
                      (("1" (grind) nil nil)
                       ("2" (typepred j) (("2" (grind) nil nil)) nil))
                      nil)
                     ("2" (typepred i) (("2" (grind) nil nil)) nil))
                    nil)
                   ("2" (typepred i) (("2" (grind) nil nil)) nil)
                   ("3" (typepred j) (("3" (grind) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (skeep)
              (("2" (inst - "length(l)-j-1" "length(l)-i-1")
                (("2" (rewrite nth_reverse)
                  (("2" (rewrite nth_reverse) (("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nth_sorted formula-decl nil sortedlist nil)
    (reverse def-decl "list[T]" list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (nth def-decl "T" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (j skolem-const-decl "below(length(reverse(l)))" sortedlist nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (l skolem-const-decl "list[T]" sortedlist nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (i skolem-const-decl "below(length(reverse(l)))" sortedlist nil)
    (sorted? const-decl "bool" sortedlist nil)
    (rev_sorted? const-decl "bool" sortedlist nil)
    (< const-decl "bool" before_list nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (length_reverse formula-decl nil list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nth_reverse formula-decl nil list_basic_props nil)
    (nth_revsorted formula-decl nil sortedlist nil))
   shostak))
 (cdr_sorted 0
  (cdr_sorted-1 nil 3578234647 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (sorted? const-decl "bool" sortedlist nil))
   shostak))
 (car_sorted 0
  (car_sorted-1 nil 3578063647
   ("" (skolem-typepred)
    (("" (use nth_sorted)
      (("" (prop)
        (("" (use member_nth)
          (("" (prop)
            (("" (skeep)
              (("" (inst - 0 "i+1")
                (("1" (grind) nil nil)
                 ("2" (typepred i) (("2" (grind) nil nil)) nil)
                 ("3" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nth_sorted formula-decl nil sortedlist nil)
    (member_nth formula-decl nil list_basic_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (< const-decl "bool" before_list nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (nth def-decl "T" list_props nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (i skolem-const-decl "below(length(cdr(sl!1)))" sortedlist nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (sl!1 skolem-const-decl "(sorted?)" sortedlist nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sorted? const-decl "bool" sortedlist nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (min_sorted 0
  (min_sorted-1 nil 3578326877
   ("" (skeep)
    (("" (typepred "min(sl)")
      (("" (lemma car_sorted)
        (("" (inst - "min(sl)" sl)
          (("" (inst - "car(sl)")
            (("" (typepred <=) (("" (grind :if-match all) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sorted? const-decl "bool" sortedlist nil)
    (min const-decl
         "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES x <= y)}"
         min_max_list nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (member def-decl "bool" list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (< const-decl "bool" before_list nil)
    (/= const-decl "boolean" notequal nil)
    (dichotomous? const-decl "bool" orders nil)
    (partial_order? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (min_aux def-decl
     "{c | member(c, l) AND (FORALL b: member(b, l) IMPLIES c <= b)}"
     min_max_list nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (car_sorted formula-decl nil sortedlist nil))
   shostak))
 (max_sorted_TCC1 0
  (max_sorted_TCC1-1 nil 3578662238
   ("" (skeep)
    (("" (lemma "length_reverse[T]")
      (("" (grind :exclude (sorted? reverse)) nil nil)) nil))
    nil)
   ((T formal-type-decl nil sortedlist nil)
    (length_reverse formula-decl nil list_props nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (sorted? const-decl "bool" sortedlist nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (max_sorted 0
  (max_sorted-1 nil 3578679035
   ("" (skeep)
    (("" (typepred "max(sl)")
      (("" (typepred sl)
        (("" (use nth_sorted)
          (("" (prop)
            (("" (use member_nth)
              (("" (prop)
                (("" (skeep)
                  (("" (case "car(reverse(sl))=nth(sl,length(sl)-1)")
                    (("1" (inst - i "length(sl)-1")
                      (("1" (inst - "car(reverse(sl))")
                        (("1" (typepred <=)
                          (("1" (prop)
                            (("1"
                              (grind :if-match all :exclude
                               (sorted? max reverse))
                              nil nil)
                             ("2" (use member_reverse)
                              (("2"
                                (expand member -1 1)
                                (("2"
                                  (hide -2 -3 -4 -5 -6 -7 -8 -9 -10 2)
                                  (("2"
                                    (lemma member_reverse)
                                    (("2"
                                      (lift-if)
                                      (("2"
                                        (prop)
                                        (("2"
                                          (inst - sl "car(sl)")
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (typepred i) (("3" (grind) nil nil))
                              nil)
                             ("4" (typepred i) (("4" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2"
                      (case "car(reverse(sl)) = nth(reverse(sl),0)")
                      (("1" (rewrite nth_reverse) nil nil)
                       ("2" (grind) nil nil)
                       ("3" (rewrite length_reverse)
                        (("3" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sorted? const-decl "bool" sortedlist nil)
    (max const-decl
         "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES y <= x)}"
         min_max_list nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (member def-decl "bool" list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nth_sorted formula-decl nil sortedlist nil)
    (member_nth formula-decl nil list_basic_props nil)
    (nth_reverse formula-decl nil list_basic_props nil)
    (length_reverse formula-decl nil list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (member_reverse formula-decl nil list_basic_props nil)
    (sl skolem-const-decl "(sorted?)" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (< const-decl "bool" before_list nil)
    (reflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (partial_order? const-decl "bool" orders nil)
    (dichotomous? const-decl "bool" orders nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (reverse def-decl "list[T]" list_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields
       nil))
   shostak))
 (s_member_TCC1 0
  (s_member_TCC1-1 nil 3577837025 ("" (grind) nil nil)
   ((list type-decl nil list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (< const-decl "bool" before_list nil)
    (sorted? const-decl "bool" sortedlist nil))
   nil))
 (s_member_TCC2 0
  (s_member_TCC2-1 nil 3577837025 ("" (termination-tcc) nil nil)
   ((sorted? const-decl "bool" sortedlist nil)
    (list type-decl nil list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (< const-decl "bool" before_list nil))
   nil))
 (s_remove_TCC1 0
  (s_remove_TCC1-1 nil 3577837025 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? const-decl "bool" sortedlist nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (member def-decl "bool" list_props nil)
    (sorted_aux? def-decl "bool" sortedlist nil))
   nil))
 (s_remove_TCC2 0
  (s_remove_TCC2-1 nil 3577837025
   ("" (skeep)
    (("" (prop)
      (("1" (typepred sl) (("1" (grind) nil nil)) nil)
       ("2" (skeep)
        (("2" (prop)
          (("1" (typepred sl)
            (("1" (use car_sorted) (("1" (grind) nil nil)) nil)) nil)
           ("2" (grind) nil nil) ("3" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? const-decl "bool" sortedlist nil)
    (car_sorted formula-decl nil sortedlist nil)
    (< const-decl "bool" before_list nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (member def-decl "bool" list_props nil))
   nil))
 (s_remove_TCC3 0
  (s_remove_TCC3-1 nil 3577837025
   ("" (grind-with-lemmas car_sorted :exclude sorted? :if-match all)
    (("" (lemma car_sorted)
      (("" (inst - x!1 sl!1)
        (("" (use strict_total_order)
          (("" (grind :if-match all) nil nil)) nil))
        nil))
      nil))
    nil)
   ((car_sorted formula-decl nil sortedlist nil)
    (strict_total_order formula-decl nil before_list nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (strict_total_order? const-decl "bool" orders nil)
    (trichotomous? const-decl "bool" orders nil)
    (strict_order? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (irreflexive? const-decl "bool" relations nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (/= const-decl "boolean" notequal nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (< const-decl "bool" before_list nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (sorted? const-decl "bool" sortedlist nil)
    (member def-decl "bool" list_props nil))
   nil))
 (s_remove_TCC4 0
  (s_remove_TCC4-1 nil 3577837025
   ("" (grind :if-match nil :defs nil)
    (("1" (inst - "(a!1,slt!1)")
      (("1" (inst - a!1) (("1" (grind) nil nil)) nil)
       ("2" (grind) nil nil))
      nil)
     ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (expand sorted?)
      (("4" (expand sorted_aux? +)
        (("4" (inst - "(a!1,slt!1)")
          (("1" (inst - "car(v!1(a!1,slt!1))")
            (("1" (lemma car_sorted)
              (("1" (inst - "car(v!1(a!1,slt!1))" sl!1)
                (("1" (grind :exclude (sorted_aux?))
                  (("1" (typepred "v!1(a!1,slt!1)")
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil)
             ("2" (grind) nil nil) ("3" (grind) nil nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((car_sorted formula-decl nil sortedlist nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (sl!1 skolem-const-decl "(sorted?)" sortedlist nil)
    (v!1 skolem-const-decl
     "[d1: {z: [T, (sorted?)] | length(z`2) < length(sl!1)} ->
   {s: (sorted?) |
            FORALL x: member(x, s) IFF NOT x = d1`1 AND member(x, d1`2)}]"
     sortedlist nil)
    (a!1 skolem-const-decl "T" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (strict_total_order? const-decl "bool" orders nil)
    (slt!1 skolem-const-decl "list[T]" sortedlist nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (< const-decl "bool" before_list nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? const-decl "bool" sortedlist nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   nil))
 (s_insert_TCC1 0
  (s_insert_TCC1-1 nil 3577837025 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (sorted? const-decl "bool" sortedlist nil)
    (member def-decl "bool" list_props nil))
   nil))
 (s_insert_TCC2 0
  (s_insert_TCC2-1 nil 3577837025
   ("" (grind :exclude sorted?) (("" (grind) nil nil)) nil)
   ((sorted_aux? def-decl "bool" sortedlist nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (sorted? const-decl "bool" sortedlist nil)
    (list type-decl nil list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (< const-decl "bool" before_list nil)
    (T formal-type-decl nil sortedlist nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (/= const-decl "boolean" notequal nil))
   nil))
 (s_insert_TCC3 0
  (s_insert_TCC3-1 nil 3577837025
   ("" (skeep)
    (("" (skeep) (("" (prop) (("" (grind) nil nil)) nil)) nil)) nil)
   ((< const-decl "bool" before_list nil)
    (T formal-type-decl nil sortedlist nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (member def-decl "bool" list_props nil))
   nil))
 (s_insert_TCC4 0
  (s_insert_TCC4-1 nil 3577837025
   ("" (grind :if-match nil :defs nil)
    (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil)
     ("4" (lemma car_sorted)
      (("4" (expand sorted?)
        (("4" (expand sorted_aux? +)
          (("4" (inst - "car(v!1(a!1,slt!1))" sl!1)
            (("1" (inst - "(a!1,slt!1)")
              (("1" (inst - "car(v!1(a!1,slt!1))")
                (("1" (grind :exclude (sorted_aux?))
                  (("1" (typepred "v!1(a!1,slt!1)")
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                   ("2" (typepred "v!1(a!1,slt!1)")
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                   ("3" (typepred "v!1(a!1,slt!1)")
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
                   ("4" (typepred <=)
                    (("4"
                      (lazy-grind :if-match all :exclude
                       (sorted? sorted_aux?))
                      nil nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil) ("3" (grind) nil nil))
                nil)
               ("2" (grind) nil nil))
              nil)
             ("2" (grind) nil nil) ("3" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((car_sorted formula-decl nil sortedlist nil)
    (reflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (partial_order? const-decl "bool" orders nil)
    (dichotomous? const-decl "bool" orders nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (sl!1 skolem-const-decl "(sorted?)" sortedlist nil)
    (v!1 skolem-const-decl
     "[d1: {z: [T, (sorted?)] | length(z`2) < length(sl!1)} ->
   {s: (sorted?) | FORALL x: member(x, s) IFF x = d1`1 OR member(x, d1`2)}]"
     sortedlist nil)
    (a!1 skolem-const-decl "T" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (< const-decl "bool" before_list nil)
    (strict_total_order? const-decl "bool" orders nil)
    (slt!1 skolem-const-decl "list[T]" sortedlist nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? const-decl "bool" sortedlist nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   nil))
 (s_subset?_TCC1 0
  (s_subset?_TCC1-1 nil 3577837025
   ("" (skeep)
    (("" (skeep) (("" (typepred sl1) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? const-decl "bool" sortedlist nil))
   nil))
 (s_subset?_TCC2 0
  (s_subset?_TCC2-1 nil 3577837025
   ("" (skeep)
    (("" (skeep) (("" (typepred sl2) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? const-decl "bool" sortedlist nil))
   nil))
 (s_subset?_TCC3 0
  (s_subset?_TCC3-1 nil 3577837025 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? const-decl "bool" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil))
   nil))
 (s_subset?_TCC4 0
  (s_subset?_TCC4-1 nil 3577837025
   ("" (skeep)
    (("" (skeep) (("" (typepred sl2) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (< const-decl "bool" before_list nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? const-decl "bool" sortedlist nil))
   nil))
 (s_subset?_TCC5 0
  (s_subset?_TCC5-1 nil 3577837025 ("" (termination-tcc) nil nil)
   ((sorted? const-decl "bool" sortedlist nil)
    (list type-decl nil list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (< const-decl "bool" before_list nil))
   nil))
 (s_subset?_TCC6 0
  (s_subset?_TCC6-1 nil 3577837025
   ("" (typepred <=) (("" (grind :if-match all) nil nil)) nil)
   ((< const-decl "bool" before_list nil)
    (/= const-decl "boolean" notequal nil)
    (dichotomous? const-decl "bool" orders nil)
    (partial_order? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (sorted? const-decl "bool" sortedlist nil)
    (list type-decl nil list_adt nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil))
   nil))
 (s_subset?_TCC7 0
  (s_subset?_TCC7-1 nil 3577837025
   ("" (typepred <=) (("" (grind :if-match all) nil nil)) nil)
   ((< const-decl "bool" before_list nil)
    (/= const-decl "boolean" notequal nil)
    (dichotomous? const-decl "bool" orders nil)
    (partial_order? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (sorted? const-decl "bool" sortedlist nil)
    (list type-decl nil list_adt nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil))
   nil))
 (s_equal?_TCC1 0
  (s_equal?_TCC1-1 nil 3578245369 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (< const-decl "bool" before_list nil)
    (sorted? const-decl "bool" sortedlist nil))
   nil))
 (s_equal?_TCC2 0
  (s_equal?_TCC2-1 nil 3578245369 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (< const-decl "bool" before_list nil)
    (sorted? const-decl "bool" sortedlist nil))
   nil))
 (s_equal?_TCC3 0
  (s_equal?_TCC3-1 nil 3578245369 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? const-decl "bool" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil))
   nil))
 (lessp_TCC1 0
  (lessp_TCC1-1 nil 3578662238
   ("" (skeep)
    (("" (use member_reverse)
      (("" (inst - "car(sl1)")
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((member_reverse formula-decl nil list_basic_props nil)
    (T formal-type-decl nil sortedlist nil)
    (sorted? const-decl "bool" sortedlist nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (member def-decl "bool" list_props nil)
    (reverse def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (sl1 skolem-const-decl "(sorted?)" sortedlist nil))
   nil))
 (sorted_uniques 0
  (sorted_uniques-1 nil 3578073858
   ("" (induct-and-simplify sl :exclude sorted?)
    (("1" (lemma car_sorted)
      (("1" (inst - cons1_var!1 "cons(cons1_var!1,cons2_var!1)")
        (("1" (grind) nil nil)) nil))
      nil)
     ("2" (grind) nil nil))
    nil)
   ((nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (car_sorted formula-decl nil sortedlist nil)
    (< const-decl "bool" before_list nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? const-decl "bool" sortedlist nil)
    (uniques? def-decl "bool" list_sets_props nil)
    (T formal-type-decl nil sortedlist nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (s_equal_char 0
  (s_equal_char-1 nil 3578255840
   ("" (induct sl1)
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skeep)
      (("3" (skeep)
        (("3" (use cdr_sorted)
          (("3" (simplify)
            (("3" (prop)
              (("1" (expand s_equal? -1)
                (("1" (lift-if)
                  (("1" (prop)
                    (("1" (typepred <=)
                      (("1" (inst - "cdr(sl2)")
                        (("1" (decompose-equality) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand s_equal? +)
                (("2" (lift-if)
                  (("2" (prop)
                    (("1" (grind) nil nil)
                     ("2" (decompose-equality)
                      (("2" (inst - "cdr(sl2)")
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil))
                      nil)
                     ("3" (inst - "cdr(sl2)")
                      (("3" (decompose-equality)
                        (("3" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cdr_sorted formula-decl nil sortedlist nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (sl2 skolem-const-decl "(sorted?)" sortedlist nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (s_equal? def-decl "bool" sortedlist nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? const-decl "bool" sortedlist nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (filter_sorted 0
  (filter_sorted-1 nil 3577837025
   ("" (induct-and-simplify sl :defs nil :if-match nil)
    (("1" (grind) nil nil)
     ("2" (inst - p!1)
      (("2" (expand filter +)
        (("2" (expand sorted? 1 1)
          (("2" (expand sorted_aux? +)
            (("2" (grind :exclude (sorted_aux? filter))
              (("1" (lemma car_sorted)
                (("1"
                  (inst - "car(filter(cons2_var!1,p!1))"
                   "cons(cons1_var!1,cons2_var!1)")
                  (("1" (typepred "filter(cons2_var!1,p!1)")
                    (("1" (inst - "car(filter(cons2_var!1,p!1))")
                      (("1" (expand member -1 1)
                        (("1" (grind :exclude (sorted_aux? filter)) nil
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (typepred "filter(cons2_var!1,p!1)")
                (("2" (lemma car_sorted)
                  (("2"
                    (inst - "car(filter(cons2_var!1,p!1))"
                     "cons(cons1_var!1,cons2_var!1)")
                    (("2" (inst - "car(filter(cons2_var!1,p!1))")
                      (("2" (typepred <=) (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (grind) nil nil))
    nil)
   ((< const-decl "bool" before_list nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (car_sorted formula-decl nil sortedlist nil)
    (dichotomous? const-decl "bool" orders nil)
    (partial_order? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (filter_member rec-application-judgement
     "{m | FORALL x: member(x, m) IFF p(x) AND member(x, l)}"
     sortedlist nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? const-decl "bool" sortedlist nil)
    (PRED type-eq-decl nil defined_types nil)
    (pred type-eq-decl nil defined_types nil)
    (filter def-decl "list[T]" filters nil)
    (T formal-type-decl nil sortedlist nil)
    (list_induction formula-decl nil list_adt nil))
   nil))
 (s_member_member 0
  (s_member_member-1 nil 3578055388
   ("" (use strict_total_order)
    (("" (typepred <=)
      (("" (induct-and-simplify sl :if-match nil :exclude sorted?)
        (("1" (lemma car_sorted)
          (("1" (inst - a!1 "cons(cons1_var!1,cons2_var!1)")
            (("1" (grind :if-match all :exclude sorted?) nil nil))
            nil))
          nil)
         ("2" (grind :if-match all :exclude sorted?) nil nil)
         ("3" (grind :if-match all :exclude sorted?) nil nil)
         ("4" (grind) nil nil) ("5" (grind) nil nil)
         ("6" (grind) nil nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (car_sorted formula-decl nil sortedlist nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (reflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (partial_order? const-decl "bool" orders nil)
    (dichotomous? const-decl "bool" orders nil)
    (< const-decl "bool" before_list nil)
    (irreflexive? const-decl "bool" relations nil)
    (/= const-decl "boolean" notequal nil)
    (strict_order? const-decl "bool" orders nil)
    (trichotomous? const-decl "bool" orders nil)
    (strict_total_order? const-decl "bool" orders nil)
    (list type-decl nil list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? const-decl "bool" sortedlist nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (s_member def-decl "bool" sortedlist nil)
    (member def-decl "bool" list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (strict_total_order formula-decl nil before_list nil))
   shostak))
 (s_subset_subset 0
  (s_subset_subset-1 nil 3578074019
   ("" (induct sl2)
    (("1" (grind) nil nil)
     ("2" (grind :rewrites every_forall)
      (("1" (expand s_subset?) (("1" (grind) nil nil)) nil)
       ("2" (inst - "car(sl1!1)")
        (("1" (expand member) (("1" (grind) nil nil)) nil)
         ("2" (grind) nil nil))
        nil))
      nil)
     ("3" (skosimp*)
      (("3" (prop)
        (("1" (expand s_subset? -1)
          (("1" (lift-if)
            (("1" (prop)
              (("1" (grind) nil nil)
               ("2" (lift-if)
                (("2" (prop)
                  (("1" (grind) nil nil)
                   ("2" (inst - "cdr(sl1!1)")
                    (("2" (prop)
                      (("1" (expand subset?)
                        (("1" (rewrite every_forall)
                          (("1" (rewrite every_forall)
                            (("1" (skeep)
                              (("1"
                                (inst - x_1)
                                (("1" (grind) nil nil)
                                 ("2"
                                  (typepred x_1)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil)
                   ("3" (inst - sl1!1)
                    (("3" (prop)
                      (("1" (expand subset?)
                        (("1" (rewrite every_forall)
                          (("1" (rewrite every_forall)
                            (("1" (skeep)
                              (("1"
                                (inst - x_1)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand s_subset? +)
          (("2" (lift-if)
            (("2" (prop)
              (("1" (grind) nil nil)
               ("2" (lift-if)
                (("2" (prop)
                  (("1" (expand subset? -2)
                    (("1" (rewrite every_forall)
                      (("1" (inst - "car(sl1!1)")
                        (("1" (use s_member_member)
                          (("1" (grind) nil nil)) nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inst - "cdr(sl1!1)")
                    (("2" (expand subset?)
                      (("2" (rewrite every_forall)
                        (("2" (rewrite every_forall)
                          (("2" (expand member -2)
                            (("2" (prop)
                              (("1" (grind) nil nil)
                               ("2"
                                (skeep)
                                (("2"
                                  (inst - x_1)
                                  (("1"
                                    (lemma car_sorted)
                                    (("1"
                                      (inst - x_1 "sl1!1")
                                      (("1"
                                        (typepred x_1)
                                        (("1" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (inst - sl1!1)
                    (("3" (prop)
                      (("1" (grind) nil nil)
                       ("2" (expand subset?)
                        (("2" (rewrite every_forall)
                          (("2" (rewrite every_forall)
                            (("2" (skeep)
                              (("2"
                                (inst - x_1)
                                (("2"
                                  (lemma car_sorted)
                                  (("2"
                                    (inst - x_1 "sl1!1")
                                    (("2"
                                      (expand member -2)
                                      (("2"
                                        (prop)
                                        (("1" (grind) nil nil)
                                         ("2" (grind) nil nil)
                                         ("3"
                                          (typepred x_1)
                                          (("3" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (grind) nil nil) ("4" (grind) nil nil))
        nil))
      nil))
    nil)
   ((s_member_member formula-decl nil sortedlist nil)
    (cons2_var!1 skolem-const-decl "list[T]" sortedlist nil)
    (cons1_var!1 skolem-const-decl "T" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (s_member def-decl "bool" sortedlist nil)
    (x_1 skolem-const-decl "{x_1 | member(x_1, cdr(sl1!1))}" sortedlist
     nil)
    (car_sorted formula-decl nil sortedlist nil)
    (every adt-def-decl "boolean" list_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (total_order? const-decl "bool" orders nil)
    (< const-decl "bool" before_list nil)
    (x_1 skolem-const-decl "{x_1 | member(x_1, sl1!1)}" sortedlist nil)
    (sl1!1 skolem-const-decl "(sorted?)" sortedlist nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (every_forall formula-decl nil list_basic_props nil)
    (member def-decl "bool" list_props nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (sl1!1 skolem-const-decl "(sorted?)" sortedlist nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (subset? const-decl "bool" list_sets_props nil)
    (s_subset? def-decl "bool" sortedlist nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? const-decl "bool" sortedlist nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (s_equal_equal 0
  (s_equal_equal-2 "to terminate" 3578948819
   ("" (induct sl1)
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skosimp*)
      (("3" (split 1)
        (("1" (use s_equal_char)
          (("1" (grind :defs nil :rewrites (member_equal every_forall))
            nil nil))
          nil)
         ("2" (split -1)
          (("1" (inst - "cdr(sl2!1)")
            (("1"
              (case "FORALL (sl1,sl2:(sorted?)): cons?(sl1) AND cons?(sl2) AND equal?(sl1,sl2) IMPLIES car(sl1)=car(sl2)")
              (("1" (prop)
                (("1" (use s_equal_char)
                  (("1" (use s_equal_char (sl2 sl2!1))
                    (("1"
                      (inst - "cons(cons1_var!1,cons2_var!1)" sl2!1)
                      (("1" (grind) nil nil)) nil))
                    nil))
                  nil)
                 ("2"
                  (case "FORALL (sl1,sl2:(sorted?)): FORALL (x:T): cons?(sl1) AND cons?(sl2) AND equal?(sl1,sl2) AND member(x,cdr(sl1)) IMPLIES member(x,cdr(sl2))")
                  (("1" (rewrite member_equal 1)
                    (("1" (skeep)
                      (("1" (split 1)
                        (("1"
                          (inst - "cons(cons1_var!1,cons2_var!1)"
                           sl2!1)
                          (("1" (grind) nil nil)) nil)
                         ("2"
                          (inst - sl2!1
                           "cons(cons1_var!1,cons2_var!1)")
                          (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (skeep)
                    (("2" (hide -2 -3 2 3 4)
                      (("2" (skeep)
                        (("2" (copy -3)
                          (("2" (rewrite member_equal -4)
                            (("2" (inst - x)
                              (("2"
                                (inst - sl1 sl2)
                                (("2"
                                  (use car_sorted)
                                  (("2"
                                    (expand member -2)
                                    (("2"
                                      (expand <)
                                      (("2"
                                        (rewrite member_equal)
                                        (("2"
                                          (grind :defs nil)
                                          nil
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide -1 -2 2)
                (("2" (skeep)
                  (("2" (rewrite member_equal)
                    (("2" (copy -3)
                      (("2" (inst - "car(sl1)")
                        (("2" (inst - "car(sl2)")
                          (("2" (lemma car_sorted)
                            (("2" (copy -1)
                              (("2"
                                (inst - "car(sl1)" sl2)
                                (("2"
                                  (inst - "car(sl2)" sl1)
                                  (("2"
                                    (expand <)
                                    (("2"
                                      (expand member -3)
                                      (("2"
                                        (expand member -6)
                                        (("2"
                                          (typepred <=)
                                          (("2"
                                            (grind
                                             :exclude
                                             (member)
                                             :if-match
                                             all)
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (typepred sl2!1)
              (("2" (use cdr_sorted) (("2" (grind) nil nil)) nil)) nil)
             ("3" (grind) nil nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((cdr_sorted formula-decl nil sortedlist nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (car_sorted formula-decl nil sortedlist nil)
    (cons2_var!1 skolem-const-decl "list[T]" sortedlist nil)
    (< const-decl "bool" before_list nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (dichotomous? const-decl "bool" orders nil)
    (partial_order? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (sl2!1 skolem-const-decl "(sorted?)" sortedlist nil)
    (cons1_var!1 skolem-const-decl "T" sortedlist nil)
    (s_equal_char formula-decl nil sortedlist nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (member_equal formula-decl nil list_sets_props nil)
    (member def-decl "bool" list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (every_forall formula-decl nil list_basic_props nil)
    (subset? const-decl "bool" list_sets_props nil)
    (every adt-def-decl "boolean" list_adt nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (equal? const-decl "bool" list_sets_props nil)
    (s_equal? def-decl "bool" sortedlist nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? const-decl "bool" sortedlist nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak)
  (s_equal_equal-1 nil 3578083479
   (""
    (induct-and-simplify sl1 :theories more_list_props[T] :defs nil
     :rewrites s_equal_char :exclude (equal_symmetric member_nth)
     :if-match nil)
    (("1" (grind) nil nil)
     ("2" (inst - "cdr(sl2!1)")
      (("1" (prop)
        (("1" (use s_equal_char)
          (("1" (prop)
            (("1" (inst - cons1_var!1)
              (("1" (inst - cons1_var!1)
                (("1" (decompose-equality 1)
                  (("1" (lemma car_sorted)
                    (("1"
                      (inst - "cons1_var!1"
                       "cons(cons1_var!1,cons2_var!1)")
                      (("1" (expand member -7 2)
                        (("1" (grind :defs nil)
                          (("1" (grind) nil nil) ("2" (grind) nil nil)
                           ("3" (grind) nil nil) ("4" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (inst - x)
            (("2"
              (grind-with-lemmas car_sorted :if-match all :exclude
               sorted?)
              (("1" (reveal *)
                (("1" (hide -2 -3)
                  (("1" (inst - cons1_var!1)
                    (("1"
                      (use car_sorted
                           (sl "cons(cons1_var!1,cons2_var!1)" a x))
                      (("1" (use car_sorted (sl sl2!1 a cons1_var!1))
                        (("1" (hide 2 3)
                          (("1" (typepred key)
                            (("1" (grind :exclude (sorted?))
                              (("1"
                                (expand member -8)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (expand member -7)
                                (("2"
                                  (expand member -4)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (reveal *)
                (("2" (hide -2 -3)
                  (("2" (expand s_equal? +)
                    (("2" (lift-if)
                      (("2" (prop)
                        (("1" (grind) nil nil)
                         ("2" (lift-if)
                          (("2" (prop)
                            (("1" (inst - "car(sl2!1)")
                              (("1"
                                (use sorted_uniques)
                                (("1"
                                  (expand uniques?)
                                  (("1" (grind :defs nil) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (copy -1)
                              (("2"
                                (inst - "car(sl2!1)")
                                (("2"
                                  (use car_sorted)
                                  (("2"
                                    (use
                                     s_member_member
                                     (sl
                                      "cons(cons1_var!1,cons2_var!1)"))
                                    (("2"
                                      (grind :exclude sorted?)
                                      (("1"
                                        (hide
                                         -1
                                         -2
                                         -4
                                         -5
                                         1
                                         2
                                         4
                                         5
                                         7
                                         8
                                         9)
                                        (("1"
                                          (grind)
                                          (("1"
                                            (expand member)
                                            (("1" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (hide
                                         -1
                                         -2
                                         -4
                                         -5
                                         1
                                         2
                                         4
                                         5
                                         7
                                         8
                                         9)
                                        (("2"
                                          (expand member)
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (inst - "car(sl2!1)")
                              (("3"
                                (use
                                 s_member_member
                                 (sl "cons(cons1_var!1,cons2_var!1)"))
                                (("3"
                                  (use car_sorted)
                                  (("3"
                                    (grind :exclude sorted?)
                                    (("1"
                                      (hide
                                       -1
                                       -2
                                       -3
                                       -4
                                       1
                                       2
                                       3
                                       4
                                       5
                                       6
                                       8
                                       9
                                       10)
                                      (("1"
                                        (grind)
                                        (("1"
                                          (expand member)
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (hide
                                       -1
                                       -2
                                       -3
                                       -4
                                       1
                                       2
                                       3
                                       4
                                       5
                                       6
                                       8
                                       9
                                       10)
                                      (("2"
                                        (expand member)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (expand member 5)
                (("3" (grind :exclude (member sorted?))
                  (("3" (reveal *)
                    (("3" (hide -2 -3)
                      (("3" (inst - "cons1_var!1")
                        (("3" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (use cdr_sorted) (("2" (grind) nil nil)) nil)
       ("3" (grind) nil nil))
      nil)
     ("3" (grind) nil nil))
    nil)
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (injective? const-decl "bool" functions nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (s_member def-decl "bool" sortedlist nil)
    (s_member_member formula-decl nil sortedlist nil)
    (sorted_uniques formula-decl nil sortedlist nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" sortedlist nil)
    (car_sorted formula-decl nil sortedlist nil)
    (cdr_sorted formula-decl nil sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (member def-decl "bool" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (s_equal_char formula-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? const-decl "bool" sortedlist nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (s_equal? def-decl "bool" sortedlist nil)
    (T formal-type-decl nil sortedlist nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (s_remove_remove 0
  (s_remove_remove-1 nil 3578071003
   ("" (skeep)
    (("" (typepred "filter(sl,LAMBDA (x:T):x/=a)")
      (("" (typepred "s_remove(a,sl)")
        (("" (use s_equal_char)
          (("" (use s_equal_equal)
            (("" (rewrite member_equal)
              (("" (prop)
                (("" (skeep)
                  (("" (inst - x_1)
                    (("" (inst - x_1) (("" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((AND const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (filter def-decl "list[T]" filters nil)
    (pred type-eq-decl nil defined_types nil)
    (sorted? const-decl "bool" sortedlist nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (filter_member rec-application-judgement
     "{m | FORALL x: member(x, m) IFF p(x) AND member(x, l)}"
     sortedlist nil)
    (filter_sorted application-judgement "(sorted?)" sortedlist nil)
    (s_equal_char formula-decl nil sortedlist nil)
    (member_equal formula-decl nil list_sets_props nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (s_equal_equal formula-decl nil sortedlist nil)
    (s_remove def-decl
     "{s: (sorted?) | FORALL x: member(x, s) IFF NOT x = a AND member(x, sl)}"
     sortedlist nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   shostak))
 (s_before_before 0
  (s_before_before-1 nil 3578421217
   ("" (skeep)
    (("" (lemma max_sorted)
      (("" (lemma min_sorted)
        (("" (lemma before_char)
          (("" (inst - sl1 sl2)
            (("1" (inst - sl2)
              (("1" (inst - sl1) (("1" (grind) nil nil)) nil)) nil)
             ("2" (grind) nil nil) ("3" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((max_sorted formula-decl nil sortedlist nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (before_char formula-decl nil before_list nil)
    (< const-decl "bool" sortedlist nil)
    (min const-decl
         "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES x <= y)}"
         min_max_list nil)
    (max const-decl
         "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES y <= x)}"
         min_max_list nil)
    (< const-decl "bool" before_list nil)
    (< const-decl "bool" before_list nil)
    (/= const-decl "boolean" notequal nil)
    (reverse def-decl "list[T]" list_props nil)
    (member def-decl "bool" list_props nil)
    (sl2 skolem-const-decl "(sorted?)" sortedlist nil)
    (sl1 skolem-const-decl "(sorted?)" sortedlist nil)
    (sorted? const-decl "bool" sortedlist nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (min_sorted formula-decl nil sortedlist nil))
   shostak))
 (append_sorted 0
  (append_sorted-1 nil 3578684494
   ("" (skeep)
    (("" (use nth_sorted)
      (("" (prop)
        (("1" (use s_before_before)
          (("1" (prop)
            (("1" (expand < 1)
              (("1" (prop)
                (("1" (grind) nil nil)
                 ("2" (skeep)
                  (("2" (use member_nth)
                    (("2" (use member_nth (x y))
                      (("2" (prop)
                        (("2" (skeep)
                          (("2" (skeep)
                            (("2" (inst - i "i!1 + length(sl1)")
                              (("1"
                                (use nth_append)
                                (("1"
                                  (use
                                   nth_append
                                   (l sl1 m sl2 i "i!1 + length(sl1)"))
                                  (("1" (grind) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (rewrite length_append)
                                (("2" (grind) nil nil))
                                nil)
                               ("3"
                                (rewrite length_append)
                                (("3" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (use s_before_before)
          (("2" (prop)
            (("2" (expand < -2)
              (("2" (prop)
                (("2" (skeep)
                  (("2" (rewrite nth_append)
                    (("1" (rewrite nth_append)
                      (("1" (lift-if)
                        (("1" (prop)
                          (("1" (lift-if)
                            (("1" (prop)
                              (("1"
                                (typepred sl1)
                                (("1"
                                  (use nth_sorted)
                                  (("1"
                                    (prop)
                                    (("1"
                                      (inst - i j)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (inst
                                 -
                                 "nth(sl1,i)"
                                 "nth(sl2,j-length(sl1))")
                                (("1"
                                  (rewrite member_nth)
                                  (("1"
                                    (rewrite member_nth)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (lift-if)
                            (("2" (prop)
                              (("1"
                                (typepred sl1)
                                (("1"
                                  (use nth_sorted)
                                  (("1"
                                    (prop)
                                    (("1"
                                      (inst - i j)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil)
                           ("3" (lift-if)
                            (("3" (prop)
                              (("1" (grind) nil nil)
                               ("2"
                                (typepred sl2)
                                (("2"
                                  (use nth_sorted)
                                  (("2"
                                    (prop)
                                    (("2"
                                      (inst
                                       -
                                       "i-length(sl1)"
                                       "j-length(sl1)")
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil)
                                       ("3" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("4" (lift-if)
                            (("4" (prop)
                              (("1"
                                (inst
                                 -
                                 "nth(sl1,j)"
                                 "nth(sl2,i-length(sl1))")
                                (("1"
                                  (rewrite member_nth)
                                  (("1"
                                    (rewrite member_nth)
                                    (("1"
                                      (grind)
                                      (("1"
                                        (typepred i)
                                        (("1"
                                          (typepred <=)
                                          (("1"
                                            (grind :if-match all)
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil)
                               ("2"
                                (typepred sl2)
                                (("2"
                                  (use nth_sorted)
                                  (("2"
                                    (prop)
                                    (("2"
                                      (inst
                                       -
                                       "i-length(sl1)"
                                       "j-length(sl1)")
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil)
                                       ("3" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (lift-if)
                        (("2" (prop)
                          (("1" (typepred j)
                            (("1" (rewrite length_append) nil nil))
                            nil)
                           ("2" (typepred j)
                            (("2" (rewrite length_append) nil nil))
                            nil)
                           ("3" (typepred j)
                            (("3" (rewrite length_append) nil nil))
                            nil)
                           ("4" (typepred j)
                            (("4" (rewrite length_append) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (typepred i)
                      (("2" (rewrite length_append) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (typepred sl1)
          (("3" (use "append_null[T]") (("3" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((nth_sorted formula-decl nil sortedlist nil)
    (sorted? const-decl "bool" sortedlist nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (append def-decl "list[T]" list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (append_null formula-decl nil list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (j skolem-const-decl "below(length(append(sl1, sl2)))" sortedlist
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (i skolem-const-decl "below(length(append(sl1, sl2)))" sortedlist
     nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (reverse def-decl "list[T]" list_props nil)
    (dichotomous? const-decl "bool" orders nil)
    (partial_order? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (s_before_before formula-decl nil sortedlist nil)
    (< const-decl "bool" before_list nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sl2 skolem-const-decl "(sorted?)" sortedlist nil)
    (i skolem-const-decl "below(length(sl1))" sortedlist nil)
    (below type-eq-decl nil naturalnumbers nil)
    (sl1 skolem-const-decl "(sorted?)" sortedlist nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (i!1 skolem-const-decl "below(length(sl2))" sortedlist nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (< const-decl "bool" before_list nil)
    (< const-decl "bool" sortedlist nil)
    (nth def-decl "T" list_props nil)
    (nth_append formula-decl nil list_basic_props nil)
    (length_append formula-decl nil list_props nil)
    (member_nth formula-decl nil list_basic_props nil))
   shostak))
 (insert_remove 0
  (insert_remove-1 nil 3578072551
   ("" (induct-and-simplify sl :exclude sorted?)
    (("1" (typepred <=)
      (("1" (expand s_insert +) (("1" (grind) nil nil)) nil)) nil)
     ("2" (grind) nil nil) ("3" (grind) nil nil))
    nil)
   ((nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (reflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (partial_order? const-decl "bool" orders nil)
    (dichotomous? const-decl "bool" orders nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (< const-decl "bool" before_list nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? const-decl "bool" sortedlist nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_insert def-decl
     "{s: (sorted?) | FORALL x: member(x, s) IFF x = a OR member(x, sl)}"
     sortedlist nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (s_remove def-decl
     "{s: (sorted?) | FORALL x: member(x, s) IFF NOT x = a AND member(x, sl)}"
     sortedlist nil)
    (T formal-type-decl nil sortedlist nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (remove_insert 0
  (remove_insert-1 nil 3578072670
   ("" (induct-and-simplify sl :exclude sorted?) (("" (grind) nil nil))
    nil)
   ((nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (< const-decl "bool" before_list nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? const-decl "bool" sortedlist nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (s_remove def-decl
     "{s: (sorted?) | FORALL x: member(x, s) IFF NOT x = a AND member(x, sl)}"
     sortedlist nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (s_insert def-decl
     "{s: (sorted?) | FORALL x: member(x, s) IFF x = a OR member(x, sl)}"
     sortedlist nil)
    (T formal-type-decl nil sortedlist nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (insert_no_change 0
  (insert_no_change-1 nil 3578072686
   ("" (induct sl)
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skeep)
      (("3" (skeep)
        (("3" (expand s_insert +)
          (("3" (prop)
            (("1" (lift-if)
              (("1" (prop)
                (("1" (decompose-equality) (("1" (grind) nil nil)) nil)
                 ("2" (typepred <=) (("2" (grind) nil nil)) nil)
                 ("3" (decompose-equality)
                  (("3" (inst - a) (("3" (grind) nil nil)) nil)) nil))
                nil))
              nil)
             ("2" (lift-if)
              (("2" (prop)
                (("1" (lemma car_sorted)
                  (("1" (inst - a "cons(cons1_var,cons2_var)")
                    (("1" (use strict_total_order)
                      (("1" (expand strict_total_order?)
                        (("1" (expand strict_order?)
                          (("1" (expand irreflexive?)
                            (("1" (expand transitive?)
                              (("1"
                                (flatten -1)
                                (("1"
                                  (inst - cons1_var)
                                  (("1"
                                    (inst - cons1_var a cons1_var)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil)
             ("3" (grind) nil nil) ("4" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((car_sorted formula-decl nil sortedlist nil)
    (strict_total_order formula-decl nil before_list nil)
    (strict_order? const-decl "bool" orders nil)
    (/= const-decl "boolean" notequal nil)
    (trichotomous? const-decl "bool" orders nil)
    (irreflexive? const-decl "bool" relations nil)
    (strict_total_order? const-decl "bool" orders nil)
    (cons2_var skolem-const-decl "list[T]" sortedlist nil)
    (cons1_var skolem-const-decl "T" sortedlist nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (dichotomous? const-decl "bool" orders nil)
    (partial_order? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" before_list nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (s_insert def-decl
     "{s: (sorted?) | FORALL x: member(x, s) IFF x = a OR member(x, sl)}"
     sortedlist nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? const-decl "bool" sortedlist nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (remove_no_change 0
  (remove_no_change-1 nil 3578073080
   ("" (induct sl)
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skeep)
      (("3" (skeep)
        (("3" (split -1)
          (("1" (prop)
            (("1" (expand s_remove -1)
              (("1" (lift-if)
                (("1" (prop)
                  (("1" (grind) nil nil)
                   ("2" (use s_member_member) (("2" (grind) nil nil))
                    nil)
                   ("3" (inst - a)
                    (("3" (decompose-equality)
                      (("3" (typepred <=) (("3" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand s_remove +)
              (("2" (lift-if)
                (("2" (prop)
                  (("1" (typepred <=) (("1" (grind) nil nil)) nil)
                   ("2" (inst - a) (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((< const-decl "bool" before_list nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (s_member def-decl "bool" sortedlist nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons1_var skolem-const-decl "T" sortedlist nil)
    (cons2_var skolem-const-decl "list[T]" sortedlist nil)
    (s_member_member formula-decl nil sortedlist nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (dichotomous? const-decl "bool" orders nil)
    (partial_order? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (s_remove def-decl
     "{s: (sorted?) | FORALL x: member(x, s) IFF NOT x = a AND member(x, sl)}"
     sortedlist nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? const-decl "bool" sortedlist nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (insert_sort_TCC1 0
  (insert_sort_TCC1-1 nil 3579465649 ("" (grind) nil nil)
   ((sorted_aux? def-decl "bool" sortedlist nil)
    (sorted? const-decl "bool" sortedlist nil)
    (member def-decl "bool" list_props nil))
   nil))
 (insert_sort_TCC2 0
  (insert_sort_TCC2-1 nil 3579465649 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (insert_sort_TCC3 0
  (insert_sort_TCC3-1 nil 3579465649
   ("" (induct l)
    (("1" (grind) nil nil)
     ("2" (skosimp*)
      (("2" (typepred "s_insert(h!1,v!1(lt!1))")
        (("2" (typepred "v!1(lt!1)")
          (("2" (inst - x!1)
            (("2" (inst - x!1)
              (("2" (decompose-equality -6)
                (("2" (expand member 1 2) (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (grind) nil nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (s_insert def-decl
     "{s: (sorted?) | FORALL x: member(x, s) IFF x = a OR member(x, sl)}"
     sortedlist nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (sorted? const-decl "bool" sortedlist nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil))
   nil))
 (merge_TCC1 0
  (merge_TCC1-1 nil 3578940637 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? const-decl "bool" sortedlist nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (member def-decl "bool" list_props nil)
    (sorted_aux? def-decl "bool" sortedlist nil))
   nil))
 (merge_TCC2 0
  (merge_TCC2-1 nil 3578940637 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? const-decl "bool" sortedlist nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (member def-decl "bool" list_props nil)
    (sorted_aux? def-decl "bool" sortedlist nil))
   nil))
 (merge_TCC3 0
  (merge_TCC3-1 nil 3578940637 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? const-decl "bool" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (length def-decl "nat" list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil))
   nil))
 (merge_TCC4 0
  (merge_TCC4-1 nil 3578940637
   ("" (skolem-typepred)
    (("" (prop)
      (("" (skolem-typepred)
        (("" (prop)
          (("1" (inst - "(t1!1,t2!1)")
            (("1" (lemma car_sorted)
              (("1" (lemma car_sorted)
                (("1" (inst - "car(v!1(t1!1,t2!1))" sl1!1)
                  (("1" (inst - "car(v!1(t1!1,t2!1))" sl2!1)
                    (("1" (flatten -5)
                      (("1" (inst - "car(v!1(t1!1,t2!1))")
                        (("1" (expand sorted? +)
                          (("1" (expand sorted_aux? +)
                            (("1" (expand member -5 1)
                              (("1"
                                (decompose-equality -7)
                                (("1"
                                  (decompose-equality -12)
                                  (("1"
                                    (expand sorted? -13)
                                    (("1" (grind :defs nil) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil) ("3" (grind) nil nil)
                         ("4" (grind) nil nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil) ("3" (grind) nil nil)
                     ("4" (grind) nil nil))
                    nil)
                   ("2" (grind) nil nil) ("3" (grind) nil nil)
                   ("4" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil) ("3" (grind) nil nil))
            nil)
           ("2" (skeep)
            (("2" (prop)
              (("1" (inst - "(t1!1,t2!1)")
                (("1" (flatten -4)
                  (("1" (inst - x) (("1" (grind) nil nil)) nil)) nil)
                 ("2" (grind) nil nil) ("3" (grind) nil nil))
                nil)
               ("2" (inst - "(t1!1,t2!1)")
                (("1" (grind) nil nil) ("2" (grind) nil nil)
                 ("3" (grind) nil nil))
                nil)
               ("3" (inst - "(t1!1,t2!1)")
                (("1" (flatten)
                  (("1" (inst - x) (("1" (grind) nil nil)) nil)) nil)
                 ("2" (grind) nil nil) ("3" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((car_sorted formula-decl nil sortedlist nil)
    (v!1 skolem-const-decl "[d1:
   {z: [(sorted?), (sorted?)] |
            length(z`1) + length(z`2) < length(sl1!1) + length(sl2!1)} ->
   {l: (sorted?) |
            FORALL x: member(x, l) IFF member(x, d1`1) OR member(x, d1`2)}]"
     sortedlist nil)
    (sl2!1 skolem-const-decl "(sorted?)" sortedlist nil)
    (sl1!1 skolem-const-decl "(sorted?)" sortedlist nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (< const-decl "bool" before_list nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (t2!1 skolem-const-decl "list[T]" sortedlist nil)
    (t1!1 skolem-const-decl "list[T]" sortedlist nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (sorted? const-decl "bool" sortedlist nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (merge_TCC5 0
  (merge_TCC5-1 nil 3578940637 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (< const-decl "bool" before_list nil)
    (sorted? const-decl "bool" sortedlist nil))
   nil))
 (merge_TCC6 0
  (merge_TCC6-1 nil 3578940637 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? const-decl "bool" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (length def-decl "nat" list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil))
   nil))
 (merge_TCC7 0
  (merge_TCC7-1 nil 3578940637
   ("" (skolem-typepred)
    (("" (prop)
      (("" (skolem-typepred)
        (("" (prop)
          (("1" (inst - "(t1!1,sl2!1)")
            (("1" (flatten -3)
              (("1" (inst - "car(v!1(t1!1,sl2!1))")
                (("1" (lemma car_sorted)
                  (("1" (lemma car_sorted)
                    (("1" (inst - "car(v!1(t1!1,sl2!1))" sl1!1)
                      (("1" (inst - "car(v!1(t1!1,sl2!1))" sl2!1)
                        (("1" (typepred <=)
                          (("1" (expand sorted?)
                            (("1" (expand sorted_aux? +)
                              (("1"
                                (expand member -6 3)
                                (("1"
                                  (expand member -6 1)
                                  (("1"
                                    (expand <)
                                    (("1"
                                      (expand total_order?)
                                      (("1"
                                        (expand partial_order?)
                                        (("1"
                                          (expand preorder?)
                                          (("1"
                                            (expand transitive?)
                                            (("1"
                                              (flatten -1)
                                              (("1"
                                                (expand antisymmetric?)
                                                (("1"
                                                  (inst
                                                   -
                                                   h1!1
                                                   h2!1
                                                   "car(v!1(t1!1,sl2!1))")
                                                  (("1"
                                                    (inst - h1!1 h2!1)
                                                    (("1"
                                                      (grind :defs nil)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (grind)
                                                    nil
                                                    nil)
                                                   ("3"
                                                    (typepred sl1!1)
                                                    (("3"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil) ("3" (grind) nil nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil)
           ("2" (skeep)
            (("2" (inst - "(t1!1,sl2!1)")
              (("1" (flatten -3)
                (("1" (inst - x) (("1" (grind) nil nil)) nil)) nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((car_sorted formula-decl nil sortedlist nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (dichotomous? const-decl "bool" orders nil)
    (/= const-decl "boolean" notequal nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (antisymmetric? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (partial_order? const-decl "bool" orders nil)
    (< const-decl "bool" before_list nil)
    (strict_total_order? const-decl "bool" orders nil)
    (t2!1 skolem-const-decl "list[T]" sortedlist nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (sl1!1 skolem-const-decl "(sorted?)" sortedlist nil)
    (sl2!1 skolem-const-decl "(sorted?)" sortedlist nil)
    (v!1 skolem-const-decl "[d1:
   {z: [(sorted?), (sorted?)] |
            length(z`1) + length(z`2) < length(sl1!1) + length(sl2!1)} ->
   {l: (sorted?) |
            FORALL x: member(x, l) IFF member(x, d1`1) OR member(x, d1`2)}]"
     sortedlist nil)
    (t1!1 skolem-const-decl "list[T]" sortedlist nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (sorted? const-decl "bool" sortedlist nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (merge_TCC8 0
  (merge_TCC8-1 nil 3578940637 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (< const-decl "bool" before_list nil)
    (sorted? const-decl "bool" sortedlist nil))
   nil))
 (merge_TCC9 0
  (merge_TCC9-1 nil 3578940637 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? const-decl "bool" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (length def-decl "nat" list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil))
   nil))
 (merge_TCC10 0
  (merge_TCC10-1 nil 3578940637
   ("" (skolem-typepred)
    (("" (prop)
      (("" (skolem-typepred)
        (("" (prop)
          (("1" (inst - "(sl1!1,t2!1)")
            (("1" (flatten -3)
              (("1" (inst - "car(v!1(sl1!1,t2!1))")
                (("1" (lemma car_sorted)
                  (("1" (lemma car_sorted)
                    (("1" (inst - "car(v!1(sl1!1,t2!1))" sl1!1)
                      (("1" (inst - "car(v!1(sl1!1,t2!1))" sl2!1)
                        (("1" (typepred <=)
                          (("1" (expand sorted?)
                            (("1" (expand sorted_aux? +)
                              (("1"
                                (expand member -6 2)
                                (("1"
                                  (expand member -6 1)
                                  (("1"
                                    (expand <)
                                    (("1"
                                      (expand total_order?)
                                      (("1"
                                        (expand partial_order?)
                                        (("1"
                                          (expand preorder?)
                                          (("1"
                                            (expand transitive?)
                                            (("1"
                                              (flatten -1)
                                              (("1"
                                                (expand antisymmetric?)
                                                (("1"
                                                  (inst
                                                   -
                                                   h2!1
                                                   h1!1
                                                   "car(v!1(sl1!1,t2!1))")
                                                  (("1"
                                                    (inst - h1!1 h2!1)
                                                    (("1"
                                                      (expand
                                                       dichotomous?)
                                                      (("1"
                                                        (inst
                                                         -
                                                         h1!1
                                                         h2!1)
                                                        (("1"
                                                          (grind
                                                           :defs
                                                           nil)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (grind)
                                                    nil
                                                    nil)
                                                   ("3"
                                                    (typepred sl2!1)
                                                    (("3"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil) ("3" (grind) nil nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil)
           ("2" (skeep)
            (("2" (inst - "(sl1!1,t2!1)")
              (("1" (flatten -3)
                (("1" (inst - x) (("1" (grind) nil nil)) nil)) nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((car_sorted formula-decl nil sortedlist nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil)
    (preorder? const-decl "bool" orders nil)
    (dichotomous? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (/= const-decl "boolean" notequal nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (antisymmetric? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (partial_order? const-decl "bool" orders nil)
    (< const-decl "bool" before_list nil)
    (strict_total_order? const-decl "bool" orders nil)
    (t1!1 skolem-const-decl "list[T]" sortedlist nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (sl1!1 skolem-const-decl "(sorted?)" sortedlist nil)
    (sl2!1 skolem-const-decl "(sorted?)" sortedlist nil)
    (v!1 skolem-const-decl "[d1:
   {z: [(sorted?), (sorted?)] |
            length(z`1) + length(z`2) < length(sl1!1) + length(sl2!1)} ->
   {l: (sorted?) |
            FORALL x: member(x, l) IFF member(x, d1`1) OR member(x, d1`2)}]"
     sortedlist nil)
    (t2!1 skolem-const-decl "list[T]" sortedlist nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (sorted? const-decl "bool" sortedlist nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (merge_sort_TCC1 0
  (merge_sort_TCC1-1 nil 3579465649
   ("" (skeep)
    (("" (skeep)
      (("" (rewrite partition_filter_pos)
        (("" (use st_length_filter_pos)
          (("" (prop)
            (("1" (grind) nil nil)
             ("2" (inst - 1)
              (("1" (grind) nil nil)
               ("2" (grind)
                (("1" (postpone) nil nil) ("2" (postpone) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((st_length_filter_pos formula-decl nil list_filter_props nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (member def-decl "bool" list_props nil)
    (partition_pos def-decl "[list[T], list[T]]" list_filter_props nil)
    (filter_pos const-decl "list[T]" list_filter_props nil)
    (length def-decl "nat" list_props nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (sorted? const-decl "bool" sortedlist nil)
    (sorted_aux? def-decl "bool" sortedlist nil))
   nil))
 (merge_sort_TCC2 0
  (merge_sort_TCC2-1 nil 3579465649
   ("" (skeep)
    (("" (skeep)
      (("" (skeep)
        (("" (rewrite partition_filter_pos)
          (("" (use st_length_filter_pos)
            (("" (prop)
              (("1" (grind) nil nil)
               ("2" (inst - 1)
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((partition_filter_pos formula-decl nil list_filter_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (even? const-decl "bool" integers nil)
    (T formal-type-decl nil sortedlist nil)
    (filter_pos_char application-judgement "{pp |
         FORALL x:
           (member(x, pp) IFF
             (EXISTS (i: bl(l)): nth(l, i) = x AND pi(i, x)))}"
     sortedlist nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (partition_pos def-decl "[list[T], list[T]]" list_filter_props nil)
    (filter_pos const-decl "list[T]" list_filter_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (partition_char rec-application-judgement "{pp, np |
         FORALL x:
           (member(x, pp) IFF
             (EXISTS (i: bl(l)): nth(l, i) = x AND pi(i, x)))
            AND
            (member(x, np) IFF
              (EXISTS (i: bl(l)): nth(l, i) = x AND NOT pi(i, x)))}"
     sortedlist nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (bl type-eq-decl nil list_basic_props nil)
    (l skolem-const-decl "list[T]" sortedlist nil)
    (< const-decl "bool" reals nil)
    (st_length_filter_pos formula-decl nil list_filter_props nil))
   nil))
 (merge_sort_TCC3 0
  (merge_sort_TCC3-1 nil 3579465649
   ("" (skosimp*)
    (("" (rewrite partition_filter_pos)
      (("" (lemma st_length_filter_pos)
        (("" (inst - l!1 "LAMBDA i,x: NOT even?(i)")
          (("" (prop)
            (("1" (grind) nil nil)
             ("2" (inst - 0)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((partition_filter_pos formula-decl nil list_filter_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (even? const-decl "bool" integers nil)
    (T formal-type-decl nil sortedlist nil)
    (filter_pos_char application-judgement "{pp |
         FORALL x:
           (member(x, pp) IFF
             (EXISTS (i: bl(l)): nth(l, i) = x AND pi(i, x)))}"
     sortedlist nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (l!1 skolem-const-decl "list[T]" sortedlist nil)
    (bl type-eq-decl nil list_basic_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (partition_char rec-application-judgement "{pp, np |
         FORALL x:
           (member(x, pp) IFF
             (EXISTS (i: bl(l)): nth(l, i) = x AND pi(i, x)))
            AND
            (member(x, np) IFF
              (EXISTS (i: bl(l)): nth(l, i) = x AND NOT pi(i, x)))}"
     sortedlist nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (filter_pos const-decl "list[T]" list_filter_props nil)
    (partition_pos def-decl "[list[T], list[T]]" list_filter_props nil)
    (length def-decl "nat" list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (st_length_filter_pos formula-decl nil list_filter_props nil))
   nil))
 (merge_sort_TCC4 0
  (merge_sort_TCC4-1 nil 3579466274
   ("" (skosimp*)
    (("" (typepred "merge(v!1(l1!1),v!1(l2!1))")
      (("" (typepred "v!1(l1!1)")
        (("" (typepred "v!1(l2!1)")
          (("" (lemma partition_member)
            (("" (inst - l!1 "LAMBDA i,x:even?(i)" x!1)
              (("" (inst - x!1)
                (("" (inst - x!1)
                  (("" (inst - x!1) (("" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (merge def-decl
           "{l: (sorted?) | FORALL x: member(x, l) IFF member(x, sl1) OR member(x, sl2)}"
           sortedlist nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? const-decl "bool" sortedlist nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (even? const-decl "bool" integers nil)
    (pred type-eq-decl nil defined_types nil)
    (partition_pos def-decl "[list[T], list[T]]" list_filter_props nil)
    (partition_char rec-application-judgement "{pp, np |
         FORALL x:
           (member(x, pp) IFF
             (EXISTS (i: bl(l)): nth(l, i) = x AND pi(i, x)))
            AND
            (member(x, np) IFF
              (EXISTS (i: bl(l)): nth(l, i) = x AND NOT pi(i, x)))}"
     sortedlist nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (partition_member formula-decl nil list_filter_props nil))
   nil))
 (quick_sort_TCC1 0
  (quick_sort_TCC1-1 nil 3579465649
   ("" (skosimp*)
    (("" (rewrite partition_filter)
      (("" (use length_filter) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((partition_filter formula-decl nil list_filter_props nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (< const-decl "bool" before_list nil)
    (T formal-type-decl nil sortedlist nil)
    (filter_member rec-application-judgement
     "{m | FORALL x: member(x, m) IFF p(x) AND member(x, l)}"
     sortedlist nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (/= const-decl "boolean" notequal nil)
    (length def-decl "nat" list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length_filter formula-decl nil list_filter_props nil))
   nil))
 (quick_sort_TCC2 0
  (quick_sort_TCC2-1 nil 3579465649
   ("" (skosimp*)
    (("" (rewrite partition_filter)
      (("" (lemma length_filter)
        (("" (inst - t!1 "LAMBDA x: NOT x < h!1")
          (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((partition_filter formula-decl nil list_filter_props nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (< const-decl "bool" before_list nil)
    (T formal-type-decl nil sortedlist nil)
    (filter_member rec-application-judgement
     "{m | FORALL x: member(x, m) IFF p(x) AND member(x, l)}"
     sortedlist nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (/= const-decl "boolean" notequal nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length_filter formula-decl nil list_filter_props nil))
   nil))
 (quick_sort_TCC3 0
  (quick_sort_TCC3-1 nil 3579465649
   ("" (skosimp*)
    (("" (prop)
      (("1" (typepred "v!1(l1!1)")
        (("1" (typepred "v!1(l2!1)")
          (("1" (typepred "s_insert(h!1,v!1(l2!1))")
            (("1" (use append_sorted)
              (("1" (flatten -1)
                (("1" (split -1)
                  (("1" (propax) nil nil)
                   ("2" (hide -1 -2)
                    (("2" (hide 2)
                      (("2" (prop)
                        (("2" (use s_before_before)
                          (("2" (prop)
                            (("2" (expand < 1)
                              (("2"
                                (prop)
                                (("1" (grind) nil nil)
                                 ("2"
                                  (skeep)
                                  (("2"
                                    (inst - y)
                                    (("2"
                                      (inst - y)
                                      (("2"
                                        (inst - x)
                                        (("2"
                                          (rewrite partition_filter)
                                          (("2"
                                            (typepred
                                             "filter(t!1,LAMBDA x: x < h!1)")
                                            (("2"
                                              (typepred
                                               "filter(t!1,LAMBDA x: NOT x < h!1)")
                                              (("2"
                                                (inst - y)
                                                (("2"
                                                  (inst - x)
                                                  (("2"
                                                    (rewrite -9)
                                                    (("2"
                                                      (rewrite -5)
                                                      (("2"
                                                        (split -4)
                                                        (("1"
                                                          (grind)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (rewrite -7)
                                                          (("2"
                                                            (use
                                                             strict_total_order)
                                                            (("2"
                                                              (expand
                                                               strict_total_order?)
                                                              (("2"
                                                                (expand
                                                                 strict_order?)
                                                                (("2"
                                                                  (expand
                                                                   transitive?)
                                                                  (("2"
                                                                    (flatten
                                                                     -1)
                                                                    (("2"
                                                                      (inst
                                                                       -
                                                                       x
                                                                       h!1
                                                                       y)
                                                                      (("2"
                                                                        (simplify
                                                                         -14)
                                                                        (("2"
                                                                          (simplify
                                                                           -15)
                                                                          (("2"
                                                                            (hide
                                                                             2
                                                                             3
                                                                             4
                                                                             -13
                                                                             -12
                                                                             -11
                                                                             -10
                                                                             -9
                                                                             -8)
                                                                            (("2"
                                                                              (expand
                                                                               trichotomous?)
                                                                              (("2"
                                                                                (inst
                                                                                 -
                                                                                 h!1
                                                                                 y)
                                                                                (("2"
                                                                                  (grind)
                                                                                  nil
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep)
        (("2" (use member_append)
          (("2" (typepred "v!1(l1!1)")
            (("2" (typepred "v!1(l2!1)")
              (("2" (rewrite partition_filter)
                (("2" (typepred "s_insert(h!1,v!1(l2!1))")
                  (("2" (inst - x)
                    (("2" (inst - x)
                      (("2" (inst - x)
                        (("2"
                          (typepred "filter(t!1,LAMBDA x: x < h!1)")
                          (("2"
                            (typepred
                             "filter(t!1,LAMBDA x: NOT x < h!1)")
                            (("2" (inst - x)
                              (("2"
                                (inst - x)
                                (("2"
                                  (use strict_total_order)
                                  (("2"
                                    (expand strict_total_order?)
                                    (("2"
                                      (expand trichotomous?)
                                      (("2"
                                        (flatten -1)
                                        (("2"
                                          (hide -1)
                                          (("2"
                                            (grind :if-match all)
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((append_sorted formula-decl nil sortedlist nil)
    (s_before_before formula-decl nil sortedlist nil)
    (< const-decl "bool" before_list nil)
    (< const-decl "bool" before_list nil)
    (<= formal-const-decl "(total_order?[T])" sortedlist nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (partition_filter formula-decl nil list_filter_props nil)
    (filter_member rec-application-judgement
     "{m | FORALL x: member(x, m) IFF p(x) AND member(x, l)}"
     sortedlist nil)
    (strict_total_order? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (trichotomous? const-decl "bool" orders nil)
    (irreflexive? const-decl "bool" relations nil)
    (strict_order? const-decl "bool" orders nil)
    (strict_total_order formula-decl nil before_list nil)
    (< const-decl "bool" sortedlist nil)
    (/= const-decl "boolean" notequal nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (filter def-decl "list[T]" filters nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (s_insert def-decl
     "{s: (sorted?) | FORALL x: member(x, s) IFF x = a OR member(x, sl)}"
     sortedlist nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? const-decl "bool" sortedlist nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (member_append formula-decl nil list_basic_props nil))
   nil))
 (merge_insert 0
  (merge_insert-1 nil 3579486148
   ("" (skeep)
    (("" (typepred "merge_sort(l)")
      (("" (typepred "insert_sort(l)")
        (("" (lemma member_equal)
          (("" (inst - "merge_sort(l)" "insert_sort(l)")
            (("" (use s_equal_equal)
              (("" (use s_equal_char) (("" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((merge_sort def-decl
     "{s: (sorted?) | FORALL x: member(x, s) IFF member(x, l)}"
     sortedlist nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? const-decl "bool" sortedlist nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member_equal formula-decl nil list_sets_props nil)
    (s_equal_equal formula-decl nil sortedlist nil)
    (equal? const-decl "bool" list_sets_props nil)
    (subset? const-decl "bool" list_sets_props nil)
    (every_forall formula-decl nil list_basic_props nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (s_equal_char formula-decl nil sortedlist nil)
    (insert_sort def-decl
     "{s: (sorted?) | FORALL x: member(x, s) IFF member(x, l)}"
     sortedlist nil))
   shostak))
 (merge_quick 0
  (merge_quick-1 nil 3579486292
   ("" (skeep)
    (("" (typepred "merge_sort(l)")
      (("" (typepred "quick_sort(l)")
        (("" (lemma member_equal)
          (("" (inst - "merge_sort(l)" "quick_sort(l)")
            (("" (use s_equal_equal)
              (("" (use s_equal_char) (("" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((merge_sort def-decl
     "{s: (sorted?) | FORALL x: member(x, s) IFF member(x, l)}"
     sortedlist nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (sorted? const-decl "bool" sortedlist nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member_equal formula-decl nil list_sets_props nil)
    (s_equal_equal formula-decl nil sortedlist nil)
    (equal? const-decl "bool" list_sets_props nil)
    (subset? const-decl "bool" list_sets_props nil)
    (every_forall formula-decl nil list_basic_props nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (s_equal_char formula-decl nil sortedlist nil)
    (quick_sort def-decl
     "{s: (sorted?) | FORALL x: member(x, s) IFF member(x, l)}"
     sortedlist nil))
   shostak))
 (quick_insert 0
  (quick_insert-1 nil 3579486360
   ("" (skeep)
    (("" (use merge_insert)
      (("" (use merge_quick) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((merge_insert formula-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil sortedlist nil)
    (merge_quick formula-decl nil sortedlist nil))
   shostak))
 (equal_insert 0
  (equal_insert-1 nil 3579486385
   ("" (skeep)
    (("" (all-typepreds)
      (("" (hide -3)
        (("" (use member_equal)
          (("" (lemma member_equal)
            (("" (inst - "insert_sort(l1)" "insert_sort(l2)")
              (("" (use s_equal_equal)
                (("" (use s_equal_char) (("" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? const-decl "bool" sortedlist nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (insert_sort def-decl
     "{s: (sorted?) | FORALL x: member(x, s) IFF member(x, l)}"
     sortedlist nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member_equal formula-decl nil list_sets_props nil)
    (s_equal_char formula-decl nil sortedlist nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (every_forall formula-decl nil list_basic_props nil)
    (subset? const-decl "bool" list_sets_props nil)
    (equal? const-decl "bool" list_sets_props nil)
    (x!1 skolem-const-decl "{x_1 | member(x_1, insert_sort(l1))}"
     sortedlist nil)
    (l1 skolem-const-decl "list[T]" sortedlist nil)
    (x!1 skolem-const-decl "{x_1 | member(x_1, insert_sort(l2))}"
     sortedlist nil)
    (l2 skolem-const-decl "list[T]" sortedlist nil)
    (s_equal_equal formula-decl nil sortedlist nil))
   shostak))
 (equal_merge 0
  (equal_merge-1 nil 3579486536
   ("" (skeep)
    (("" (all-typepreds)
      (("" (hide -3)
        (("" (use member_equal)
          (("" (lemma member_equal)
            (("" (inst - "merge_sort(l1)" "merge_sort(l2)")
              (("" (use s_equal_equal)
                (("" (use s_equal_char) (("" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? const-decl "bool" sortedlist nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (merge_sort def-decl
     "{s: (sorted?) | FORALL x: member(x, s) IFF member(x, l)}"
     sortedlist nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member_equal formula-decl nil list_sets_props nil)
    (s_equal_char formula-decl nil sortedlist nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (every_forall formula-decl nil list_basic_props nil)
    (subset? const-decl "bool" list_sets_props nil)
    (equal? const-decl "bool" list_sets_props nil)
    (x!1 skolem-const-decl "{x_1 | member(x_1, merge_sort(l1))}"
     sortedlist nil)
    (l1 skolem-const-decl "list[T]" sortedlist nil)
    (x!1 skolem-const-decl "{x_1 | member(x_1, merge_sort(l2))}"
     sortedlist nil)
    (l2 skolem-const-decl "list[T]" sortedlist nil)
    (s_equal_equal formula-decl nil sortedlist nil))
   shostak))
 (equal_quick 0
  (equal_quick-1 nil 3579486586
   ("" (skeep)
    (("" (all-typepreds)
      (("" (hide -3)
        (("" (use member_equal)
          (("" (lemma member_equal)
            (("" (inst - "quick_sort(l1)" "quick_sort(l2)")
              (("" (use s_equal_equal)
                (("" (use s_equal_char) (("" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil sortedlist nil)
    (list type-decl nil list_adt nil)
    (sorted? const-decl "bool" sortedlist nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (quick_sort def-decl
     "{s: (sorted?) | FORALL x: member(x, s) IFF member(x, l)}"
     sortedlist nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member_equal formula-decl nil list_sets_props nil)
    (s_equal_char formula-decl nil sortedlist nil)
    (nth_sorted_aux rec-application-judgement "{b: bool |
         b IFF
          (FORALL (i, j: below(length(l))):
             i < j IMPLIES nth(l, i) < nth(l, j))}" sortedlist nil)
    (every_forall formula-decl nil list_basic_props nil)
    (subset? const-decl "bool" list_sets_props nil)
    (equal? const-decl "bool" list_sets_props nil)
    (x!1 skolem-const-decl "{x_1 | member(x_1, quick_sort(l1))}"
     sortedlist nil)
    (l1 skolem-const-decl "list[T]" sortedlist nil)
    (x!1 skolem-const-decl "{x_1 | member(x_1, quick_sort(l2))}"
     sortedlist nil)
    (l2 skolem-const-decl "list[T]" sortedlist nil)
    (s_equal_equal formula-decl nil sortedlist nil))
   shostak)))

