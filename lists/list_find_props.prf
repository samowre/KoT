(list_find_props
 (satisfied?_some 0
  (satisfied?_some-1 nil 3579555788
   ("" (grind :rewrites (some_exists member_nth)) nil nil)
   ((some_exists formula-decl nil list_basic_props nil)
    (satisfied? const-decl "bool" list_find_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (l!1 skolem-const-decl "list[T]" list_find_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (i!1 skolem-const-decl "bl[T](l!1)" list_find_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (member def-decl "bool" list_props nil)
    (bl type-eq-decl nil list_basic_props nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member_nth formula-decl nil list_basic_props nil)
    (T formal-type-decl nil list_find_props nil))
   shostak))
 (first?_TCC1 0
  (first?_TCC1-1 nil 3579532829 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil))
   nil))
 (first?_TCC2 0
  (first?_TCC2-1 nil 3579532829 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil))
   nil))
 (first?_pi_p 0
  (first?_pi_p-1 nil 3579537751 ("" (grind-with-ext) nil nil)
   ((nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (first? const-decl "bool" list_find_props nil)
    (first? const-decl "bool" list_find_props nil)
    (pred type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil list_find_props nil))
   shostak))
 (satisfied?_first? 0
  (satisfied?_first?-1 nil 3579555849
   ("" (skeep)
    (("" (prop)
      (("1" (use wf_nat)
        (("1" (expand (well_founded? satisfied? singleton?))
          (("1"
            (inst -1 "LAMBDA i: i < length(l) AND pi(i, nth(l, i))")
            (("1" (prop)
              (("1" (skolem-typepred)
                (("1" (inst 1 "y!1")
                  (("1" (lazy-grind) nil nil)
                   ("2" (lazy-grind :if-match all) nil nil))
                  nil))
                nil)
               ("2" (lazy-grind) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((singleton? const-decl "bool" sets nil)
    (satisfied? const-decl "bool" list_find_props nil)
    (well_founded? const-decl "bool" orders nil)
    (first? const-decl "bool" list_find_props nil)
    (l skolem-const-decl "list[T]" list_find_props nil)
    (pi skolem-const-decl "pred[[nat, T]]" list_find_props nil)
    (y!1 skolem-const-decl
     "(LAMBDA i: i < length(l) AND pi(i, nth(l, i)))" list_find_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (bl type-eq-decl nil list_basic_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil list_find_props nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (wf_nat formula-decl nil naturalnumbers nil))
   shostak))
 (first?_cons_TCC1 0
  (first?_cons_TCC1-1 nil 3579535318 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (first?_cons 0
  (first?_cons-1 nil 3579535318
   ("" (skeep)
    (("" (apply-extensionality :hide? t)
      (("1" (expand first?)
        (("1" (grind :if-match nil)
          (("1" (inst -3 0) (("1" (grind) nil nil)) nil)
           ("2" (inst -4 "j!1 + 1") (("2" (grind) nil nil)) nil)
           ("3" (rewrite nth_cons)
            (("3" (lift-if)
              (("3" (prop)
                (("1" (rewrite -1) nil nil)
                 ("2" (inst -5 "j!1 - 1")
                  (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (grind) nil nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (first? const-decl "bool" list_find_props nil)
    (list type-decl nil list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil list_find_props nil)
    (pred type-eq-decl nil defined_types nil)
    (pi skolem-const-decl "pred[[nat, T]]" list_find_props nil)
    (x1 skolem-const-decl "T" list_find_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nth def-decl "T" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (x!1 skolem-const-decl "nat" list_find_props nil)
    (j!1 skolem-const-decl "below(x!1)" list_find_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nth_cons formula-decl nil list_basic_props nil))
   shostak))
 (first_TCC1 0
  (first_TCC1-1 nil 3579532829
   ("" (lemma satisfied?_first?) (("" (grind) nil nil)) nil)
   ((singleton? const-decl "bool" sets nil)
    (satisfied? const-decl "bool" list_find_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil list_find_props nil)
    (list type-decl nil list_adt nil)
    (length def-decl "nat" list_props nil)
    (bl type-eq-decl nil list_basic_props nil)
    (pred type-eq-decl nil defined_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (satisfied?_first? formula-decl nil list_find_props nil))
   nil))
 (first_TCC2 0
  (first_TCC2-1 nil 3579532829
   ("" (skeep)
    (("" (use satisfied?_first?)
      (("" (rewrite singleton_elt_def[nat])
        (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((satisfied?_first? formula-decl nil list_find_props nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil list_find_props nil)
    (singleton? const-decl "bool" sets nil)
    (satisfied? const-decl "bool" list_find_props nil)
    (first? const-decl "bool" list_find_props nil)
    (set type-eq-decl nil sets nil)
    (singleton_elt_def formula-decl nil sets nil))
   nil))
 (first_TCC3 0
  (first_TCC3-1 nil 3579537073
   ("" (use satisfied?_first?)
    (("" (skeep)
      (("" (rewrite first?_pi_p) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((singleton? const-decl "bool" sets nil)
    (satisfied? const-decl "bool" list_find_props nil)
    (bl type-eq-decl nil list_basic_props nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil list_find_props nil)
    (first?_pi_p formula-decl nil list_find_props nil)
    (satisfied?_first? formula-decl nil list_find_props nil))
   nil))
 (first_TCC4 0
  (first_TCC4-1 nil 3579537073
   ("" (skeep)
    (("" (rewrite first?_pi_p)
      (("" (use first_TCC2) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((first?_pi_p formula-decl nil list_find_props nil)
    (T formal-type-decl nil list_find_props nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (first_TCC2 subtype-tcc nil list_find_props nil))
   nil))
 (first_pi_p 0
  (first_pi_p-1 nil 3579547912
   ("" (skeep)
    (("" (expand first) (("" (rewrite first?_pi_p) nil nil)) nil)) nil)
   ((first const-decl "lift[(first?(l, pi))]" list_find_props nil)
    (first const-decl "lift[(first?(l, p))]" list_find_props nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil list_find_props nil)
    (first?_pi_p formula-decl nil list_find_props nil))
   shostak))
 (satisfied?_first 0
  (satisfied?_first-1 nil 3579556395 ("" (grind) nil nil)
   ((satisfied? const-decl "bool" list_find_props nil)
    (first? const-decl "bool" list_find_props nil)
    (member const-decl "bool" sets nil)
    (singleton_elt const-decl "T" sets nil)
    (first const-decl "lift[(first?(l, pi))]" list_find_props nil))
   shostak))
 (first_cons 0
  (first_cons-2 nil 3579556609
   ("" (skeep)
    (("" (expand first 1 1)
      (("" (rewrite first?_cons)
        (("" (lift-if)
          (("" (prop)
            (("1" (lift-if)
              (("1" (prop)
                (("1" (use singleton_elt_def[nat])
                  (("1" (prop)
                    (("1" (rewrite -1)
                      (("1" (use singleton_elt_def[nat])
                        (("1" (prop)
                          (("1" (rewrite -1) (("1" (grind) nil nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (lemma satisfied?_first?)
                      (("2" (expand satisfied?)
                        (("2" (inst -1 "cons(x1, l)" pi)
                          (("2" (prop)
                            (("2" (simplify)
                              (("2"
                                (decompose-equality)
                                (("1"
                                  (use singleton_elt_def[nat])
                                  (("1" (grind) nil nil))
                                  nil)
                                 ("2" (grind) nil nil)
                                 ("3" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skeep)
                  (("2" (rewrite nth_cons)
                    (("1" (lift-if)
                      (("1" (prop)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil)
                 ("3" (simplify)
                  (("3" (decompose-equality)
                    (("1" (use singleton_elt_lem[nat])
                      (("1" (prop)
                        (("1" (use satisfied?_first?)
                          (("1" (expand satisfied?)
                            (("1" (prop)
                              (("1"
                                (expand singleton?)
                                (("1"
                                  (skolem-typepred -2)
                                  (("1"
                                    (inst 1 "x!1 + 1")
                                    (("1"
                                      (skolem-typepred 1)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (skeep)
                                (("2"
                                  (rewrite nth_cons)
                                  (("1"
                                    (lift-if)
                                    (("1"
                                      (prop)
                                      (("1" (grind) nil nil)
                                       ("2"
                                        (inst 3 "i - 1")
                                        (("1" (grind) nil nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil)
                         ("3" (simplify) (("3" (propax) nil nil)) nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil)
                     ("2" (expand every)
                      (("2" (rewrite first?_cons)
                        (("2" (beta)
                          (("2" (prop)
                            (("1" (grind) nil nil)
                             ("2" (simplify) (("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("3" (use satisfied?_first?)
                      (("3" (prop)
                        (("1" (expand singleton?)
                          (("1" (skolem-typepred)
                            (("1" (inst 1 "x!1 + 1")
                              (("1"
                                (skolem-typepred)
                                (("1"
                                  (inst -4 "y!1 - 1")
                                  (("1" (grind) nil nil)
                                   ("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil)
                     ("4" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (lift-if)
              (("2" (prop)
                (("1" (grind) nil nil)
                 ("2" (use satisfied?_first)
                  (("2" (prop)
                    (("1" (expand satisfied?)
                      (("1" (skolem-typepred)
                        (("1" (inst 4 "i!1 + 1")
                          (("1" (grind) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((first const-decl "lift[(first?(l, pi))]" list_find_props nil)
    (satisfied?_first formula-decl nil list_find_props nil)
    (length_cons formula-decl nil list_basic_props nil)
    (y!1 skolem-const-decl "({i |
    IF i = 0 THEN FALSE
    ELSE first?(l, LAMBDA i, x: pi(1 + i, x))(i - 1)
    ENDIF})" list_find_props nil)
    (singleton_elt_lem formula-decl nil sets nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (x!1 skolem-const-decl "(first?(l, LAMBDA i, x: pi(1 + i, x)))"
     list_find_props nil)
    (y!1 skolem-const-decl "({i |
    IF i = 0 THEN FALSE
    ELSE first?(l, LAMBDA i, x: pi(1 + i, x))(i - 1)
    ENDIF})" list_find_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (i skolem-const-decl "bl[T](cons(x1, l))" list_find_props nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (down adt-accessor-decl "[(up?) -> T]" lift_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (bl type-eq-decl nil list_basic_props nil)
    (nth_cons formula-decl nil list_basic_props nil)
    (singleton_elt_def formula-decl nil sets nil)
    (set type-eq-decl nil sets nil)
    (first? const-decl "bool" list_find_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (satisfied?_first? formula-decl nil list_find_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (up? adt-recognizer-decl "[lift -> boolean]" lift_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" lift_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (lift type-decl nil lift_adt nil)
    (lift_up_extensionality formula-decl nil lift_adt nil)
    (up adt-constructor-decl "[T -> (up?)]" lift_adt nil)
    (pi skolem-const-decl "pred[[nat, T]]" list_find_props nil)
    (l skolem-const-decl "list[T]" list_find_props nil)
    (x1 skolem-const-decl "T" list_find_props nil)
    (satisfied? const-decl "bool" list_find_props nil)
    (singleton_elt const-decl "T" sets nil)
    (member const-decl "bool" sets nil)
    (singleton? const-decl "bool" sets nil)
    (FALSE const-decl "bool" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil list_find_props nil)
    (first?_cons formula-decl nil list_find_props nil))
   nil)
  (first_cons-1 nil 3579535094
   ("" (skeep)
    (("" (expand first)
      (("" (rewrite first?_cons)
        (("" (lift-if)
          (("" (prop)
            (("1" (lift-if)
              (("1" (prop)
                (("1" (decompose-equality)
                  (("1" (use singleton_elt_lem[nat])
                    (("1" (grind) nil nil)) nil)
                   ("2" (grind :if-match all) nil nil)
                   ("3" (grind :if-match all) nil nil))
                  nil)
                 ("2" (lift-if)
                  (("2" (prop)
                    (("1" (grind) nil nil)
                     ("2" (decompose-equality)
                      (("1" (use singleton_elt_lem[nat])
                        (("1" (prop)
                          (("1" (use exists_first?)
                            (("1" (prop)
                              (("1"
                                (expand singleton?)
                                (("1"
                                  (skeep)
                                  (("1"
                                    (inst 1 "x_1 + 1")
                                    (("1"
                                      (skolem-typepred)
                                      (("1"
                                        (inst -2 "y!1 - 1")
                                        (("1" (grind) nil nil)
                                         ("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil)
                           ("3" (simplify)
                            (("3" (use singleton_elt_def[nat])
                              (("3"
                                (prop)
                                (("1"
                                  (rewrite -1)
                                  (("1" (grind) nil nil))
                                  nil)
                                 ("2"
                                  (use exists_first?)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil)
                       ("2" (expand every)
                        (("2" (rewrite first?_cons)
                          (("2" (beta)
                            (("2" (simplify)
                              (("2"
                                (use singleton_elt_lem[nat])
                                (("2"
                                  (use singleton_elt_lem[nat])
                                  (("2"
                                    (use singleton_elt_def[nat])
                                    (("2"
                                      (prop)
                                      (("1"
                                        (rewrite -1)
                                        (("1" (grind) nil nil))
                                        nil)
                                       ("2"
                                        (use exists_first?)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (use exists_first?)
                        (("3" (prop)
                          (("3" (expand singleton?)
                            (("3" (skolem-typepred)
                              (("3"
                                (inst 1 "x!1 + 1")
                                (("3" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (grind) nil nil))
                      nil))
                    nil))
                  nil)
                 ("3" (skeep)
                  (("3" (rewrite nth_cons)
                    (("1" (lift-if)
                      (("1" (split -)
                        (("1" (grind) nil nil) ("2" (grind) nil nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (grind :if-match nil)
              (("1" (inst 1 0)
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
               ("2" (inst 1 "1 + i!1") (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((first const-decl "lift[(first?(l, pi))]" list_find_props nil)
    (nth_cons formula-decl nil list_basic_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (down adt-accessor-decl "[(up?) -> T]" lift_adt nil)
    (< const-decl "bool" reals nil)
    (bl type-eq-decl nil list_basic_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (singleton_elt_def formula-decl nil sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (set type-eq-decl nil sets nil)
    (singleton? const-decl "bool" sets nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (TRUE const-decl "bool" booleans nil)
    (FALSE const-decl "bool" booleans nil)
    (up adt-constructor-decl "[T -> (up?)]" lift_adt nil)
    (singleton_elt const-decl "T" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (up? adt-recognizer-decl "[lift -> boolean]" lift_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (lift type-decl nil lift_adt nil)
    (lift_up_extensionality formula-decl nil lift_adt nil)
    (member const-decl "bool" sets nil)
    (singleton_elt_lem formula-decl nil sets nil)
    (nth def-decl "T" list_props nil)
    (length def-decl "nat" list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil list_find_props nil)
    (first?_cons formula-decl nil list_find_props nil))
   shostak))
 (find_aux_TCC1 0
  (find_aux_TCC1-1 nil 3579532829 ("" (subtype-tcc) nil nil)
   ((T formal-type-decl nil list_find_props nil)
    (length_cons formula-decl nil list_basic_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (find_aux_TCC2 0
  (find_aux_TCC2-1 nil 3579532829 ("" (grind) nil nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nth def-decl "T" list_props nil)
    (first? const-decl "bool" list_find_props nil))
   nil))
 (find_aux_TCC3 0
  (find_aux_TCC3-1 nil 3579532829 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (find_aux_TCC4 0
  (find_aux_TCC4-1 nil 3579532829 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil list_find_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (bl type-eq-decl nil list_basic_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (lift type-decl nil lift_adt nil)
    (every adt-def-decl "boolean" lift_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (first? const-decl "bool" list_find_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length_cons formula-decl nil list_basic_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields
       nil))
   nil))
 (find_aux_TCC5 0
  (find_aux_TCC5-1 nil 3579532829
   ("" (grind :rewrites (every_forall nth_cons))
    (("" (rewrite nth_cons) (("" (grind) nil nil)) nil)) nil)
   ((nth_cons formula-decl nil list_basic_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil list_find_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (bl type-eq-decl nil list_basic_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (lift type-decl nil lift_adt nil)
    (every adt-def-decl "boolean" lift_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (first? const-decl "bool" list_find_props nil)
    (nth def-decl "T" list_props nil))
   nil))
 (find_aux_first_TCC1 0
  (find_aux_first_TCC1-1 nil 3579553766 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil list_find_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (first? const-decl "bool" list_find_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (find_aux_first 0
  (find_aux_first-1 nil 3579553766
   ("" (induct l)
    (("1" (grind) nil nil)
     ("2" (skosimp*)
      (("2" (expand find_aux +)
        (("2" (rewrite first_cons)
          (("2" (inst?)
            (("2" (rewrite -1) (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil)
     ("3" (grind) nil nil))
    nil)
   ((first_cons formula-decl nil list_find_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (member const-decl "bool" sets nil)
    (singleton_elt const-decl "T" sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil list_find_props nil)
    (bottom adt-constructor-decl "(bottom?)" lift_adt nil)
    (bottom? adt-recognizer-decl "[lift -> boolean]" lift_adt nil)
    (find_aux def-decl
     "lift[{r: [bl(l), T] | first?(l, pi)(r`1) AND r`2 = nth(l, r`1)}]"
     list_find_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (bl type-eq-decl nil list_basic_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (first? const-decl "bool" list_find_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (lift type-decl nil lift_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" lift_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (first const-decl "lift[(first?(l, pi))]" list_find_props nil)
    (up? adt-recognizer-decl "[lift -> boolean]" lift_adt nil)
    (up adt-constructor-decl "[T -> (up?)]" lift_adt nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil))
   shostak))
 (satisfied?_find_aux 0
  (satisfied?_find_aux-1 nil 3579557871
   ("" (skeep)
    (("" (rewrite find_aux_first)
      (("" (use satisfied?_first) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((find_aux_first formula-decl nil list_find_props nil)
    (T formal-type-decl nil list_find_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (first const-decl "lift[(first?(l, pi))]" list_find_props nil)
    (singleton_elt const-decl "T" sets nil)
    (member const-decl "bool" sets nil)
    (first? const-decl "bool" list_find_props nil)
    (satisfied? const-decl "bool" list_find_props nil)
    (satisfied?_first formula-decl nil list_find_props nil))
   shostak))
 (find_pos_TCC1 0
  (find_pos_TCC1-1 nil 3579532829 ("" (subtype-tcc) nil nil) nil nil))
 (find_pos_first 0
  (find_pos_first-1 nil 3579533891
   ("" (skeep)
    (("" (expand find_pos)
      (("" (rewrite find_aux_first) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((find_pos const-decl "lift[(first?(l, pi))]" list_find_props nil)
    (first? const-decl "bool" list_find_props nil)
    (member const-decl "bool" sets nil)
    (singleton_elt const-decl "T" sets nil)
    (first const-decl "lift[(first?(l, pi))]" list_find_props nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil list_find_props nil)
    (find_aux_first formula-decl nil list_find_props nil))
   shostak))
 (satisfied?_find_pos 0
  (satisfied?_find_pos-1 nil 3579558401
   ("" (skeep)
    (("" (rewrite find_pos_first) (("" (use satisfied?_first) nil nil))
      nil))
    nil)
   ((find_pos_first formula-decl nil list_find_props nil)
    (T formal-type-decl nil list_find_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (satisfied?_first formula-decl nil list_find_props nil))
   shostak))
 (find_pos_elt_TCC1 0
  (find_pos_elt_TCC1-1 nil 3579532829 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil list_find_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (bl type-eq-decl nil list_basic_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (first? const-decl "bool" list_find_props nil))
   nil))
 (find_pos_elt_first 0
  (find_pos_elt_first-1 nil 3579548292
   ("" (skeep)
    (("" (expand find_pos_elt)
      (("" (rewrite find_aux_first) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((find_pos_elt const-decl
     "lift[{x | EXISTS (i: bl(l)): x = nth(l, i) AND first?(l, pi)(i)}]"
     list_find_props nil)
    (first? const-decl "bool" list_find_props nil)
    (member const-decl "bool" sets nil)
    (singleton_elt const-decl "T" sets nil)
    (first const-decl "lift[(first?(l, pi))]" list_find_props nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil list_find_props nil)
    (find_aux_first formula-decl nil list_find_props nil))
   shostak))
 (satisfied?_find_pos_elt 0
  (satisfied?_find_pos_elt-1 nil 3579558421
   ("" (skeep)
    (("" (rewrite find_pos_elt_first)
      (("" (use satisfied?_first) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((find_pos_elt_first formula-decl nil list_find_props nil)
    (T formal-type-decl nil list_find_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (first const-decl "lift[(first?(l, pi))]" list_find_props nil)
    (singleton_elt const-decl "T" sets nil)
    (member const-decl "bool" sets nil)
    (first? const-decl "bool" list_find_props nil)
    (satisfied? const-decl "bool" list_find_props nil)
    (satisfied?_first formula-decl nil list_find_props nil))
   shostak))
 (find_TCC1 0
  (find_TCC1-1 nil 3579532829
   ("" (typepred find_aux) (("" (grind) nil nil)) nil)
   ((first? const-decl "bool" list_find_props nil)
    (find_pos const-decl "lift[(first?(l, pi))]" list_find_props nil)
    (up? adt-recognizer-decl "[lift -> boolean]" lift_adt nil)
    (down adt-accessor-decl "[(up?) -> T]" lift_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil list_find_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (bl type-eq-decl nil list_basic_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (lift type-decl nil lift_adt nil)
    (every adt-def-decl "boolean" lift_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (first? const-decl "bool" list_find_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (find_aux def-decl
     "lift[{r: [bl(l), T] | first?(l, pi)(r`1) AND r`2 = nth(l, r`1)}]"
     list_find_props nil))
   nil))
 (find_first 0
  (find_first-1 nil 3579547801
   ("" (skeep)
    (("" (expand find)
      (("" (rewrite find_pos_first) (("" (rewrite first_pi_p) nil nil))
        nil))
      nil))
    nil)
   ((find const-decl "lift[(first?(l, p))]" list_find_props nil)
    (first_pi_p formula-decl nil list_find_props nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil list_find_props nil)
    (find_pos_first formula-decl nil list_find_props nil))
   shostak))
 (satisfied?_find 0
  (satisfied?_find-1 nil 3579558431
   ("" (skeep)
    (("" (rewrite find_first)
      (("" (rewrite first_pi_p)
        (("" (use satisfied?_first) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((find_first formula-decl nil list_find_props nil)
    (T formal-type-decl nil list_find_props nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (satisfied?_first formula-decl nil list_find_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (satisfied? const-decl "bool" list_find_props nil)
    (first? const-decl "bool" list_find_props nil)
    (member const-decl "bool" sets nil)
    (singleton_elt const-decl "T" sets nil)
    (first const-decl "lift[(first?(l, pi))]" list_find_props nil)
    (satisfied? const-decl "bool" list_find_props nil)
    (first_pi_p formula-decl nil list_find_props nil))
   shostak))
 (find_elt_TCC1 0
  (find_elt_TCC1-1 nil 3579532829
   ("" (typepred find_aux) (("" (grind) nil nil)) nil)
   ((first? const-decl "bool" list_find_props nil)
    (find_pos_elt const-decl
     "lift[{x | EXISTS (i: bl(l)): x = nth(l, i) AND first?(l, pi)(i)}]"
     list_find_props nil)
    (up? adt-recognizer-decl "[lift -> boolean]" lift_adt nil)
    (down adt-accessor-decl "[(up?) -> T]" lift_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil list_find_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (bl type-eq-decl nil list_basic_props nil)
    (PRED type-eq-decl nil defined_types nil)
    (lift type-decl nil lift_adt nil)
    (every adt-def-decl "boolean" lift_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (first? const-decl "bool" list_find_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (find_aux def-decl
     "lift[{r: [bl(l), T] | first?(l, pi)(r`1) AND r`2 = nth(l, r`1)}]"
     list_find_props nil))
   nil))
 (find_elt_first_TCC1 0
  (find_elt_first_TCC1-1 nil 3579553954 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil list_find_props nil)
    (list type-decl nil list_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (first? const-decl "bool" list_find_props nil)
    (member const-decl "bool" sets nil)
    (singleton_elt const-decl "T" sets nil)
    (first const-decl "lift[(first?(l, p))]" list_find_props nil))
   nil))
 (find_elt_first 0
  (find_elt_first-1 nil 3579553967
   ("" (skeep)
    (("" (expand find_elt)
      (("" (use find_pos_elt_first) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((find_elt const-decl
     "lift[{x | EXISTS (i: bl(l)): x = nth(l, i) AND first?(l, p)(i)}]"
     list_find_props nil)
    (find_pos_elt const-decl
     "lift[{x | EXISTS (i: bl(l)): x = nth(l, i) AND first?(l, pi)(i)}]"
     list_find_props nil)
    (first? const-decl "bool" list_find_props nil)
    (member const-decl "bool" sets nil)
    (singleton_elt const-decl "T" sets nil)
    (first const-decl "lift[(first?(l, pi))]" list_find_props nil)
    (first? const-decl "bool" list_find_props nil)
    (first const-decl "lift[(first?(l, p))]" list_find_props nil)
    (T formal-type-decl nil list_find_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (find_pos_elt_first formula-decl nil list_find_props nil))
   shostak))
 (satisfied?_find_elt 0
  (satisfied?_find_elt-1 nil 3579558486
   ("" (skeep)
    (("" (expand find_elt)
      (("" (use satisfied?_find_pos_elt) (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((find_elt const-decl
     "lift[{x | EXISTS (i: bl(l)): x = nth(l, i) AND first?(l, p)(i)}]"
     list_find_props nil)
    (satisfied? const-decl "bool" list_find_props nil)
    (find_pos_elt const-decl
     "lift[{x | EXISTS (i: bl(l)): x = nth(l, i) AND first?(l, pi)(i)}]"
     list_find_props nil)
    (satisfied? const-decl "bool" list_find_props nil)
    (T formal-type-decl nil list_find_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (satisfied?_find_pos_elt formula-decl nil list_find_props nil))
   shostak))
 (find_filter_pos_car_TCC1 0
  (find_filter_pos_car_TCC1-1 nil 3579532829
   ("" (use satisfied?_find_pos_elt) (("" (grind) nil nil)) nil)
   ((find_pos_elt const-decl
     "lift[{x | EXISTS (i: bl(l)): x = nth(l, i) AND first?(l, pi)(i)}]"
     list_find_props nil)
    (satisfied? const-decl "bool" list_find_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil list_find_props nil)
    (list type-decl nil list_adt nil)
    (length def-decl "nat" list_props nil)
    (bl type-eq-decl nil list_basic_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pred type-eq-decl nil defined_types nil)
    (satisfied?_find_pos_elt formula-decl nil list_find_props nil))
   nil))
 (find_filter_pos_car_TCC2 0
  (find_filter_pos_car_TCC2-1 nil 3579558668
   ("" (skeep) (("" (use filter_pos_char) (("" (grind) nil nil)) nil))
    nil)
   ((filter_pos_char judgement-tcc nil list_filter_props nil)
    (T formal-type-decl nil list_find_props nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (bl type-eq-decl nil list_basic_props nil)
    (member def-decl "bool" list_props nil)
    (filter_pos const-decl "list[T]" list_filter_props nil)
    (satisfied? const-decl "bool" list_find_props nil)
    (filter_pos_char application-judgement "{pp |
         FORALL x:
           (member(x, pp) IFF
             (EXISTS (i: bl(l)): nth(l, i) = x AND pi(i, x)))}"
     list_find_props nil)
    (partition_char rec-application-judgement "{pp, np |
         FORALL x:
           (member(x, pp) IFF
             (EXISTS (i: bl(l)): nth(l, i) = x AND pi(i, x)))
            AND
            (member(x, np) IFF
              (EXISTS (i: bl(l)): nth(l, i) = x AND NOT pi(i, x)))}"
     list_find_props nil))
   nil))
 (find_filter_pos_car 0
  (find_filter_pos_car-1 nil 3579555037
   ("" (induct-and-simplify l :if-match nil)
    (("1" (grind) (("1" (typepred "i!1") (("1" (grind) nil nil)) nil))
      nil)
     ("2" (rewrite find_pos_elt_first)
      (("2" (rewrite first_cons)
        (("2" (inst?)
          (("2" (prop)
            (("1" (rewrite find_pos_elt_first) (("1" (grind) nil nil))
              nil)
             ("2" (rewrite nth_cons)
              (("1" (lift-if)
                (("1" (prop)
                  (("1" (grind) nil nil) ("2" (grind) nil nil)
                   ("3" (grind) nil nil) ("4" (grind) nil nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (use partition_char) (("3" (grind) nil nil)) nil)
     ("4" (use satisfied?_find_pos_elt) (("4" (grind) nil nil)) nil))
    nil)
   ((satisfied?_find_pos_elt formula-decl nil list_find_props nil)
    (partition_char recursive-judgement-axiom nil list_filter_props
     nil)
    (member def-decl "bool" list_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (find_pos_elt_first formula-decl nil list_find_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth_cons formula-decl nil list_basic_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (first const-decl "lift[(first?(l, pi))]" list_find_props nil)
    (singleton_elt const-decl "T" sets nil)
    (member const-decl "bool" sets nil)
    (first_cons formula-decl nil list_find_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (find_aux def-decl
     "lift[{r: [bl(l), T] | first?(l, pi)(r`1) AND r`2 = nth(l, r`1)}]"
     list_find_props nil)
    (partition_char rec-application-judgement "{pp, np |
         FORALL x:
           (member(x, pp) IFF
             (EXISTS (i: bl(l)): nth(l, i) = x AND pi(i, x)))
            AND
            (member(x, np) IFF
              (EXISTS (i: bl(l)): nth(l, i) = x AND NOT pi(i, x)))}"
     list_find_props nil)
    (filter_pos_char application-judgement "{pp |
         FORALL x:
           (member(x, pp) IFF
             (EXISTS (i: bl(l)): nth(l, i) = x AND pi(i, x)))}"
     list_find_props nil)
    (find_pos_elt const-decl
     "lift[{x | EXISTS (i: bl(l)): x = nth(l, i) AND first?(l, pi)(i)}]"
     list_find_props nil)
    (up? adt-recognizer-decl "[lift -> boolean]" lift_adt nil)
    (first? const-decl "bool" list_find_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" lift_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (lift type-decl nil lift_adt nil) (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (bl type-eq-decl nil list_basic_props nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (partition_pos def-decl "[list[T], list[T]]" list_filter_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (satisfied? const-decl "bool" list_find_props nil)
    (down adt-accessor-decl "[(up?) -> T]" lift_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (filter_pos const-decl "list[T]" list_filter_props nil)
    (T formal-type-decl nil list_find_props nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (find_filter_car_TCC1 0
  (find_filter_car_TCC1-1 nil 3579532829
   ("" (skeep)
    (("" (use satisfied?_find_elt) (("" (grind) nil nil)) nil)) nil)
   ((satisfied?_find_elt formula-decl nil list_find_props nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil list_find_props nil))
   nil))
 (find_filter_car_TCC2 0
  (find_filter_car_TCC2-1 nil 3579559217
   ("" (skeep)
    (("" (rewrite filter_filter_pos)
      (("" (use find_filter_pos_car_TCC2) (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((filter_filter_pos formula-decl nil list_filter_props nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (T formal-type-decl nil list_find_props nil)
    (filter_pos_char application-judgement "{pp |
         FORALL x:
           (member(x, pp) IFF
             (EXISTS (i: bl(l)): nth(l, i) = x AND pi(i, x)))}"
     list_find_props nil)
    (partition_char rec-application-judgement "{pp, np |
         FORALL x:
           (member(x, pp) IFF
             (EXISTS (i: bl(l)): nth(l, i) = x AND pi(i, x)))
            AND
            (member(x, np) IFF
              (EXISTS (i: bl(l)): nth(l, i) = x AND NOT pi(i, x)))}"
     list_find_props nil)
    (satisfied? const-decl "bool" list_find_props nil)
    (filter_pos const-decl "list[T]" list_filter_props nil)
    (satisfied? const-decl "bool" list_find_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (find_filter_pos_car_TCC2 subtype-tcc nil list_find_props nil))
   nil))
 (find_filter_car 0
  (find_filter_car-1 nil 3579559225
   ("" (skeep)
    (("" (expand find_elt)
      (("" (rewrite filter_filter_pos)
        (("" (use find_filter_pos_car) (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((find_elt const-decl
     "lift[{x | EXISTS (i: bl(l)): x = nth(l, i) AND first?(l, p)(i)}]"
     list_find_props nil)
    (find_filter_pos_car formula-decl nil list_find_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (satisfied? const-decl "bool" list_find_props nil)
    (find_pos_elt const-decl
     "lift[{x | EXISTS (i: bl(l)): x = nth(l, i) AND first?(l, pi)(i)}]"
     list_find_props nil)
    (filter_pos const-decl "list[T]" list_filter_props nil)
    (satisfied? const-decl "bool" list_find_props nil)
    (partition_char rec-application-judgement "{pp, np |
         FORALL x:
           (member(x, pp) IFF
             (EXISTS (i: bl(l)): nth(l, i) = x AND pi(i, x)))
            AND
            (member(x, np) IFF
              (EXISTS (i: bl(l)): nth(l, i) = x AND NOT pi(i, x)))}"
     list_find_props nil)
    (filter_pos_char application-judgement "{pp |
         FORALL x:
           (member(x, pp) IFF
             (EXISTS (i: bl(l)): nth(l, i) = x AND pi(i, x)))}"
     list_find_props nil)
    (T formal-type-decl nil list_find_props nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (filter_filter_pos formula-decl nil list_filter_props nil))
   shostak)))

