(lex_list
 (lesseqp_TCC1 0
  (lesseqp_TCC1-1 nil 3578400254 ("" (termination-tcc) nil nil)
   ((length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (reflexive 0
  (reflexive-1 nil 3578400278
   ("" (expand reflexive?) (("" (induct-and-simplify x) nil nil)) nil)
   ((list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil lex_list nil)
    (<= def-decl "bool" lex_list nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (reflexive? const-decl "bool" relations nil))
   shostak))
 (transitive 0
  (transitive-1 nil 3578400350
   ("" (expand transitive?)
    (("" (prop)
      (("" (induct z)
        (("1" (grind) nil nil)
         ("2" (skeep)
          (("2" (skeep)
            (("2" (expand <= -2)
              (("2" (lift-if)
                (("2" (prop)
                  (("1" (grind) nil nil)
                   ("2" (lift-if)
                    (("2" (prop)
                      (("1" (grind) nil nil) ("2" (grind) nil nil)
                       ("3" (expand <= -3)
                        (("3" (lift-if)
                          (("3" (prop)
                            (("1" (grind) nil nil)
                             ("2" (lift-if)
                              (("2"
                                (prop)
                                (("1" (grind) nil nil)
                                 ("2"
                                  (inst
                                   -
                                   "car(x)"
                                   "car(y)"
                                   "cons1_var")
                                  (("2"
                                    (expand antisymmetric?)
                                    (("2"
                                      (inst -5 cons1_var "car(y)")
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (antisymmetric? const-decl "bool" relations nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil lex_list nil)
    (<= def-decl "bool" lex_list nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (transitive? const-decl "bool" relations nil))
   shostak))
 (antisymmetric 0
  (antisymmetric-1 nil 3578401741
   ("" (expand antisymmetric?)
    (("" (prop)
      (("" (induct-and-simplify x :if-match nil)
        (("1" (inst - "cdr(y!1)")
          (("1" (decompose-equality 2) nil nil)) nil)
         ("2" (grind :if-match all) nil nil))
        nil))
      nil))
    nil)
   ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= def-decl "bool" lex_list nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil lex_list nil)
    (list_induction formula-decl nil list_adt nil)
    (antisymmetric? const-decl "bool" relations nil))
   shostak))
 (dichotomous 0
  (dichotomous-1 nil 3578401283
   ("" (expand trichotomous?)
    (("" (expand dichotomous?)
      (("" (prop)
        (("" (induct x)
          (("1" (grind) nil nil)
           ("2" (skeep)
            (("2" (skeep)
              (("2" (inst - "cons1_var" "car(y)")
                (("1" (inst - "cdr(y)")
                  (("1" (grind)
                    (("1" (expand "<=" +) (("1" (grind) nil nil)) nil)
                     ("2" (expand "<=" +) (("2" (grind) nil nil)) nil)
                     ("3" (expand "<=" +) (("3" (grind) nil nil)) nil)
                     ("4" (expand "<=" +) (("4" (grind) nil nil)) nil)
                     ("5" (expand <= 2) (("5" (grind) nil nil)) nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((dichotomous? const-decl "bool" orders nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (<= def-decl "bool" lex_list nil)
    (T formal-type-decl nil lex_list nil)
    (list_induction formula-decl nil list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (y skolem-const-decl "list[T]" lex_list nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (trichotomous? const-decl "bool" orders nil))
   shostak))
 (irreflexive 0
  (irreflexive-1 nil 3578400344 ("" (grind) nil nil)
   ((< const-decl "bool" lex_list nil)
    (irreflexive? const-decl "bool" relations nil))
   shostak))
 (transitive_strict 0
  (transitive_strict-1 nil 3578400687
   ("" (use transitive)
    (("" (prop)
      (("" (expand transitive?)
        (("" (skeep)
          (("" (inst - x y z)
            (("" (expand <)
              (("" (grind)
                (("" (use antisymmetric) (("" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((< const-decl "bool" lex_list nil)
    (antisymmetric formula-decl nil lex_list nil)
    (antisymmetric? const-decl "bool" relations nil)
    (/= const-decl "boolean" notequal nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil lex_list nil)
    (transitive? const-decl "bool" relations nil)
    (transitive formula-decl nil lex_list nil))
   shostak))
 (trichotomous 0
  (trichotomous-1 nil 3578407692
   ("" (use dichotomous) (("" (grind) nil nil)) nil)
   ((list type-decl nil list_adt nil)
    (T formal-type-decl nil lex_list nil)
    (trichotomous? const-decl "bool" orders nil)
    (dichotomous? const-decl "bool" orders nil)
    (/= const-decl "boolean" notequal nil)
    (< const-decl "bool" lex_list nil)
    (dichotomous formula-decl nil lex_list nil))
   shostak))
 (partial_order 0
  (partial_order-1 nil 3578410108
   ("" (use reflexive)
    (("" (use transitive)
      (("" (use antisymmetric) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((transitive formula-decl nil lex_list nil)
    (antisymmetric? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (partial_order? const-decl "bool" orders nil)
    (antisymmetric formula-decl nil lex_list nil)
    (reflexive formula-decl nil lex_list nil))
   shostak))
 (total_order 0
  (total_order-1 nil 3578410140
   ("" (use partial_order)
    (("" (use dichotomous) (("" (grind) nil nil)) nil)) nil)
   ((dichotomous formula-decl nil lex_list nil)
    (trichotomous? const-decl "bool" orders nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil lex_list nil)
    (total_order? const-decl "bool" orders nil)
    (partial_order? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (dichotomous? const-decl "bool" orders nil)
    (partial_order formula-decl nil lex_list nil))
   shostak))
 (strict_order 0
  (strict_order-1 nil 3578410159
   ("" (use transitive_strict)
    (("" (use irreflexive)
      (("" (expand strict_order?)
        (("" (prop)
          (("" (expand antisymmetric?)
            (("" (skeep)
              (("" (expand transitive? -)
                (("" (expand irreflexive?)
                  (("" (inst -4 x)
                    (("" (inst -4 x y x) (("" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((irreflexive formula-decl nil lex_list nil)
    (irreflexive? const-decl "bool" relations nil)
    (T formal-type-decl nil lex_list nil)
    (transitive? const-decl "bool" relations nil)
    (antisymmetric? const-decl "bool" relations nil)
    (strict_order? const-decl "bool" orders nil)
    (transitive_strict formula-decl nil lex_list nil))
   shostak))
 (strict_total_order 0
  (strict_total_order-1 nil 3578410267
   ("" (use strict_order)
    (("" (use trichotomous) (("" (grind) nil nil)) nil)) nil)
   ((trichotomous formula-decl nil lex_list nil)
    (strict_total_order? const-decl "bool" orders nil)
    (strict_order? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (irreflexive? const-decl "bool" relations nil)
    (trichotomous? const-decl "bool" orders nil)
    (< const-decl "bool" lex_list nil)
    (/= const-decl "boolean" notequal nil)
    (strict_order formula-decl nil lex_list nil))
   shostak)))
(before_list
 (strict_total_order 0
  (strict_total_order-1 nil 3578840032
   ("" (typepred <=)
    (("" (grind :if-match nil)
      (("1" (grind :if-match all) nil nil)
       ("2" (grind :if-match all) nil nil)
       ("3" (inst -2 x!1 y!1 z!1) (("3" (grind) nil nil)) nil))
      nil))
    nil)
   ((reflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (partial_order? const-decl "bool" orders nil)
    (dichotomous? const-decl "bool" orders nil)
    (< const-decl "bool" before_list nil)
    (irreflexive? const-decl "bool" relations nil)
    (/= const-decl "boolean" notequal nil)
    (strict_order? const-decl "bool" orders nil)
    (trichotomous? const-decl "bool" orders nil)
    (strict_total_order? const-decl "bool" orders nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil before_list nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" before_list nil))
   shostak))
 (irreflexive 0
  (irreflexive-1 nil 3578414630 ("" (grind) nil nil)
   ((member def-decl "bool" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil before_list nil)
    (/= const-decl "boolean" notequal nil)
    (< const-decl "bool" before_list nil)
    (< const-decl "bool" before_list nil)
    (irreflexive? const-decl "bool" relations nil))
   shostak))
 (transitive 0
  (transitive-1 nil 3578414635
   ("" (use strict_total_order)
    (("" (expand < +)
      (("" (grind :if-match nil :exclude (< member))
        (("" (inst - x!2 "car(y!1)")
          (("" (inst -5 x!2 "car(y!1)")
            (("" (inst -7 "car(y!1)" y!2)
              (("" (inst -2 x!2 "car(y!1)" y!2) (("" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((< const-decl "bool" before_list nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil before_list nil)
    (member def-decl "bool" list_props nil)
    (< const-decl "bool" before_list nil)
    (/= const-decl "boolean" notequal nil)
    (strict_total_order? const-decl "bool" orders nil)
    (trichotomous? const-decl "bool" orders nil)
    (strict_order? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (irreflexive? const-decl "bool" relations nil)
    (strict_total_order formula-decl nil before_list nil))
   shostak))
 (well_founded 0
  (well_founded-1 nil 3578414856
   ("" (grind :if-match nil :exclude <)
    (("" (case "p!1(null)")
      (("1" (inst + null) (("1" (grind) nil nil)) nil)
       ("2"
        (inst -
         "LAMBDA (x:T): EXISTS (l:list[T]): cons?(l) AND car(l)=x AND p!1(l)")
        (("2" (grind :if-match nil :exclude <)
          (("1" (inst + l!1)
            (("1" (skeep)
              (("1" (inst - "car(x)")
                (("1" (expand < -5)
                  (("1" (inst - "car(x)" "y!2") (("1" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (inst + x) (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (inst 2 "car(y!1)")
            (("2" (inst 2 y!1) (("2" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil before_list nil)
    (/= const-decl "boolean" notequal nil)
    (< const-decl "bool" before_list nil)
    (member def-decl "bool" list_props nil)
    (< const-decl "bool" before_list nil)
    (p!1 skolem-const-decl "pred[list[T]]" before_list nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (x skolem-const-decl "(p!1)" before_list nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (well_founded? const-decl "bool" orders nil))
   shostak))
 (strict_order 0
  (strict_order-1 nil 3578415589
   ("" (use irreflexive)
    (("" (use transitive) (("" (grind) nil nil)) nil)) nil)
   ((transitive formula-decl nil before_list nil)
    (/= const-decl "boolean" notequal nil)
    (< const-decl "bool" before_list nil)
    (< const-decl "bool" before_list nil)
    (transitive? const-decl "bool" relations nil)
    (irreflexive? const-decl "bool" relations nil)
    (strict_order? const-decl "bool" orders nil)
    (irreflexive formula-decl nil before_list nil))
   shostak))
 (strict_well_founded 0
  (strict_well_founded-1 nil 3578415608
   ("" (use strict_order)
    (("" (use well_founded) (("" (grind) nil nil)) nil)) nil)
   ((well_founded formula-decl nil before_list nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (strict_order? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (irreflexive? const-decl "bool" relations nil)
    (well_founded? const-decl "bool" orders nil)
    (< const-decl "bool" before_list nil)
    (< const-decl "bool" before_list nil)
    (/= const-decl "boolean" notequal nil)
    (strict_order formula-decl nil before_list nil))
   shostak))
 (before_rcons 0
  (before_rcons-1 nil 3578415623
   ("" (lazy-grind :if-match all) nil nil)
   ((< const-decl "bool" before_list nil)
    (< const-decl "bool" before_list nil)
    (/= const-decl "boolean" notequal nil)
    (member def-decl "bool" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil before_list nil))
   shostak))
 (before_lcons 0
  (before_lcons-1 nil 3578415711
   ("" (lazy-grind :if-match all) nil nil)
   ((< const-decl "bool" before_list nil)
    (< const-decl "bool" before_list nil)
    (/= const-decl "boolean" notequal nil)
    (member def-decl "bool" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil before_list nil))
   shostak))
 (lcons_before 0
  (lcons_before-1 nil 3578415727
   ("" (grind :if-match nil :rewrites every_forall :defs nil)
    (("" (expand <)
      (("" (skeep)
        (("" (inst - x y) (("" (inst - x) (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((< const-decl "bool" before_list nil)
    (< const-decl "bool" before_list nil)
    (/= const-decl "boolean" notequal nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (member def-decl "bool" list_props nil)
    (x skolem-const-decl "T" before_list nil)
    (l1!1 skolem-const-decl "list[T]" before_list nil)
    (every_forall formula-decl nil list_basic_props nil)
    (T formal-type-decl nil before_list nil))
   shostak))
 (rcons_before 0
  (rcons_before-1 nil 3578415812
   ("" (lazy-grind :if-match all :rewrites every_forall) nil nil)
   ((bool nonempty-type-eq-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (x!1 skolem-const-decl "T" before_list nil)
    (l2!1 skolem-const-decl "list[T]" before_list nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (/= const-decl "boolean" notequal nil)
    (< const-decl "bool" before_list nil)
    (< const-decl "bool" before_list nil)
    (T formal-type-decl nil before_list nil)
    (every_forall formula-decl nil list_basic_props nil)
    (member def-decl "bool" list_props nil))
   shostak))
 (before_rappend 0
  (before_rappend-1 nil 3578415816
   ("" (lazy-grind :if-match all :rewrites member_append) nil nil)
   ((member def-decl "bool" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (T formal-type-decl nil before_list nil)
    (member_append formula-decl nil list_basic_props nil)
    (/= const-decl "boolean" notequal nil)
    (< const-decl "bool" before_list nil)
    (< const-decl "bool" before_list nil))
   shostak))
 (before_lappend 0
  (before_lappend-1 nil 3578416096
   ("" (lazy-grind :if-match all :rewrites member_append) nil nil)
   ((member def-decl "bool" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil before_list nil)
    (member_append formula-decl nil list_basic_props nil)
    (/= const-decl "boolean" notequal nil)
    (< const-decl "bool" before_list nil)
    (< const-decl "bool" before_list nil))
   shostak))
 (before_rreverse 0
  (before_rreverse-1 nil 3578667869
   (""
    (lazy-grind :if-match all :rewrites member_reverse :exclude
     reverse)
    (("1" (use "length_reverse[T]") (("1" (grind) nil nil)) nil)
     ("2" (use "length_reverse[T]") (("2" (grind) nil nil)) nil)
     ("3" (use "length_reverse[T]") (("3" (grind) nil nil)) nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length_reverse formula-decl nil list_props nil)
    (length def-decl "nat" list_props nil)
    (reverse def-decl "list[T]" list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (member def-decl "bool" list_props nil)
    (< const-decl "bool" before_list nil)
    (< const-decl "bool" before_list nil)
    (/= const-decl "boolean" notequal nil)
    (member_reverse formula-decl nil list_basic_props nil)
    (T formal-type-decl nil before_list nil))
   shostak))
 (before_lreverse 0
  (before_lreverse-1 nil 3578416171
   (""
    (lazy-grind :if-match all :rewrites member_reverse :exclude
     reverse)
    nil nil)
   ((< const-decl "bool" before_list nil)
    (< const-decl "bool" before_list nil)
    (/= const-decl "boolean" notequal nil)
    (member_reverse formula-decl nil list_basic_props nil)
    (T formal-type-decl nil before_list nil))
   shostak))
 (mix_transitive 0
  (mix_transitive-1 nil 3578843616
   ("" (typepred <=)
    (("" (grind :if-match nil)
      (("1" (inst -2 z!1 t!1 y!1)
        (("1" (inst -3 y!1 z!1) (("1" (grind) nil nil)) nil)) nil)
       ("2" (copy -2)
        (("2" (inst - x!1 y!1 z!1)
          (("2" (inst -3 x!1 z!1 t!1) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((reflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (partial_order? const-decl "bool" orders nil)
    (dichotomous? const-decl "bool" orders nil)
    (/= const-decl "boolean" notequal nil)
    (< const-decl "bool" before_list nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil before_list nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" before_list nil))
   shostak))
 (before_char 0
  (before_char-1 nil 3578842342
   ("" (skeep)
    (("" (prop)
      (("1" (all-typepreds)
        (("1" (hide -3 -6)
          (("1" (expand < -5)
            (("1" (inst - "max(cl1)" "min(cl2)")
              (("1" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("2" (all-typepreds)
        (("2" (hide -3 -6)
          (("2" (expand < 1)
            (("2" (skeep)
              (("2" (inst - x)
                (("2" (inst - y)
                  (("2" (lemma mix_transitive)
                    (("2" (inst - y x "max(cl1)" "min(cl2)")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((< const-decl "bool" before_list nil)
    (max const-decl
         "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES y <= x)}"
         min_max_list nil)
    (min const-decl
         "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES x <= y)}"
         min_max_list nil)
    (<= formal-const-decl "(total_order?[T])" before_list nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil before_list nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (mix_transitive formula-decl nil before_list nil))
   shostak))
 (before_lchar 0
  (before_lchar-1 nil 3578843037
   ("" (skeep)
    (("" (prop)
      (("1" (expand < -1)
        (("1" (skeep)
          (("1" (inst - "max(cl1)" x)
            (("1" (typepred "max(cl1)") (("1" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("2" (use before_char)
        (("2" (inst - "min(cl2)")
          (("2" (typepred "min(cl2)") (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (max const-decl
         "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES y <= x)}"
         min_max_list nil)
    (<= formal-const-decl "(total_order?[T])" before_list nil)
    (total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil before_list nil)
    (< const-decl "bool" before_list nil)
    (min const-decl
         "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES x <= y)}"
         min_max_list nil)
    (before_char formula-decl nil before_list nil))
   shostak))
 (before_rchar 0
  (before_rchar-1 nil 3578844143
   ("" (skeep)
    (("" (prop)
      (("1" (expand < -1)
        (("1" (skeep)
          (("1" (inst - x "min(cl2)")
            (("1" (typepred "min(cl2)") (("1" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("2" (use before_char)
        (("2" (inst - "max(cl1)")
          (("2" (typepred "max(cl1)") (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((before_char formula-decl nil before_list nil)
    (max const-decl
         "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES y <= x)}"
         min_max_list nil)
    (< const-decl "bool" before_list nil)
    (T formal-type-decl nil before_list nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (total_order? const-decl "bool" orders nil)
    (<= formal-const-decl "(total_order?[T])" before_list nil)
    (min const-decl
         "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES x <= y)}"
         min_max_list nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   shostak)))
(subword_list)

