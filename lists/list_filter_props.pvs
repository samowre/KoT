list_filter_props[T: TYPE]: THEORY
BEGIN
  IMPORTING list_basic_props[T]

  l, m,pp,np: VAR list[T]
  p: VAR pred[T]
  pi: VAR pred[[nat,T]]
  x: VAR T
  a: VAR T
  i,j: VAR nat
  
  % This theory contains 4 main functions:
    % Filter : returns the list of elements of l satisfying p (in the prelude)
    % Filter_pos : the same, with p depending on the position of the element in l
    % Partition  : (filter(l,p),filter(l,NOT p))
    % Partition_pos : (filter_pos(l,p),filter_pos(l,NOT p))

  % Filter specification
  filter_member: RECURSIVE JUDGEMENT
    filter(l, p) HAS_TYPE { m | FORALL x: member(x, m) IFF p(x) AND member(x, l) }

  % Partition
  % Returns the sublist of l verifying p and the one verifying not p
  partition_aux(l,pi,i): RECURSIVE [list[T],list[T]] = 
  	CASES l OF
	   null: (null,null),
 	   cons(h,t): LET (pp,np) = partition_aux(t,pi,i+1) IN
	   	      IF pi(i,h) THEN (cons(h,pp),np)
		      	      	 ELSE (pp,cons(h,np))
 		      ENDIF
	ENDCASES
  MEASURE length(l)
  
  partition_pos(l,pi): [list[T],list[T]] = partition_aux(l,pi,0)
  % Same with a predicate not depending on the position
  partition(l,p): MACRO [list[T],list[T]] = partition_pos(l,LAMBDA i,x: p(x))

  % The same as filter, except that the predicates may depend on the position of the element
  filter_pos(l,pi): list[T] = proj_1(partition_pos(l,pi))


  % Specifictations: 
    % Characterisation
  partition_aux_char: RECURSIVE JUDGEMENT partition_aux(l,pi,i) HAS_TYPE 
  	{ (pp,np) | FORALL x: 
	  	  (member(x,pp) IFF EXISTS (j:below(length(l))): nth(l,j)=x AND pi(i+j,x)) AND 
  		  (member(x,np) IFF EXISTS (j:below(length(l))): nth(l,j)=x AND NOT pi(i+j,x)) }
  partition_char: JUDGEMENT partition_pos(l,pi) HAS_TYPE 
  	{ (pp,np) | FORALL x:  
		  (member(x,pp) IFF EXISTS (i:below(length(l))): nth(l,i)=x AND pi(i,x)) AND 
  		  (member(x,np) IFF EXISTS (i:below(length(l))): nth(l,i)=x AND NOT pi(i,x)) }

  partition_member: LEMMA member(x,l) IFF member(x,partition_pos(l,pi)`1) OR 
  		    	  	      	  member(x,partition_pos(l,pi)`2)

    % Partition does not depend on the third argument of partition_aux
  partition_no_pos: LEMMA partition_aux(l,LAMBDA i,x: p(x),j) = partition(l,p)
    % Useful invariant of partition_aux for next properties
  partition_aux_inv: LEMMA partition_aux(l,LAMBDA i,x: pi(i+1,x),j) = partition_aux(l,pi,j+1) 

    % Partition if just 2 filters. It hence inherits of all properties of filter
  partition_filter: LEMMA partition(l,p) = (filter(l,p),filter(l,LAMBDA x: NOT p(x)))
    % Partition_pos is just 2 filters_pos
  partition_filter_pos: LEMMA partition_pos(l,pi) = (filter_pos(l,pi),filter_pos(l,LAMBDA i,x: NOT pi(i,x)))

    % Partitioning with [not p] is just swapping the results
  partition_neg: LEMMA LET (pp,np)=partition_pos(l,pi) IN partition_pos(l,LAMBDA i,x: NOT pi(i,x)) = (np,pp)
    % If p does not use the position, filter = filter_pos
    % The same with partition is just the definition
  filter_filter_pos: LEMMA filter(l,p) = filter_pos(l,LAMBDA i,x: p(x))

  % More precise specification for filter and filter_pos
  filter_nth: LEMMA FORALL (j:below(length(l))): nth(filter(l,p),j) = x IMPLIES EXISTS (i:below(length(l))): j <= i AND nth(l,i) = x AND p(x)
  nth_filter: LEMMA FORALL (i:below(length(l))): nth(l,i) = x AND p(x)  IMPLIES EXISTS (j:upto(i)): nth(filter(l,p),j) = x
  filter_pos_nth: LEMMA FORALL (j:below(length(l))): nth(filter_pos(l,pi),j) = x IMPLIES EXISTS (i:below(length(l))): j <= i AND nth(l,i) = x AND pi(i,x)
  nth_filter_pos: LEMMA FORALL (i:below(length(l))): nth(l,i) = x AND pi(i,x)  IMPLIES EXISTS (j:upto(i)): nth(filter_pos(l,pi),j) = x
  
  % Thanks to partition_filter and partition_filter_pos, we need only to have lemmas on filter
  % and filter_pos.
  
  % Filter rewrites and comon functions
  filter_cons: THEOREM filter(cons(x, l), p) =
    IF p(x) THEN cons(x, filter(l, p)) 
  	    ELSE filter(l, p) ENDIF
  filter_null: THEOREM filter(null,p) = null 

    % Length filter : useful for recursive calls (see merge sort in sortedlist.pvs for instance)
  length_filter   : LEMMA length(filter(l,p)) <= length(l)
  st_length_filter: LEMMA length(filter(l,p)) < length(l) OR every(p)(l) 

  filter_append: LEMMA
    filter(append(l, m), p) = append(filter(l, p), filter(m, p))

  filter_reverse: LEMMA filter(reverse(l),p) = reverse(filter(l,p))
  

  % Same with filter_pos
  filter_pos_cons: THEOREM filter_pos(cons(x,l),pi) = 
    IF pi(0,x) THEN cons(x,filter_pos(l,LAMBDA i,x: pi(i+1,x)))
       	       ELSE filter_pos(l,LAMBDA i,x: pi(i+1,x))
	       ENDIF
  filter_pos_null: LEMMA filter_pos(null,pi) = null

  length_filter_pos: LEMMA length(filter_pos(l,pi)) <= length(l)
  st_length_filter_pos: LEMMA length(filter_pos(l,pi)) < length(l) OR FORALL (i:below(length(l))): pi(i,nth(l,i))

  filter_pos_append: LEMMA
    filter_pos(append(l,m),pi) = append(filter_pos(l,pi),
					filter_pos(l,LAMBDA i,x: pi(i+length(l),x))) 
  filter_pos_reverse: LEMMA
    filter_pos(reverse(l),pi) = reverse(filter_pos(l,LAMBDA i,x: IF i<length(l) THEN pi(length(l)-1-i,x) ELSE pi(i,x) ENDIF))



    % Remove (all instances of) an element from a list
  remove(a, l): MACRO { m | FORALL x: member(x, m) IFF (x /= a AND member(x, l)) } =
    filter(l, LAMBDA x: x /= a)


  % The same properties on partition are easily obtained by partition_filter and partition_filter_pos
END list_filter_props
