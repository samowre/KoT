sortedlist   [ T: TYPE, key: { k:[T-> real]  | injective?(k)} ]
		: THEORY

  BEGIN

  IMPORTING more_list_props[T]
  IMPORTING list_filter_props[T]

  l, m, l1, l2 : VAR list[T]
  a,b,c: VAR T
  x,y,z: VAR T
  p: VAR PRED[T]


% The key function is injective. This requirement has been thought for a long time.
% If you think this requirement is senseless, we can modify that.
% A list is sorted if the element are ordered by key, and contains no dupplicate.
  sorted?(l): RECURSIVE bool =
      CASES l OF
        null: TRUE,
     	cons(h, lt): 
	  CASES lt OF
	    null: TRUE,
	    cons(th, ltt): key(h) < key(th) AND sorted?(lt)
	  ENDCASES
      ENDCASES
     MEASURE length(l)

  sl, sl1, sl2 : VAR (sorted?)


  cdr_sorted: LEMMA cons?(sl) => sorted?(cdr(sl))
  car_sorted:  LEMMA cons?(sl) AND member(a, cdr(sl)) IMPLIES key(car(sl)) < key(a)
  
  % Powerful characterisation of sorted list with nth

nth_sorted: LEMMA FORALL l: sorted?(l) IFF (FORALL (i,j:below(length(l))): i < j IFF key(nth(l,i)) < key(nth(l,j)))


% More efficient version of member in the case of a sorted list
  s_member(a, sl): RECURSIVE bool = 
    CASES sl OF
      null: FALSE,
      cons(h, slt): IF key(a)<key(h) THEN FALSE
      	      	    ELSIF key(a) = key(h) THEN TRUE
		    ELSE s_member(a, slt)
		    ENDIF
    ENDCASES
  MEASURE length(sl)


% More efficient version of remove in the case of a sorted list   
  s_remove(a,sl): RECURSIVE { s:(sorted?)  | FORALL x: member(x,s) IFF 
       	 	      	      NOT key(x) = key(a) AND member(x,sl)} = 
      CASES sl OF
        null : sl,
	cons(h, slt) : IF key(a) = key(h) THEN slt
		    ELSIF key(a) < key(h) THEN sl % a not in the list
		      	  	   	  ELSE cons(h, s_remove(a, slt))
		    ENDIF
      ENDCASES
      MEASURE length(sl)

% /!\ Semantic of insert : if the element is already in, just return the list
  s_insert(a,sl): RECURSIVE { s:(sorted?) | FORALL x: member(x,s) IFF key(x) = key(a) OR member(x,sl) } =
	CASES sl OF
	null: cons(a,null),
  	cons(h,slt): IF key(a) < key(h) THEN cons(a,sl)
		  ELSIF key(a) = key(h) THEN sl
		    	       	 	ELSE cons(h,s_insert(a,slt))
  		  ENDIF 
  	ENDCASES
MEASURE length(sl)

% Sort a list, and remove dupplicates
sort(l): RECURSIVE { s:(sorted?) | FORALL x: member(x,s) IFF member(x,l) } = 
   	      CASES l OF
	      	  null: null,
		  cons(h,lt): s_insert(h,sort(lt))
	      ENDCASES
MEASURE length(l)


% s_member and s_remove are indeed the same as member and remove
s_member_member: LEMMA s_member(a, sl) IFF member(a, sl)
s_remove_remove: LEMMA s_remove(a, sl) = remove(a,sl)

insert_remove: 	 LEMMA s_insert(a,s_remove(a,sl))=s_insert(a,sl)
remove_insert: 	 LEMMA s_remove(a,s_insert(a,sl))=s_remove(a,sl)
insert_no_change: LEMMA s_insert(a,sl)=sl IFF member(a,sl)
remove_no_change: LEMMA s_remove(a,sl)=sl IFF NOT member(a,sl)



% Sorted Lists as Sets
% More efficient version of subset
  s_subset?(sl1, sl2): RECURSIVE bool = 
    	 CASES sl1 OF
	   null: true,
	   cons(h1, t1): 
	     CASES sl2 OF
	       null: false,
	       cons(h2, t2): 
	         COND
		   key(h1) < key(h2) -> false, 
		   key(h1) = key(h2) -> s_subset?(t1, t2),
		   key(h1) > key(h2) -> s_subset?(sl1, t2)
		 ENDCOND
	     ENDCASES
   	 ENDCASES
    MEASURE length(sl2)

  s_equal?(sl1,sl2): RECURSIVE bool = 
	CASES sl1 OF
	 null: null?(sl2),
	 cons(h1,t1): CASES sl2 OF
	 	      null: FALSE,
		      cons(h2,t2): key(h2)=key(h1) AND s_equal?(t1,t2)
	MEASURE length(sl2) 

 sorted_uniques:  LEMMA uniques?(sl)
 s_subset_subset: LEMMA s_subset?(sl1, sl2) IFF subset?(sl1, sl2)
 s_equal_equal:   LEMMA  s_equal?(sl1,sl2)  IFF  equal?(sl1,sl2) ;



% Append

  % Need some order on list first : sl1 < sl2 IFF every element of sl1 is smaller than any element of sl2
  % Since sl2 is sorted, it is equivalent to : every element of sl1 is smaller than car(sl2)
<: [[(sorted?),(sorted?)] -> bool] = LAMBDA (sl1,sl2): 
		   	  (cons?(sl2) AND every(LAMBDA x: key(x) < key(car(sl2)))(sl1))


strict_order: LEMMA strict_order?(<::[[(sorted?),(sorted?)] -> bool])

  % Lemmas on order 
% sl1 < sl2 IFF FORALL x,y in (sl1,sl2) : x<y
order_char: LEMMA sl1 < sl2 IFF cons?(sl2) AND FORALL (x,y): member(x,sl1) AND member(y,sl2) IMPLIES key(x) < key(y)

order_rcdr: LEMMA sl1 < sl2 AND length(sl2) > 1 IMPLIES sl1 < cdr(sl2)
order_lcdr: LEMMA sl1 < sl2 AND cons?(sl1)      IMPLIES cdr(sl1) < sl2
% more order properties in rev_sortedlist

append_sorted: LEMMA (sl1 < sl2 OR null?(sl2)) IFF sorted?(append(sl1,sl2))




% Filter

filter_sorted: JUDGEMENT filter(sl,p) HAS_TYPE (sorted?)

% min/max

% min_sorted: LEMMA cons?(sl) IMPLIES minlist(sl) = car(sl)

	
  END sortedlist


