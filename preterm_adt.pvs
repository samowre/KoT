%%% ADT file generated from fmla

preterm_adt: THEORY
 BEGIN

  preterm: TYPE

  IMPORTING funpred

  var?, apply?: [preterm -> boolean]

  v_index: [(var?) -> nat]

  fun: [(apply?) -> (fun?)]

  args: [(apply?) -> list[preterm]]

  v: [nat -> (var?)]

  apply: [[(fun?), list[preterm]] -> (apply?)]

  preterm_ord: [preterm -> upto(1)]

  preterm_ord_defaxiom: AXIOM
    (FORALL (v_index: nat): preterm_ord(v(v_index)) = 0) AND
     (FORALL (fun: (fun?), args: list[preterm]):
        preterm_ord(apply(fun, args)) = 1);

  ord(x: preterm): [preterm -> upto(1)] =
      CASES x OF v(v1_var): 0, apply(apply1_var, apply2_var): 1 ENDCASES

  preterm_v_extensionality: AXIOM
    FORALL (var?_var: (var?), var?_var2: (var?)):
      v_index(var?_var) = v_index(var?_var2) IMPLIES var?_var = var?_var2;

  preterm_v_eta: AXIOM
    FORALL (var?_var: (var?)): v(v_index(var?_var)) = var?_var;

  preterm_apply_extensionality: AXIOM
    FORALL (apply?_var: (apply?), apply?_var2: (apply?)):
      fun(apply?_var) = fun(apply?_var2) AND
       args(apply?_var) = args(apply?_var2)
       IMPLIES apply?_var = apply?_var2;

  preterm_apply_eta: AXIOM
    FORALL (apply?_var: (apply?)):
      apply(fun(apply?_var), args(apply?_var)) = apply?_var;

  preterm_v_index_v: AXIOM
    FORALL (v1_var: nat): v_index(v(v1_var)) = v1_var;

  preterm_fun_apply: AXIOM
    FORALL (apply1_var: (fun?), apply2_var: list[preterm]):
      fun(apply(apply1_var, apply2_var)) = apply1_var;

  preterm_args_apply: AXIOM
    FORALL (apply1_var: (fun?), apply2_var: list[preterm]):
      args(apply(apply1_var, apply2_var)) = apply2_var;

  preterm_inclusive: AXIOM
    FORALL (preterm_var: preterm): var?(preterm_var) OR apply?(preterm_var);

  preterm_induction: AXIOM
    FORALL (p: [preterm -> boolean]):
      ((FORALL (v1_var: nat): p(v(v1_var))) AND
        (FORALL (apply1_var: (fun?), apply2_var: list[preterm]):
           every(p)(apply2_var) IMPLIES p(apply(apply1_var, apply2_var))))
       IMPLIES (FORALL (preterm_var: preterm): p(preterm_var));

  subterm(x: preterm, y: preterm):  boolean =
      x = y OR
       CASES y
         OF v(v1_var): FALSE,
            apply(apply1_var, apply2_var):
              some[preterm]
                  ((LAMBDA (z: preterm): subterm(x, z)))(apply2_var)
         ENDCASES;

  <<:  (strict_well_founded?[preterm]) =
      LAMBDA (x, y: preterm):
        CASES y
          OF v(v1_var): FALSE,
             apply(apply1_var, apply2_var):
               some[preterm]
                   (LAMBDA (z: preterm): x = z OR x << z)(apply2_var)
          ENDCASES;

  preterm_well_founded: AXIOM strict_well_founded?[preterm](<<);

  reduce_nat(var?_fun: [nat -> nat],
             apply?_fun: [[(fun?), list[nat]] -> nat]):
        [preterm -> nat] =
      LAMBDA (preterm_adtvar: preterm):
        LET red: [preterm -> nat] = reduce_nat(var?_fun, apply?_fun) IN
          CASES preterm_adtvar
            OF v(v1_var): var?_fun(v1_var),
               apply(apply1_var, apply2_var):
                 apply?_fun(apply1_var, map[preterm, nat](red)(apply2_var))
            ENDCASES;

  REDUCE_nat(var?_fun: [[nat, preterm] -> nat],
             apply?_fun: [[(fun?), list[nat], preterm] -> nat]):
        [preterm -> nat] =
      LAMBDA (preterm_adtvar: preterm):
        LET red: [preterm -> nat] = REDUCE_nat(var?_fun, apply?_fun) IN
          CASES preterm_adtvar
            OF v(v1_var): var?_fun(v1_var, preterm_adtvar),
               apply(apply1_var, apply2_var):
                 apply?_fun(apply1_var, map[preterm, nat](red)(apply2_var),
                            preterm_adtvar)
            ENDCASES;

  reduce_ordinal(var?_fun: [nat -> ordinal],
                 apply?_fun: [[(fun?), list[ordinal]] -> ordinal]):
        [preterm -> ordinal] =
      LAMBDA (preterm_adtvar: preterm):
        LET red: [preterm -> ordinal] =
              reduce_ordinal(var?_fun, apply?_fun)
          IN
          CASES preterm_adtvar
            OF v(v1_var): var?_fun(v1_var),
               apply(apply1_var, apply2_var):
                 apply?_fun(apply1_var,
                            map[preterm, ordinal](red)(apply2_var))
            ENDCASES;

  REDUCE_ordinal(var?_fun: [[nat, preterm] -> ordinal],
                 apply?_fun:
                   [[(fun?), list[ordinal], preterm] -> ordinal]):
        [preterm -> ordinal] =
      LAMBDA (preterm_adtvar: preterm):
        LET red: [preterm -> ordinal] =
              REDUCE_ordinal(var?_fun, apply?_fun)
          IN
          CASES preterm_adtvar
            OF v(v1_var): var?_fun(v1_var, preterm_adtvar),
               apply(apply1_var, apply2_var):
                 apply?_fun(apply1_var,
                            map[preterm, ordinal](red)(apply2_var),
                            preterm_adtvar)
            ENDCASES;
 END preterm_adt

preterm_adt_reduce[range: TYPE]: THEORY
 BEGIN

  IMPORTING preterm_adt

  IMPORTING funpred

  reduce(var?_fun: [nat -> range],
         apply?_fun: [[(fun?), list[range]] -> range]):
        [preterm -> range] =
      LAMBDA (preterm_adtvar: preterm):
        LET red: [preterm -> range] = reduce(var?_fun, apply?_fun) IN
          CASES preterm_adtvar
            OF v(v1_var): var?_fun(v1_var),
               apply(apply1_var, apply2_var):
                 apply?_fun(apply1_var,
                            map[preterm, range](red)(apply2_var))
            ENDCASES;

  REDUCE(var?_fun: [[nat, preterm] -> range],
         apply?_fun: [[(fun?), list[range], preterm] -> range]):
        [preterm -> range] =
      LAMBDA (preterm_adtvar: preterm):
        LET red: [preterm -> range] = REDUCE(var?_fun, apply?_fun) IN
          CASES preterm_adtvar
            OF v(v1_var): var?_fun(v1_var, preterm_adtvar),
               apply(apply1_var, apply2_var):
                 apply?_fun(apply1_var,
                            map[preterm, range](red)(apply2_var),
                            preterm_adtvar)
            ENDCASES;
 END preterm_adt_reduce