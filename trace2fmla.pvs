trace2fmla[m, n: nat, i : upto(n)]: THEORY
BEGIN

  IMPORTING trace_resolution[m,n,i]
  IMPORTING resolution

  k: VAR (trace_resolution[m,n,i].tr_literal?)
  cl, ck: VAR (trace_resolution[m,n,i].tr_clause?)

  % transforms ( n:nzint ) -> fmla = (f_not)? (atom(upred...))
  translate_lit(k): (literal?) = IF k > 0 
  		    	       	 THEN atom(upred(k, 0), null)
				 ELSE f_not(atom(upred(abs(k), 0), null))
				 ENDIF

  %equivalence of indexes
  index_index: LEMMA 
    index(translate_lit(k)) = index(k)

  % maps list(nzint) -> list(fmla)-
  translate_clause(cl): (clause?) = map(translate_lit)(cl)

  % translation equivalence
  clause_clause: LEMMA
    member(k, cl) IFF member(translate_lit(k), translate_clause(cl))
  
  % translation preserves order
  translate_cons: LEMMA
     cons?(ck) =>
     translate_clause(cons(car(ck), cdr(ck))) = cons(translate_lit(car(ck)), translate_clause(cdr(ck)))

  neg_translate:  LEMMA
     f_neg(translate_lit(k)) = translate_lit(-k)

  lc, lk: VAR list[(trace_resolution[m,n,i].tr_literal?)]

  translate_inclusion: LEMMA
    subset(lk, lc) = subset(translate_clause(lk), translate_clause(lc))


END trace2fmla

