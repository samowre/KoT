(lists
 (filter_filters 0
  (filter_filters-1 nil 3577630157
   ("" (auto-rewrite-theory "list_props")
    (("" (induct-and-simplify l) nil nil)) nil)
   ((list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil lists nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (filter def-decl "list[T]" filters nil)
    (member def-decl "bool" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (filter_append 0
  (filter_append-1 nil 3577651730 ("" (induct-and-simplify l) nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (filter def-decl "list[T]" filters nil)
    (append def-decl "list[T]" list_props nil)
    (T formal-type-decl nil lists nil)
    (list_induction formula-decl nil list_adt nil)
    (filter_filters application-judgement
     "{m | FORALL c: member(c, m) = (p(c) AND member(c, l))}" lists
     nil))
   shostak))
 (suffixes_TCC1 0
  (suffixes_TCC1-1 nil 3577646350 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (suffix_length 0
  (suffix_length-1 nil 3577631782
   ("" (induct l)
    (("1" (grind) nil nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (inst - m)
          (("2" (grind) (("2" (decompose-equality) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil lists nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (suffix? def-decl "bool" lists nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (suffix_partial_order 0
  (suffix_partial_order-1 nil 3577630948
   ("" (expand "partial_order?")
    (("" (expand "preorder?")
      (("" (expand "reflexive?")
        (("" (expand "transitive?")
          (("" (expand "antisymmetric?")
            (("" (split)
              (("1" (expand "suffix?") (("1" (grind) nil nil)) nil)
               ("2" (induct z)
                (("1" (grind) nil nil)
                 ("2" (skosimp*)
                  (("2" (expand "suffix?" 1)
                    (("2" (prop)
                      (("2" (inst -1 x!1 y!1)
                        (("2" (grind)
                          (("2" (decompose-equality) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (skolem!)
                (("3" (flatten)
                  (("3" (use "suffix_length")
                    (("3" (use "suffix_length" ("m" "y!1"))
                      (("3" (prop)
                        (("3" (expand "suffix?" -3)
                          (("3" (lift-if)
                            (("3" (prop)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil)
                               ("3"
                                (use "suffix_length" ("l" "cdr(y!1)"))
                                (("3"
                                  (prop)
                                  (("3"
                                    (expand "length" -4 1)
                                    (("3"
                                      (lift-if)
                                      (("3"
                                        (prop)
                                        (("3" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (suffix? def-decl "bool" lists nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (T formal-type-decl nil lists nil)
    (list_induction formula-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (suffix_length formula-decl nil lists nil)
    (antisymmetric? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (partial_order? const-decl "bool" orders nil))
   shostak))
 (suffix_cons 0
  (suffix_cons-1 nil 3577633061
   ("" (grind)
    (("" (use "suffix_partial_order") (("" (grind) nil nil)) nil)) nil)
   ((suffix_partial_order formula-decl nil lists nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil lists nil)
    (reflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (partial_order? const-decl "bool" orders nil)
    (suffix? def-decl "bool" lists nil))
   shostak))
 (suffix_member 0
  (suffix_member-1 nil 3577633778
   ("" (induct l)
    (("1" (grind) nil nil)
     ("2" (skosimp*)
      (("2" (expand "member" 1)
        (("2" (expand "suffix?" -2)
          (("2" (prop)
            (("1" (inst -2 m!1 x!1)
              (("1" (grind)
                (("1" (decompose-equality) nil nil)
                 ("2" (decompose-equality) nil nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil lists nil)
    (member def-decl "bool" list_props nil)
    (suffix? def-decl "bool" lists nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (suffix?_suffixes 0
  (suffix?_suffixes-1 nil 3577633248
   ("" (induct-and-simplify l) nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (suffix? def-decl "bool" lists nil)
    (member def-decl "bool" list_props nil)
    (suffixes def-decl "list[list[T]]" lists nil)
    (T formal-type-decl nil lists nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (suffixes_suffix? 0
  (suffixes_suffix?-1 nil 3577633284
   ("" (induct-and-simplify l) nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (suffixes def-decl "list[list[T]]" lists nil)
    (suffix? def-decl "bool" lists nil)
    (T formal-type-decl nil lists nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (find_char 0
  (find_char-1 nil 3577646352 ("" (induct-and-simplify l) nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (lift type-decl nil lift_adt nil)
    (find def-decl "lift[T]" lists nil)
    (bottom? adt-recognizer-decl "[lift -> boolean]" lift_adt nil)
    (bottom adt-constructor-decl "(bottom?)" lift_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (some adt-def-decl "boolean" list_adt nil)
    (up? adt-recognizer-decl "[lift -> boolean]" lift_adt nil)
    (up adt-constructor-decl "[T -> (up?)]" lift_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (T formal-type-decl nil lists nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (member_subset 0
  (member_subset-1 nil 3577646986
   ("" (auto-rewrite-theory list_adt_props) (("" (grind) nil nil)) nil)
   ((subset? const-decl "bool" lists nil)
    (every_forall formula-decl nil list_adt_props nil)
    (member const-decl "bool" list_adt_props nil)
    (member_nth formula-decl nil list_adt_props nil))
   shostak))
 (subset_order 0
  (subset_order-1 nil 3577647621
   ("" (auto-rewrite-theory list_adt_props) (("" (grind) nil nil)) nil)
   ((preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (subset? const-decl "bool" lists nil)
    (every_forall formula-decl nil list_adt_props nil)
    (member const-decl "bool" list_adt_props nil)
    (member_nth formula-decl nil list_adt_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-type-decl nil lists nil)
    (list type-decl nil list_adt nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   shostak))
 (member_equal 0
  (member_equal-1 nil 3577647336
   ("" (auto-rewrite member_subset)
    (("" (grind :exclude subset?) nil nil)) nil)
   ((T formal-type-decl nil lists nil)
    (member_subset formula-decl nil lists nil)
    (equal? const-decl "bool" lists nil))
   shostak))
 (equal_equiv 0
  (equal_equiv-1 nil 3577647749
   ("" (auto-rewrite member_equal)
    (("" (lazy-grind :exclude equal?) nil nil)) nil)
   ((equivalence? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (symmetric? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (member_equal formula-decl nil lists nil)
    (T formal-type-decl nil lists nil))
   shostak))
 (cons_equal 0
  (cons_equal-1 nil 3577648289
   ("" (auto-rewrite member_equal)
    (("" (grind :exclude equal?) nil nil)) nil)
   ((member def-decl "bool" list_props nil)
    (member_equal formula-decl nil lists nil))
   shostak))
 (uniques_TCC1 0
  (uniques_TCC1-1 nil 3577646350 ("" (grind) nil nil)
   ((uniques? def-decl "bool" lists nil)
    (every adt-def-decl "boolean" list_adt nil)
    (subset? const-decl "bool" lists nil)
    (equal? const-decl "bool" lists nil))
   nil))
 (uniques_TCC2 0
  (uniques_TCC2-1 nil 3577646350
   ("" (auto-rewrite cons_equal)
    (("" (use "equal_equiv")
      (("" (grind :if-match nil :exclude equal?)
        (("" (typepred "v!1(t!1)")
          (("" (inst -5 "v!1(t!1)" t!1 "cons(h!1, t!1)")
            (("" (grind :exclude equal?) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((equal_equiv formula-decl nil lists nil)
    (equal? const-decl "bool" lists nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uniques? def-decl "bool" lists nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil lists nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cons_equal formula-decl nil lists nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (equivalence? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (symmetric? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil))
   nil))
 (uniques_TCC3 0
  (uniques_TCC3-1 nil 3577646527
   ("" (auto-rewrite cons_equal)
    (("" (auto-rewrite member_equal)
      (("" (grind :exclude equal?)
        (("1" (typepred "v!1(t!1)")
          (("1" (grind :exclude equal?) nil nil)) nil)
         ("2" (typepred "v!1(t!1)")
          (("2" (grind :exclude equal?) nil nil)) nil)
         ("3" (typepred "v!1(t!1)")
          (("3" (grind :exclude equal?) nil nil)) nil))
        nil))
      nil))
    nil)
   ((equal? const-decl "bool" lists nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil lists nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member_equal formula-decl nil lists nil)
    (member def-decl "bool" list_props nil)
    (uniques? def-decl "bool" lists nil))
   nil))
 (minlistx_TCC1 0
  (minlistx_TCC1-1 nil 3577650495 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil lists nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (member def-decl "bool" list_props nil))
   nil))
 (minlistx_TCC2 0
  (minlistx_TCC2-1 nil 3577650495 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil lists nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil))
   nil))
 (minlistx_TCC3 0
  (minlistx_TCC3-1 nil 3577650495 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil lists nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (minlistx_TCC4 0
  (minlistx_TCC4-1 nil 3577650495
   ("" (grind :if-match nil)
    (("1" (typepred "v!1(t!1, key!1, c!1, key!1(c!1))")
      (("1" (grind) nil nil)) nil)
     ("2" (typepred "v!1(t!1, key!1, c!1, key!1(c!1))")
      (("2" (grind) nil nil)) nil)
     ("3" (typepred "v!1(t!1, key!1, c!1, key!1(c!1))")
      (("3" (grind) nil nil)) nil)
     ("4" (typepred "v!1(t!1, key!1, c!1, key!1(c!1))")
      (("4" (grind) nil nil)) nil))
    nil)
   ((<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil lists nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (member def-decl "bool" list_props nil))
   nil))
 (minlistx_TCC5 0
  (minlistx_TCC5-1 nil 3577650495 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil lists nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (minlistx_TCC6 0
  (minlistx_TCC6-1 nil 3577650495
   ("" (grind)
    (("1" (typepred "v!1(t!1, key!1, a!1, m!1)")
      (("1" (inst - a!1) (("1" (grind) nil nil)) nil)) nil)
     ("2" (typepred "v!1(t!1, key!1, a!1, m!1)")
      (("2" (inst - a!1) (("2" (grind) nil nil)) nil)) nil)
     ("3" (typepred "v!1(t!1, key!1, a!1, m!1)")
      (("3" (inst - b!1) (("3" (grind) nil nil)) nil)) nil)
     ("4" (typepred "v!1(t!1, key!1, a!1, m!1)")
      (("4" (grind) nil nil)) nil))
    nil)
   ((<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil lists nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (member def-decl "bool" list_props nil))
   nil))
 (minlist_TCC1 0
  (minlist_TCC1-1 nil 3577650495
   ("" (grind)
    (("1"
      (typepred "minlistx(cdr(l!1), key!1, car(l!1), key!1(car(l!1)))")
      (("1" (grind) nil nil)) nil)
     ("2"
      (typepred "minlistx(cdr(l!1), key!1, car(l!1), key!1(car(l!1)))")
      (("2" (grind) nil nil)) nil)
     ("3"
      (typepred "minlistx(cdr(l!1), key!1, car(l!1), key!1(car(l!1)))")
      (("3" (grind) nil nil)) nil))
    nil)
   ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (minlistx def-decl "{c |
         member(c, cons(a, l)) AND
          (FORALL b: member(b, cons(a, l)) IMPLIES key(c) <= key(b))}"
     lists nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil lists nil)
    (list type-decl nil list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (member def-decl "bool" list_props nil))
   nil))
 (maxlist_TCC1 0
  (maxlist_TCC1-1 nil 3577650495
   ("" (grind :exclude minlist)
    (("1" (typepred "minlist(l!1, LAMBDA x: -key!1(x))")
      (("1" (grind) nil nil)) nil)
     ("2" (typepred "minlist(l!1, LAMBDA x: -key!1(x))")
      (("2" (inst - y!1) (("2" (grind) nil nil)) nil)) nil)
     ("3" (typepred "minlist(l!1, LAMBDA x: -key!1(x))")
      (("3" (grind) nil nil)) nil))
    nil)
   ((- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (minlist const-decl
             "{x | member(x, l) AND (FORALL y: member(y, l) IMPLIES key(x) <= key(y))}"
             lists nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil lists nil)
    (list type-decl nil list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (member def-decl "bool" list_props nil))
   nil)))
(lists_map
 (delete_reduce 0
  (delete_reduce-1 nil 3577652150
   ("" (auto-rewrite-theory lists)
    (("" (induct-and-simplify kk) nil nil)) nil)
   ((filter_append formula-decl nil lists nil)
    (filter_filters application-judgement
     "{m | FORALL c: member(c, m) = (p(c) AND member(c, l))}" lists
     nil)
    (filter def-decl "list[T]" filters nil)
    (list_induction formula-decl nil list_adt nil)
    (S formal-type-decl nil lists_map nil)
    (append def-decl "list[T]" list_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (reduce adt-def-decl "[list[T] -> range]" list_adt_reduce nil)
    (delete const-decl
            "{m | FORALL c: member(c, m) = (c /= a AND member(c, l))}"
      lists nil)
    (/= const-decl "boolean" notequal nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil lists_map nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (every_reduce 0
  (every_reduce-1 nil 3577652175 ("" (induct-and-simplify kk) nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil lists_map nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (reduce adt-def-decl "[list[T] -> range]" list_adt_reduce nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (S formal-type-decl nil lists_map nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (reduce_map 0
  (reduce_map-1 nil 3577652183 ("" (induct-and-simplify kk) nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil lists_map nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (reduce adt-def-decl "[list[T] -> range]" list_adt_reduce nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (S formal-type-decl nil lists_map nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (every_forall 0
  (every_forall-1 nil 3577652189 ("" (induct-and-simplify ll) nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil lists_map nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (S formal-type-decl nil lists_map nil)
    (list_induction formula-decl nil list_adt nil))
   shostak)))
(lists_map2
 (map2_TCC1 0
  (map2_TCC1-1 nil 3577652115 ("" (termination-tcc) nil nil)
   ((length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (reduce2_TCC1 0
  (reduce2_TCC1-1 nil 3577652115 ("" (termination-tcc) nil nil)
   ((length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil)))
(list_subtype
 (length_length 0
  (length_length-1 nil 3577652385 ("" (induct-and-simplify l) nil nil)
   ((list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (S formal-subtype-decl nil list_subtype nil)
    (S_pred const-decl "[T -> boolean]" list_subtype nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil list_subtype nil)
    (list_induction formula-decl nil list_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   shostak)))

