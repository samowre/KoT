resolution : THEORY

  BEGIN

  IMPORTING rule

    r, s, t: VAR term
    rr, ss, tt: VAR list[term]
    i, j, k: VAR nat
    ii, jj, kk: VAR list[nat]
    f, g, h: VAR (fun?)
    p, q: VAR (pred?)
    A, B, C: VAR fmla
    AA, BB, CC: VAR list[fmla]
    x, y, z: VAR (var?)
    xx, yy, zz: VAR list[(var?)]
    nr, ns, nt: VAR nterm

    atom?(A): bool = (atom?(A) AND 
    	      	   upred?(pred(A)) AND 
		   arity(pred(A)) = 0)

    pA, pB, pC: VAR (atom?)

    literal?(A): bool = (atom?(A) OR 
    		      (f_not?(A) AND atom?(arg(A))))

    lA, lB, lC: VAR (literal?)

    lAA, lBB, lCC: VAR finite_set[(literal?)]

    clause_lit_list?(lAA): bool =
      FORALL (lA : (literal?)) : member(lA, lAA) => NOT member(f_neg(lA), lAA) %AND ??

    remove_p_nonp(lAA) : (clause_lit_list?) =
    			{p:(literal?) | member(p, lAA) AND NOT member(f_neg(p), lAA)}

    % unifies the two sets and removes occurrences of p and ~p
    % Returns emptyset if the resulting clause is always true
    apply_resolution( a:(clause_lit_list?), b: (clause_lit_list?)) : (clause_lit_list?) = 
		      LET new_clause = union(a, b) IN
		      LET result = remove_p_nonp(new_clause) IN
		      	  IF (card(result) < card(new_clause) - 2)
		      	  THEN emptyset
		      	  ELSE result
		      	  ENDIF
    
    resolution_step : DATATYPE  
    BEGIN
	ax (axiom_clauses:(clause_lit_list?)) : ax?
	res_step (clauses : {l : list[nat] | length(l) > 1})  : res_step?
    END resolution_step

    clauses_list: TYPE = list[(clause_lit_list?)]

    %adds a clause at the end of a list of clauses
    append_clause(l : clauses_list, e : (clause_lit_list?)) : clauses_list= 
    		    append(l, cons(e, null))		    
		      
    resolution_certificate: TYPE = list[resolution_step]

    %verifies that each resolution step refers to previous clauses 
    good_indices (cert : resolution_certificate, n:nat) : RECURSIVE bool = 
    		  IF null?(cert) 
		  THEN TRUE
		  ELSE 
		       CASES car(cert) OF
		       	     ax(l) : good_indices(cdr(cert), n+1),
		  	     res_step(l) : (FORALL (i:nat) : member(i, l) AND (i<n))
			     		 AND good_indices(cdr(cert), n+1)
		       ENDCASES
		  ENDIF
    MEASURE length(cert)

    multiple_resolutions(l : {lst : list[nat] | length(lst) > 1}, acc : (clause_lit_list?) : (clause_lit_list?) =
    			   

    good_indices_cert?(cert : resolution_certificate) : bool = 
    				  good_indices(cert, 0)
    
    % Creates from the certificate a list of clauses. 
    % Each clause coresponds to an axiom or a resolution step in the certificate.
    % Returns null if the indices do not refer to previous clauses

    create_clauses (cert : resolution_certificate, 
    		   context : {c : clauses_list | good_indices(cert, length(c))}) 
		   : RECURSIVE clauses_list = 
    		   IF null?(cert) 
		   THEN context
		   ELSE 
		   	LET step = car(cert) IN
		   	    CASES step OF
		   	    ax(lst) : 
			    	    create_clauses( cdr(cert), append_clause(context, lst)),
		   	    res_step(l) : 
				    create_clauses( cdr(cert), 
		   	       		  append_clause( context, apply_resolution(nth(context, i), 
					  nth(context, j)) ) )				       
		   	    ENDCASES
    		   ENDIF
     MEASURE length(cert)


    check_certificate(cert: (good_indices_cert?)) : clauses_list = 
    			    create_clauses(cert, null)

    %apply_resolution_check: LEMMA  
  END resolution
