resolution : THEORY

  BEGIN

  IMPORTING minlist
  IMPORTING sequents
  IMPORTING proof

    r, s, t: VAR term
    rr, ss, tt: VAR list[term]
    i, j, k: VAR nat
    ii, jj, kk: VAR list[nat]
    f, g, h: VAR (fun?)
    p, q: VAR (pred?)
    A, B, C: VAR fmla
    AA, BB, CC: VAR list[fmla]
    x, y, z: VAR (var?)
    xx, yy, zz: VAR list[(var?)]
    RR1, RR2: VAR ne_proof_seq

    prop_atom?(A): bool = (atom?(A) AND 
    	      	           upred?(pred(A)) AND 
		           arity(pred(A)) = 0)

    pA, pB, pC: VAR (prop_atom?)

    literal?(A): bool = (prop_atom?(A) OR 
    		         (f_not?(A) AND prop_atom?(arg(A))))

    lA, lB, lC: VAR (literal?)

    literal_sentence: LEMMA sentence?(lA)

    lAA, lBB, lCC: VAR list[(literal?)]

    literal_list_sentence_list: LEMMA sentence_list?(lAA) 

    member_lit_member_fmla: LEMMA member[fmla](lA, lAA) = member[(literal?)](lA, lAA)

    % (not 1) -> 1, (1) -> 2, (not 2) -> 3, (2) -> 4...
    index(lA) : posnat = 
    	  IF prop_atom?(lA) 
	  THEN 2*index(pred(lA))
	  ELSE 2*index(pred(arg(lA)))-1
	  ENDIF
 
    index_inj: LEMMA 
      index(lA) = index(lB) 
      => 
      lA = lB

    IMPORTING sortedlist[(literal?), index]
	
    %list[literal?] sorted by index
    clause?(lAA) : bool = sorted?(lAA)

    clause_prop: LEMMA 
      clause?(lAA) 
      <=> 
      (null?(lAA) 
	OR null?(cdr(lAA)) 
	OR (index(car(lAA)) < index(car(cdr(lAA))) AND 
	    clause?(cdr(lAA))))

    sorted_clause: LEMMA
      clause?(lAA) AND cons?(lAA)
      =>
      (FORALL (e: (literal?)) : 
        member(e, cdr(lAA))
	=> 
	index(car(lAA)) < index(e))	
  
    % obs: setlist? is O(n^2). 
    no_duplicates?(lAA) : bool = setlist?(lAA)  

    clause_implies_no_duplicates: LEMMA
      clause?(lAA) IMPLIES no_duplicates?(lAA)

    clAA, clBB, clCC : VAR (clause?)

    clauses_list: TYPE = list[(clause?)]

    %non empty clause
    nclause?(clAA): bool = cons?(clAA)

    nclAA, nclBB : VAR (nclause?)

    include_clause(clAA, clBB): bool = sorted_include(clAA, clBB)

    % transform p1::p2::...pn into p1 or (p2 or ...(pn-1 or pn))...)
    % obs: add stronger type to fmla ?
    nclause2fmla(nclAA): RECURSIVE fmla= 
      IF null?(cdr(nclAA)) 
      THEN car(nclAA)
      ELSE f_or(car(nclAA), nclause2fmla(cdr(nclAA)))
      ENDIF
    MEASURE length(nclAA)

    nclause2fmla_sentence: LEMMA sentence?(nclause2fmla(nclAA))

    clause_sentence_list: LEMMA sentence_list?(clAA)

    % transform p1::p2::..pn into |- p1 or (p2 or ...pn))   and null into |- null (i.e |- false)
    or_reduction(clAA): sequent = 
      IF null?(clAA) 
      THEN null 
      ELSE cons(nclause2fmla(clAA), null) 
      ENDIF

    % transform p1::p2::..pn into |- not[p1 or (p2 or ...pn))]  
    not_or_reduction(nclAA): sequent = 
      cons(f_not(nclause2fmla(nclAA)), null) 

    offset_proof_step(ps: proof_step, n: nat): proof_step = 
     	  ps WITH [ subs:= map(LAMBDA(j: nat):j + n)(ps`subs)]

    %===================================================================================		  
    % lemma axiom rule |- l if both A and ~A belong to l

    ax_proof_step(A): proof_step = (# sequent:= cons(A, cons(f_not(A), null)),
    	      		     	      rule:= ax,
			    	      subs:= null #)

    concl_ax(AA): proof_step = (# sequent:= AA, 
    	     	      	       	  rule:= subset,
	     			  subs:= cons(0, null) #)

    RR_ax(A, AA): ne_proof_seq = 
    (# length := 2,
       seq := LAMBDA(j: below(2)):
       	      	 COND
		  j = 0 -> ax_proof_step(A), 
		  j = 1 -> concl_ax(AA)
		 ENDCOND #)   

    lemma_ax: LEMMA (sentence_list?(AA) AND
		     member(A, AA) AND
    	    	     member(f_not(A), AA))
	   	    =>
		    (conclusion(RR_ax(A, AA)) = AA AND
	      	     checkProof(empty_seq)(RR_ax(A, AA)))


    % end lemma axiom rule
    %===================================================================================
    % lemma nor rule  |- ~(a \/ b)::k  if |- ~a::k and |- ~b::k

    concl_norr(A, B, AA, (n, m: posnat)): proof_step = 
          (# sequent:= cons(f_not(f_or(A, B)), AA) , 
    	     rule:= norr,
	     subs:= cons(n - 1, cons(n + m - 1,null)) #)

    RR_norr(A, B, AA, RR1, RR2): ne_proof_seq = 
    LET n = RR1`length IN
    LET m = RR2`length IN
    (# length := n + m + 1,
       seq := LAMBDA(j: below(n + m + 1)):
       	      	 COND
		  j < n -> RR1`seq(j),
		  j < n + m -> offset_proof_step(RR2`seq(j - n), n), 
		  j = n + m -> concl_norr(A, B, AA, n, m)
		 ENDCOND #)   

    lemma_norr: LEMMA (sentence?(A) AND
    	    	       sentence?(B) AND
		       sentence_list?(AA) AND
    	    	       conclusion(RR1) = cons(f_not(A), AA) AND
		       conclusion(RR2) = cons(f_not(B), AA) AND
		       checkProof(empty_seq)(RR1) AND
		       checkProof(empty_seq)(RR2))
		      =>
		      (conclusion(RR_norr(A, B, AA, RR1, RR2)) = cons(f_not(f_or(A, B)), AA) AND
		       checkProof(empty_seq)(RR_norr(A, B, AA, RR1, RR2)))
		     

    % end lemma nor rule
    %===================================================================================
    % lemma or rule  |- (a \/ b)::k  if |- a::b::k

    concl_orr(A, B, AA, (n : posnat)): proof_step = 
          (# sequent:= cons(f_or(A, B), AA) , 
    	     rule:= orr,
	     subs:= cons(n - 1, null) #)

    RR_orr(A, B, AA, RR1): ne_proof_seq = 
    LET n = RR1`length IN
    (# length := n + 1,
       seq := LAMBDA(j: below(n + 1)):
       	      	 COND
		  j < n -> RR1`seq(j), 
		  j = n -> concl_orr(A, B, AA, n)
		 ENDCOND #)   

    lemma_orr: LEMMA (sentence?(A) AND
    	    	      sentence?(B) AND
		      sentence_list?(AA) AND
    	    	      conclusion(RR1) = cons(A, cons(B, AA)) AND
		      checkProof(empty_seq)(RR1))
		     =>
		     (conclusion(RR_orr(A, B, AA, RR1)) = cons(f_or(A, B), AA) AND
		      checkProof(empty_seq)(RR_orr(A, B, AA, RR1)))
		     

    % end lemma or rule
    %===================================================================================
    % lemma subset rule  |- k  if |- l and l include in k

    concl_subsetr(AA, (n : posnat)): proof_step = 
          (# sequent:= AA, 
    	     rule:= subset,
	     subs:= cons(n - 1, null) #)

    RR_subsetr(AA, BB, RR1): ne_proof_seq = 
    LET n = RR1`length IN
    (# length := n + 1,
       seq := LAMBDA(j: below(n + 1)):
       	      	 COND
		  j < n -> RR1`seq(j), 
		  j = n -> concl_subsetr(BB, n)
		 ENDCOND #)   

    lemma_subsetr: LEMMA (sentence_list?(AA) AND
		      	  sentence_list?(BB) AND
		      	  subset(AA, BB) AND
    	    	          conclusion(RR1) = AA AND
		      	  checkProof(empty_seq)(RR1))
		     	 =>
		     	 (conclusion(RR_subsetr(AA, BB, RR1)) = BB AND
		      	  checkProof(empty_seq)(RR_subsetr(AA, BB, RR1)))
		     

    % end lemma subset rule
    %===================================================================================
    % lemma neg rule  |- ~~k, l  if |- k, l

    concl_negr(A, AA, (n : posnat)): proof_step = 
          (# sequent:= cons(f_not(f_not(A)), AA), 
    	     rule:= neg,
	     subs:= cons(n - 1, null) #)

    RR_negr(A, AA, RR1): ne_proof_seq = 
    LET n = RR1`length IN
    (# length := n + 1,
       seq := LAMBDA(j: below(n + 1)):
       	      	 COND
		  j < n -> RR1`seq(j), 
		  j = n -> concl_negr(A, AA, n)
		 ENDCOND #)   

    lemma_negr: LEMMA (sentence?(A) AND
		      	  sentence_list?(AA) AND
    	    	          conclusion(RR1) = cons(A, AA) AND
		      	  checkProof(empty_seq)(RR1))
		     	 =>
		     	 (conclusion(RR_negr(A, AA, RR1)) = cons(f_not(f_not(A)), AA) AND
		      	  checkProof(empty_seq)(RR_negr(A, AA, RR1)))
		     

    % end lemma neg rule
    %===================================================================================
    %===================================================================================
    % lemma 1 : |- ~p::l if p belongs l 
    
    RR_lemma1(A, AA): ne_proof_seq = RR_ax(A, cons(f_not(A), AA))
 
    lemma1: LEMMA (member(A, AA) AND sentence?(A) AND sentence_list?(AA))
    	    	  => 
      		  (conclusion(RR_lemma1(A, AA))= cons(f_not(A), AA) AND 
		   checkProof(empty_seq)(RR_lemma1(A, AA)))

    % end lemma 1
    %===================================================================================	
    % th1 the sequent |- ~(p1 or p2 or...pn) , p1, ..., pn, ... is provable in KoT

    RR_th1(nclAA, clCC): RECURSIVE ne_proof_seq =
          LET lA = car(nclAA) IN
	  LET clAA = cdr(nclAA) IN 
          IF null?(clAA) THEN RR_lemma1(lA, clCC)
	     		 ELSE RR_norr(lA, nclause2fmla(clAA), clCC, RR_lemma1(lA, clCC), RR_th1(clAA, clCC))
	  ENDIF
	  MEASURE length(nclAA)
 
    th1: THEOREM 
      include_clause(nclAA, clBB)
      => 
      (conclusion(RR_th1(nclAA, clBB))= append(not_or_reduction(nclAA), clBB) AND 
       checkProof(empty_seq)(RR_th1(nclAA, clBB)))
       
    %===================================================================================
    % th2 the sequent |- ~(p1 or ... pk or pivot or pk+1 ... or pn), ~(q1 or ...or f_neg(pivot) or ...qm), p1, ...pn, q1, ...qm

    lpivot: VAR (literal?)

    RR_th2_1(lpivot, nclBB, clCC): ne_proof_seq =
          IF f_not?(lpivot)
	  THEN 
	    LET RR1 = RR_subsetr(append(not_or_reduction(nclBB), cons(arg(lpivot), clCC)),
	       	       	 	 cons(arg(lpivot), append(not_or_reduction(nclBB), clCC)),
				 RR_th1(nclBB, cons(arg(lpivot), clCC))) IN		
	    RR_negr(arg(lpivot), append(not_or_reduction(nclBB), clCC), RR1)
	  ELSE
	    RR_subsetr(append(not_or_reduction(nclBB), cons(f_not(lpivot), clCC)),
	       	       cons(f_not(lpivot), append(not_or_reduction(nclBB), clCC)),
		       RR_th1(nclBB, cons(f_not(lpivot), clCC))) 
	  ENDIF	    
	    
	 
    RR_th2(lpivot, nclAA, nclBB, clCC): ne_proof_seq = empty_seq
%          LET lA = car(nclAA) IN
%	  LET clAA = cdr(nclAA) IN
%	  LET lB = car(nclBB) IN
%	  LET clBB = cdr(nclBB) IN 
%          IF null?(clAA) % |- ~lA, ~nclBB, clCC 
%	  THEN 
%	    IF member(lA, clCC)
%	     THEN RR_ax(lA, cons(f_not(lA), cons(not_or_reduction(nclBB), clCC)))
%	     ELSE RR_th2.1(lA, nclBB, clCC)
%	    ENDIF
%	  ELSIF 
%	     		 ELSE RR_norr(lA, nclause2fmla(clAA), clCC, RR_lemma1(lA, clCC), RR_th2(clAA, clCC))
%	  ENDIF
%	  MEASURE length(nclAA)

    th2_1: THEOREM 
      include_clause(nclBB, cons(f_neg(lpivot), clCC))
      => 
      (conclusion(RR_th2_1(lpivot, nclBB, clCC))= cons(f_not(lpivot), append(not_or_reduction(nclBB), clCC)) AND 
       checkProof(empty_seq)(RR_th2_1(lpivot, nclBB, clCC)))

    th2: THEOREM 
      (include_clause(nclAA, cons(lpivot, clCC)) AND
       include_clause(nclBB, cons(f_neg(lpivot), clCC)))
      => 
      (conclusion(RR_th2(lpivot, nclAA, nclBB, clCC))= append(not_or_reduction(nclAA), append(not_or_reduction(nclBB), clCC)) AND 
       checkProof(empty_seq)(RR_th2(lpivot, nclAA, nclBB, clCC)))
			       
 		
  END resolution
