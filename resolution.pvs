resolution : THEORY

  BEGIN

  IMPORTING minlist
  IMPORTING sequents
  IMPORTING proof

    r, s, t: VAR term
    rr, ss, tt: VAR list[term]
    i, j, k: VAR nat
    ii, jj, kk: VAR list[nat]
    f, g, h: VAR (fun?)
    p, q: VAR (pred?)
    A, B, C: VAR fmla
    AA, BB, CC: VAR list[fmla]
    x, y, z: VAR (var?)
    xx, yy, zz: VAR list[(var?)]

    prop_atom?(A): bool = (atom?(A) AND 
    	      	           upred?(pred(A)) AND 
		           arity(pred(A)) = 0)

    pA, pB, pC: VAR (prop_atom?)

    literal?(A): bool = (prop_atom?(A) OR 
    		         (f_not?(A) AND prop_atom?(arg(A))))

    lA, lB, lC: VAR (literal?)

    literal_sentence: LEMMA sentence?(lA)

    lAA, lBB, lCC: VAR list[(literal?)]

    literal_list_sentence_list: LEMMA sentence_list?(lAA) 

    member_lit_member_fmla: LEMMA member[fmla](lA, lAA) = member[(literal?)](lA, lAA)

    % (not 1) -> 1, (1) -> 2, (not 2) -> 3, (2) -> 4...
    index(lA) : posnat = 
    	  IF prop_atom?(lA) 
	  THEN 2*index(pred(lA))
	  ELSE 2*index(pred(arg(lA)))-1
	  ENDIF
 
    index_inj: LEMMA 
      index(lA) = index(lB) 
      => 
      lA = lB

    IMPORTING sortedlist[(literal?), index]
	
    %list[literal?] sorted by index
    clause?(lAA) : bool = sorted?(lAA)

    clause_prop: LEMMA 
      clause?(lAA) 
      <=> 
      (null?(lAA) 
	OR null?(cdr(lAA)) 
	OR (index(car(lAA)) < index(car(cdr(lAA))) AND 
	    clause?(cdr(lAA))))

    sorted_clause: LEMMA
      clause?(lAA) AND cons?(lAA)
      =>
      (FORALL (e: (literal?)) : 
        member(e, cdr(lAA))
	=> 
	index(car(lAA)) < index(e))	
  
    % obs: setlist? is O(n^2). 
    no_duplicates?(lAA) : bool = setlist?(lAA)  

    clause_implies_no_duplicates: LEMMA
      clause?(lAA) IMPLIES no_duplicates?(lAA)

    clAA, clBB, clCC : VAR (clause?)

    clauses_list: TYPE = list[(clause?)]

    %non empty clause
    nclause?(clAA): bool = cons?(clAA)

    nclAA, nclBB : VAR (nclause?)

    include_clause(clAA, clBB): bool = sorted_include(clAA, clBB)

    % transform p1::p2::...pn into p1 or (p2 or ...(pn-1 or pn))...)
    % obs: add stronger type to fmla ?
    nclause2fmla(nclAA): RECURSIVE fmla= 
      IF null?(cdr(nclAA)) 
      THEN car(nclAA)
      ELSE f_or(car(nclAA), nclause2fmla(cdr(nclAA)))
      ENDIF
    MEASURE length(nclAA)

    nclause2fmla_sentence: LEMMA sentence?(nclause2fmla(nclAA))

    clause_sentence_list: LEMMA sentence_list?(clAA)

    % transform p1::p2::..pn into |- p1 or (p2 or ...pn))   and null into |- null (i.e |- false)
    or_reduction(clAA): sequent = 
      IF null?(clAA) 
      THEN null 
      ELSE cons(nclause2fmla(clAA), null) 
      ENDIF

    % transform p1::p2::..pn into |- not[p1 or (p2 or ...pn))]  
    not_or_reduction(nclAA): sequent = 
      cons(f_not(nclause2fmla(nclAA)), null) 

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % lemma 1 : |- ~p::l if p belongs l 
    
    cut1_lemma1(A): proof_step = (# sequent:= cons(A, cons(f_not(A), null)), rule:= ax, subs:= null #)
    cut2_lemma1(A): proof_step = (# sequent:= cons(f_not(A), cons(f_not(f_not(A)), null)), rule:= ax, subs:= null #)
    concl_lemma1(A, AA): proof_step = (# sequent:= cons(f_not(A), AA) , rule:= cut(f_not(A)), subs:= cons(0,cons(1,null)) #)

    RR_lemma1(A, AA): ne_proof_seq = 
    (# length:=3, 
       seq:= LAMBDA(j:below(3)):
		COND
        	  j = 0 -> cut1_lemma1(A),
		  j = 1 -> cut2_lemma1(A),
		  j = 2 -> concl_lemma1(A, AA) 
      		ENDCOND #)

    lemma1: LEMMA (member(A, AA) AND sentence?(A) AND sentence_list?(AA))
    	    	  =>
      		  conclusion(RR_lemma1(A, AA))= cons(f_not(A), AA) AND checkProof(empty_seq)(RR_lemma1(A, AA))

    % end lemma 1		  
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % the sequent |- not(p1 or p2 or...pn), not(q1 or q2 or... qm), p1, ..., pn, q1, ..., qm, t, u, ... is provable in KoT
    th1: THEOREM 
      (include_clause(nclAA, clCC) AND 
       include_clause(nclBB, clCC)) 
      => 
      (EXISTS(RR: ne_proof_seq): 
      	conclusion(RR)= append(not_or_reduction(nclAA), append(not_or_reduction(nclBB), clCC))
	 AND checkProof(empty_seq)(RR))
			       
 		
  END resolution
