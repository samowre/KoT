resolution : THEORY

  BEGIN

  IMPORTING rule

    r, s, t: VAR term
    rr, ss, tt: VAR list[term]
    i, j, k: VAR nat
    ii, jj, kk: VAR list[nat]
    f, g, h: VAR (fun?)
    p, q: VAR (pred?)
    A, B, C: VAR fmla
    AA, BB, CC: VAR list[fmla]
    x, y, z: VAR (var?)
    xx, yy, zz: VAR list[(var?)]
    nr, ns, nt: VAR nterm

    atom?(A): bool = (atom?(A) AND 
    	      	   upred?(pred(A)) AND 
		   arity(pred(A)) = 0)

    pA, pB, pC: VAR (atom?)

    literal?(A): bool = (atom?(A) OR 
    		      (f_not?(A) AND atom?(arg(A))))

    lA, lB, lC: VAR (literal?)

    lAA, lBB, lCC: VAR list[(literal?)]

    index(lA) : nat = 
    	  IF atom?(lA) THEN index(pred(lA))
	  ELSE index(pred(arg(lA)))
	  ENDIF

    sorted_no_duplicates?(lAA) : RECURSIVE bool = 
    		 CASES lAA OF	  
		       null: TRUE,
		       cons(e, r) : 
		         CASES r OF
			   null: TRUE,	
			   cons(f, s) :
			     index(e) < index(f) AND sorted_no_duplicates?(r)
			 ENDCASES
		 ENDCASES
	MEASURE length(lAA)

    no_duplicates?(lAA) : RECURSIVE bool = 
    		    CASES lAA OF
		    	  null : TRUE,
			  cons(e, r) : NOT member(e, r) AND no_duplicates?(r)
		    ENDCASES
	MEASURE length(lAA)

    clause_lit_list?(lAA): bool =
      sorted_no_duplicates?(lAA)
      

    sorted_no_duplicates:  LEMMA
       sorted_no_duplicates?(lAA) => FORALL (q : (literal?)) : member(q, lAA) => NOT member(f_neg(q), lAA)

    clAA, clBB, clCC : VAR (clause_lit_list?)

    remove(lA, clAA) : RECURSIVE (clause_lit_list?) = 
    	       CASES clAA OF
	         null : clAA,
		 cons(e, r) : IF index(e) = index(lA) 
		 	      THEN r
			      ELSE cons(e, remove(lA, r))
			      ENDIF
	       ENDCASES
	    MEASURE length(clAA)

    %merge and eliminates duplicates and pairs (p, ~p)
    strict_merge(clAA, clBB) : RECURSIVE (clause_lit_list?) = 
    		CASES clAA OF
		  null : clBB,
		  cons(a, rA) : 
		    CASES clBB OF
		      null : clAA,
		      cons(b, rB) : IF index(a) < index(b) 
		      	      	    THEN cons(a, strict_merge(rA, clBB))
				    ELSIF index(a) > index(b) 
				    THEN cons(b, strict_merge(clAA, rB))
				    ELSIF a = f_neg(b) 
				    %eliminates p, ~p
				    THEN strict_merge(rA, rB)
				    ELSE cons(a, strict_merge(rA, rB))
				    ENDIF
		    ENDCASES
		ENDCASES
	MEASURE length(clAA) + length(clBB)

    % unifies the two sets and removes occurrences of p and ~p
    % Returns null if the resulting clause is always true
    resolve( clAA, clBB ) : (clause_lit_list?) = 
		      LET p_nonp_set = {q:(literal?) | member(q, clAA) AND member(f_neg(q), clBB)} IN
		        IF card(p_nonp_set) > 1 
			THEN null
			ELSIF card(p_nonp_set) = 1
			THEN 
			  LET q = choose(p_nonp_set) IN
			  strict_merge(remove(q, clAA), remove(f_neg(q), clBB ))
			ELSE strict_merge(clAA, clBB)
		        ENDIF
    
    resolution_step : DATATYPE  
    BEGIN
	ax (axiom_clauses:(clause_lit_list?)) : ax?
	res_step (clauses : {l : list[nat] | length(l) > 1})  : res_step?
    END resolution_step

    clauses_list: TYPE = list[(clause_lit_list?)]

    %adds a clause at the end of a list of clauses
    append_clause(l : clauses_list, e : (clause_lit_list?)) : clauses_list= 
    		    append(l, cons(e, null))		    
		      
    resolution_certificate: TYPE = list[resolution_step]

    %verifies that each resolution step refers to previous clauses 
    good_indices (cert : resolution_certificate, n:nat) : RECURSIVE bool = 
    		  IF null?(cert) 
		  THEN TRUE
		  ELSE 
		       CASES car(cert) OF
		       	     ax(l) : good_indices(cdr(cert), n+1),
		  	     res_step(l) : (FORALL (i:nat) : member(i, l) AND (i<n))
			     		 AND good_indices(cdr(cert), n+1)
		       ENDCASES
		  ENDIF
    MEASURE length(cert) 

    fold_resolutions(l : clauses_list, acc : (clause_lit_list?)) : RECURSIVE (clause_lit_list?) =
    			   CASES l OF
			   null : acc,
			   cons(e, rest) : fold_resolutions(rest, resolve(acc, e))
			   ENDCASES
		MEASURE length(l)

    good_indices_cert?(cert : resolution_certificate) : bool = 
    				  good_indices(cert, 0)
    
    % Creates from the certificate a list of clauses. 
    % Each clause coresponds to an axiom or a resolution step in the certificate.
    create_clauses (cert : resolution_certificate, 
    		   context : {c : clauses_list | good_indices(cert, length(c))}) 
		   : RECURSIVE clauses_list = 
    		   IF null?(cert) 
		   THEN context
		   ELSE 
		   	LET step = car(cert) IN
		   	    CASES step OF
		   	    ax(lst) : 
			    	    create_clauses( cdr(cert), append_clause(context, lst)),
		   	    res_step(l) : 
			        %the list of clauses corresponding to the list of indices
			    	LET clauses_used = map(LAMBDA i : nth(context, i))(l) IN
				%first clause for resolution
				LET clause1 = car(clauses_used) IN
				%second clause
				LET clause2 = car(cdr(clauses_used)) IN
				%resolution applied to the first two clauses
				LET first_res = resolve(clause1, clause2) IN
				%other resolution steps
				LET rest_used = cdr(cdr(clauses_used)) IN
				    create_clauses( cdr(cert), 
		   	       		  append_clause( context, 
					    fold_resolutions(rest_used, first_res) ) )				       
		   	    ENDCASES
    		   ENDIF
     MEASURE length(cert)


    execute_certificate(cert: (good_indices_cert?)) : clauses_list = 
    			    create_clauses(cert, null)

    %returns true if the certificate ends with an empty clause
    unsat?(cert: resolution_certificate) : bool = 
    		 IF NOT good_indices_cert?(cert) 
		 THEN FALSE
		 ELSE LET clauses = execute_certificate(cert) IN
		      	  IF nth(clauses, length(clauses) - 1) = emptyset 
			  THEN TRUE
			  ELSE FALSE
			  ENDIF
		 ENDIF

    %apply_resolution_check: LEMMA  
 %			    LET res_result = resolve(clAA, clBB) IN
  %  			    LET seqent = cons(f_not(clAA), cons(f_not(clBB), cons(clCC, null))) IN
	%		    TRUE
		
  END resolution
