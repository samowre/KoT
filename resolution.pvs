resolution : THEORY

  BEGIN

  IMPORTING minlist
  IMPORTING sequents
  IMPORTING proof

    r, s, t: VAR term
    rr, ss, tt: VAR list[term]
    i, j, k: VAR nat
    ii, jj, kk: VAR list[nat]
    f, g, h: VAR (fun?)
    p, q: VAR (pred?)
    A, B, C: VAR fmla
    AA, BB, CC: VAR list[fmla]
    x, y, z: VAR (var?)
    xx, yy, zz: VAR list[(var?)]

    prop_atom?(A): bool = (atom?(A) AND 
    	      	           upred?(pred(A)) AND 
		           arity(pred(A)) = 0)

    pA, pB, pC: VAR (prop_atom?)

    literal?(A): bool = (prop_atom?(A) OR 
    		         (f_not?(A) AND prop_atom?(arg(A))))

    lA, lB, lC: VAR (literal?)

    lAA, lBB, lCC: VAR list[(literal?)]

    % (not 1) -> 1, (1) -> 2, (not 2) -> 3, (2) -> 4...
    index(lA) : posnat = 
    	  IF prop_atom?(lA) 
	  THEN 2*index(pred(lA))
	  ELSE 2*index(pred(arg(lA)))-1
	  ENDIF
 
    index_inj: LEMMA 
      index(lA) = index(lB) 
      => 
      lA = lB

    clause_rec?(lAA, (j: nat)): RECURSIVE bool =
      CASES lAA OF
        null: TRUE,
     	cons(k, lBB): index(k)> j AND clause_rec?(lBB, index(k))
      ENDCASES
     MEASURE length(lAA)
	
    %list[literal?] sorted by index
    clause?(lAA) : bool = clause_rec?(lAA, 0)

    clause_rec_red: LEMMA 
      FORALL(j1, j2: nat): 
        (clause_rec?(lAA, j1) AND j2<j1) 
        => 
        clause_rec?(lAA, j2)

    clause_prop: LEMMA 
      clause?(lAA) 
      <=> 
      (null?(lAA) 
	OR null?(cdr(lAA)) 
	OR (index(car(lAA)) < index(car(cdr(lAA))) AND 
	    clause?(cdr(lAA))))

    sorted_clause: LEMMA
      clause?(lAA) AND cons?(lAA)
      =>
      (FORALL (e: (literal?)) : 
        member(e, cdr(lAA))
	=> 
	index(car(lAA)) < index(e))	
  
    % obs: setlist? is O(n^2). 
    no_duplicates?(lAA) : bool = setlist?(lAA)  

    clause_implies_no_duplicates: LEMMA
      clause?(lAA) IMPLIES no_duplicates?(lAA)

    clAA, clBB, clCC : VAR (clause?)

    remove(lA, clAA) : RECURSIVE 
       {clBB | (FORALL lB : member(lB, clBB) = (lB /= lA AND member(lB, clAA)))} = 
      CASES clAA OF
        null : clAA,
	cons(e, r) : IF index(e) = index(lA) 
		      THEN r
		      ELSIF index(lA) < index(e)
		      % lA not in the list
		      THEN clAA
		      ELSE cons(e, remove(lA, r))
		      ENDIF
      ENDCASES
      MEASURE length(clAA)
  

    clauses_list: TYPE = list[(clause?)]

    %non empty clause
    nclause?(clAA): bool = cons?(clAA)

    nclAA, nclBB : VAR (nclause?)

    % transform p1::p2::...pn into p1 or (p2 or ...(pn-1 or pn))...)
    % obs: add stronger type to fmla ?
    nclause2fmla(nclAA): RECURSIVE fmla= 
      IF null?(cdr(nclAA)) 
      THEN car(nclAA)
      ELSE f_or(car(nclAA), nclause2fmla(cdr(nclAA)))
      ENDIF
    MEASURE length(nclAA)

    clause_sentence_list: LEMMA 
      sentence_list?(clAA)

    % transform p1::p2::..pn into |- p1 or (p2 or ...pn))   and null into |- null (i.e |- false)
    or_reduction(clAA): sequent = 
      IF null?(clAA) 
      THEN null 
      ELSE cons(nclause2fmla(clAA), null) 
      ENDIF

    % transform p1::p2::..pn into |- not[p1 or (p2 or ...pn))]  
    not_or_reduction(nclAA): sequent = 
      cons(f_not(nclause2fmla(nclAA)), null) 
    
    % inclusion efficiently implemented for clauses
    include_clause(clAA, clBB): RECURSIVE bool = 
    	 CASES clAA OF
	   null: true,
	   cons(lA, clAAA): 
	     CASES clBB OF
	       null: false,
	       cons(lB, clBBB): 
	         COND
		   index(lA) < index(lB) -> false, 
		   index(lA) = index(lB) -> include_clause(clAAA, clBBB),
		   index(lA) > index(lB) -> include_clause(clAA, clBBB)
		 ENDCOND
	     ENDCASES
   	 ENDCASES
    MEASURE length(clBB)

    subset_include_clause: LEMMA include_clause(clAA, clBB) IMPLIES subset(clAA, clBB)


    % the sequent |- not(p1 or p2 or...pn), not(q1 or q2 or... qm), p1, ..., pn, q1, ..., qm, t, u, ... is provable in KoT
    th1: THEOREM 
      (include_clause(nclAA, clCC) AND 
       include_clause(nclBB, clCC)) 
      => 
      (EXISTS(RR: ne_proof_seq): 
      	conclusion(RR)= append(not_or_reduction(nclAA), append(not_or_reduction(nclBB), clCC))
	 AND checkProof(empty_seq)(RR))
			       
 		
  END resolution
