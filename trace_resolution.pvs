trace_resolution[m, n: nat, i : upto(n)]: THEORY
BEGIN

  IMPORTING minlist

  literal?(k: nzint): bool = (abs(k) < m)

  k, l: VAR (literal?)

  index(k): posnat = abs(k)

  clause_rec?(ll: list[(literal?)], (j: nat)): RECURSIVE bool =
    CASES ll OF
     null: TRUE,
     cons(k, jj): index(k)> j AND clause_rec?(jj, index(k))
     ENDCASES
     MEASURE length(ll)

  sorted_clause_rec: LEMMA 
  	FORALL (l: (cons?[(literal?)]), j: nat): clause_rec?(l,j) IMPLIES 
	  (FORALL (e:(literal?)): member(e,cdr(l)) IMPLIES (index(e)>index(car(l))))  

  clause?(ll: list[(literal?)]): bool = clause_rec?(ll, 0)

  ck, cl: VAR (clause?)

  cons_clause: LEMMA (clause?(ck) AND cons?(ck)) IMPLIES (clause?(cdr(ck)))

%  trace_entry: DATATYPE
%    BEGIN
%     tr_clause(clause:(clause?)): tr_clause?
%     tr_merg(merg_list: (cons?[below(n)])) : tr_merg?
%    END trace_entry


  %list of integers smaller than i
  chain(index : below(n)) : TYPE = list[below(index)]
  
  %record with fields clause and chain(i)
  clause_chain(index : below(n)) : TYPE = [# cl: (clause?), chn: chain(index) #]

  %array of records
  certificate: TYPE = ARRAY[index: below(n) -> clause_chain(index)]

  cert : VAR certificate

  merge(ck, cl) : RECURSIVE 
       {cla: (clause?) | (FORALL k: 
       	     	 (member(k,cla) OR (member(k,ck) AND member(-k,cl)) OR (member(-k,ck) AND member(k,cl))) 
		 IFF (member(k,ck) OR member(k,cl)))} = 
       	     CASES ck OF
   	         null : cl,
		 cons(k, ckk) : 
	  	  CASES cl OF
	    	  	null : ck,
	    		cons(l, cll) : IF k = l
				        THEN cons(k, merge(ckk, cll))
					ELSIF index(k) < index(l) 
	          	   	        THEN cons(k, merge(ckk, cl))
			    		ELSE cons(l, merge(ck, cll))
			  	       ENDIF
	         ENDCASES
             ENDCASES
      	     MEASURE length(ck) + length(cl)
      
  %applies merge on a non-empty list of clauses
  merge_list(lck: (cons?[(clause?)])): RECURSIVE (clause?) =
     CASES cdr(lck) OF
       null : car(lck),
       cons(ck, lcl) : merge_list(cons(merge(car(lck), ck), lcl))
     ENDCASES
     MEASURE length(lck)

  build_chain_list(j: below(n), cert): (cons?[(clause?)]) = 
      map(LAMBDA (a : below(j)) : cert(a)`cl)(cert(j)`chn)  		    
  
  resolve_rec ( j: upto(n), cert ): RECURSIVE certificate = 
    IF j=n OR null?( cert(j)`chn )
    THEN cert
    ELSE resolve_rec(j+1, cert WITH [(j)`cl := merge_list(build_chain_list(j, cert))])
    ENDIF 
  MEASURE n-j

  resolve(cert): certificate = resolve_rec(0, cert) 
 
END trace_resolution
