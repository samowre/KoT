trace_resolution[m, n: nat, i : upto(n)]: THEORY
BEGIN

  IMPORTING minlist

  tr_literal?(k: nzint): bool = (abs(k) < m)

  k, l: VAR (tr_literal?)
  ll: VAR list[(tr_literal?)]

  % (-1) -> 1, (1) -> 2, (-2) -> 3, (2) -> 4 ...
  index(k): posnat = IF (k<0) THEN 2*abs(k)-1 ELSE 2*k ENDIF

  %index must be injective?
  IMPORTING sortedlist[(tr_literal?), index]

  % A trace clause is a list of trace literals sorted by index
  tr_clause?(ll): bool = sorted?(ll)

  tr_clause_prop: LEMMA tr_clause?(ll) IFF 
    		       (null?(ll) 
		        OR null?(cdr(ll)) 
			OR (index(car(ll))<index(car(cdr(ll))) AND tr_clause?(cdr(ll))))

  ck, cl, cm: VAR (tr_clause?)

  %not empty trace clause
  ne_tr_clause?(cl): bool = NOT null?(cl)
 
  ncl, nck, ncm : VAR (ne_tr_clause?)

  cons_tr_clause: LEMMA (tr_clause?(ck) AND cons?(ck)) IMPLIES tr_clause?(cdr(ck))

%  trace_entry: DATATYPE
%    BEGIN
%     tr_clause(clause:(clause?)): tr_clause?
%     tr_merg(merg_list: (cons?[below(n)])) : tr_merg?
%    END trace_entry


  %list of integers smaller than i
  chain(index : below(n)) : TYPE = list[below(index)]
  
  %record with fields clause and chain(i)
  clause_chain(j : below(n)) : TYPE = [# cl: (tr_clause?), chn: chain(j) #]

  %array of records
  certificate: TYPE = ARRAY[index: below(n) -> clause_chain(index)]

  cert : VAR certificate


  % tr_clause is sorted by index => ~p, p are on consecutive positions.
  % deletes the pair (~pivot, pivot)  
  delete_pivot(ck, (pivot: {l| member(l, ck) AND member(-l, ck)}))
   : {cl | FORALL l: member(l, cl) <=> member(l, ck) AND (NOT l = pivot) AND (NOT l = -pivot)} = 
    remove(-pivot, remove(pivot, ck))

  % true if a pivot exists for ck and cl
  exist_pivot?(ck, cl) : RECURSIVE bool =
    CASES ck OF 
      null: FALSE,
      cons(k, cm): member(-k, cl) OR exist_pivot?(cm, cl)
    ENDCASES
  MEASURE length(ck)

  exist_lemma : LEMMA
    exist_pivot?(ck, cl) <=> EXISTS k: member(k, ck) AND member(-k, cl)

  % returns a pivot of nck and ncl
  find_pivot(nck, (ncl:{ncm | exist_pivot?(nck, ncm)})) : RECURSIVE {k | member(k, nck) AND member(-k, ncl)} =
    CASES cdr(nck) OF
      null: car(nck),
      cons(k, ck): 
        IF member(-car(nck), ncl) 
	THEN car(nck) 
	ELSIF member(-k, ncl) 
	THEN k 
	ELSE find_pivot(cdr(nck), ncl) 
	ENDIF
    ENDCASES
  MEASURE length(nck)
      
  %eliminates duplicates
  merge(ck, cl) : RECURSIVE 
       {cla: (tr_clause?) | FORALL k: 
       	     	 member(k,cla)  
		 IFF (member(k,ck) OR member(k,cl))} = 
       	     CASES ck OF
   	         null : cl,
		 cons(k, ckk) : 
	  	  CASES cl OF
	    	  	null : ck,
	    		cons(l, cll) : IF k = l
				        THEN cons(k, merge(ckk, cll))
					ELSIF index(k) < index(l) 
	          	   	        THEN cons(k, merge(ckk, cl))
			    		ELSE cons(l, merge(ck, cll))
			  	       ENDIF
	         ENDCASES
             ENDCASES
      	     MEASURE length(ck) + length(cl)

  merge_includes1: LEMMA
    sorted_include(ck, merge(ck, cl)) AND sorted_include(cl, merge(ck, cl))
    
  % applies resolution to nck and ncl
  resolution(nck, (ncl:{ncm | exist_pivot?(nck, ncm)})) : (tr_clause?) = 
    LET pivot= find_pivot(nck, ncl) IN 
    delete_pivot(merge(nck, ncl), pivot) 

  % member(x, ck) => member(x, res) \/ x =  pivot
  % member(x, cl) => member(x, res) \/ x = -pivot
  resolution_lemma : LEMMA
    exist_pivot?(nck, ncl) =>
      LET pivot = find_pivot(nck, ncl) IN
      LET res = resolution(nck, ncl) IN
      (FORALL k: member(k, nck) => member(k, res) OR k=pivot
       AND
        FORALL l: member(l, ncl) => member(l, res) OR l= -pivot)
      
  %applies merge on a non-empty list of clauses
  resolution_list(lck: (cons?[(tr_clause?)])): RECURSIVE (tr_clause?) =
     CASES cdr(lck) OF
       null : car(lck),
       cons(ck, lcl) : resolution_list(cons(resolution(car(lck), ck), lcl))
     ENDCASES
     MEASURE length(lck)

  % creates the list of clauses corresponding to the chain values
  build_chain_list(j: below(n), cert : {c : certificate|cons?(c(j)`chn)}): (cons?[(tr_clause?)]) = 
      map(LAMBDA (a : below(j)) : cert(a)`cl)(cert(j)`chn)
  		    
  % applies resolution_list on all chains starting from j  
  resolve_rec ( j: upto(n), cert ): RECURSIVE certificate = 
    IF j=n 
    THEN cert
    ELSIF null?( cert(j)`chn )
    THEN resolve_rec(j+1, cert)
    ELSE resolve_rec(j+1, cert WITH [(j)`cl := resolution_list(build_chain_list(j, cert))])
    ENDIF 
  MEASURE n-j

  resolve(cert): certificate = resolve_rec(0, cert) 
 
END trace_resolution




