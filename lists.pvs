lists_map[S, T: TYPE]: THEORY
BEGIN
  IMPORTING lists
  h: VAR [S -> S]
  a, b, c: VAR T
  x: VAR S

  f, g: VAR [S -> list[T]]
  A, B, C: VAR list[T]
  % From map2
     kk: VAR list[S]
     delete_reduce: LEMMA
       remove(a, reduce(null, LAMBDA x, A: append(f(x), A))(kk)) =
       reduce(null, LAMBDA x, A: append(remove(a, f(x)), A))(kk)
	    
     every_reduce: LEMMA
       every(LAMBDA x: f(x) = g(x))(kk) =>
       reduce(null, LAMBDA x, A: append(f(x), A))(kk) =
       reduce(null, LAMBDA x, A: append(g(x), A))(kk)

     reduce_map: LEMMA
       reduce(null, LAMBDA x, A: append(f(x), A))(map(h)(kk)) =
       reduce(null, LAMBDA x, A: append(f(h(x)), A))(kk)

     map(f: [S -> T])(ss: finseq[S]): finseq[T] =
       (# length := ss`length,
          seq := (LAMBDA (i: below(ss`length)): f(ss(i))) #)
END lists_map

lists_map2[S1, S2, T: TYPE]: THEORY
BEGIN
    map2(f: [S1, S2 -> T], l1: list[S1], l2: list[S2]): RECURSIVE list[T] =
      CASES l1 OF
        null: null,
	cons(x, t1):
	  CASES l2 OF
	    null: null,
	    cons(y, t2): cons(f(x, y), map2(f, t1, t2))
	  ENDCASES
      ENDCASES
    MEASURE length(l1)

    reduce2(a: T, f: [S1, S2, T -> T], l1: list[S1], l2: list[S2]): RECURSIVE T =
      CASES l1 OF
        null: a,
	cons(x, t1):
	  CASES l2 OF
	    null: a,
	    cons(y, t2): f(x, y, reduce2(a, f, t1, t2))
	  ENDCASES
      ENDCASES
    MEASURE length(l1)
END lists_map2

list_subtype[T: TYPE, S: TYPE FROM T]: THEORY
BEGIN
  l: VAR list[S]

  length_length: LEMMA
    length[S](l) = length[T](l)
END list_subtype
