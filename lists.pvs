lists[T:TYPE]: THEORY 
BEGIN
%  IMPORTING adt_props
%  IMPORTING list_adt_props
  IMPORTING more_list_props

  l, m, l1, l2: VAR list[T]
  p: VAR pred[T]
  P: VAR pred[list[T]]
  a, b, c: VAR T
  x, y, z: VAR T

  minlistx(l, (key: [T -> real]), a, (m: real | key(a) = m)): RECURSIVE
    { c | member(c, cons(a, l)) AND (FORALL b: member(b, cons(a, l)) IMPLIES key(c) <= key(b)) } =
    CASES l OF
      null: a,
      cons(c, t):
        LET k = key(c) IN
	IF k < m
	  THEN minlistx(t, key, c, k)
	  ELSE minlistx(t, key, a, m)
	ENDIF
    ENDCASES
  MEASURE length(l)

  minlist(l: (cons?[T]), (key: [T -> real])):
    { x | member(x, l) AND (FORALL y: member(y, l) IMPLIES key(x) <= key(y)) } =
    minlistx(cdr(l), key, car(l), key(car(l)))

  maxlist(l: (cons?[T]), (key: [T -> real])):
    { x | member(x, l) AND (FORALL y: member(y, l) IMPLIES key(y) <= key(x)) } =
    minlist(l, LAMBDA x: -key(x))

 

END lists

lists_map[S, T: TYPE]: THEORY
BEGIN
  IMPORTING lists
  h: VAR [S -> S]
  a, b, c: VAR T
  x: VAR S

  f, g: VAR [S -> list[T]]
  A, B, C: VAR list[T]
  % From map2
     kk: VAR list[S]
     delete_reduce: LEMMA
       remove(a, reduce(null, LAMBDA x, A: append(f(x), A))(kk)) =
       reduce(null, LAMBDA x, A: append(remove(a, f(x)), A))(kk)
	    
     every_reduce: LEMMA
       every(LAMBDA x: f(x) = g(x))(kk) =>
       reduce(null, LAMBDA x, A: append(f(x), A))(kk) =
       reduce(null, LAMBDA x, A: append(g(x), A))(kk)

     reduce_map: LEMMA
       reduce(null, LAMBDA x, A: append(f(x), A))(map(h)(kk)) =
       reduce(null, LAMBDA x, A: append(f(h(x)), A))(kk)

     map(f: [S -> T])(ss: finseq[S]): finseq[T] =
       (# length := ss`length,
          seq := (LAMBDA (i: below(ss`length)): f(ss(i))) #)
END lists_map

lists_map2[S1, S2, T: TYPE]: THEORY
BEGIN
    map2(f: [S1, S2 -> T], l1: list[S1], l2: list[S2]): RECURSIVE list[T] =
      CASES l1 OF
        null: null,
	cons(x, t1):
	  CASES l2 OF
	    null: null,
	    cons(y, t2): cons(f(x, y), map2(f, t1, t2))
	  ENDCASES
      ENDCASES
    MEASURE length(l1)

    reduce2(a: T, f: [S1, S2, T -> T], l1: list[S1], l2: list[S2]): RECURSIVE T =
      CASES l1 OF
        null: a,
	cons(x, t1):
	  CASES l2 OF
	    null: a,
	    cons(y, t2): f(x, y, reduce2(a, f, t1, t2))
	  ENDCASES
      ENDCASES
    MEASURE length(l1)
END lists_map2

list_subtype[T: TYPE, S: TYPE FROM T]: THEORY
BEGIN
  l: VAR list[S]

  length_length: LEMMA
    length[S](l) = length[T](l)
END list_subtype
