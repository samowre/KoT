rev_sortedlist   [ T: TYPE, key: { k:[T-> real]  | injective?(k)} ]
		: THEORY
  BEGIN

  IMPORTING more_list_props[T]

  l, m, l1, l2 : VAR list[T]
  a,b,c: VAR T
  x,y,z: VAR T
  i,j: VAR nat
  p: VAR PRED[T]

  rev_key(x): real = -key(x)

  IMPORTING sortedlist[T,key]
  IMPORTING sortedlist[T,rev_key]


rev_sorted?(l): bool = sorted?[T,rev_key](l)

  sl, sl1, sl2 : VAR (sorted?[T,key])
  rl, rl1, rl2 : VAR (rev_sorted?)


rev_sorted: THEOREM rev_sorted?(reverse(sl)) ;

% More order props:

<: [[(sorted?[T,key]),(sorted?[T,key])] -> bool] = sortedlist[T,key].<

  % We can only test the elements of sl2
order_char_right: LEMMA sl1 < sl2 IFF cons?(sl2) AND (null?(sl1) OR FORALL y: member(y,sl2) IMPLIES key(car(reverse(sl1))) < key(y))
  % Or only the elements of sl1
order_char_left : LEMMA sl1 < sl2 IFF cons?(sl2) AND FORALL x: member(x,sl1) IMPLIES key(x) < key(car(sl2))
  % Or only 2 elements
order_char_2: LEMMA sl1 < sl2 IFF cons?(sl2) AND (null?(sl1) OR key(car(reverse(sl1))) < key(car(sl2)))

 	
  END rev_sortedlist


