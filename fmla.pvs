% A symbol is a (interpreted or not) predicate or function
symbol: DATATYPE WITH SUBTYPES pred?, fun?
BEGIN
  ipred(index, arity: nat): ipred? : pred?
  upred(index, arity: nat): upred? : pred?
  ifun(index, arity: nat): ifun?   : fun?
  ufun(index, arity: nat): ufun?   : fun?
END symbol

symbol_props: THEORY
BEGIN
  IMPORTING symbol
  s: VAR symbol
  
  usymb?(s): bool = upred?(s) OR ufun?(s)
END symbol_props

% A term is either a variable, or the application of a function symbol to a list of arguments
term: DATATYPE
BEGIN
  IMPORTING symbol_props
  v(index: nat): var?
  apply(fun: (fun?), args: { l: finseq[term] | l`length = arity(fun) }): apply?
END term

% A first-order formula over terms
fmla: DATATYPE
BEGIN
  IMPORTING term
  atom(pred: (pred?), args: { l: finseq[term] | l`length = arity(pred) }): atom?
  f_not(arg: fmla): f_not?
  f_or(larg, rarg: fmla): f_or?
  f_exists(bvar: nat, body: fmla): f_exists?
END fmla

term_props: THEORY
BEGIN
  IMPORTING term
  IMPORTING more_list_props
  IMPORTING list2_props
  IMPORTING more_finseq_props
  IMPORTING assoc2, smap, setmap
  IMPORTING set_props
  CONVERSION- singleton_elt

  s, t: VAR term
  ss, ts: VAR set[term]
  i, n: VAR nat
  is, ns: VAR set[nat]
  uf: VAR (ufun?)

  % Computes the set of variables present in a term.
  % This is intended to be used in specifications only, and may not be executable.
  vars(t): RECURSIVE set[nat] =
    CASES t OF
      v(n): singleton(n),
      apply(f, args): vars(args :: set[term])
    ENDCASES
  MEASURE t BY <<

  vars_subterm: THEOREM n ∈ vars(t) IFF subterm(v(n), t)
  
  % vars only increases
  vars_increases: THEOREM
    t << s IMPLIES vars(t) ⊂ vars(s)

  % Computes the set of unintepreted symbols present in a term
  ufuns(t): RECURSIVE set[(ufun?)] =
    CASES t OF
      v(n): emptyset,
      apply(f, args): { uf | uf = f OR uf ∈ ufuns(args :: set[term]) }
    ENDCASES
  MEASURE t BY <<

  % Parallel substitution in a term using a mapping function from variables to terms.
  % We can actually know a superset of the new variables
  parsubst(s: term, mapping: [nat -> term]): RECURSIVE
    { t | subset?(vars(t), vars(setmap(mapping)(vars(s)))) } =
%TODO { t | vars(t) ⊂ vars(setmap(mapping))(vars(s)) }
    CASES s OF
      v(i): mapping(i),
      apply(f, args): apply(f, smap[{t | t << s }, { t | subset?(vars(t), vars(setmap(mapping)(vars(s)))) }]
                                   (LAMBDA (t | t << s): parsubst(t, mapping))(args))
    ENDCASES
  MEASURE s BY <<

  % Paralel substitution, with association lists
  % Again, we can know a superset of the new variables
  parsubst(s: term, vars: list[nat], (vals: finseq[term] | vals`length = length(vars))):
    term =
%TODO    { r | vars(r) ⊂ (vars(s) \ vars) ∪ vars(vals) }
    parsubst(s, LAMBDA i: assoc2[nat, term](i, vars, vals, v(i)))

  % Single substitution is actually a parallel substitution
  % We know a superset of the new variables
  subst(s, n, t): term =
%TODO    { r | vars(r) ⊂ (vars(s) \ n) ∪ vars(t) }
    parsubst(s, LAMBDA i: IF i = n THEN t ELSE v(i) ENDIF)

  % Interprets an uninterpreted function by a body.
  % There is no restriction on the variables present in the replacement function.
  fsubst(s,
        (u: (ufun?)),
	(vars: (uniques?[nat]) | length(vars) = arity(u)),
	t):
    RECURSIVE term =
%TODO { r | vars(r) ⊂ vars(s) ∪ (vars(t) \ vars) }
    CASES s OF
      v(i): s,
      apply(f, args):
        LET nargs = smap[{ t | t << s }, term]
	                (LAMBDA (r: term | r << s): fsubst(r, u, vars, t))(args) IN
	IF f = u
	  THEN parsubst(t, vars, nargs)
	  ELSE apply(f, nargs)
	ENDIF
    ENDCASES
  MEASURE s BY <<
END term_props

fmla_props: THEORY
BEGIN
  IMPORTING term
  IMPORTING fmla
  IMPORTING term_props

  s, t: VAR term
  ss, ts: VAR set[term]
  f, g: VAR fmla
  fs, gs: VAR set[fmla]
  i, n: VAR nat
  is, ns: VAR set[nat]
  li, ln: VAR list[nat]

  % Intelligent constructors
  ;¬(f): fmla    = IF f_not?(f) THEN arg(f) ELSE f_not(f) ENDIF
  ;∨(f, g): fmla = f_or(f, g)
  ;∧(f, g): fmla = ¬(¬f ∨ ¬g)
  ;⇒(f, g): fmla = ¬f ∨ ¬g
  ;⇔(f, g): fmla = (f ⇒ g) ∨ (g ⇒ f)
  ;◇(n)(f): fmla = f_exists(n, f)
  ;◇(ln)(f): RECURSIVE fmla =
    CASES ln OF
      null: f,
      cons(n, t): f_exists(n, (◇t)(f))
    ENDCASES
  MEASURE length(ln)
  ;□(n)(f): fmla  = ¬(◇n)(f)
  ;□(ln)(f): fmla = ¬(◇ln)(f)

  % Free variables of a formula
  % This is intended to be used in specifications only, and may not be executable.
  freevars(f): RECURSIVE set[nat] =
    CASES f OF
      atom(p, args): vars({ t | EXISTS (i: below(args`length)): t = args(i) }),
      f_not(g): freevars(g),
      f_or(g, h): union(freevars(g), freevars(h)),
      f_exists(n, b): remove(n, freevars(b))
    ENDCASES  
  MEASURE f BY <<

  % A formula without free variables is a sentence
  sentence?(f): bool = empty?(freevars(f))

  % Free variables of a set of formulae
  freevars(fs): set[nat] =
    { n | EXISTS (f | member(f, fs)): member(n, freevars(f)) }

  % Bound variables (i.e, variables bound by an ∃, whether they actually are used or not)
  boundvars(f): RECURSIVE set[nat] =
    CASES f OF
      atom(p, args): emptyset,
      f_not(g): boundvars(g),
      f_or(g, h): union(boundvars(g), boundvars(h)),
      f_exists(n, b): add(n, boundvars(b))
    ENDCASES
  MEASURE f BY <<

  % Bound variables of a set of formulae
  boundvars(fs): set[nat] =
    { n | EXISTS (f | member(f, fs)): member(n, boundvars(f)) }

  % The variables of a formula are both the free and bound variables
  vars(f): set[nat] = union(freevars(f), boundvars(f))
  CONVERSION LAMBDA f: vars(f)

  % Checks whether the variables in ns are not bound in formula f
  freefor(f, ns): bool =
    empty?(intersection(ns, boundvars(f)))

  % A term or a formula is free w.r.t f if is variables are free
  freefor(f, t): MACRO bool =
    freefor(f, vars(t))
  freefor(f, g): MACRO bool =
    freefor(f, vars(g))

  % Parallel substitution of variables in a formula through a mapping
  % We can actually have more informations about the free variables of the
  % new formula
  parsubst(f: fmla, mapping: [n: nat -> { t | t = v(n) OR freefor(f, t) }]):
%TODO: { h | freevars(h) ⊂ vars(setmap(mapping))(freevars(f)) AND
%            boundvars(h) = boundvars(f) }
    RECURSIVE fmla =
    CASES f OF
      atom(p, args): atom(p, smap(LAMBDA t: parsubst(t, mapping))(args)),
      f_not(g): f_not(parsubst(g, mapping)),
      f_or(g, h): f_or(parsubst(g, mapping), parsubst(h, mapping)),
      f_exists(n, b): f_exists(n, parsubst(b, mapping))
    ENDCASES
  MEASURE f BY <<

  % Parallel substitution with an association list
  parsubst(f: fmla,
           vars: list[nat],
	   (vals: finseq[{ t | freefor(f, t) }] | vals`length = length(vars))): fmla =
%TODO: { h | freevars(h) ⊂ (freevars(f) \ vars) ∪ vars(vals) AND
%            boundvars(h) = boundvars(f) }
    parsubst(f, LAMBDA i: assoc2[nat, { t | t = v(i) OR freefor(f, t) }](i, vars, vals, v(i)))

  % Single substitution can come in handy
  subst(f, n, (t | freefor(f, t))): fmla =
% TODO { h | freevars(h) ⊂ (freevars(f) \ n) ∪ vars(t) AND
%            boundvars(h) = boundvars(f) }
    parsubst(f, LAMBDA i: IF i = n THEN t ELSE v(i) ENDIF)

  % Substitutes an uninterpreted function symbol with a term
  fsubst(f,
         (u: (ufun?)),
	 (vars: (uniques?[nat]) | length(vars) = arity(u)),
	 (t | freefor(f, t))):
    RECURSIVE fmla =
%TODO { h | freevars(h) ⊂ freevars(f) ∪ (vars(t) \ vars) AND
%           boundvars(h) = boundvars(f) }
    CASES f OF
      atom(p, args): atom(p, smap(LAMBDA s: fsubst(s, u, vars, t))(args)),
      f_not(g): f_not(fsubst(g, u, vars, t)),
      f_or(g, h): f_or(fsubst(g, u, vars, t), fsubst(h, u, vars, t)),
      f_exists(n, b): f_exists(n, fsubst(b, u, vars, t))
    ENDCASES
  MEASURE f BY <<

  % Substitutes an unintepreted predicate symbol with  formula
  psubst(f,
         (u: (upred?)),
	 (vars: (uniques?[nat]) | length(vars) = arity(u)),
	 (g | subset?(freevars(g), vars) AND freefor(f, g))):
    RECURSIVE fmla =
%TODO { h | freevars(h) ⊂ freevars(f) ∪ (freevars(g) \ vars) AND
%           boundvars(h) ⊂ boundvars(f) ∪ boundvars(g) }
    CASES f OF
      atom(p, args):
        IF p = u
	  THEN parsubst(g, vars, args)
	  ELSE f
	ENDIF,
      f_not(h): f_not(psubst(h, u, vars, g)),
      f_or(l, r): f_or(psubst(l, u, vars, g), psubst(r, u, vars, g)),
      f_exists(n, b): f_exists(n, psubst(b, u, vars, g))
    ENDCASES
  MEASURE f BY <<
END fmla_props

%   equal_subst_aux(s: term,
%                   (ss: list[[term, term]] | every(LAMBDA (r, t): r << s)(ss)),
% 		  mapping: [nat -> term],
%                   equal_subst: [r: { r | r << s}, t: term -> { b: bool | b = (t = parsubst(mapping)(r)) }]):
%     RECURSIVE { b: bool | b = every(LAMBDA (r, t): t = parsubst(mapping)(r))(ss) } =
%     CASES ss OF
%       null: TRUE,
%       cons(h, t):
%         equal_subst(h`1, h`2) AND equal_subst_aux(s, t, mapping, equal_subst)
%     ENDCASES
%   MEASURE length(ss)

%   equal_subst(s, t: term, mapping: [nat -> term]):
%     RECURSIVE { b: bool | b = (t = parsubst(mapping)(s)) } =
%     CASES s OF
%       v(i): mapping(i) = t,
%       apply(f, args):
%         CASES t OF
% 	  v(i): FALSE,
% 	  apply(g, args2):
% 	    f = g AND equal_subst_aux(s, zip(args, args(t)), mapping, LAMBDA (r | r << s), t: equal_subst(r, t, mapping))
% 	ENDCASES
%     ENDCASES
%   MEASURE s BY <<

% END fmla

% % % % Need to assert that t has no freevars outside vars, and vars is a set.
% % % % If s is a function app with f=u, then substitute in t the variables vars 
% % % % with the call parameters in ss in witch we substitute recursively
% % % % (u ss1..ssN) -> [ss/vars]t (fsubst in each ss recursively)

% % % fmla_equal(A, B, (A_vars, B_vars: list[(var?)])): RECURSIVE bool =
% % %   CASES A OF
% % %     atom(p, ss): (atom?(B) AND pred(B) = p AND
% % %                   reduce2(TRUE,
% % % 		          LAMBDA s, t, (b:bool):
% % % 			    b AND term_equal(s, t, A_vars, B_vars),
% % % 			  ss, args(B))),
% % %     f_not(A1): (f_not?(B) AND fmla_equal(A1, arg(B), A_vars, B_vars)),
% % %     f_or(A1, A2): (f_or?(B) AND fmla_equal(A1, arg1(B), A_vars, B_vars) AND
% % %                    fmla_equal(A2, arg2(B), A_vars, B_vars)), 
% % %     f_exists(y, A1): (f_exists?(B) AND
% % %                      fmla_equal(A1, body(B),
% % % 		                cons(y, A_vars),
% % % 				cons(bvar(B), B_vars)))
% % %   ENDCASES
% % %   MEASURE A BY <<

% % % usymb?(pf: funpred): bool =
% % %   (upred?(pf) OR ufun?(pf))

% % % freesymbols(s): RECURSIVE list[(ufun?)] =
% % %   CASES s OF
% % %     v(i): null,
% % %     apply(f, ss): IF ufun?(f) THEN (: f :)
% % %                     ELSE reduce(null,
% % % 		                (LAMBDA (t | t << s), (vv: list[(ufun?)]):
% % % 				   append(freesymbols(t), vv)))(ss)
% % %                   ENDIF
% % %   ENDCASES
% % %   Measure s BY <<

% % % freesymbols(ss): RECURSIVE list[(ufun?)] =
% % %    CASES ss OF
% % %      null: null,
% % %      cons(s, tt): append(freesymbols(s), freesymbols(tt))
% % %    ENDCASES
% % %    MEASURE length(ss)
  

% % % freesymbols(A): RECURSIVE list[(usymb?)] =
% % %   CASES A OF
% % %     atom(p, ss): freesymbols(ss),
% % %     f_not(B): freesymbols(B),
% % %     f_or(B, C): append(freesymbols(B), freesymbols(C)),
% % %     f_exists(x, B): freesymbols(B)
% % %   ENDCASES
% % %   MEASURE A BY <<

% % % freesymbols(AA): RECURSIVE list[(usymb?)] =
% % %   CASES AA OF
% % %     null: null,
% % %     cons(A, BB): append(freesymbols(A), freesymbols(BB))
% % %   ENDCASES
% % %   MEASURE length(AA)

% % %   sentence_list_cons:  LEMMA
% % %     FORALL (A, AA):
% % %     sentence?(A) & sentence_list?(AA) <=> sentence_list?(cons(A, AA))

% % %   sentence_list_append:  LEMMA
% % %     FORALL (AA, BB):
% % %     sentence_list?(AA) & sentence_list?(BB) <=>sentence_list?(append(AA, BB))

% % %   freevars_append:  LEMMA
% % %     FORALL (AA, BB):
% % %     append(freevars(AA), freevars(BB)) = freevars(append(AA, BB))
% % END fmla

  
