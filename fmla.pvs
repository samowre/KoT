funpred: DATATYPE WITH SUBTYPES pred?, fun?
BEGIN
  ipred(index, arity: nat): ipred? : pred?
  upred(index, arity: nat): upred? : pred?
  ifun(index, arity: nat): ifun?   : fun?
  ufun(index, arity: nat): ufun?   : fun?
END funpred

term: DATATYPE
BEGIN
  IMPORTING funpred
  v(index: nat): var?
%  apply(fun: (fun?), args: { l: finseq[term] | l`length = arity(fun) }): apply?
  apply(fun: (fun?), args: { l: list[term] | length(l) = arity(fun) }): apply?
END term

fmla: THEORY
BEGIN
  IMPORTING term
  IMPORTING more_list_props
  IMPORTING list2_props

  r, s, t: VAR term
  rs, ss, ts: VAR list[term]
  n: VAR nat
  ns: VAR list[nat]
  l: VAR list[nat]

  %% Computation of the variables present in a term
  % nats(t) is the type of lists containing the indices of the variables present in term t
  nats(t): TYPE = { l | FORALL n: member(n, l) IFF subterm(v(n), t) }

  aux(s: term,
      (ts: list[term] | every(LAMBDA r: r << s)(ts)),
      tnats: [t: { t | t << s } -> nats(t) ]):
    RECURSIVE { l | FORALL n: member(n, l) IFF EXISTS (r | member(r, ts)): subterm(v(n), r) } =
    CASES ts OF
      null: null,
      cons(h, t): append(tnats(h), aux(s, t, tnats))
    ENDCASES
  MEASURE length(ts)

  vars(t): RECURSIVE nats(t) =
    CASES t OF
      v(n): (: n :),
      apply(f, args): aux(t, args, vars)
    ENDCASES
  MEASURE t BY <<
  AUTO_REWRITE- vars

  % Variables of a list of terms
  vars(ts): RECURSIVE list[nat] =
    CASES ts OF
      null: null,
      cons(h, t): append(vars(h), vars(t))
    ENDCASES
  MEASURE length(ts)

  vars_subterm: THEOREM member(n, vars(s)) IFF subterm(v(n), s)

  %% Parallel substitution
  parsubst_aux(s: term,
               (ts: list[term] | every(LAMBDA r: r << s)(ts)),
	       parsubst: [{ t | t << s } -> term]):
    RECURSIVE { l: list[term] | length(l) = length(ts) AND FORALL (i: below(length(ts))): nth(l, i) = parsubst(nth(ts, i)) } =
    CASES ts OF
      null: null,
      cons(h, t): cons(parsubst(h), parsubst_aux(s, t, parsubst))
    ENDCASES
  MEASURE length(ts)

  parsubst(mapping: [nat -> term])(s): RECURSIVE term =
    CASES s OF
      v(i): mapping(i),
      apply(f, args): apply(f, parsubst_aux(s, args, LAMBDA (r | r << s): parsubst(mapping)(r)))
    ENDCASES
  MEASURE s BY <<

  parsubst(s: term, mapping: list[[nat, term]]): term =
    parsubst(LAMBDA (i: nat): assoc(i, mapping, v(i)))(s)

  % Single substitution (as a shortcut)
  subst(s, n, t): term =
    parsubst(LAMBDA (i: nat): IF i = n THEN t ELSE v(i) ENDIF)(s)

  equal_subst_aux(s: term,
                  (ss: list[[term, term]] | every(LAMBDA (r, t): r << s)(ss)),
		  mapping: [nat -> term],
                  equal_subst: [r: { r | r << s}, t: term -> { b: bool | b = (t = parsubst(mapping)(r)) }]):
    RECURSIVE { b: bool | b = every(LAMBDA (r, t): t = parsubst(mapping)(r))(ss) } =
    CASES ss OF
      null: TRUE,
      cons(h, t):
        equal_subst(h`1, h`2) AND equal_subst_aux(s, t, mapping, equal_subst)
    ENDCASES
  MEASURE length(ss)

  equal_subst(s, t: term, mapping: [nat -> term]):
    RECURSIVE { b: bool | b = (t = parsubst(mapping)(s)) } =
    CASES s OF
      v(i): mapping(i) = t,
      apply(f, args):
        CASES t OF
	  v(i): FALSE,
	  apply(g, args2):
	    f = g AND equal_subst_aux(s, zip(args, args(t)), mapping, LAMBDA (r | r << s), t: equal_subst(r, t, mapping))
	ENDCASES
    ENDCASES
  MEASURE s BY <<

  %% Formulae
  fmla: DATATYPE
  BEGIN
    atom(pred: (pred?), args: { l: list[term] | length(l) = arity(pred) }): atom?
    f_not(arg: fmla): f_not?
    f_or(larg, rarg: fmla): f_or?
    f_exists(bvar: nat, body: fmla): f_exists?
  END fmla

  f, g: VAR fmla

  ;¬(f): fmla    = IF f_not?(f) THEN arg(f) ELSE f_not(f) ENDIF
  ;⋁(f, g): fmla = f_or(f, g)
  ;⋀(f, g): fmla = ¬(¬f ⋁ ¬g)
  ;⇒(f, g): fmla = ¬f ⋁ ¬g
  ;⇔(f, g): fmla = (f ⇒ g) ⋁ (g ⇒ f)
  ;◇(n)(f): fmla = f_exists(n, f)
  ;◇(ns)(f): RECURSIVE fmla =
    CASES ns OF
      null: f,
      cons(n, t): f_exists(n, (◇t)(f))
    ENDCASES
  MEASURE length(ns)
  ;□(n)(f): fmla  = ¬(◇n)(f)
  ;□(ns)(f): fmla = ¬(◇ns)(f)

  %% Free variables in a formula
  freevars(f): RECURSIVE list[nat] =
    CASES f OF
      atom(p, args): vars(args),
      f_not(f): freevars(f),
      f_or(f, g): append(freevars(f), freevars(g)),
      f_exists(n, f): remove(n, freevars(f))
    ENDCASES
  MEASURE f BY <<

  sentence?(f): bool = null?(freevars(f))

  vars(f): RECURSIVE list[nat] =
    CASES f OF
      atom(p, args): vars(args),
      f_not(f): vars(f),
      f_or(f, g): append(vars(f), vars(g)),
      f_exists(n, f): vars(f)
    ENDCASES
  MEASURE f BY <<

  boundvars(f): RECURSIVE list[nat] =
    CASES f OF
      atom(p, args): null,
      f_not(f): boundvars(f),
      f_or(f, g): append(boundvars(f), boundvars(g)),
      f_exists(n, f): cons(n, boundvars(f))
    ENDCASES
  MEASURE f BY <<

  % Are variables ns free in term f?
  freefor(f, ns): RECURSIVE bool =
    CASES f OF
      atom(p, args): TRUE,
      f_not(f): freefor(f, ns),
      f_or(f, g): freefor(f, ns) AND freefor(g, ns),
      f_exists(n, f): NOT member(n, ns) AND freefor(f, ns)
    ENDCASES
  MEASURE f BY <<

  freefor(f, n): bool = freefor(f, (: n :))

  % freefor characterisations
  freefor_forall: THEOREM freefor(f, ns) IFF FORALL (n | member(n, ns)): freefor(f, n)
  freefor_boundvars: THEOREM freefor(f, n) IFF NOT member(n, boundvars(f))
END fmla

% fmla theory introduces the datatypes for the pre-terms and pre-formulas
% fmla: THEORY
% BEGIN

% % funpred is a combined datatype for interpreted/uninterpreted function and
% % predicate symbols. 

%   IMPORTING funpred, more_list_props, list_suffixes, list_map_props, concat_map
%   IMPORTING preterm

%   % term is the pre-term datatype with variables and compound terms

% % subst(A, x, (t | freefor(A, termvars(t)))): RECURSIVE fmla =
% %   CASES A OF
% %     atom(p, ss): atom(p, subst(ss, x, t)),
% %     f_not(B): f_not(subst(B, x, t)),
% %     f_or(B, C): f_or(subst(B, x, t), subst(C, x, t)), 
% %     f_exists(y, B): (IF x = y THEN A
% %                      ELSE f_exists(y, subst(B, x, t))
% % 		     ENDIF)
% %   ENDCASES
% %   MEASURE A BY <<
  
% % max_index(xx): nat =
% %   (IF cons?(xx) THEN v_index(maxlist(xx, (LAMBDA x: v_index(x))))
% %    ELSE 0 ENDIF)

% % M: VAR nat

% % %used to prove TCCs of parsubstr
% % ub_max_index: LEMMA
% % 	      (FORALL (x: (var?) | member(x, xx)): v_index(x) <= M) <=> max_index(xx) <= M

% % % using max_index(termvars(tt)) to eliminate obligation cons?(termvars(tt))
% % parsubstr(A, xx	, tt, (m: nat | max_index(termvars(tt)) <= m)):
% %   RECURSIVE fmla =
% %   CASES A OF
% %     atom(p, ss): atom(p, map(LAMBDA s: parsubst(s, xx, tt))(ss)),
% %     f_not(B): f_not(parsubstr(B, xx, tt, m)),
% %     f_or(B, C): f_or(parsubstr(B, xx, tt, m), parsubstr(C, xx, tt, m)),
% %     f_exists(y, B): (IF member(y, termvars(tt))
% %                       THEN f_exists(v(m+1),
% % 		                     parsubstr(B, cons(y, xx),
% % 				                 cons(v(m+1), tt), m+1))
% % 	              ELSE f_exists(y, parsubstr(B, cons(y, xx),
% % 		      	   	       	%max(m, v_index(y)) to satisfy the condition on m
% % 				                  cons(y, tt), max(m, v_index(y))))
% % 	             ENDIF)
% %   ENDCASES
% %   MEASURE A BY <<

% % % replaces variables in xx with the terms in tt in formula A
% % parsubst(A, xx, tt):  fmla =
% %   parsubstr(A, xx, tt, max_index(termvars(tt)))

  
% % % Need to assert that t has no freevars outside vars, and vars is a set.
% % % If s is a function app with f=u, then substitute in t the variables vars 
% % % with the call parameters in ss in witch we substitute recursively
% % % (u ss1..ssN) -> [ss/vars]t (fsubst in each ss recursively)
% % fsubst(s, (u : (ufun?)), vars: list[(var?)], t): RECURSIVE term =
% %   CASES s OF
% %     v(i): s,
% %     apply(f, ss): (IF f = u
% %                     THEN parsubst(t, vars,
% % 		                     map(LAMBDA (r: term | r <<s):
% % 				        fsubst(r, u, vars, t))(ss))
% %                     ELSE apply(f, map(LAMBDA (r: term | r <<s):
% % 					       fsubst(r, u, vars, t))(ss))
% %                    ENDIF)
% %    ENDCASES
% %    MEASURE s BY <<

% % % Simple recursion on formula structure
% % fsubst(A, (u : (ufun?)), vars: list[(var?)], t): RECURSIVE fmla =
% %   CASES A OF
% %     atom(p, ss): atom(p, map(LAMBDA s: fsubst(s, u, vars, t))(ss)),
% %     f_not(A1): f_not(fsubst(A1, u, vars, t)),
% %     f_or(A1, A2): f_or(fsubst(A1, u, vars, t), fsubst(A2, u, vars, t)), 
% %     f_exists(y, A1): f_exists(y, fsubst(A1, u, vars, t))
% %   ENDCASES
% %   MEASURE A BY <<
 
% % % If A is the predicate u with vars, we substitute in B vars with ss
% % psubst(A, (u : (upred?)), vars: list[(var?)], B): RECURSIVE fmla =
% %   CASES A OF
% %     atom(p, ss): IF p = u
% %                   THEN parsubst(B, vars, ss)
% % 		  ELSE A
% % 		  ENDIF,
% %     f_not(A1): f_not(psubst(A1, u, vars, B)),
% %     f_or(A1, A2): f_or(psubst(A1, u, vars, B), psubst(A2, u, vars, B)), 
% %     f_exists(y, A1): f_exists(y, psubst(A1, u, vars, B))
% %   ENDCASES
% %   MEASURE A BY <<
   

% % fmla_equal(A, B, (A_vars, B_vars: list[(var?)])): RECURSIVE bool =
% %   CASES A OF
% %     atom(p, ss): (atom?(B) AND pred(B) = p AND
% %                   reduce2(TRUE,
% % 		          LAMBDA s, t, (b:bool):
% % 			    b AND term_equal(s, t, A_vars, B_vars),
% % 			  ss, args(B))),
% %     f_not(A1): (f_not?(B) AND fmla_equal(A1, arg(B), A_vars, B_vars)),
% %     f_or(A1, A2): (f_or?(B) AND fmla_equal(A1, arg1(B), A_vars, B_vars) AND
% %                    fmla_equal(A2, arg2(B), A_vars, B_vars)), 
% %     f_exists(y, A1): (f_exists?(B) AND
% %                      fmla_equal(A1, body(B),
% % 		                cons(y, A_vars),
% % 				cons(bvar(B), B_vars)))
% %   ENDCASES
% %   MEASURE A BY <<


% % freevars(AA): RECURSIVE list[(var?)] =
% %   CASES AA OF
% %    null: null,
% %    cons(A, BB): append(freevars(A), freevars(BB))
% %   ENDCASES
% %   MEASURE length(AA)

% % sentence_list?(AA): bool = null?(freevars(AA))


% % usymb?(pf: funpred): bool =
% %   (upred?(pf) OR ufun?(pf))

% % freesymbols(s): RECURSIVE list[(ufun?)] =
% %   CASES s OF
% %     v(i): null,
% %     apply(f, ss): IF ufun?(f) THEN (: f :)
% %                     ELSE reduce(null,
% % 		                (LAMBDA (t | t << s), (vv: list[(ufun?)]):
% % 				   append(freesymbols(t), vv)))(ss)
% %                   ENDIF
% %   ENDCASES
% %   Measure s BY <<

% % freesymbols(ss): RECURSIVE list[(ufun?)] =
% %    CASES ss OF
% %      null: null,
% %      cons(s, tt): append(freesymbols(s), freesymbols(tt))
% %    ENDCASES
% %    MEASURE length(ss)
  

% % freesymbols(A): RECURSIVE list[(usymb?)] =
% %   CASES A OF
% %     atom(p, ss): freesymbols(ss),
% %     f_not(B): freesymbols(B),
% %     f_or(B, C): append(freesymbols(B), freesymbols(C)),
% %     f_exists(x, B): freesymbols(B)
% %   ENDCASES
% %   MEASURE A BY <<

% % freesymbols(AA): RECURSIVE list[(usymb?)] =
% %   CASES AA OF
% %     null: null,
% %     cons(A, BB): append(freesymbols(A), freesymbols(BB))
% %   ENDCASES
% %   MEASURE length(AA)

% %   sentence_list_cons:  LEMMA
% %     FORALL (A, AA):
% %     sentence?(A) & sentence_list?(AA) <=> sentence_list?(cons(A, AA))

% %   sentence_list_append:  LEMMA
% %     FORALL (AA, BB):
% %     sentence_list?(AA) & sentence_list?(BB) <=>sentence_list?(append(AA, BB))

% %   freevars_append:  LEMMA
% %     FORALL (AA, BB):
% %     append(freevars(AA), freevars(BB)) = freevars(append(AA, BB))
% END fmla

  
