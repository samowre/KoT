funpred: DATATYPE WITH SUBTYPES pred?, fun?
BEGIN
  ipred(index, arity: nat): ipred? : pred?
  upred(index, arity: nat): upred? : pred?
  ifun(index, arity: nat): ifun?   : fun?
  ufun(index, arity: nat): ufun?   : fun?
END funpred

term: DATATYPE
BEGIN
  IMPORTING funpred
  v(index: nat): var?
  apply(fun: (fun?), args: { l: finseq[term] | l`length = arity(fun) }): apply?
END term

%% Formulae
fmla: DATATYPE
BEGIN
  IMPORTING term
  atom(pred: (pred?), args: { l: finseq[term] | l`length = arity(pred) }): atom?
  f_not(arg: fmla): f_not?
  f_or(larg, rarg: fmla): f_or?
  f_exists(bvar: nat, body: fmla): f_exists?
END fmla

smap[S: TYPE, T: TYPE]: THEORY
BEGIN
  smap(f: [S -> T])(s: finseq[S]): { r: finseq[T] | r`length = s`length }  =
    (# length := s`length,
       seq := LAMBDA (x: below(s`length)): f(s`seq(x)) #)
END smap

term_props: THEORY
BEGIN
  IMPORTING term
  IMPORTING more_list_props
  IMPORTING list2_props
  IMPORTING smap

  s, t: VAR term
  ss, ts: VAR set[term]
  i, n: VAR nat
  is, ns: VAR set[nat]
  
  % Variables of a term
  vars(t): RECURSIVE set[nat] =
    CASES t OF
      v(n): singleton(n),
      apply(f, args): { n | EXISTS (i: below(args`length)): member(n, vars(args(i))) }
    ENDCASES
  MEASURE t BY <<

  vars_subterm: THEOREM member(n, vars(t)) IFF subterm(v(n), t)

  % Variables of a set of terms
  vars(ts): set[nat] =
    { n | EXISTS (t | member(t, ts)): member(n, vars(t)) }
    
  % Parallel substitution with a functional mapping
  parsubst(s: term, mapping: [nat -> term]): RECURSIVE term =
    CASES s OF
      v(i): mapping(i),
      apply(f, args): apply(f, smap(LAMBDA (t | t << s): parsubst(t, mapping))(args))
    ENDCASES
  MEASURE s BY <<

  % Parallel substitution with an association list
  parsubst(s: term, mapping: list[[nat, term]]): term =
    parsubst(s, LAMBDA i: assoc(i, mapping, v(i)))

  % Single substitution
  subst(s, n, t): term =
    parsubst(s, (: (n, t) :))

  fsubst(s, (u: (ufun?)), (vars: (uniques?[nat]) | length(vars) = arity(u)), t):
    RECURSIVE term =
    CASES s OF
      v(i): s,
      apply(f, args):
        LET nargs = smap(LAMBDA (r: term | r << s): fsubst(r, u, vars, t))(args) IN
	IF f = u
	  THEN parsubst(t, zipi[nat, term](vars, nargs))
	  ELSE apply(f, nargs)
	ENDIF
    ENDCASES
  MEASURE s BY <<
END term_props

fmla_props: THEORY
BEGIN
  IMPORTING term
  IMPORTING fmla
  IMPORTING term_props

  s, t: VAR term
  ss, ts: VAR set[term]
  f, g: VAR fmla
  fs, gs: VAR set[fmla]
  i, n: VAR nat
  is, ns: VAR set[nat]
  li, ln: VAR list[nat]

  ;¬(f): fmla    = IF f_not?(f) THEN arg(f) ELSE f_not(f) ENDIF
  ;∨(f, g): fmla = f_or(f, g)
  ;∧(f, g): fmla = ¬(¬f ∨ ¬g)
  ;⇒(f, g): fmla = ¬f ∨ ¬g
  ;⇔(f, g): fmla = (f ⇒ g) ∨ (g ⇒ f)
  ;◇(n)(f): fmla = f_exists(n, f)
  ;◇(ln)(f): RECURSIVE fmla =
    CASES ln OF
      null: f,
      cons(n, t): f_exists(n, (◇t)(f))
    ENDCASES
  MEASURE length(ln)
  ;□(n)(f): fmla  = ¬(◇n)(f)
  ;□(ln)(f): fmla = ¬(◇ln)(f)

  % Free variables of a formula
  freevars(f): RECURSIVE set[nat] =
    CASES f OF
      atom(p, args): vars({ t | EXISTS (i: below(args`length)): t = args(i) }),
      f_not(g): freevars(g),
      f_or(g, h): union(freevars(g), freevars(h)),
      f_exists(n, b): remove(n, freevars(b))
    ENDCASES
  MEASURE f BY <<

  sentence?(f): bool = empty?(freevars(f))

  freevars(fs): set[nat] =
    { n | EXISTS (f | member(f, fs)): member(n, freevars(f)) }

  boundvars(f): RECURSIVE set[nat] =
    CASES f OF
      atom(p, args): emptyset,
      f_not(g): boundvars(g),
      f_or(g, h): union(boundvars(g), boundvars(h)),
      f_exists(n, b): add(n, boundvars(b))
    ENDCASES
  MEASURE f BY <<

  boundvars(fs): set[nat] =
    { n | EXISTS (f | member(f, fs)): member(n, boundvars(f)) }

  % Checks whether the variables in ns are not bound in formula f
  freefor(f, ns): bool =
    empty?(intersection(ns, boundvars(f)))

  freefor(f, t): MACRO bool =
    freefor(f, vars(t))

  freefor(f, g): MACRO bool =
    freefor(f, freevars(g))

  parsubst(f: fmla, mapping: [n: nat -> { t | t = v(n) OR freefor(f, t) }]):
    RECURSIVE fmla =
    CASES f OF
      atom(p, args): atom(p, smap(LAMBDA t: parsubst(t, mapping))(args)),
      f_not(g): f_not(parsubst(g, mapping)),
      f_or(g, h): f_or(parsubst(g, mapping), parsubst(h, mapping)),
      f_exists(n, b): f_exists(n, parsubst(b, mapping))
    ENDCASES
  MEASURE f BY <<

  parsubst(f: fmla, mapping: list[[nat, { t | freefor(f, t) }]]): fmla =
    parsubst(f, LAMBDA i: assoc[nat, { t | t = v(i) OR freefor(f, t) }](i, mapping, v(i)))

  subst(f, n, (t | freefor(f, t))): fmla =
    parsubst(f, (: (n, t) :))

  fsubst(f,
         (u: (ufun?)),
	 (vars: (uniques?[nat]) | length(vars) = arity(u)),
	 (t | freefor(f, t))):
    RECURSIVE fmla =
    CASES f OF
      atom(p, args): atom(p, smap(LAMBDA s: fsubst(s, u, vars, t))(args)),
      f_not(g): f_not(fsubst(g, u, vars, t)),
      f_or(g, h): f_or(fsubst(g, u, vars, t), fsubst(h, u, vars, t)),
      f_exists(n, b): f_exists(n, fsubst(b, u, vars, t))
    ENDCASES
  MEASURE f BY <<

  psubst(f,
         (u: (upred?)),
	 (vars: (uniques?[nat]) | length(vars) = arity(u)),
	 (g | freefor(f, g))):
    RECURSIVE fmla =
    CASES f OF
      atom(p, args):
        IF p = u
	  THEN parsubst(g, zip(vars, args))
	  ELSE f
	ENDIF,
      f_not(h): f_not(psubst(h, u, vars, g)),
      f_or(l, r): f_or(psubst(l, u, vars, g), psubst(r, u, vars, g)),
      f_exists(n, b): f_exists(n, psubst(b, u, vars, g))
    ENDCASES
  MEASURE f BY <<
END fmla_props

%   equal_subst_aux(s: term,
%                   (ss: list[[term, term]] | every(LAMBDA (r, t): r << s)(ss)),
% 		  mapping: [nat -> term],
%                   equal_subst: [r: { r | r << s}, t: term -> { b: bool | b = (t = parsubst(mapping)(r)) }]):
%     RECURSIVE { b: bool | b = every(LAMBDA (r, t): t = parsubst(mapping)(r))(ss) } =
%     CASES ss OF
%       null: TRUE,
%       cons(h, t):
%         equal_subst(h`1, h`2) AND equal_subst_aux(s, t, mapping, equal_subst)
%     ENDCASES
%   MEASURE length(ss)

%   equal_subst(s, t: term, mapping: [nat -> term]):
%     RECURSIVE { b: bool | b = (t = parsubst(mapping)(s)) } =
%     CASES s OF
%       v(i): mapping(i) = t,
%       apply(f, args):
%         CASES t OF
% 	  v(i): FALSE,
% 	  apply(g, args2):
% 	    f = g AND equal_subst_aux(s, zip(args, args(t)), mapping, LAMBDA (r | r << s), t: equal_subst(r, t, mapping))
% 	ENDCASES
%     ENDCASES
%   MEASURE s BY <<

% END fmla

% % fmla theory introduces the datatypes for the pre-terms and pre-formulas
% % fmla: THEORY
% % BEGIN

% % % funpred is a combined datatype for interpreted/uninterpreted function and
% % % predicate symbols. 

% %   IMPORTING funpred, more_list_props, list_suffixes, list_map_props, concat_map
% %   IMPORTING preterm

% %   % term is the pre-term datatype with variables and compound terms

% % % % Need to assert that t has no freevars outside vars, and vars is a set.
% % % % If s is a function app with f=u, then substitute in t the variables vars 
% % % % with the call parameters in ss in witch we substitute recursively
% % % % (u ss1..ssN) -> [ss/vars]t (fsubst in each ss recursively)
% % % fsubst(s, (u : (ufun?)), vars: list[(var?)], t): RECURSIVE term =
% % %   CASES s OF
% % %     v(i): s,
% % %     apply(f, ss): (IF f = u
% % %                     THEN parsubst(t, vars,
% % % 		                     map(LAMBDA (r: term | r <<s):
% % % 				        fsubst(r, u, vars, t))(ss))
% % %                     ELSE apply(f, map(LAMBDA (r: term | r <<s):
% % % 					       fsubst(r, u, vars, t))(ss))
% % %                    ENDIF)
% % %    ENDCASES
% % %    MEASURE s BY <<

% % % % If A is the predicate u with vars, we substitute in B vars with ss
% % % psubst(A, (u : (upred?)), vars: list[(var?)], B): RECURSIVE fmla =
% % %   CASES A OF
% % %     atom(p, ss): IF p = u
% % %                   THEN parsubst(B, vars, ss)
% % % 		  ELSE A
% % % 		  ENDIF,
% % %     f_not(A1): f_not(psubst(A1, u, vars, B)),
% % %     f_or(A1, A2): f_or(psubst(A1, u, vars, B), psubst(A2, u, vars, B)), 
% % %     f_exists(y, A1): f_exists(y, psubst(A1, u, vars, B))
% % %   ENDCASES
% % %   MEASURE A BY <<
   

% % % fmla_equal(A, B, (A_vars, B_vars: list[(var?)])): RECURSIVE bool =
% % %   CASES A OF
% % %     atom(p, ss): (atom?(B) AND pred(B) = p AND
% % %                   reduce2(TRUE,
% % % 		          LAMBDA s, t, (b:bool):
% % % 			    b AND term_equal(s, t, A_vars, B_vars),
% % % 			  ss, args(B))),
% % %     f_not(A1): (f_not?(B) AND fmla_equal(A1, arg(B), A_vars, B_vars)),
% % %     f_or(A1, A2): (f_or?(B) AND fmla_equal(A1, arg1(B), A_vars, B_vars) AND
% % %                    fmla_equal(A2, arg2(B), A_vars, B_vars)), 
% % %     f_exists(y, A1): (f_exists?(B) AND
% % %                      fmla_equal(A1, body(B),
% % % 		                cons(y, A_vars),
% % % 				cons(bvar(B), B_vars)))
% % %   ENDCASES
% % %   MEASURE A BY <<

% % % usymb?(pf: funpred): bool =
% % %   (upred?(pf) OR ufun?(pf))

% % % freesymbols(s): RECURSIVE list[(ufun?)] =
% % %   CASES s OF
% % %     v(i): null,
% % %     apply(f, ss): IF ufun?(f) THEN (: f :)
% % %                     ELSE reduce(null,
% % % 		                (LAMBDA (t | t << s), (vv: list[(ufun?)]):
% % % 				   append(freesymbols(t), vv)))(ss)
% % %                   ENDIF
% % %   ENDCASES
% % %   Measure s BY <<

% % % freesymbols(ss): RECURSIVE list[(ufun?)] =
% % %    CASES ss OF
% % %      null: null,
% % %      cons(s, tt): append(freesymbols(s), freesymbols(tt))
% % %    ENDCASES
% % %    MEASURE length(ss)
  

% % % freesymbols(A): RECURSIVE list[(usymb?)] =
% % %   CASES A OF
% % %     atom(p, ss): freesymbols(ss),
% % %     f_not(B): freesymbols(B),
% % %     f_or(B, C): append(freesymbols(B), freesymbols(C)),
% % %     f_exists(x, B): freesymbols(B)
% % %   ENDCASES
% % %   MEASURE A BY <<

% % % freesymbols(AA): RECURSIVE list[(usymb?)] =
% % %   CASES AA OF
% % %     null: null,
% % %     cons(A, BB): append(freesymbols(A), freesymbols(BB))
% % %   ENDCASES
% % %   MEASURE length(AA)

% % %   sentence_list_cons:  LEMMA
% % %     FORALL (A, AA):
% % %     sentence?(A) & sentence_list?(AA) <=> sentence_list?(cons(A, AA))

% % %   sentence_list_append:  LEMMA
% % %     FORALL (AA, BB):
% % %     sentence_list?(AA) & sentence_list?(BB) <=>sentence_list?(append(AA, BB))

% % %   freevars_append:  LEMMA
% % %     FORALL (AA, BB):
% % %     append(freevars(AA), freevars(BB)) = freevars(append(AA, BB))
% % END fmla

  
