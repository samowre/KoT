trace_checker[m, n: nat, i : upto(n)] : THEORY

  BEGIN

    IMPORTING minlist
    IMPORTING fmla
    IMPORTING rule
    IMPORTING proof
    IMPORTING trace2fmla
    IMPORTING resolution
    IMPORTING trace_resolution[m, n, i]

    tp, tq: VAR (ne_tr_clause?)
    pivot: VAR (trace_resolution[m,n,i].tr_literal?)
    RR : VAR ne_proof_seq
    
    clAA, clBB, clCC : VAR (clause?)
    nclAA, nclBB : VAR (nclause?)
    lA, lB, lC: VAR (literal?)

    pivot?(lA, clAA, clBB):bool = prop_atom?(lA) AND member(lA, clAA) AND member(f_not(lA), clBB)

    prop_resolve(lA, clAA, clBB): bool = 
      FORALL lB: 
        member(lB, clAA) AND 
	lB /= lA <=> member(lB, clBB)

 %    cons(f_not(delta), cons(f_not(p), cons(gamma, cons(delta, null)))) %&
 %    cons(f_not(f_not(p)), , cons(f_not(p), cons(gamma, cons(delta, null))))
 %    cons(f_not(f_or(f_not(p), delta)), cons(f_not(p), cons(gamma, cons(delta, null)))) % subset
 %   cons(f_not(p), cons(f_not(f_or(f_not(p), delta)), cons(gamma, cons(delta, null)))) & 
 %    cons(f_not(gamma), cons(f_not(f_or(f_not(p), delta)), cons(gamma, cons(delta, null)))) % consider second done(ax) - nor
 %    cons(f_not(f_or(p, gamma)), cons(f_not(f_or(f_not(p), delta)), cons(gamma, cons(delta, null)))) % subset
 %    cons(gamma, cons(delta, cons (f_not(f_or(p, gamma)), cons(f_not(f_or(f_not(p), delta)), null)))) %or
 %    cons(f_or(gamma, delta), cons (f_not(f_or(p, gamma)), cons(f_not(f_or(f_not(p), delta)), null))) %subset
 %    conclusion(RR)= cons(f_not(f_or(p, gamma)), cons(f_not(f_or(f_not(p), delta)), cons(f_or(gamma, delta), null)))
%	 AND checkProof(empty_seq)(RR))
  
   p, q, gamma, delta : VAR (sentence?)

   build_proof_th0(p, gamma, delta): ne_proof_seq = 

     LET ax3 = RR_lemma1(
     	         delta, 
		 cons(f_not(p), 
		  cons(gamma, 
		   cons(delta, 
		    null)))) IN
     % |- ~delta, ~p, gamma, delta

     LET ax2 = RR_lemma1(
     	         f_not(p), 
		 cons(f_not(p), 
		  cons(gamma, 
		   cons(delta, 
		    null)))) IN
     % |- ~~p, ~p, gamma, delta

     LET nor2 = RR_norr(
     	      	  f_not(p), 
		  delta,  
		  cons(f_not(p), 
		   cons(gamma, 
		    cons(delta, 
		     null))), 
		  ax2, 
		  ax3) IN
     % |- ~(~p \/ delta), ~p, gamma, delta

     LET ss3 = RR_subsetr(
		 cons(f_not(f_or(f_not(p), delta)), 
		  cons(f_not(p), 
		   cons(gamma, 
		    cons(delta, 
		     null)))), 
     	         cons(f_not(p), 
		  cons(f_not(f_or(f_not(p), delta)), 
		   cons(gamma, 
		    cons(delta, 
		     null)))), 
		 nor2) IN
     % |- ~p, ~(~p \/ delta), gamma, delta

     LET ax1 = RR_lemma1(
     	         gamma, 
		 cons(f_not(f_or(f_not(p), delta)), 
		  cons(gamma, 
		   cons(delta, 
		    null)))) IN
     % |- ~gamma, ~(~p \/ delta), gamma, delta

     LET nor1 = RR_norr(
     	      	  p, 
		  gamma, 
		  cons(f_not(f_or(f_not(p), delta)), 
		   cons(gamma, 
		    cons(delta, 
		     null))), 
		  ss3, 
		  ax1) IN
     % |- ~(p \/ gamma), ~(~p \/ delta), gamma, delta

     LET ss1 = RR_subsetr(
     	         cons (f_not(f_or(p, gamma)), 
		  cons(f_not(f_or(f_not(p), delta)),
		   cons(gamma, 
		    cons(delta, 
		     null)))), 
     	         cons(gamma, 
		  cons(delta, 
		   cons (f_not(f_or(p, gamma)), 
		    cons(f_not(f_or(f_not(p), delta)), 
		     null)))), 
		 nor1) IN
     % |- gamma, delta, ~(p \/ gamma), ~(~p \/ delta)

     LET or1 = RR_orr(
     	         gamma, 
		 delta, 
		 cons (f_not(f_or(p, gamma)), 
		  cons(f_not(f_or(f_not(p), delta)), 
		   null)), 
		 ss1) IN
     % |- (gamma \/ delta), ~(p \/ gamma), ~(~p \/ delta)

     LET ss2 = RR_subsetr(
     	         cons(f_or(gamma, delta), 
		  cons (f_not(f_or(p, gamma)), 
		   cons(f_not(f_or(f_not(p), delta)), 
		    null))),  
     	         cons(f_not(f_or(p, gamma)), 
		  cons(f_not(f_or(f_not(p), delta)), 
		   cons(f_or(gamma, delta), 
		    null))), 
		 or1) IN
     % |- ~(p \/ gamma), ~(~p \/ delta), (gamma \/ delta)
     ss2

  % |- ~(p \/ gamma), ~(~p \/ delta), (gamma \/ delta) 
  % is provable in KoT (not used)
  th0: THEOREM
    FORALL (p, gamma, delta):
    conclusion(build_proof_th0(p, gamma, delta)) = cons(f_not(f_or(p, gamma)), cons(f_not(f_or(f_not(p), delta)), cons(f_or(gamma, delta), null)))
      AND checkProof(empty_seq)(build_proof_th0(p, gamma, delta))
   

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % proof for one step resolution %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  ntcA, ntcB: VAR (ne_tr_clause?)
 
  cA, cB : VAR (clause?)

  
  proof_th(ntcA, ntcB): ne_proof_seq = 
    LET res = resolution(ntcA, ntcB) IN
    IF not_true_clauses(ntcA, ntcB) THEN
      IF exist_pivot?(ntcA, ntcB) 
      THEN RR_th2(
	 	translate_lit(find_pivot(ntcA, ntcB)),
		translate_clause(ntcA),
		translate_clause(ntcB),
		translate_clause(res))
		
      ELSE RR_th1(
		translate_clause(ntcA),
		append(
		 not_or_reduction(translate_clause(ntcB)),
		 translate_clause(res)))
      ENDIF
    ELSIF tr_clause_true?(ntcA) THEN
      LET pr1 = RR_th1(translate_clause(ntcB),
		append(
		 not_or_reduction(translate_clause(ntcA)),
		 translate_clause(res))) IN

      RR_subsetr(
        append(
	  not_or_reduction(translate_clause(ntcB)), 
	  append(
	    not_or_reduction(translate_clause(ntcA)), 
	    translate_clause(res))), 
        append(
	  not_or_reduction(translate_clause(ntcA)), 
	  append(
	    not_or_reduction(translate_clause(ntcB)), 
	    translate_clause(res))), 
	pr1)
    ELSE %tr_clause_true?(ntcB)
      RR_th1(
		translate_clause(ntcA),
		append(
		 not_or_reduction(translate_clause(ntcB)),
		 translate_clause(res)))
    ENDIF
    
  % |- ~translate(ntcA), ~translate(ntcB), translate(resolution(ntcA, ntcB))
  % is provable in KoT
  th: THEOREM  
      	conclusion(proof_th(ntcA, ntcB)) = 
	 append(
	  not_or_reduction(translate_clause(ntcA)), 
	  append(
	  	   not_or_reduction(translate_clause(ntcB)), 
	    translate_clause(resolution(ntcA, ntcB))))
	AND checkProof(empty_seq)(proof_th(ntcA, ntcB))

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % proof for chain resolution %
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  lntcA, lntcAA : VAR (cons?[(ne_tr_clause?)])

  not_or_map(lntcA): sequent = 
    map(f_not o nclause2fmla o translate_clause)(lntcA)


  proof_th_list(lntcA) : RECURSIVE ne_proof_seq = 
    IF null?(cdr(lntcA)) 
    THEN 
      % |- ~a, a
      LET tc = translate_clause(car(lntcA)) IN
      RR_th1(tc, tc)
    ELSE
      % res(p1, p2) 
      LET res = resolution(car(lntcA), car(cdr(lntcA))) IN
      IF null?(res) 
      THEN 
      ELSE
	LET cut_lit = nclause2fmla(translate_clause(res)) IN
      	% recursive proof for |- ~res(p1, p2), ~p3 .., res(res(p1, p2), p3 ...)
      	LET pr_rec = proof_th_list( cons(res, cdr(cdr(lntcA))) ) IN
      	% proof for |- ~p1, ~p2, res(p1, p2)
      	LET pr_step = RR_lemma2( append(not_or_reduction(translate_clause(car(lntcA))), not_or_reduction(translate_clause(car(cdr(lntcA))))), 
      	  	    	       translate_clause(res), 
			       proof_th(car(lntcA), car(cdr(lntcA)))) IN

          RR_cut(cut_lit, append(
	  	         not_or_map(lntcA), 
	   		  translate_clause(resolution_list(lntcA))), 
		       pr_step, pr_rec)  
    ENDIF
  MEASURE length(lntcA)


  th_list:  THEOREM
        conclusion(proof_th_list(lntcA)) = 
	 append(
	  not_or_map(lntcA), 
	   translate_clause(resolution_list(lntcA)))
	AND checkProof(empty_seq)(proof_th_list(lntcA))


  th_cert:  THEOREM
    
	
  END trace_checker
