map2[S1, S2, T: TYPE ]
		: THEORY

  BEGIN

    map2(f: [S1, S2 -> T], l1: list[S1], l2: list[S2]): RECURSIVE list[T] =
      CASES l1 OF
        null: null,
	cons(x, t1):
	  CASES l2 OF
	    null: null,
	    cons(y, t2): cons(f(x, y), map2(f, t1, t2))
	  ENDCASES
      ENDCASES
    MEASURE length(l1)

    reduce2(a: T, f: [S1, S2, T -> T], l1: list[S1], l2: list[S2]): RECURSIVE T =
      CASES l1 OF
        null: a,
	cons(x, t1):
	  CASES l2 OF
	    null: a,
	    cons(y, t2): f(x, y, reduce2(a, f, t1, t2))
	  ENDCASES
      ENDCASES
    MEASURE length(l1)

     f, g: VAR [S1 -> list[T]]

     h: VAR [S1 -> S1]

     a, b, c: VAR T
     A, B, C: VAR list[T]


     x: VAR S1

     IMPORTING minlist, lists
     kk: VAR list[S1]
     delete_reduce: LEMMA
       delete(a, reduce(null, LAMBDA x, A: append(f(x), A))(kk)) =
       reduce(null, LAMBDA x, A: append(delete(a, f(x)), A))(kk)
	    
     every_reduce: LEMMA
       every(LAMBDA x: f(x) = g(x))(kk) =>
       reduce(null, LAMBDA x, A: append(f(x), A))(kk) =
       reduce(null, LAMBDA x, A: append(g(x), A))(kk)

     reduce_map: LEMMA
       reduce(null, LAMBDA x, A: append(f(x), A))(map(h)(kk)) =
       reduce(null, LAMBDA x, A: append(f(h(x)), A))(kk)

       ll: VAR list[S1]
     every_forall: LEMMA
      (FORALL (p: [S1, T -> bool]):
        every(LAMBDA x: (FORALL a: p(x, a)))(ll) =
	(FORALL a: every(LAMBDA x: p(x, a))(ll)))

     map(f: [S1 -> T])(ss: finseq[S1]): finseq[T] =
       (# length := ss`length,
          seq := (LAMBDA (i: below(ss`length)): f(ss(i))) #)
       

  END map2


