(more_list_props
 (remove_TCC1 0
  (remove_TCC1-1 nil 3578150641 ("" (induct-and-simplify l) nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (pred type-eq-decl nil defined_types nil)
    (filter def-decl "list[T]" filters nil)
    (/= const-decl "boolean" notequal nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list_induction formula-decl nil list_adt nil))
   nil))
 (every_forall 0
  (every_forall-1 nil 3577636177
   ("" (induct-and-simplify l :if-match all) nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (some_exists 0
  (some_exists-1 nil 3577636393 ("" (induct-and-simplify l) nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (some adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (member_subset 0
  (member_subset-1 nil 3577708631
   ("" (grind :rewrites "every_forall") nil nil)
   ((subset? const-decl "bool" more_list_props nil)
    (every_forall formula-decl nil more_list_props nil)
    (member const-decl "bool" more_list_props nil))
   shostak))
 (subset_order 0
  (subset_order-1 nil 3577708818
   ("" (grind :rewrites "every_forall") nil nil)
   ((preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (subset? const-decl "bool" more_list_props nil)
    (every_forall formula-decl nil more_list_props nil)
    (member const-decl "bool" more_list_props nil)
    (T formal-type-decl nil more_list_props nil))
   shostak))
 (member_equal 0
  (member_equal-1 nil 3577708838
   ("" (auto-rewrite member_subset)
    (("" (grind :exclude subset?) nil nil)) nil)
   ((T formal-type-decl nil more_list_props nil)
    (member_subset formula-decl nil more_list_props nil)
    (equal? const-decl "bool" more_list_props nil))
   shostak))
 (equal_equiv 0
  (equal_equiv-1 nil 3577708854
   ("" (auto-rewrite member_equal)
    (("" (lazy-grind :exclude equal?) nil nil)) nil)
   ((equivalence? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (symmetric? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (member_equal formula-decl nil more_list_props nil)
    (T formal-type-decl nil more_list_props nil))
   shostak))
 (equal_reflexive 0
  (equal_reflexive-1 nil 3577714643
   ("" (use "equal_equiv")
    (("" (grind :theories ("orders" "relations") :exclude equal?) nil
      nil))
    nil)
   ((equivalence? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (symmetric? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (equal_equiv formula-decl nil more_list_props nil))
   shostak))
 (equal_transitive 0
  (equal_transitive-1 nil 3577714736
   ("" (use "equal_equiv")
    (("" (grind :theories ("orders" "relations") :exclude equal?) nil
      nil))
    nil)
   ((equivalence? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (symmetric? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (equal_equiv formula-decl nil more_list_props nil))
   shostak))
 (equal_symmetric 0
  (equal_symmetric-1 nil 3577714740
   ("" (use "equal_equiv")
    (("" (grind :theories ("orders" "relations") :exclude equal?) nil
      nil))
    nil)
   ((equivalence? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (symmetric? const-decl "bool" relations nil)
    (reflexive? const-decl "bool" relations nil)
    (equal_equiv formula-decl nil more_list_props nil))
   shostak))
 (cons_equal 0
  (cons_equal-1 nil 3577708872
   ("" (auto-rewrite member_equal)
    (("" (grind :exclude equal?) nil nil)) nil)
   ((member def-decl "bool" list_props nil)
    (member_equal formula-decl nil more_list_props nil))
   shostak))
 (member_append 0
  (member_append-1 nil 3577636826 ("" (induct-and-simplify l) nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (append def-decl "list[T]" list_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list_induction formula-decl nil list_adt nil))
   nil))
 (member_reverse 0
  (member_reverse-1 nil 3577637967
   ("" (auto-rewrite member_append)
    (("" (induct-and-simplify l) nil nil)) nil)
   ((member_append formula-decl nil more_list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (reverse def-decl "list[T]" list_props nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (member_nth 0
  (member_nth-1 nil 3577637302
   ("" (induct l)
    (("1" (grind) nil nil)
     ("2" (skosimp*)
      (("2" (prop)
        (("1" (expand "member" -1)
          (("1" (split -)
            (("1" (inst + 0)
              (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)
             ("2" (inst - x!1)
              (("2" (prop)
                (("2" (skeep)
                  (("2" (inst + "i+1")
                    (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (inst - x!1)
            (("2" (prop)
              (("1" (grind) nil nil)
               ("2" (inst + "i-1")
                (("1" (expand "nth" -1) (("1" (grind) nil nil)) nil)
                 ("2" (typepred "i") (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((i skolem-const-decl
     "below(length(cons(cons1_var!1, cons2_var!1)))" more_list_props
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (i skolem-const-decl "below(length(cons2_var!1))" more_list_props
     nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons1_var!1 skolem-const-decl "T" more_list_props nil)
    (cons2_var!1 skolem-const-decl "list[T]" more_list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (nth_append_TCC1 0
  (nth_append_TCC1-1 nil 3578223563
   ("" (grind :rewrites length_append) nil nil)
   ((length_append formula-decl nil list_props nil)) nil))
 (nth_append_TCC2 0
  (nth_append_TCC2-1 nil 3578223563 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (nth_append 0
  (nth_append-1 nil 3578224052
   ("" (induct l)
    (("1" (grind) nil nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand nth 1 (1 2))
          (("2" (expand length +)
            (("2" (grind :exclude (length nth))
              (("2" (typepred i) (("2" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (grind) nil nil)
     ("4" (grind :rewrites length_append) nil nil))
    nil)
   ((length_append formula-decl nil list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons1_var skolem-const-decl "T" more_list_props nil)
    (cons2_var skolem-const-decl "list[T]" more_list_props nil)
    (m skolem-const-decl "list[T]" more_list_props nil)
    (i skolem-const-decl
     "below(length(cons(cons1_var, cons2_var)) + length(m))"
     more_list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (append def-decl "list[T]" list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (nth_reverse_TCC1 0
  (nth_reverse_TCC1-1 nil 3578223563
   ("" (grind :rewrites length_reverse) nil nil)
   ((length_reverse formula-decl nil list_props nil)) nil))
 (nth_reverse_TCC2 0
  (nth_reverse_TCC2-1 nil 3578223563 ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (nth_reverse 0
  (nth_reverse-1 nil 3578224332
   ("" (induct l)
    (("1" (skeep) (("1" (typepred i) (("1" (grind) nil nil)) nil)) nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand reverse +)
          (("2" (expand nth 1 2)
            (("2" (expand length +)
              (("2" (rewrite nth_append)
                (("1"
                  (grind :rewrites (length_reverse) :if-match nil
                   :exclude (nth length append reverse))
                  (("1"
                    (grind :rewrites (length_reverse) :if-match all)
                    nil nil)
                   ("2"
                    (grind :rewrites (length_reverse) :if-match all)
                    nil nil)
                   ("3" (typepred i) (("3" (grind) nil nil)) nil))
                  nil)
                 ("2"
                  (grind :rewrites (length_reverse) :if-match nil
                   :exclude (nth length append reverse))
                  (("1"
                    (grind :rewrites (length_reverse) :if-match all)
                    nil nil)
                   ("2"
                    (grind :rewrites (length_reverse) :if-match nil
                     :exclude (nth length append reverse))
                    (("2" (typepred i) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (grind :rewrites length_reverse) nil nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (length_reverse formula-decl nil list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nth_append formula-decl nil more_list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (reverse def-decl "list[T]" list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (flatten_null 0
  (flatten_null-1 nil 3577728887 ("" (grind) nil nil)
   ((flatten const-decl "list[T]" more_list_props nil)
    (reduce adt-def-decl "[list[T] -> range]" list_adt_reduce nil))
   shostak))
 (flatten_cons 0
  (flatten_cons-1 nil 3577728891 ("" (induct-and-simplify ll) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (flatten const-decl "list[T]" more_list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (reduce adt-def-decl "[list[T] -> range]" list_adt_reduce nil))
   shostak))
 (flatten_member 0
  (flatten_member-1 nil 3577728794
   (""
    (induct-and-simplify ll :rewrites (flatten_cons member_append)
     :if-match all)
    nil nil)
   ((append def-decl "list[T]" list_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (member_append formula-decl nil more_list_props nil)
    (flatten_cons formula-decl nil more_list_props nil)
    (reduce adt-def-decl "[list[T] -> range]" list_adt_reduce nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (flatten const-decl "list[T]" more_list_props nil)
    (member def-decl "bool" list_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (uniques?_TCC1 0
  (uniques?_TCC1-1 nil 3577713883 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (uniques_TCC1 0
  (uniques_TCC1-1 nil 3577713883 ("" (grind) nil nil)
   ((uniques? def-decl "bool" more_list_props nil)
    (every adt-def-decl "boolean" list_adt nil)
    (subset? const-decl "bool" more_list_props nil)
    (equal? const-decl "bool" more_list_props nil))
   nil))
 (uniques_TCC2 0
  (uniques_TCC2-1 nil 3577713883 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (uniques_TCC3 0
  (uniques_TCC3-1 nil 3577713883
   (""
    (apply (then
            (grind :exclude equal? :rewrites
             ("cons_equal" "member_equal"))
            (typepred "v!1(t!1)") (grind)))
    nil nil)
   ((member_equal formula-decl nil more_list_props nil)
    (member def-decl "bool" list_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (uniques? def-decl "bool" more_list_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (equal? const-decl "bool" more_list_props nil))
   nil))
 (uniques_TCC4 0
  (uniques_TCC4-1 nil 3577713883
   ("" (use "equal_equiv")
    (("" (grind :theories ("orders" "relations") :exclude equal?)
      (("1" (typepred "v!1(t!1)")
        (("1" (grind :rewrites member_equal) nil nil)) nil)
       ("2" (typepred "v!1(t!1)")
        (("2" (use "equal_equiv")
          (("2"
            (grind :theories ("orders" "relations") :exclude equal?
             :rewrites member_equal)
            nil nil))
          nil))
        nil))
      nil))
    nil)
   ((reflexive? const-decl "bool" relations nil)
    (symmetric? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (equivalence? const-decl "bool" relations nil)
    (uniques? def-decl "bool" more_list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list type-decl nil list_adt nil)
    (member_equal formula-decl nil more_list_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (equal? const-decl "bool" more_list_props nil)
    (member def-decl "bool" list_props nil)
    (equal_equiv formula-decl nil more_list_props nil))
   nil))
 (find_TCC1 0
  (find_TCC1-1 nil 3577708630 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (find_char 0
  (find_char-1 nil 3577709078 ("" (induct-and-simplify l) nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (lift type-decl nil lift_adt nil)
    (find def-decl "lift[T]" more_list_props nil)
    (bottom? adt-recognizer-decl "[lift -> boolean]" lift_adt nil)
    (bottom adt-constructor-decl "(bottom?)" lift_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (some adt-def-decl "boolean" list_adt nil)
    (up? adt-recognizer-decl "[lift -> boolean]" lift_adt nil)
    (up adt-constructor-decl "[T -> (up?)]" lift_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (T formal-type-decl nil more_list_props nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (rev_append_TCC1 0
  (rev_append_TCC1-1 nil 3577708630 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (rev_append_char 0
  (rev_append_char-1 nil 3577709091
   ("" (induct-and-simplify l1 :rewrites "append_assoc") nil nil)
   ((cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (append_assoc formula-decl nil list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil more_list_props nil)
    (reverse def-decl "list[T]" list_props nil)
    (append def-decl "list[T]" list_props nil)
    (rev_append def-decl "list[T]" more_list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak)))
(list_subterms
 (subterms_TCC1 0
  (subterms_TCC1-1 nil 3578228686 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (subterm_append 0
  (subterm_append-1 nil 3578228739
   ("" (induct l)
    (("1" (grind) (("1" (expand append) (("1" (grind) nil nil)) nil))
      nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (prop)
          (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil))
        nil))
      nil))
    nil)
   nil shostak)))
(list_filter_props
 (member_filter 0
  (member_filter-1 nil 3578168143 ("" (induct-and-simplify l) nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (filter def-decl "list[T]" filters nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil list_filter_props nil)
    (list_induction formula-decl nil list_adt nil))
   nil))
 (filter_append 0
  (filter_append-1 nil 3577717053 ("" (induct-and-simplify l) nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (filter def-decl "list[T]" filters nil)
    (append def-decl "list[T]" list_props nil)
    (T formal-type-decl nil list_filter_props nil)
    (list_induction formula-decl nil list_adt nil)
    (member_filter application-judgement
     "{m | FORALL x: member(x, m) IFF p(x) AND member(x, l)}"
     list_filter_props nil))
   shostak)))
(list_map_props
 (member_map 0
  (member_map-1 nil 3577637101 ("" (induct-and-simplify l) nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (S formal-type-decl nil list_map_props nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (T formal-type-decl nil list_map_props nil)
    (list_induction formula-decl nil list_adt nil))
   nil))
 (map_member 0
  (map_member-1 nil 3577718713 ("" (induct-and-simplify l) nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (S formal-type-decl nil list_map_props nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil list_map_props nil)
    (list_induction formula-decl nil list_adt nil))
   shostak)))
(concat_map
 (concat_map_TCC1 0
  (concat_map_TCC1-1 nil 3577732876 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (concat_map_flatten 0
  (concat_map_flatten-1 nil 3577731396
   ("" (induct-and-simplify l) nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (S formal-type-decl nil concat_map nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (concat_map def-decl "list[S]" concat_map nil)
    (flatten const-decl "list[T]" more_list_props nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (T formal-type-decl nil concat_map nil)
    (list_induction formula-decl nil list_adt nil)
    (reduce adt-def-decl "[list[T] -> range]" list_adt_reduce nil))
   shostak))
 (member_concat_map 0
  (member_concat_map-1 nil 3577731404
   (""
    (grind :rewrites (concat_map_flatten member_map flatten_member)
     :if-match all)
    nil nil)
   ((flatten_member formula-decl nil more_list_props nil)
    (concat_map_flatten formula-decl nil concat_map nil)
    (S formal-type-decl nil concat_map nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil concat_map nil)
    (member_map formula-decl nil list_map_props nil))
   shostak))
 (concat_map_member 0
  (concat_map_member-1 nil 3577731568
   ("" (lemma map_member)
    ((""
      (grind :rewrites (concat_map_flatten flatten_member) :if-match
       all)
      nil nil))
    nil)
   ((flatten_member formula-decl nil more_list_props nil)
    (concat_map_flatten formula-decl nil concat_map nil)
    (map_member formula-decl nil list_map_props nil)
    (S formal-type-decl nil concat_map nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil concat_map nil))
   shostak)))

